{"pr_number": 5218, "pr_title": "Alternative Pool Strategies", "pr_author": "gregw", "pr_createdAt": "2020-09-01T10:16:27Z", "pr_url": "https://github.com/eclipse/jetty.project/pull/5218", "timeline": [{"oid": "b63c59d511e274908808ac3b338c40149f074864", "url": "https://github.com/eclipse/jetty.project/commit/b63c59d511e274908808ac3b338c40149f074864", "message": "Speculative idea to make a pluggable Pool strategy\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T10:14:49Z", "type": "commit"}, {"oid": "410fe53ea19e7b0a66e010da66672936326cfc55", "url": "https://github.com/eclipse/jetty.project/commit/410fe53ea19e7b0a66e010da66672936326cfc55", "message": "Speculative idea to make a pluggable Pool strategy\n\n + javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T13:43:34Z", "type": "commit"}, {"oid": "27d31dedb26cd625b3919b31efd7043c78abf226", "url": "https://github.com/eclipse/jetty.project/commit/27d31dedb26cd625b3919b31efd7043c78abf226", "message": "Speculative idea to make a pluggable Pool strategy\n\n + Added a ThreadLocalStrategy for a single cached item\n + Tell strategies about newly reserved entries\n + Fixed multiplexing test that was dependent on the impl of the cache\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T14:13:17Z", "type": "commit"}, {"oid": "91df8dad0945b6951ff30629df4e86e739a02d85", "url": "https://github.com/eclipse/jetty.project/commit/91df8dad0945b6951ff30629df4e86e739a02d85", "message": "Speculative idea to make a pluggable Pool strategy\n\n + added tests\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-01T15:38:54Z", "type": "commit"}, {"oid": "db086a513502d36bde7d1d886eaea7dca3e53721", "url": "https://github.com/eclipse/jetty.project/commit/db086a513502d36bde7d1d886eaea7dca3e53721", "message": "Feedback from review\n\n + Don't have a fallback iteration, instead make a SearchStrategy and DualStrategy", "committedDate": "2020-09-02T11:53:56Z", "type": "commit"}, {"oid": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "url": "https://github.com/eclipse/jetty.project/commit/6ab7bd726b0e2412a5c1497348473dbac98d64a3", "message": "Feedback from review\n\n + split strategies into Cache and Strategies", "committedDate": "2020-09-02T12:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NDU0NA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482044544", "body": "Why a `release()` inside `reserve()`?", "bodyText": "Why a release() inside reserve()?", "bodyHTML": "<p dir=\"auto\">Why a <code>release()</code> inside <code>reserve()</code>?</p>", "author": "sbordet", "createdAt": "2020-09-02T12:53:16Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -165,7 +201,8 @@ public Entry reserve(int allotment)\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            sharedList.add(entry);\n+            entries.add(entry);\n+            strategy.released(entries, entry, true);", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -171,39 +128,35 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Create a new disabled slot into the pool.\n-     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n-     * method called or be removed via {@link Pool.Entry#remove()} or\n-     * {@link Pool#remove(Pool.Entry)}.\n+     * Create a new disabled slot into the pool. The returned entry\n+     * won't be acquirable as long as {@link Entry#enable(Object)}\n+     * has not been called.\n      *\n-     * @param allotment the desired allotment, where each entry handles an allotment of maxMultiplex,\n+     * @param maxReservations the max desired number of reserved entries,\n      * or a negative number to always trigger the reservation of a new entry.\n      * @return a disabled entry that is contained in the pool,\n      * or null if the pool is closed or if the pool already contains\n-     * {@link #getMaxEntries()} entries, or the allotment has already been reserved\n+     * {@link #getMaxEntries()} entries.\n      */\n-    public Entry reserve(int allotment)\n+    public Entry reserve(int maxReservations)\n     {\n-        try (Locker.Lock l = locker.lock())\n+        if (maxReservations >= 0 && getPendingConnectionCount() >= maxReservations)\n+            return null;\n+\n+        lock.lock();\n+        try\n+        {\n+            if (!closed && sharedList.size() < maxEntries)\n+            {\n+                Entry entry = new Entry();\n+                sharedList.add(entry);\n+                return entry;\n+            }\n+            return null;\n+        }\n+        finally\n         {\n-            if (closed)\n-                return null;\n-\n-            int space = maxEntries - entries.size();\n-            if (space <= 0)\n-                return null;\n-\n-            // The pending count is an AtomicInteger that is only ever incremented here with\n-            // the lock held.  Thus the pending count can be reduced immediately after the\n-            // test below, but never incremented.  Thus the allotment limit can be enforced.\n-            if (allotment >= 0 && (pending.get() * getMaxMultiplex()) >= allotment)\n-                return null;\n-            pending.incrementAndGet();\n-\n-            Entry entry = new Entry();\n-            entries.add(entry);\n-            strategy.released(entries, entry, true);\n-            return entry;\n+            lock.unlock();\n         }\n     }\n \n", "next_change": {"commit": "d2df0fc2e9eff2ba40fb75a594b11aa98470f06c", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..d1c5017d0e 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -154,10 +152,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             }\n             return null;\n         }\n-        finally\n-        {\n-            lock.unlock();\n-        }\n     }\n \n     /**\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d1c5017d0e..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -139,18 +148,26 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      */\n     public Entry reserve(int maxReservations)\n     {\n-        if (maxReservations >= 0 && getPendingConnectionCount() >= maxReservations)\n-            return null;\n-\n         try (AutoLock l = lock.lock())\n         {\n-            if (!closed && sharedList.size() < maxEntries)\n-            {\n-                Entry entry = new Entry();\n-                sharedList.add(entry);\n-                return entry;\n-            }\n-            return null;\n+            if (closed)\n+                return null;\n+\n+            int space = maxEntries - sharedList.size();\n+            if (space <= 0)\n+                return null;\n+\n+            // The pending count is an AtomicInteger that is only ever incremented here with\n+            // the lock held.  Thus the pending count can be reduced immediately after the\n+            // test below, but never incremented.  Thus the maxReservations limit can be\n+            // enforced.\n+            if (maxReservations >= 0 && pending.get() >= maxReservations)\n+                return null;\n+            pending.incrementAndGet();\n+\n+            Entry entry = new Entry();\n+            sharedList.add(entry);\n+            return entry;\n         }\n     }\n \n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -140,43 +184,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * method called or be removed via {@link Pool.Entry#remove()} or\n      * {@link Pool#remove(Pool.Entry)}.\n      *\n-     * @param maxReservations the max desired number of reserved entries,\n+     * @param allotment the desired allotment, where each entry handles an allotment of maxMultiplex,\n      * or a negative number to always trigger the reservation of a new entry.\n      * @return a disabled entry that is contained in the pool,\n      * or null if the pool is closed or if the pool already contains\n-     * {@link #getMaxEntries()} entries.\n+     * {@link #getMaxEntries()} entries, or the allotment has already been reserved\n      */\n-    public Entry reserve(int maxReservations)\n+    public Entry reserve(int allotment)\n     {\n-        try (AutoLock l = lock.lock())\n+        try (Locker.Lock l = locker.lock())\n         {\n             if (closed)\n                 return null;\n \n-            int space = maxEntries - sharedList.size();\n+            int space = maxEntries - entries.size();\n             if (space <= 0)\n                 return null;\n \n             // The pending count is an AtomicInteger that is only ever incremented here with\n             // the lock held.  Thus the pending count can be reduced immediately after the\n-            // test below, but never incremented.  Thus the maxReservations limit can be\n-            // enforced.\n-            if (maxReservations >= 0 && pending.get() >= maxReservations)\n+            // test below, but never incremented.  Thus the allotment limit can be enforced.\n+            if (allotment >= 0 && (pending.get() * getMaxMultiplex()) >= allotment)\n                 return null;\n             pending.incrementAndGet();\n \n             Entry entry = new Entry();\n-            sharedList.add(entry);\n+            entries.add(entry);\n             return entry;\n         }\n     }\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047333", "body": "Just `release()` and implementations have to call `entry.tryRelease()` so that we're symmetric with `acquire()` above?", "bodyText": "Just release() and implementations have to call entry.tryRelease() so that we're symmetric with acquire() above?", "bodyHTML": "<p dir=\"auto\">Just <code>release()</code> and implementations have to call <code>entry.tryRelease()</code> so that we're symmetric with <code>acquire()</code> above?</p>", "author": "sbordet", "createdAt": "2020-09-02T12:57:31Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NTkxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482055914", "bodyText": "I second @sbordet; and wouldn't the following signature be better?\nvoid release(Pool<T>.Entry entry);\nwithout a list of entries (I can't see why it would be needed) and no default impl?", "author": "lorban", "createdAt": "2020-09-02T13:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA0NzcyMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482047722", "body": "Is not this class missing a `remove()` method?", "bodyText": "Is not this class missing a remove() method?", "bodyHTML": "<p dir=\"auto\">Is not this class missing a <code>remove()</code> method?</p>", "author": "sbordet", "createdAt": "2020-09-02T12:58:08Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MjMwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052306", "body": "`LinearSearchStrategy`?", "bodyText": "LinearSearchStrategy?", "bodyHTML": "<p dir=\"auto\"><code>LinearSearchStrategy</code>?</p>", "author": "lorban", "createdAt": "2020-09-02T13:05:07Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Mjc1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482052750", "body": "`private final`?", "bodyText": "private final?", "bodyHTML": "<p dir=\"auto\"><code>private final</code>?</p>", "author": "lorban", "createdAt": "2020-09-02T13:05:49Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482053009", "body": "do we want to keep this strategy?", "bodyText": "do we want to keep this strategy?", "bodyHTML": "<p dir=\"auto\">do we want to keep this strategy?</p>", "author": "lorban", "createdAt": "2020-09-02T13:06:13Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = cache.acquire(entries);\n+            return entry == null ? strategy.acquire(entries) : entry;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            cache.released(entries, entry, reusable);\n+            strategy.released(entries, entry, reusable);\n+        }\n+    }\n+\n+    public static class SearchStrategy<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            for (Pool<T>.Entry e : entries)\n+            {\n+                if (e.tryAcquire())\n+                    return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class ThreadLocalCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<Pool<T>.Entry> last;\n+\n+        ThreadLocalCache()\n+        {\n+            last = new ThreadLocal<>();\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            Pool<T>.Entry entry = last.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+                last.set(entry);\n+        }\n+    }\n+\n+    public static class ThreadLocalListCache<T> implements Cache<T>\n+    {\n+        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n+        private final int cacheSize;\n+\n+        ThreadLocalListCache(int size)\n+        {\n+            this.cacheSize = size;\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n+        }\n+\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            List<Pool<T>.Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+            if (reusable)\n+            {\n+                List<Pool<T>.Entry> cachedList = cache.get();\n+                if (cachedList.size() < cacheSize)\n+                    cachedList.add(entry);\n+            }\n+        }\n+    }\n+\n+    private abstract static class IndexedCached<T> implements Cache<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int size = entries.size();\n+            if (size == 0)\n+                return null;\n+            int i = nextIndex(size);\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(i);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (Exception e)\n+            {\n+                // Could be out of bounds\n+                LOGGER.ignore(e);\n+            }\n+            return null;\n+        }\n+\n+        protected abstract int nextIndex(int size);\n+    }\n+\n+    public static class RandomCache<T> extends IndexedCached<T>\n+    {\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return ThreadLocalRandom.current().nextInt(size);\n+        }\n+    }\n+\n+    public static class RoundRobinCache<T> extends IndexedCached<T>\n+    {\n+        AtomicInteger index = new AtomicInteger();\n+\n+        @Override\n+        protected int nextIndex(int size)\n+        {\n+            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+        }\n+    }\n+\n+    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n+    {\n+        @Override\n+        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n+        {\n+            int tries = entries.size();\n+            while (tries-- > 0)\n+            {\n+                Pool<T>.Entry entry = super.acquire(entries);\n+                if (entry != null)\n+                    return entry;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMDA5NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482310095", "bodyText": "I'll keep for now to test API during dev... but don't think we should include it in final merge... actually I might move it to a test to check that an external strategy can be applied without access to protected methods", "author": "gregw", "createdAt": "2020-09-02T18:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1MzAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482056332", "body": "Are both `Strategy` and `Cache` needed?", "bodyText": "Are both Strategy and Cache needed?", "bodyHTML": "<p dir=\"auto\">Are both <code>Strategy</code> and <code>Cache</code> needed?</p>", "author": "lorban", "createdAt": "2020-09-02T13:11:12Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMwODQzNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482308436", "bodyText": "Strategy and Cache are needed if we want to make a distinction between impls that just try to find an entry and then give up (threadlocal, random) and those that do a search  ( linear, round-robin).\nHowever, I too am not convinced the distinction is necessary.", "author": "gregw", "createdAt": "2020-09-02T18:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NjMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1NzEyOA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057128", "body": "If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.", "bodyText": "If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.", "bodyHTML": "<p dir=\"auto\">If we go with this design, the RR connection pool should be rewritten to use the RR strategy and this method should be removed.</p>", "author": "lorban", "createdAt": "2020-09-02T13:12:22Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +213,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -213,7 +166,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n-    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -128,44 +179,48 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Create a new disabled slot into the pool. The returned entry\n-     * won't be acquirable as long as {@link Entry#enable(Object)}\n-     * has not been called.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n      *\n-     * @param maxReservations the max desired number of reserved entries,\n+     * @param allotment the desired allotment, where each entry handles an allotment of maxMultiplex,\n      * or a negative number to always trigger the reservation of a new entry.\n      * @return a disabled entry that is contained in the pool,\n      * or null if the pool is closed or if the pool already contains\n-     * {@link #getMaxEntries()} entries.\n+     * {@link #getMaxEntries()} entries, or the allotment has already been reserved\n      */\n-    public Entry reserve(int maxReservations)\n+    public Entry reserve(int allotment)\n     {\n-        if (maxReservations >= 0 && getPendingConnectionCount() >= maxReservations)\n-            return null;\n-\n-        lock.lock();\n-        try\n-        {\n-            if (!closed && sharedList.size() < maxEntries)\n-            {\n-                Entry entry = new Entry();\n-                sharedList.add(entry);\n-                return entry;\n-            }\n-            return null;\n-        }\n-        finally\n+        try (Locker.Lock l = locker.lock())\n         {\n-            lock.unlock();\n+            if (closed)\n+                return null;\n+\n+            int space = maxEntries - entries.size();\n+            if (space <= 0)\n+                return null;\n+\n+            // The pending count is an AtomicInteger that is only ever incremented here with\n+            // the lock held.  Thus the pending count can be reduced immediately after the\n+            // test below, but never incremented.  Thus the allotment limit can be enforced.\n+            if (allotment >= 0 && (pending.get() * getMaxMultiplex()) >= allotment)\n+                return null;\n+            pending.incrementAndGet();\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n     }\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -173,7 +228,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n         try\n         {\n-            Entry entry = sharedList.get(idx);\n+            Entry entry = entries.get(idx);\n             if (entry.tryAcquire())\n                 return entry;\n         }\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1Nzg1OA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482057858", "body": "`this.cache = Objects.requireNonNull(cache);`", "bodyText": "this.cache = Objects.requireNonNull(cache);", "bodyHTML": "<p dir=\"auto\"><code>this.cache = Objects.requireNonNull(cache);</code></p>", "author": "lorban", "createdAt": "2020-09-02T13:13:32Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODAyNw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058027", "body": "`this.strategy = Objects.requireNonNull(planB);`", "bodyText": "this.strategy = Objects.requireNonNull(planB);", "bodyHTML": "<p dir=\"auto\"><code>this.strategy = Objects.requireNonNull(planB);</code></p>", "author": "lorban", "createdAt": "2020-09-02T13:13:49Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -559,4 +574,222 @@ public String toString()\n                 pooled);\n         }\n     }\n+\n+    /** A pluggable strategy to optimize pool acquisition\n+     * @param <T> The type of the items in the pool\n+     */\n+    public interface Cache<T>\n+    {\n+        /** Acquire an entry\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @return An acquired entry or null if none can be acquired by this strategy\n+         */\n+        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n+\n+        /**\n+         * Notification an entry has been release.  The notification comes after the entry\n+         * has been put back in the pool and it may already have been reacquired before or during this call.\n+         * @param entries The list of entries known to the pool. This may be concurrently modified.\n+         * @param entry The entry to be release\n+         * @param reusable true if the entry is reusable and will be put back in the pool.\n+         */\n+        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n+        {\n+        }\n+    }\n+\n+    public interface Strategy<T> extends Cache<T>\n+    {\n+    }\n+\n+    public static class CacheStrategy<T> implements Strategy<T>\n+    {\n+        final Cache<T> cache;\n+        final Strategy<T> strategy;\n+\n+        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n+        {\n+            Objects.requireNonNull(cache);\n+            Objects.requireNonNull(planB);\n+            this.cache = cache;\n+            this.strategy = planB;", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -564,232 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n-                getMaxMultiplex(),\n-                pooled);\n-        }\n-    }\n-\n-    /** A pluggable strategy to optimize pool acquisition\n-     * @param <T> The type of the items in the pool\n-     */\n-    public interface Cache<T>\n-    {\n-        /** Acquire an entry\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @return An acquired entry or null if none can be acquired by this strategy\n-         */\n-        Pool<T>.Entry acquire(List<Pool<T>.Entry> entries);\n-\n-        /**\n-         * Notification an entry has been release.  The notification comes after the entry\n-         * has been put back in the pool and it may already have been reacquired before or during this call.\n-         * @param entries The list of entries known to the pool. This may be concurrently modified.\n-         * @param entry The entry to be release\n-         * @param reusable true if the entry is reusable and will be put back in the pool.\n-         */\n-        default void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-        }\n-    }\n-\n-    public interface Strategy<T> extends Cache<T>\n-    {\n-    }\n-\n-    public static class CacheStrategy<T> implements Strategy<T>\n-    {\n-        final Cache<T> cache;\n-        final Strategy<T> strategy;\n-\n-        public CacheStrategy(Cache<T> cache, Strategy<T> planB)\n-        {\n-            Objects.requireNonNull(cache);\n-            Objects.requireNonNull(planB);\n-            this.cache = cache;\n-            this.strategy = planB;\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = cache.acquire(entries);\n-            return entry == null ? strategy.acquire(entries) : entry;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            cache.released(entries, entry, reusable);\n-            strategy.released(entries, entry, reusable);\n-        }\n-    }\n-\n-    public static class SearchStrategy<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            for (Pool<T>.Entry e : entries)\n-            {\n-                if (e.tryAcquire())\n-                    return e;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class ThreadLocalCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<Pool<T>.Entry> last;\n-\n-        ThreadLocalCache()\n-        {\n-            last = new ThreadLocal<>();\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            Pool<T>.Entry entry = last.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                last.set(entry);\n-        }\n-    }\n-\n-    public static class ThreadLocalListCache<T> implements Cache<T>\n-    {\n-        private final ThreadLocal<List<Pool<T>.Entry>> cache;\n-        private final int cacheSize;\n-\n-        ThreadLocalListCache(int size)\n-        {\n-            this.cacheSize = size;\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<>(cacheSize));\n-        }\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            List<Pool<T>.Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n-            {\n-                Pool<T>.Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-            {\n-                List<Pool<T>.Entry> cachedList = cache.get();\n-                if (cachedList.size() < cacheSize)\n-                    cachedList.add(entry);\n-            }\n-        }\n-    }\n-\n-    private abstract static class IndexedCached<T> implements Cache<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int size = entries.size();\n-            if (size == 0)\n-                return null;\n-            int i = nextIndex(size);\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(i);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (Exception e)\n-            {\n-                // Could be out of bounds\n-                LOGGER.ignore(e);\n-            }\n-            return null;\n-        }\n-\n-        protected abstract int nextIndex(int size);\n-    }\n-\n-    public static class RandomCache<T> extends IndexedCached<T>\n-    {\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return ThreadLocalRandom.current().nextInt(size);\n-        }\n-    }\n-\n-    public static class RoundRobinCache<T> extends IndexedCached<T>\n-    {\n-        AtomicInteger index = new AtomicInteger();\n-\n-        @Override\n-        protected int nextIndex(int size)\n-        {\n-            return index.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-        }\n-    }\n-\n-    public static class RoundRobinStrategy<T> extends RoundRobinCache<T> implements Strategy<T>\n-    {\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            int tries = entries.size();\n-            while (tries-- > 0)\n-            {\n-                Pool<T>.Entry entry = super.acquire(entries);\n-                if (entry != null)\n-                    return entry;\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LeastRecentlyUsedStrategy<T> implements Strategy<T>\n-    {\n-        Queue<Pool<T>.Entry> lru = new ConcurrentLinkedQueue<>();\n-\n-        @Override\n-        public Pool<T>.Entry acquire(List<Pool<T>.Entry> entries)\n-        {\n-            while (true)\n-            {\n-                Pool<T>.Entry entry = lru.poll();\n-                if (entry == null)\n-                    return null;\n-                if (entry.tryAcquire())\n-                    return entry;\n-            }\n-        }\n-\n-        @Override\n-        public void released(List<Pool<T>.Entry> entries, Pool<T>.Entry entry, boolean reusable)\n-        {\n-            if (reusable)\n-                lru.add(entry);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA1ODY1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r482058659", "body": "This comment isn't accurate anymore as the iteration is also part of the strategy.", "bodyText": "This comment isn't accurate anymore as the iteration is also part of the strategy.", "bodyHTML": "<p dir=\"auto\">This comment isn't accurate anymore as the iteration is also part of the strategy.</p>", "author": "lorban", "createdAt": "2020-09-02T13:14:43Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -197,32 +235,14 @@ public Entry acquireAt(int idx)\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * The implementation first tries the pool strategy and then a brute force iteration over entries.", "originalCommit": "6ab7bd726b0e2412a5c1497348473dbac98d64a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 64d3a2ae63..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -234,52 +186,33 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     /**\n      * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n-     * The implementation first tries the pool strategy and then a brute force iteration over entries.\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n     {\n         if (closed)\n             return null;\n-        return strategy.acquire(entries);\n-    }\n \n-    /**\n-     * Utility method to acquire an entry from the pool,\n-     * reserving and creating a new entry if necessary.\n-     *\n-     * @param creator a function to create the pooled value for a reserved entry.\n-     * @return an entry from the pool or null if none is available.\n-     */\n-    public Entry acquire(Function<Pool<T>.Entry, T> creator)\n-    {\n-        Entry entry = acquire();\n-        if (entry != null)\n-            return entry;\n-\n-        entry = reserve(-1);\n-        if (entry == null)\n-            return null;\n-\n-        T value;\n-        try\n-        {\n-            value = creator.apply(entry);\n-        }\n-        catch (Throwable th)\n+        // first check the thread-local cache\n+        if (cache != null)\n         {\n-            remove(entry);\n-            throw th;\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n+            {\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n+            }\n         }\n \n-        if (value == null)\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n         {\n-            remove(entry);\n-            return null;\n+            if (entry.tryAcquire())\n+                return entry;\n         }\n-\n-        return entry.enable(value, true) ? entry : null;\n+        return null;\n     }\n \n     /**\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -215,6 +226,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return null;\n     }\n \n+    /**\n+     * Utility method to acquire an entry from the pool,\n+     * reserving and creating a new entry if necessary.\n+     *\n+     * @param creator a function to create the pooled value for a reserved entry.\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire(Function<Pool<T>.Entry, T> creator)\n+    {\n+        Entry entry = acquire();\n+        if (entry != null)\n+            return entry;\n+\n+        entry = reserve(-1);\n+        if (entry == null)\n+            return null;\n+\n+        T value;\n+        try\n+        {\n+            value = creator.apply(entry);\n+        }\n+        catch (Throwable th)\n+        {\n+            remove(entry);\n+            throw th;\n+        }\n+\n+        if (value == null)\n+        {\n+            remove(entry);\n+            return null;\n+        }\n+\n+        return entry.enable(value, true) ? entry : null;\n+    }\n+\n     /**\n      * This method will return an acquired object to the pool. Objects\n      * that are acquired from the pool but never released will result\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -264,36 +461,28 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * This method will return an acquired object to the pool. Objects\n-     * that are acquired from the pool but never released will result\n-     * in a memory leak.\n+     * <p>Releases an {@link #acquire() acquired} entry to the pool.</p>\n+     * <p>Entries that are acquired from the pool but never released\n+     * will result in a memory leak.</p>\n      *\n      * @param entry the value to return to the pool\n      * @return true if the entry was released and could be acquired again,\n      * false if the entry should be removed by calling {@link #remove(Pool.Entry)}\n      * and the object contained by the entry should be disposed.\n-     * @throws NullPointerException if value is null\n      */\n     public boolean release(Entry entry)\n     {\n         if (closed)\n             return false;\n \n-        // first mark it as unused\n-        boolean reusable = entry.tryRelease();\n-\n-        // then cache the released entry\n-        if (cache != null && reusable)\n-        {\n-            List<Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n-        }\n-        return reusable;\n+        boolean released = entry.tryRelease();\n+        if (released && cache != null)\n+            cache.set(entry);\n+        return released;\n     }\n \n     /**\n-     * Remove a value from the pool.\n+     * <p>Removes an entry from the pool.</p>\n      *\n      * @param entry the value to remove\n      * @return true if the entry was removed, false otherwise\n", "next_change": null}]}}]}}]}}, {"oid": "e250a4966d93eeb9117b93c6a9030ca7537a8443", "url": "https://github.com/eclipse/jetty.project/commit/e250a4966d93eeb9117b93c6a9030ca7537a8443", "message": "Feedback from review\n\n + Added reserve and release", "committedDate": "2020-09-02T13:57:26Z", "type": "commit"}, {"oid": "505321687c6ad3e7bcc6e64e6d1d0b183167b419", "url": "https://github.com/eclipse/jetty.project/commit/505321687c6ad3e7bcc6e64e6d1d0b183167b419", "message": "Improved Pool Strategies:\n\n+ reverted to post notifications for removed, reserved and released.\n+ Added a few more strategies that need to be benchmarked, that use the list iterator.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-07T17:30:07Z", "type": "commit"}, {"oid": "d9abdeb3cd71f0405b9b95f8d288baccb2edbf8c", "url": "https://github.com/eclipse/jetty.project/commit/d9abdeb3cd71f0405b9b95f8d288baccb2edbf8c", "message": "Testing all the different strategies\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T10:39:07Z", "type": "commit"}, {"oid": "0aa6bc92110ade8c4c96b26e8c074620447857ee", "url": "https://github.com/eclipse/jetty.project/commit/0aa6bc92110ade8c4c96b26e8c074620447857ee", "message": "More simplifications and made LRU work (ish)\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T10:51:13Z", "type": "commit"}, {"oid": "15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "url": "https://github.com/eclipse/jetty.project/commit/15ab22647b3e1bc8e791d9a4e6bd16a9d1ed61e8", "message": "javadoc", "committedDate": "2020-09-08T12:38:01Z", "type": "commit"}, {"oid": "c18a77e8135047393ba289ca3179693b5af4ffad", "url": "https://github.com/eclipse/jetty.project/commit/c18a77e8135047393ba289ca3179693b5af4ffad", "message": "More javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-08T12:54:40Z", "type": "commit"}, {"oid": "8906678227cc6ab9bc6feadbd0e0bb3533f9781c", "url": "https://github.com/eclipse/jetty.project/commit/8906678227cc6ab9bc6feadbd0e0bb3533f9781c", "message": "JMH Test\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-09T10:01:25Z", "type": "commit"}, {"oid": "feda65d15aa906a1c0689ea45b26e15a17906beb", "url": "https://github.com/eclipse/jetty.project/commit/feda65d15aa906a1c0689ea45b26e15a17906beb", "message": "one strategy\n\nSigned-off-by: gregw <gregw@webtide.com>", "committedDate": "2020-09-10T06:10:02Z", "type": "commit"}, {"oid": "0b0030d9897ce8d95e3167e35b72855cd57db0fd", "url": "https://github.com/eclipse/jetty.project/commit/0b0030d9897ce8d95e3167e35b72855cd57db0fd", "message": "test\n\nSigned-off-by: gregw <gregw@webtide.com>", "committedDate": "2020-09-10T07:18:36Z", "type": "commit"}, {"oid": "bf520b4d8b559c5ed8551573d780dced775bcc06", "url": "https://github.com/eclipse/jetty.project/commit/bf520b4d8b559c5ed8551573d780dced775bcc06", "message": "Split implementations:\n\n + pluggable strategies\n + hard coded\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T07:35:11Z", "type": "commit"}, {"oid": "e91578457bbc36b8db01006b3a821d5185ecac1c", "url": "https://github.com/eclipse/jetty.project/commit/e91578457bbc36b8db01006b3a821d5185ecac1c", "message": "More benchmarks", "committedDate": "2020-09-10T09:40:03Z", "type": "commit"}, {"oid": "db00126abd11f5734e499bb8a7ab795bc769b879", "url": "https://github.com/eclipse/jetty.project/commit/db00126abd11f5734e499bb8a7ab795bc769b879", "message": "Built in strategy", "committedDate": "2020-09-10T12:41:48Z", "type": "commit"}, {"oid": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "url": "https://github.com/eclipse/jetty.project/commit/69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "message": "removed strategies version and simplified to single configurable solution.\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T13:40:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3NTQxNA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486475414", "body": "You should move this comment around since you also moved the ThreadLocal variable it speaks about.", "bodyText": "You should move this comment around since you also moved the ThreadLocal variable it speaks about.", "bodyHTML": "<p dir=\"auto\">You should move this comment around since you also moved the ThreadLocal variable it speaks about.</p>", "author": "lorban", "createdAt": "2020-09-10T16:25:47Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -24,49 +24,33 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n-import java.util.ListIterator;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jetty.util.component.Dumpable;\n-import org.eclipse.jetty.util.component.DumpableCollection;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n-import org.eclipse.jetty.util.thread.Locker;\n \n /**\n- * A fast pool of objects, with optional support for\n- * multiplexing, max usage count and several optimized strategies plus\n- * an optional {@link ThreadLocal} cache of the last release entry.\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n  * <p>\n- * When the method {@link #close()} is called, all {@link Closeable}s in the pool\n- * are also closed.\n- * </p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n  * @param <T>\n  */\n public class Pool<T> implements AutoCloseable, Dumpable\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n-    {\n-        @Override\n-        public ListIterator<Entry> listIterator(int index)\n-        {\n-            try\n-            {\n-                return super.listIterator(index);\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                return listIterator();\n-            }\n-        }\n-    };\n-\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n", "next_change": {"commit": "d2df0fc2e9eff2ba40fb75a594b11aa98470f06c", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..d1c5017d0e 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -48,7 +47,7 @@ import org.eclipse.jetty.util.log.Logger;\n  */\n public class Pool<T> implements AutoCloseable, Dumpable\n {\n-    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+    private static final Logger LOGGER = LoggerFactory.getLogger(Pool.class);\n \n     private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n     /*\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d1c5017d0e..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -26,75 +26,127 @@ import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n \n import org.eclipse.jetty.util.component.Dumpable;\n-import org.eclipse.jetty.util.thread.AutoLock;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.eclipse.jetty.util.component.DumpableCollection;\n+import org.eclipse.jetty.util.log.Log;\n+import org.eclipse.jetty.util.log.Logger;\n+import org.eclipse.jetty.util.thread.Locker;\n \n /**\n- * A fast container of poolable objects, with optional support for\n- * multiplexing, max usage count and thread-local caching.\n+ * A fast pool of objects, with optional support for\n+ * multiplexing, max usage count and several optimized strategies plus\n+ * an optional {@link ThreadLocal} cache of the last release entry.\n  * <p>\n- * The thread-local caching mechanism is about remembering up to N previously\n- * used entries into a thread-local single-threaded collection.\n- * When that collection is not empty, its entries are removed one by one\n- * during acquisition until an entry that can be acquired is found.\n- * This can greatly speed up acquisition when both the acquisition and the\n- * release of the entries is done on the same thread as this avoids iterating\n- * the global, thread-safe collection of entries.\n+ * When the method {@link #close()} is called, all {@link Closeable}s in the pool\n+ * are also closed.\n+ * </p>\n  * @param <T>\n  */\n public class Pool<T> implements AutoCloseable, Dumpable\n {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(Pool.class);\n+    private static final Logger LOGGER = Log.getLogger(Pool.class);\n+\n+    private final List<Entry> entries = new CopyOnWriteArrayList<>();\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the configured strategy so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n-    private final AutoLock lock = new AutoLock();\n-    private final int maxEntries;\n-    private final int cacheSize;\n+    private final Locker locker = new Locker();\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n     /**\n-     * Construct a Pool with the specified thread-local cache size.\n+     * The type of the strategy to use for the pool.\n+     * The strategy primarily determines where iteration over the pool entries begins.\n+     */\n+    public enum StrategyType\n+    {\n+        /**\n+         * A strategy that looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        FIRST,\n+\n+        /**\n+         * A strategy that looks for an entry by iterating from a random starting\n+         * index.  No entries are favoured and contention is reduced.\n+         */\n+        RANDOM,\n+\n+        /**\n+         * A strategy that uses the {@link Thread#getId()} of the current thread\n+         * to select a starting point for an entry search.  Whilst not as performant as\n+         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n+         * than the number of available threads.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        THREAD_ID,\n+\n+        /**\n+         * A strategy that looks for an entry by iterating from a starting point\n+         * that is incremented on every search. This gives similar results to the\n+         * random strategy but with more predictable behaviour.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        ROUND_ROBIN,\n+    }\n+\n+    /**\n+     * Construct a Pool with a specified lookup strategy and no\n+     * {@link ThreadLocal} cache.\n      *\n+     * @param strategyType The strategy to used for looking up entries.\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     */\n+    public Pool(StrategyType strategyType, int maxEntries)\n+    {\n+        this(strategyType, maxEntries, false);\n+    }\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size and\n+     * an optional {@link ThreadLocal} cache.\n+     * @param strategyType The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n+     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n      */\n-    public Pool(int maxEntries, int cacheSize)\n+    public Pool(StrategyType strategyType, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.cacheSize = cacheSize;\n-        if (cacheSize > 0)\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n-        else\n-            this.cache = null;\n+        this.strategyType = strategyType;\n+        this.cache = cache ? new ThreadLocal<>() : null;\n+        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -75,89 +59,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-\n-    private final Locker locker = new Locker();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n     private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final Strategy strategy;\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger next;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum Strategy\n-    {\n-        /**\n-         * The Linear strategy looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        LINEAR,\n-\n-        /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * The Round Robin strategy looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(Strategy strategy, int maxEntries)\n-    {\n-        this(strategy, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategy The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n-     */\n-    public Pool(Strategy strategy, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategy = strategy;\n-        this.cache = cache ? new ThreadLocal() : null;\n-        next = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486477965", "body": "This method should go and any caller should be replaced with a Pool using the RR strategy.", "bodyText": "This method should go and any caller should be replaced with a Pool using the RR strategy.", "bodyHTML": "<p dir=\"auto\">This method should go and any caller should be replaced with a Pool using the RR strategy.</p>", "author": "lorban", "createdAt": "2020-09-10T16:29:46Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNDE3NA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486504174", "bodyText": "Yep - waiting for @sbordet to help rework connection pool.", "author": "gregw", "createdAt": "2020-09-10T17:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3Nzk2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -231,7 +166,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n-    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -128,44 +179,48 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Create a new disabled slot into the pool. The returned entry\n-     * won't be acquirable as long as {@link Entry#enable(Object)}\n-     * has not been called.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n      *\n-     * @param maxReservations the max desired number of reserved entries,\n+     * @param allotment the desired allotment, where each entry handles an allotment of maxMultiplex,\n      * or a negative number to always trigger the reservation of a new entry.\n      * @return a disabled entry that is contained in the pool,\n      * or null if the pool is closed or if the pool already contains\n-     * {@link #getMaxEntries()} entries.\n+     * {@link #getMaxEntries()} entries, or the allotment has already been reserved\n      */\n-    public Entry reserve(int maxReservations)\n+    public Entry reserve(int allotment)\n     {\n-        if (maxReservations >= 0 && getPendingConnectionCount() >= maxReservations)\n-            return null;\n-\n-        lock.lock();\n-        try\n-        {\n-            if (!closed && sharedList.size() < maxEntries)\n-            {\n-                Entry entry = new Entry();\n-                sharedList.add(entry);\n-                return entry;\n-            }\n-            return null;\n-        }\n-        finally\n+        try (Locker.Lock l = locker.lock())\n         {\n-            lock.unlock();\n+            if (closed)\n+                return null;\n+\n+            int space = maxEntries - entries.size();\n+            if (space <= 0)\n+                return null;\n+\n+            // The pending count is an AtomicInteger that is only ever incremented here with\n+            // the lock held.  Thus the pending count can be reduced immediately after the\n+            // test below, but never incremented.  Thus the allotment limit can be enforced.\n+            if (allotment >= 0 && (pending.get() * getMaxMultiplex()) >= allotment)\n+                return null;\n+            pending.incrementAndGet();\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n     }\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -173,7 +228,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n         try\n         {\n-            Entry entry = sharedList.get(idx);\n+            Entry entry = entries.get(idx);\n             if (entry.tryAcquire())\n                 return entry;\n         }\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3ODY3OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486478679", "body": "I'd add a message to the exception, something like\r\n```\r\nthrow new IllegalArgumentException(\"Invalid strategy : \" + strategy);\r\n```", "bodyText": "I'd add a message to the exception, something like\nthrow new IllegalArgumentException(\"Invalid strategy : \" + strategy);", "bodyHTML": "<p dir=\"auto\">I'd add a message to the exception, something like</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"throw new IllegalArgumentException(&quot;Invalid strategy : &quot; + strategy);\"><pre><code>throw new IllegalArgumentException(\"Invalid strategy : \" + strategy);\n</code></pre></div>", "author": "lorban", "createdAt": "2020-09-10T16:30:54Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -204,25 +260,51 @@ public Entry acquire()\n         if (closed)\n             return null;\n \n-        // first check the thread-local cache\n+        int size = entries.size();\n+        if (size == 0)\n+            return null;\n+\n         if (cache != null)\n         {\n-            List<Entry> cachedList = cache.get();\n-            while (!cachedList.isEmpty())\n+            Pool<T>.Entry entry = cache.get();\n+            if (entry != null && entry.tryAcquire())\n+                return entry;\n+        }\n+\n+        int index = startIndex(size);\n+\n+        for (int tries = size; tries-- > 0;)\n+        {\n+            try\n+            {\n+                Pool<T>.Entry entry = entries.get(index);\n+                if (entry != null && entry.tryAcquire())\n+                    return entry;\n+            }\n+            catch (IndexOutOfBoundsException e)\n             {\n-                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n-                if (cachedEntry.tryAcquire())\n-                    return cachedEntry;\n+                LOGGER.ignore(e);\n             }\n+            index = (index + 1) % size;\n         }\n+        return null;\n+    }\n \n-        // then iterate the shared list\n-        for (Entry entry : sharedList)\n+    private int startIndex(int size)\n+    {\n+        switch (strategy)\n         {\n-            if (entry.tryAcquire())\n-                return entry;\n+            case LINEAR:\n+                return 0;\n+            case RANDOM:\n+                return ThreadLocalRandom.current().nextInt(size);\n+            case ROUND_ROBIN:\n+                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n+            case THREAD_ID:\n+                return (int)(Thread.currentThread().getId() % size);\n+            default:\n+                throw new IllegalArgumentException();", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,88 +194,25 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         if (closed)\n             return null;\n \n-        int size = entries.size();\n-        if (size == 0)\n-            return null;\n-\n+        // first check the thread-local cache\n         if (cache != null)\n         {\n-            Pool<T>.Entry entry = cache.get();\n-            if (entry != null && entry.tryAcquire())\n-                return entry;\n-        }\n-\n-        int index = startIndex(size);\n-\n-        for (int tries = size; tries-- > 0;)\n-        {\n-            try\n-            {\n-                Pool<T>.Entry entry = entries.get(index);\n-                if (entry != null && entry.tryAcquire())\n-                    return entry;\n-            }\n-            catch (IndexOutOfBoundsException e)\n+            List<Entry> cachedList = cache.get();\n+            while (!cachedList.isEmpty())\n             {\n-                LOGGER.ignore(e);\n+                Entry cachedEntry = cachedList.remove(cachedList.size() - 1);\n+                if (cachedEntry.tryAcquire())\n+                    return cachedEntry;\n             }\n-            index = (index + 1) % size;\n-        }\n-        return null;\n-    }\n-\n-    private int startIndex(int size)\n-    {\n-        switch (strategy)\n-        {\n-            case LINEAR:\n-                return 0;\n-            case RANDOM:\n-                return ThreadLocalRandom.current().nextInt(size);\n-            case ROUND_ROBIN:\n-                return next.getAndUpdate(c -> Math.max(0, c + 1)) % size;\n-            case THREAD_ID:\n-                return (int)(Thread.currentThread().getId() % size);\n-            default:\n-                throw new IllegalArgumentException();\n-        }\n-    }\n-\n-    /**\n-     * Utility method to acquire an entry from the pool,\n-     * reserving and creating a new entry if necessary.\n-     *\n-     * @param creator a function to create the pooled value for a reserved entry.\n-     * @return an entry from the pool or null if none is available.\n-     */\n-    public Entry acquire(Function<Pool<T>.Entry, T> creator)\n-    {\n-        Entry entry = acquire();\n-        if (entry != null)\n-            return entry;\n-\n-        entry = reserve(-1);\n-        if (entry == null)\n-            return null;\n-\n-        T value;\n-        try\n-        {\n-            value = creator.apply(entry);\n-        }\n-        catch (Throwable th)\n-        {\n-            remove(entry);\n-            throw th;\n         }\n \n-        if (value == null)\n+        // then iterate the shared list\n+        for (Entry entry : sharedList)\n         {\n-            remove(entry);\n-            return null;\n+            if (entry.tryAcquire())\n+                return entry;\n         }\n-\n-        return entry.enable(value, true) ? entry : null;\n+        return null;\n     }\n \n     /**\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -215,6 +226,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return null;\n     }\n \n+    /**\n+     * Utility method to acquire an entry from the pool,\n+     * reserving and creating a new entry if necessary.\n+     *\n+     * @param creator a function to create the pooled value for a reserved entry.\n+     * @return an entry from the pool or null if none is available.\n+     */\n+    public Entry acquire(Function<Pool<T>.Entry, T> creator)\n+    {\n+        Entry entry = acquire();\n+        if (entry != null)\n+            return entry;\n+\n+        entry = reserve(-1);\n+        if (entry == null)\n+            return null;\n+\n+        T value;\n+        try\n+        {\n+            value = creator.apply(entry);\n+        }\n+        catch (Throwable th)\n+        {\n+            remove(entry);\n+            throw th;\n+        }\n+\n+        if (value == null)\n+        {\n+            remove(entry);\n+            return null;\n+        }\n+\n+        return entry.enable(value, true) ? entry : null;\n+    }\n+\n     /**\n      * This method will return an acquired object to the pool. Objects\n      * that are acquired from the pool but never released will result\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -264,36 +461,28 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * This method will return an acquired object to the pool. Objects\n-     * that are acquired from the pool but never released will result\n-     * in a memory leak.\n+     * <p>Releases an {@link #acquire() acquired} entry to the pool.</p>\n+     * <p>Entries that are acquired from the pool but never released\n+     * will result in a memory leak.</p>\n      *\n      * @param entry the value to return to the pool\n      * @return true if the entry was released and could be acquired again,\n      * false if the entry should be removed by calling {@link #remove(Pool.Entry)}\n      * and the object contained by the entry should be disposed.\n-     * @throws NullPointerException if value is null\n      */\n     public boolean release(Entry entry)\n     {\n         if (closed)\n             return false;\n \n-        // first mark it as unused\n-        boolean reusable = entry.tryRelease();\n-\n-        // then cache the released entry\n-        if (cache != null && reusable)\n-        {\n-            List<Entry> cachedList = cache.get();\n-            if (cachedList.size() < cacheSize)\n-                cachedList.add(entry);\n-        }\n-        return reusable;\n+        boolean released = entry.tryRelease();\n+        if (released && cache != null)\n+            cache.set(entry);\n+        return released;\n     }\n \n     /**\n-     * Remove a value from the pool.\n+     * <p>Removes an entry from the pool.</p>\n      *\n      * @param entry the value to remove\n      * @return true if the entry was removed, false otherwise\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479656", "body": "This doesn't seem to be used.", "bodyText": "This doesn't seem to be used.", "bodyHTML": "<p dir=\"auto\">This doesn't seem to be used.</p>", "author": "lorban", "createdAt": "2020-09-10T16:32:25Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -500,6 +575,13 @@ boolean tryRelease()\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n+        public boolean isOverUsed()", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTI2OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505269", "bodyText": "I did have a use for it.... but can't remember now... was probably some esoteric strategy or perhaps a unit test.\nI still think it is a nice to have along with the isIdle type methods.", "author": "gregw", "createdAt": "2020-09-10T17:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDYwMg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489224602", "bodyText": "+1 for keeping the method for JMX and such.", "author": "sbordet", "createdAt": "2020-09-16T07:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTY1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -575,18 +412,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             return !(overUsed && newMultiplexingCount == 0);\n         }\n \n-        public boolean isOverUsed()\n-        {\n-            int currentMaxUsageCount = maxUsageCount;\n-            int usageCount = state.getHi();\n-            return currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount;\n-        }\n-\n         /**\n          * Try to mark the entry as removed.\n          * @return true if the entry has to be removed from the containing pool, false otherwise.\n          */\n-        boolean tryRemove()\n+        public boolean tryRemove()\n         {\n             while (true)\n             {\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -416,7 +500,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * Try to mark the entry as removed.\n          * @return true if the entry has to be removed from the containing pool, false otherwise.\n          */\n-        public boolean tryRemove()\n+        boolean tryRemove()\n         {\n             while (true)\n             {\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -497,8 +632,9 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         /**\n-         * Try to mark the entry as removed.\n-         * @return true if the entry has to be removed from the containing pool, false otherwise.\n+         * Try to remove the entry by marking it as closed and decrementing the multiplexing counter.\n+         * The multiplexing counter will never go below zero and if it reaches zero, the entry is considered removed.\n+         * @return true if the entry can be removed from the containing pool, false otherwise.\n          */\n         boolean tryRemove()\n         {\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -618,24 +903,26 @@ public class Pool<T> implements AutoCloseable, Dumpable\n                 if (closed)\n                     return false;\n \n-                newMultiplexingCount = AtomicBiInteger.getLo(encoded) - 1;\n-                if (newMultiplexingCount < 0)\n+                newMultiplexCount = AtomicBiInteger.getLo(encoded) - 1;\n+                if (newMultiplexCount < 0)\n                     throw new IllegalStateException(\"Cannot release an already released entry\");\n \n-                if (state.compareAndSet(encoded, usageCount, newMultiplexingCount))\n+                if (state.compareAndSet(encoded, usageCount, newMultiplexCount))\n                     break;\n             }\n \n-            int currentMaxUsageCount = maxUsageCount;\n+            int currentMaxUsageCount = maxUsage;\n             boolean overUsed = currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount;\n-            return !(overUsed && newMultiplexingCount == 0);\n+            return !(overUsed && newMultiplexCount == 0);\n         }\n \n         /**\n-         * Try to remove the entry by marking it as closed and decrementing the multiplexing counter.\n-         * The multiplexing counter will never go below zero and if it reaches zero, the entry is considered removed.\n+         * <p>Tries to remove the entry by marking it as closed and decrementing the multiplex counter.</p>\n+         * <p>The multiplex counter will never go below zero and if it reaches zero, the entry is considered removed.</p>\n+         *\n          * @return true if the entry can be removed from the containing pool, false otherwise.\n          */\n+        @Override\n         boolean tryRemove()\n         {\n             while (true)\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486479829", "body": "This doesn't have to be `public`.", "bodyText": "This doesn't have to be public.", "bodyHTML": "<p dir=\"auto\">This doesn't have to be <code>public</code>.</p>", "author": "lorban", "createdAt": "2020-09-10T16:32:40Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -452,7 +527,7 @@ public boolean remove()\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        boolean tryAcquire()\n+        public boolean tryAcquire()", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTU2Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505563", "bodyText": "Ah yes! It needed to be public for strategies... but not now!", "author": "gregw", "createdAt": "2020-09-10T17:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -527,7 +448,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n          * the multiplex count is maxMultiplex and the entry is not closed,\n          * false otherwise.\n          */\n-        public boolean tryAcquire()\n+        boolean tryAcquire()\n         {\n             while (true)\n             {\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -442,38 +643,257 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         /**\n-         * Try to acquire the entry if possible by incrementing both the usage\n-         * count and the multiplex count.\n-         * @return true if the usage count is &lt;= maxUsageCount and\n-         * the multiplex count is maxMultiplex and the entry is not closed,\n-         * false otherwise.\n+         * <p>Tries to enable, and possible also acquire, this Entry.</p>\n+         *\n+         * @param acquire whether to also acquire this Entry\n+         * @return whether this Entry was enabled\n+         */\n+        abstract boolean tryEnable(boolean acquire);\n+\n+        /**\n+         * <p>Tries to acquire this Entry.</p>\n+         *\n+         * @return whether this Entry was acquired\n+         */\n+        abstract boolean tryAcquire();\n+\n+        /**\n+         * <p>Tries to release this Entry.</p>\n+         *\n+         * @return true if this Entry was released,\n+         * false if {@link #tryRemove()} should be called.\n+         */\n+        abstract boolean tryRelease();\n+\n+        /**\n+         * <p>Tries to remove the entry by marking it as closed.</p>\n+         *\n+         * @return whether the entry can be removed from the containing pool\n+         */\n+        abstract boolean tryRemove();\n+\n+        /**\n+         * @return whether this Entry is closed\n+         */\n+        public abstract boolean isClosed();\n+\n+        /**\n+         * @return whether this Entry is reserved\n+         */\n+        public abstract boolean isReserved();\n+\n+        /**\n+         * @return whether this Entry is idle\n+         */\n+        public abstract boolean isIdle();\n+\n+        /**\n+         * @return whether this entry is in use.\n+         */\n+        public abstract boolean isInUse();\n+\n+        /**\n+         * @return whether this entry has been used beyond {@link #getMaxUsageCount()}\n+         * @deprecated MaxUsage functionalities will be removed\n+         */\n+        @Deprecated\n+        public boolean isOverUsed()\n+        {\n+            return false;\n+        }\n+\n+        boolean isIdleAndOverUsed()\n+        {\n+            return false;\n+        }\n+\n+        // Only for testing.\n+        int getUsageCount()\n+        {\n+            return 0;\n+        }\n+\n+        // Only for testing.\n+        void setUsageCount(int usageCount)\n+        {\n+        }\n+    }\n+\n+    /**\n+     * <p>A Pool entry that holds metadata and a pooled object,\n+     * that can only be acquired concurrently at most once, and\n+     * can be acquired/released multiple times.</p>\n+     */\n+    private class MonoEntry extends Entry\n+    {\n+        // MIN_VALUE => pending; -1 => closed; 0 => idle; 1 => active;\n+        private final AtomicInteger state = new AtomicInteger(Integer.MIN_VALUE);\n+\n+        @Override\n+        protected boolean tryEnable(boolean acquire)\n+        {\n+            return state.compareAndSet(Integer.MIN_VALUE, acquire ? 1 : 0);\n+        }\n+\n+        @Override\n+        boolean tryAcquire()\n+        {\n+            while (true)\n+            {\n+                int s = state.get();\n+                if (s != 0)\n+                    return false;\n+                if (state.compareAndSet(s, 1))\n+                    return true;\n+            }\n+        }\n+\n+        @Override\n+        boolean tryRelease()\n+        {\n+            while (true)\n+            {\n+                int s = state.get();\n+                if (s < 0)\n+                    return false;\n+                if (s == 0)\n+                    throw new IllegalStateException(\"Cannot release an already released entry\");\n+                if (state.compareAndSet(s, 0))\n+                    return true;\n+            }\n+        }\n+\n+        @Override\n+        boolean tryRemove()\n+        {\n+            state.set(-1);\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isClosed()\n+        {\n+            return state.get() < 0;\n+        }\n+\n+        @Override\n+        public boolean isReserved()\n+        {\n+            return state.get() == Integer.MIN_VALUE;\n+        }\n+\n+        @Override\n+        public boolean isIdle()\n+        {\n+            return state.get() == 0;\n+        }\n+\n+        @Override\n+        public boolean isInUse()\n+        {\n+            return state.get() == 1;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            String s;\n+            switch (state.get())\n+            {\n+                case Integer.MIN_VALUE:\n+                    s = \"PENDING\";\n+                    break;\n+                case -1:\n+                    s = \"CLOSED\";\n+                    break;\n+                case 0:\n+                    s = \"IDLE\";\n+                    break;\n+                default:\n+                    s = \"ACTIVE\";\n+            }\n+            return String.format(\"%s@%x{%s,pooled=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                s,\n+                getPooled());\n+        }\n+    }\n+\n+    /**\n+     * <p>A Pool entry that holds metadata and a pooled object,\n+     * that can be acquired concurrently multiple times, and\n+     * can be acquired/released multiple times.</p>\n+     */\n+    class MultiEntry extends Entry\n+    {\n+        // hi: MIN_VALUE => pending; -1 => closed; 0+ => usage counter;\n+        // lo: 0 => idle; positive => multiplex counter\n+        private final AtomicBiInteger state;\n+\n+        MultiEntry()\n+        {\n+            this.state = new AtomicBiInteger(Integer.MIN_VALUE, 0);\n+        }\n+\n+        @Override\n+        void setUsageCount(int usageCount)\n+        {\n+            this.state.getAndSetHi(usageCount);\n+        }\n+\n+        @Override\n+        protected boolean tryEnable(boolean acquire)\n+        {\n+            int usage = acquire ? 1 : 0;\n+            return state.compareAndSet(Integer.MIN_VALUE, usage, 0, usage);\n+        }\n+\n+        /**\n+         * <p>Tries to acquire the entry if possible by incrementing both the usage\n+         * count and the multiplex count.</p>\n+         *\n+         * @return true if the usage count is less than {@link #getMaxUsageCount()} and\n+         * the multiplex count is less than {@link #getMaxMultiplex(Object)} and\n+         * the entry is not closed, false otherwise.\n          */\n+        @Override\n         boolean tryAcquire()\n         {\n             while (true)\n             {\n                 long encoded = state.get();\n                 int usageCount = AtomicBiInteger.getHi(encoded);\n+                int multiplexCount = AtomicBiInteger.getLo(encoded);\n                 boolean closed = usageCount < 0;\n-                int multiplexingCount = AtomicBiInteger.getLo(encoded);\n-                int currentMaxUsageCount = maxUsageCount;\n-                if (closed || multiplexingCount >= maxMultiplex || (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount))\n+                if (closed)\n+                    return false;\n+                T pooled = getPooled();\n+                int maxUsageCount = getMaxUsageCount(pooled);\n+                int maxMultiplexed = getMaxMultiplex(pooled);\n+                if (maxMultiplexed > 0 && multiplexCount >= maxMultiplexed)\n+                    return false;\n+                if (maxUsageCount > 0 && usageCount >= maxUsageCount)\n                     return false;\n \n-                if (state.compareAndSet(encoded, usageCount + 1, multiplexingCount + 1))\n+                // Prevent overflowing the usage counter by capping it at Integer.MAX_VALUE.\n+                int newUsageCount = usageCount == Integer.MAX_VALUE ? Integer.MAX_VALUE : usageCount + 1;\n+                if (state.compareAndSet(encoded, newUsageCount, multiplexCount + 1))\n                     return true;\n             }\n         }\n \n         /**\n-         * Try to release the entry if possible by decrementing the multiplexing\n-         * count unless the entity is closed.\n+         * <p>Tries to release the entry if possible by decrementing the multiplex\n+         * count unless the entity is closed.</p>\n+         *\n          * @return true if the entry was released,\n          * false if {@link #tryRemove()} should be called.\n          */\n+        @Override\n         boolean tryRelease()\n         {\n-            int newMultiplexingCount;\n+            int newMultiplexCount;\n             int usageCount;\n             while (true)\n             {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486480038", "body": "This index doesn't seem to be used.", "bodyText": "This index doesn't seem to be used.", "bodyHTML": "<p dir=\"auto\">This index doesn't seem to be used.</p>", "author": "lorban", "createdAt": "2020-09-10T16:33:00Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -345,45 +417,48 @@ public void close()\n \n     public int size()\n     {\n-        return sharedList.size();\n+        return entries.size();\n     }\n \n     public Collection<Entry> values()\n     {\n-        return Collections.unmodifiableCollection(sharedList);\n+        return Collections.unmodifiableCollection(entries);\n     }\n \n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Dumpable.dumpObjects(out, indent, this);\n+        Dumpable.dumpObjects(out, indent, this,\n+            new DumpableCollection(\"entries\", entries));\n     }\n \n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s entries=%s]\",\n+        return String.format(\"%s@%x[size=%d closed=%s pending=%d]\",\n             getClass().getSimpleName(),\n             hashCode(),\n-            sharedList.size(),\n+            entries.size(),\n             closed,\n-            sharedList);\n+            pending.get());\n     }\n \n     public class Entry\n     {\n         // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n         // lo: multiplexing counter\n         private final AtomicBiInteger state;\n+        private final int index;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNTk3MQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486505971", "bodyText": "oops yes - that was a broken hack for another esoteric round robin", "author": "gregw", "createdAt": "2020-09-10T17:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MDAzOA=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -400,99 +281,66 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     public void close()\n     {\n         List<Entry> copy;\n-        try (Locker.Lock l = locker.lock())\n+        lock.lock();\n+        try\n         {\n             closed = true;\n-            copy = new ArrayList<>(entries);\n-            entries.clear();\n+            copy = new ArrayList<>(sharedList);\n+            sharedList.clear();\n+        }\n+        finally\n+        {\n+            lock.unlock();\n         }\n \n         // iterate the copy and close its entries\n         for (Entry entry : copy)\n         {\n             if (entry.tryRemove() && entry.pooled instanceof Closeable)\n-                IO.close((Closeable)entry.pooled);\n+            {\n+                try\n+                {\n+                    ((Closeable)entry.pooled).close();\n+                }\n+                catch (IOException e)\n+                {\n+                    LOGGER.warn(\"Error closing entry {}\", entry, e);\n+                }\n+            }\n         }\n     }\n \n     public int size()\n     {\n-        return entries.size();\n+        return sharedList.size();\n     }\n \n     public Collection<Entry> values()\n     {\n-        return Collections.unmodifiableCollection(entries);\n+        return Collections.unmodifiableCollection(sharedList);\n     }\n \n     @Override\n     public void dump(Appendable out, String indent) throws IOException\n     {\n-        Dumpable.dumpObjects(out, indent, this,\n-            new DumpableCollection(\"entries\", entries));\n+        Dumpable.dumpObjects(out, indent, this);\n     }\n \n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s pending=%d]\",\n-            getClass().getSimpleName(),\n-            hashCode(),\n-            entries.size(),\n-            closed,\n-            pending.get());\n+        return getClass().getSimpleName() + \" size=\" + sharedList.size() + \" closed=\" + closed + \" entries=\" + sharedList;\n     }\n \n     public class Entry\n     {\n-        // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n-        // lo: multiplexing counter\n+        // hi: positive=open/maxUsage counter,negative=closed lo: multiplexing counter\n         private final AtomicBiInteger state;\n-        private final int index;\n-\n-        // The pooled item.  This is not volatile as it is set once and then never changed.\n-        // Other threads accessing must check the state field above first, so a good before/after\n-        // relationship exists to make a memory barrier.\n-        private T pooled;\n+        private volatile T pooled;\n \n-        Entry(int index)\n+        public Entry()\n         {\n-            this.state = new AtomicBiInteger(Integer.MIN_VALUE, 0);\n-            this.index = index;\n-        }\n-\n-        /** Enable a reserved entry {@link Entry}.\n-         * An entry returned from the {@link #reserve(int)} method must be enabled with this method,\n-         * once and only once, before it is usable by the pool.\n-         * The entry may be enabled and not acquired, in which case it is immediately available to be\n-         * acquired, potentially by another thread; or it can be enabled and acquired atomically so that\n-         * no other thread can acquire it, although the acquire may still fail if the pool has been closed.\n-         * @param pooled The pooled item for the entry\n-         * @param acquire If true the entry is atomically enabled and acquired.\n-         * @return true If the entry was enabled.\n-         * @throws IllegalStateException if the entry was already enabled\n-         */\n-        public boolean enable(T pooled, boolean acquire)\n-        {\n-            Objects.requireNonNull(pooled);\n-\n-            if (state.getHi() != Integer.MIN_VALUE)\n-            {\n-                if (state.getHi() == -1)\n-                    return false; // Pool has been closed\n-                throw new IllegalStateException(\"Entry already enabled: \" + this);\n-            }\n-            this.pooled = pooled;\n-            int usage = acquire ? 1 : 0;\n-            if (!state.compareAndSet(Integer.MIN_VALUE, usage, 0, usage))\n-            {\n-                this.pooled = null;\n-                if (state.getHi() == -1)\n-                    return false; // Pool has been closed\n-                throw new IllegalStateException(\"Entry already enabled: \" + this);\n-            }\n-            pending.decrementAndGet();\n-            return true;\n+            this.state = new AtomicBiInteger(-1, 0);\n         }\n \n         public T getPooled()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -334,13 +368,52 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public class Entry\n     {\n-        // hi: positive=open/maxUsage counter,negative=closed lo: multiplexing counter\n+        // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n+        // lo: multiplexing counter\n         private final AtomicBiInteger state;\n-        private volatile T pooled;\n \n-        public Entry()\n+        // The pooled item.  This is not volatile as it is set once and then never changed.\n+        // Other threads accessing must check the state field above first, so a good before/after\n+        // relationship exists to make a memory barrier.\n+        private T pooled;\n+\n+        Entry()\n         {\n-            this.state = new AtomicBiInteger(-1, 0);\n+            this.state = new AtomicBiInteger(Integer.MIN_VALUE, 0);\n+        }\n+\n+        /** Enable a reserved entry {@link Entry}.\n+         * An entry returned from the {@link #reserve(int)} method must be enabled with this method,\n+         * once and only once, before it is usable by the pool.\n+         * The entry may be enabled and not acquired, in which case it is immediately available to be\n+         * acquired, potentially by another thread; or it can be enabled and acquired atomically so that\n+         * no other thread can acquire it, although the acquire may still fail if the pool has been closed.\n+         * @param pooled The pooled item for the entry\n+         * @param acquire If true the entry is atomically enabled and acquired.\n+         * @return true If the entry was enabled.\n+         * @throws IllegalStateException if the entry was already enabled\n+         */\n+        public boolean enable(T pooled, boolean acquire)\n+        {\n+            Objects.requireNonNull(pooled);\n+\n+            if (state.getHi() != Integer.MIN_VALUE)\n+            {\n+                if (state.getHi() == -1)\n+                    return false; // Pool has been closed\n+                throw new IllegalStateException(\"Entry already enabled: \" + this);\n+            }\n+            this.pooled = pooled;\n+            int usage = acquire ? 1 : 0;\n+            if (!state.compareAndSet(Integer.MIN_VALUE, usage, 0, usage))\n+            {\n+                this.pooled = null;\n+                if (state.getHi() == -1)\n+                    return false; // Pool has been closed\n+                throw new IllegalStateException(\"Entry already enabled: \" + this);\n+            }\n+            pending.decrementAndGet();\n+            return true;\n         }\n \n         public T getPooled()\n", "next_change": {"commit": "403d5ec318ffaa20f1f2c0b62df217cfc99ebbe0", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..dd705fb2fd 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -412,7 +540,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n                     return false; // Pool has been closed\n                 throw new IllegalStateException(\"Entry already enabled: \" + this);\n             }\n-            pending.decrementAndGet();\n+\n             return true;\n         }\n \n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex dd705fb2fd..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -481,78 +559,72 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     @Override\n     public String toString()\n     {\n-        return String.format(\"%s@%x[size=%d closed=%s]\",\n+        return String.format(\"%s@%x[inUse=%d,size=%d,max=%d,closed=%b]\",\n             getClass().getSimpleName(),\n             hashCode(),\n-            entries.size(),\n-            closed);\n+            getInUseCount(),\n+            size(),\n+            getMaxEntries(),\n+            isClosed());\n     }\n \n-    public class Entry\n+    /**\n+     * <p>A Pool entry that holds metadata and a pooled object.</p>\n+     */\n+    public abstract class Entry\n     {\n-        // hi: positive=open/maxUsage counter; negative=closed; MIN_VALUE pending\n-        // lo: multiplexing counter\n-        private final AtomicBiInteger state;\n-\n-        // The pooled item.  This is not volatile as it is set once and then never changed.\n+        // The pooled object.  This is not volatile as it is set once and then never changed.\n         // Other threads accessing must check the state field above first, so a good before/after\n         // relationship exists to make a memory barrier.\n         private T pooled;\n \n-        Entry()\n-        {\n-            this.state = new AtomicBiInteger(Integer.MIN_VALUE, 0);\n-        }\n-\n-        // for testing only\n-        void setUsageCount(int usageCount)\n-        {\n-            this.state.getAndSetHi(usageCount);\n-        }\n-\n-        /** Enable a reserved entry {@link Entry}.\n-         * An entry returned from the {@link #reserve()} method must be enabled with this method,\n-         * once and only once, before it is usable by the pool.\n-         * The entry may be enabled and not acquired, in which case it is immediately available to be\n+        /**\n+         * <p>Enables this, previously {@link #reserve() reserved}, Entry.</p>\n+         * <p>An entry returned from the {@link #reserve()} method must be enabled with this method,\n+         * once and only once, before it is usable by the pool.</p>\n+         * <p>The entry may be enabled and not acquired, in which case it is immediately available to be\n          * acquired, potentially by another thread; or it can be enabled and acquired atomically so that\n-         * no other thread can acquire it, although the acquire may still fail if the pool has been closed.\n-         * @param pooled The pooled item for the entry\n-         * @param acquire If true the entry is atomically enabled and acquired.\n-         * @return true If the entry was enabled.\n-         * @throws IllegalStateException if the entry was already enabled\n+         * no other thread can acquire it, although the acquire may still fail if the pool has been closed.</p>\n+         *\n+         * @param pooled the pooled object for this Entry\n+         * @param acquire whether this Entry should be atomically enabled and acquired\n+         * @return whether this Entry was enabled\n+         * @throws IllegalStateException if this Entry was already enabled\n          */\n         public boolean enable(T pooled, boolean acquire)\n         {\n             Objects.requireNonNull(pooled);\n \n-            if (state.getHi() != Integer.MIN_VALUE)\n+            if (!isReserved())\n             {\n-                if (state.getHi() == -1)\n+                if (isClosed())\n                     return false; // Pool has been closed\n                 throw new IllegalStateException(\"Entry already enabled: \" + this);\n             }\n             this.pooled = pooled;\n-            int usage = acquire ? 1 : 0;\n-            if (!state.compareAndSet(Integer.MIN_VALUE, usage, 0, usage))\n-            {\n-                this.pooled = null;\n-                if (state.getHi() == -1)\n-                    return false; // Pool has been closed\n-                throw new IllegalStateException(\"Entry already enabled: \" + this);\n-            }\n \n-            return true;\n+            if (tryEnable(acquire))\n+                return true;\n+\n+            this.pooled = null;\n+            if (isClosed())\n+                return false; // Pool has been closed\n+            throw new IllegalStateException(\"Entry already enabled: \" + this);\n         }\n \n+        /**\n+         * @return the pooled object\n+         */\n         public T getPooled()\n         {\n             return pooled;\n         }\n \n         /**\n-         * Release the entry.\n-         * This is equivalent to calling {@link Pool#release(Pool.Entry)} passing this entry.\n-         * @return true if released.\n+         * <p>Releases this Entry.</p>\n+         * <p>This is equivalent to calling {@link Pool#release(Pool.Entry)} passing this entry.</p>\n+         *\n+         * @return whether this Entry was released\n          */\n         public boolean release()\n         {\n", "next_change": null}]}}]}}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -348,13 +421,24 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             return pooled;\n         }\n \n-        public void enable(T pooled)\n+        /**\n+         * Release the entry.\n+         * This is equivalent to calling {@link Pool#release(Pool.Entry)} passing this entry.\n+         * @return true if released.\n+         */\n+        public boolean release()\n         {\n-            if (!isClosed())\n-                throw new IllegalStateException(\"Open entries cannot be enabled : \" + this);\n-            Objects.requireNonNull(pooled);\n-            this.pooled = pooled;\n-            state.set(0, 0);\n+            return Pool.this.release(this);\n+        }\n+\n+        /**\n+         * Remove the entry.\n+         * This is equivalent to calling {@link Pool#remove(Pool.Entry)} passing this entry.\n+         * @return true if remove.\n+         */\n+        public boolean remove()\n+        {\n+            return Pool.this.remove(this);\n         }\n \n         /**\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -432,9 +632,10 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         /**\n-         * Remove the entry.\n-         * This is equivalent to calling {@link Pool#remove(Pool.Entry)} passing this entry.\n-         * @return true if remove.\n+         * <p>Removes this Entry from the Pool.</p>\n+         * <p>This is equivalent to calling {@link Pool#remove(Pool.Entry)} passing this entry.</p>\n+         *\n+         * @return whether this Entry was removed\n          */\n         public boolean remove()\n         {\n", "next_change": null}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -442,38 +643,257 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n \n         /**\n-         * Try to acquire the entry if possible by incrementing both the usage\n-         * count and the multiplex count.\n-         * @return true if the usage count is &lt;= maxUsageCount and\n-         * the multiplex count is maxMultiplex and the entry is not closed,\n-         * false otherwise.\n+         * <p>Tries to enable, and possible also acquire, this Entry.</p>\n+         *\n+         * @param acquire whether to also acquire this Entry\n+         * @return whether this Entry was enabled\n+         */\n+        abstract boolean tryEnable(boolean acquire);\n+\n+        /**\n+         * <p>Tries to acquire this Entry.</p>\n+         *\n+         * @return whether this Entry was acquired\n+         */\n+        abstract boolean tryAcquire();\n+\n+        /**\n+         * <p>Tries to release this Entry.</p>\n+         *\n+         * @return true if this Entry was released,\n+         * false if {@link #tryRemove()} should be called.\n+         */\n+        abstract boolean tryRelease();\n+\n+        /**\n+         * <p>Tries to remove the entry by marking it as closed.</p>\n+         *\n+         * @return whether the entry can be removed from the containing pool\n+         */\n+        abstract boolean tryRemove();\n+\n+        /**\n+         * @return whether this Entry is closed\n+         */\n+        public abstract boolean isClosed();\n+\n+        /**\n+         * @return whether this Entry is reserved\n+         */\n+        public abstract boolean isReserved();\n+\n+        /**\n+         * @return whether this Entry is idle\n+         */\n+        public abstract boolean isIdle();\n+\n+        /**\n+         * @return whether this entry is in use.\n+         */\n+        public abstract boolean isInUse();\n+\n+        /**\n+         * @return whether this entry has been used beyond {@link #getMaxUsageCount()}\n+         * @deprecated MaxUsage functionalities will be removed\n+         */\n+        @Deprecated\n+        public boolean isOverUsed()\n+        {\n+            return false;\n+        }\n+\n+        boolean isIdleAndOverUsed()\n+        {\n+            return false;\n+        }\n+\n+        // Only for testing.\n+        int getUsageCount()\n+        {\n+            return 0;\n+        }\n+\n+        // Only for testing.\n+        void setUsageCount(int usageCount)\n+        {\n+        }\n+    }\n+\n+    /**\n+     * <p>A Pool entry that holds metadata and a pooled object,\n+     * that can only be acquired concurrently at most once, and\n+     * can be acquired/released multiple times.</p>\n+     */\n+    private class MonoEntry extends Entry\n+    {\n+        // MIN_VALUE => pending; -1 => closed; 0 => idle; 1 => active;\n+        private final AtomicInteger state = new AtomicInteger(Integer.MIN_VALUE);\n+\n+        @Override\n+        protected boolean tryEnable(boolean acquire)\n+        {\n+            return state.compareAndSet(Integer.MIN_VALUE, acquire ? 1 : 0);\n+        }\n+\n+        @Override\n+        boolean tryAcquire()\n+        {\n+            while (true)\n+            {\n+                int s = state.get();\n+                if (s != 0)\n+                    return false;\n+                if (state.compareAndSet(s, 1))\n+                    return true;\n+            }\n+        }\n+\n+        @Override\n+        boolean tryRelease()\n+        {\n+            while (true)\n+            {\n+                int s = state.get();\n+                if (s < 0)\n+                    return false;\n+                if (s == 0)\n+                    throw new IllegalStateException(\"Cannot release an already released entry\");\n+                if (state.compareAndSet(s, 0))\n+                    return true;\n+            }\n+        }\n+\n+        @Override\n+        boolean tryRemove()\n+        {\n+            state.set(-1);\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isClosed()\n+        {\n+            return state.get() < 0;\n+        }\n+\n+        @Override\n+        public boolean isReserved()\n+        {\n+            return state.get() == Integer.MIN_VALUE;\n+        }\n+\n+        @Override\n+        public boolean isIdle()\n+        {\n+            return state.get() == 0;\n+        }\n+\n+        @Override\n+        public boolean isInUse()\n+        {\n+            return state.get() == 1;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            String s;\n+            switch (state.get())\n+            {\n+                case Integer.MIN_VALUE:\n+                    s = \"PENDING\";\n+                    break;\n+                case -1:\n+                    s = \"CLOSED\";\n+                    break;\n+                case 0:\n+                    s = \"IDLE\";\n+                    break;\n+                default:\n+                    s = \"ACTIVE\";\n+            }\n+            return String.format(\"%s@%x{%s,pooled=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                s,\n+                getPooled());\n+        }\n+    }\n+\n+    /**\n+     * <p>A Pool entry that holds metadata and a pooled object,\n+     * that can be acquired concurrently multiple times, and\n+     * can be acquired/released multiple times.</p>\n+     */\n+    class MultiEntry extends Entry\n+    {\n+        // hi: MIN_VALUE => pending; -1 => closed; 0+ => usage counter;\n+        // lo: 0 => idle; positive => multiplex counter\n+        private final AtomicBiInteger state;\n+\n+        MultiEntry()\n+        {\n+            this.state = new AtomicBiInteger(Integer.MIN_VALUE, 0);\n+        }\n+\n+        @Override\n+        void setUsageCount(int usageCount)\n+        {\n+            this.state.getAndSetHi(usageCount);\n+        }\n+\n+        @Override\n+        protected boolean tryEnable(boolean acquire)\n+        {\n+            int usage = acquire ? 1 : 0;\n+            return state.compareAndSet(Integer.MIN_VALUE, usage, 0, usage);\n+        }\n+\n+        /**\n+         * <p>Tries to acquire the entry if possible by incrementing both the usage\n+         * count and the multiplex count.</p>\n+         *\n+         * @return true if the usage count is less than {@link #getMaxUsageCount()} and\n+         * the multiplex count is less than {@link #getMaxMultiplex(Object)} and\n+         * the entry is not closed, false otherwise.\n          */\n+        @Override\n         boolean tryAcquire()\n         {\n             while (true)\n             {\n                 long encoded = state.get();\n                 int usageCount = AtomicBiInteger.getHi(encoded);\n+                int multiplexCount = AtomicBiInteger.getLo(encoded);\n                 boolean closed = usageCount < 0;\n-                int multiplexingCount = AtomicBiInteger.getLo(encoded);\n-                int currentMaxUsageCount = maxUsageCount;\n-                if (closed || multiplexingCount >= maxMultiplex || (currentMaxUsageCount > 0 && usageCount >= currentMaxUsageCount))\n+                if (closed)\n+                    return false;\n+                T pooled = getPooled();\n+                int maxUsageCount = getMaxUsageCount(pooled);\n+                int maxMultiplexed = getMaxMultiplex(pooled);\n+                if (maxMultiplexed > 0 && multiplexCount >= maxMultiplexed)\n+                    return false;\n+                if (maxUsageCount > 0 && usageCount >= maxUsageCount)\n                     return false;\n \n-                if (state.compareAndSet(encoded, usageCount + 1, multiplexingCount + 1))\n+                // Prevent overflowing the usage counter by capping it at Integer.MAX_VALUE.\n+                int newUsageCount = usageCount == Integer.MAX_VALUE ? Integer.MAX_VALUE : usageCount + 1;\n+                if (state.compareAndSet(encoded, newUsageCount, multiplexCount + 1))\n                     return true;\n             }\n         }\n \n         /**\n-         * Try to release the entry if possible by decrementing the multiplexing\n-         * count unless the entity is closed.\n+         * <p>Tries to release the entry if possible by decrementing the multiplex\n+         * count unless the entity is closed.</p>\n+         *\n          * @return true if the entry was released,\n          * false if {@link #tryRemove()} should be called.\n          */\n+        @Override\n         boolean tryRelease()\n         {\n-            int newMultiplexingCount;\n+            int newMultiplexCount;\n             int usageCount;\n             while (true)\n             {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MTA1MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486481050", "body": "I would rename these variables to the actual name of their value: `usageCount` and `multiplexingCount`.", "bodyText": "I would rename these variables to the actual name of their value: usageCount and multiplexingCount.", "bodyHTML": "<p dir=\"auto\">I would rename these variables to the actual name of their value: <code>usageCount</code> and <code>multiplexingCount</code>.</p>", "author": "lorban", "createdAt": "2020-09-10T16:34:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -549,12 +631,17 @@ public int getUsageCount()\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int hi = AtomicBiInteger.getHi(encoded);\n+            int lo = AtomicBiInteger.getLo(encoded);", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -631,19 +450,8 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            int hi = AtomicBiInteger.getHi(encoded);\n-            int lo = AtomicBiInteger.getLo(encoded);\n-\n-            String state = hi < 0 ? \"CLOSED\" : lo == 0 ? \"IDLE\" : \"INUSE\";\n-\n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n-                getClass().getSimpleName(),\n-                hashCode(),\n-                state,\n-                Math.max(hi, 0),\n-                Math.max(lo, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n+                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n         }\n     }\n }\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -450,8 +545,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return super.toString() + \" stateHi=\" + AtomicBiInteger.getHi(encoded) +\n-                \" stateLo=\" + AtomicBiInteger.getLo(encoded) + \" pooled=\" + pooled;\n+            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+                getClass().getSimpleName(),\n+                hashCode(),\n+                AtomicBiInteger.getHi(encoded),\n+                AtomicBiInteger.getLo(encoded),\n+                pooled);\n         }\n     }\n }\n", "next_change": {"commit": "823e713ee4926659045fcd038abfe1970a256d78", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..98e99d1410 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -545,11 +549,13 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{hi=%d,lo=%d.p=%s}\",\n+            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 AtomicBiInteger.getHi(encoded),\n+                getMaxUsageCount(),\n                 AtomicBiInteger.getLo(encoded),\n+                getMaxMultiplex(),\n                 pooled);\n         }\n     }\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 98e99d1410..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -549,12 +619,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         public String toString()\n         {\n             long encoded = state.get();\n-            return String.format(\"%s@%x{usage=%d/%d,multiplex=%d/%d,pooled=%s}\",\n+            int usageCount = AtomicBiInteger.getHi(encoded);\n+            int multiplexCount = AtomicBiInteger.getLo(encoded);\n+\n+            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+\n+            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n-                AtomicBiInteger.getHi(encoded),\n-                getMaxUsageCount(),\n-                AtomicBiInteger.getLo(encoded),\n+                state,\n+                Math.max(usageCount, 0),\n+                Math.max(multiplexCount, 0),\n                 getMaxMultiplex(),\n                 pooled);\n         }\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -622,16 +995,17 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             int usageCount = AtomicBiInteger.getHi(encoded);\n             int multiplexCount = AtomicBiInteger.getLo(encoded);\n \n-            String state = usageCount < 0 ? \"CLOSED\" : multiplexCount == 0 ? \"IDLE\" : \"INUSE\";\n+            String state = usageCount < 0\n+                ? (usageCount == Integer.MIN_VALUE ? \"PENDING\" : \"CLOSED\")\n+                : (multiplexCount == 0 ? \"IDLE\" : \"ACTIVE\");\n \n-            return String.format(\"%s@%x{%s, usage=%d, multiplex=%d/%d, pooled=%s}\",\n+            return String.format(\"%s@%x{%s,usage=%d,multiplex=%d,pooled=%s}\",\n                 getClass().getSimpleName(),\n                 hashCode(),\n                 state,\n                 Math.max(usageCount, 0),\n                 Math.max(multiplexCount, 0),\n-                getMaxMultiplex(),\n-                pooled);\n+                getPooled());\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483470", "body": "Since all the other names of this enum describe the starting index, I'd rename this one to something like `INDEX_ZERO`.", "bodyText": "Since all the other names of this enum describe the starting index, I'd rename this one to something like INDEX_ZERO.", "bodyHTML": "<p dir=\"auto\">Since all the other names of this enum describe the starting index, I'd rename this one to something like <code>INDEX_ZERO</code>.</p>", "author": "lorban", "createdAt": "2020-09-10T16:38:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMTI1OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486511259", "bodyText": "How about FIRST?", "author": "gregw", "createdAt": "2020-09-10T17:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4MzQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -75,89 +59,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-\n-    private final Locker locker = new Locker();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n     private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final Strategy strategy;\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger next;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum Strategy\n-    {\n-        /**\n-         * The Linear strategy looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        LINEAR,\n-\n-        /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * The Round Robin strategy looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(Strategy strategy, int maxEntries)\n-    {\n-        this(strategy, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategy The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n-     */\n-    public Pool(Strategy strategy, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategy = strategy;\n-        this.cache = cache ? new ThreadLocal() : null;\n-        next = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4Mzk4OQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486483989", "body": "`AtomicInteger nextIndex`?", "bodyText": "AtomicInteger nextIndex?", "bodyHTML": "<p dir=\"auto\"><code>AtomicInteger nextIndex</code>?</p>", "author": "lorban", "createdAt": "2020-09-10T16:39:21Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -75,89 +59,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-\n-    private final Locker locker = new Locker();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n     private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final Strategy strategy;\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger next;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum Strategy\n-    {\n-        /**\n-         * The Linear strategy looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        LINEAR,\n-\n-        /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * The Round Robin strategy looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(Strategy strategy, int maxEntries)\n-    {\n-        this(strategy, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategy The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n-     */\n-    public Pool(Strategy strategy, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategy = strategy;\n-        this.cache = cache ? new ThreadLocal() : null;\n-        next = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486484485", "body": "`new ThreadLocal<>()`?", "bodyText": "new ThreadLocal<>()?", "bodyHTML": "<p dir=\"auto\"><code>new ThreadLocal&lt;&gt;()</code>?</p>", "author": "lorban", "createdAt": "2020-09-10T16:40:06Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -65,29 +75,74 @@\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n+\n     private final Locker locker = new Locker();\n     private final int maxEntries;\n-    private final int cacheSize;\n     private final AtomicInteger pending = new AtomicInteger();\n+    private final Strategy strategy;\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger next;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum Strategy\n+    {\n+        /**\n+         * The Linear strategy looks for an entry always starting from the first entry.\n+         * It will favour the early entries in the pool, but may contend on them more.\n+         */\n+        LINEAR,\n+\n+        /**\n+         * The Random strategy looks for an entry by iterating from a random starting\n+         * index.  No entries are favoured and contention is reduced.\n+         */\n+        RANDOM,\n+\n+        /**\n+         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n+         * to select a starting point for an entry search.  Whilst not as performant as\n+         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n+         * than the number of available threads.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        THREAD_ID,\n+\n+        /**\n+         * The Round Robin strategy looks for an entry by iterating from a starting point\n+         * that is incremented on every search. This gives similar results to the\n+         * random strategy but with more predictable behaviour.\n+         * No entries are favoured and contention is reduced.\n+         */\n+        ROUND_ROBIN,\n+    }\n+\n     /**\n-     * Construct a Pool with the specified thread-local cache size.\n+     * Construct a Pool with a specified lookup strategy and no\n+     * {@link ThreadLocal} cache.\n      *\n+     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(int maxEntries, int cacheSize)\n+    public Pool(Strategy strategy, int maxEntries)\n+    {\n+        this(strategy, maxEntries, false);\n+    }\n+\n+    /**\n+     * Construct a Pool with the specified thread-local cache size and\n+     * an optional {@link ThreadLocal} cache.\n+     * @param strategy The strategy to used for looking up entries.\n+     * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     */\n+    public Pool(Strategy strategy, int maxEntries, boolean cache)\n     {\n         this.maxEntries = maxEntries;\n-        this.cacheSize = cacheSize;\n-        if (cacheSize > 0)\n-            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n-        else\n-            this.cache = null;\n+        this.strategy = strategy;\n+        this.cache = cache ? new ThreadLocal() : null;", "originalCommit": "69fe8f669bcf89607c5da6f4a39964585e2dc0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwOTAwNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r486509005", "bodyText": "Don't need the threadlocal if not caching", "author": "gregw", "createdAt": "2020-09-10T17:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 2521139934..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -75,89 +59,43 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * When an entry can't be found in the cache, the global list is iterated\n      * normally so the cache has no visible effect besides performance.\n      */\n-\n-    private final Locker locker = new Locker();\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n     private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final Strategy strategy;\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger next;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum Strategy\n-    {\n-        /**\n-         * The Linear strategy looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        LINEAR,\n-\n-        /**\n-         * The Random strategy looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * The Thread ID strategy uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * The Round Robin strategy looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategy The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(Strategy strategy, int maxEntries)\n-    {\n-        this(strategy, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategy The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n-     */\n-    public Pool(Strategy strategy, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategy = strategy;\n-        this.cache = cache ? new ThreadLocal() : null;\n-        next = strategy == Strategy.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "68bf2b508004b214483b598314490b0c000c2f8a", "url": "https://github.com/eclipse/jetty.project/commit/68bf2b508004b214483b598314490b0c000c2f8a", "message": "updates from review\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T17:24:16Z", "type": "commit"}, {"oid": "225b096122977e3a0c8576559288aa1ba34839b1", "url": "https://github.com/eclipse/jetty.project/commit/225b096122977e3a0c8576559288aa1ba34839b1", "message": "better javadoc\n\nSigned-off-by: Greg Wilkins <gregw@webtide.com>", "committedDate": "2020-09-10T17:26:14Z", "type": "commit"}, {"oid": "46d18190d1acff0fe13e727d7ce219cc4b19aaa8", "url": "https://github.com/eclipse/jetty.project/commit/46d18190d1acff0fe13e727d7ce219cc4b19aaa8", "message": "Merge branch 'jetty-9.4.x' into jetty-9.4.x-PoolStrategy", "committedDate": "2020-09-15T09:55:33Z", "type": "commit"}, {"oid": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "url": "https://github.com/eclipse/jetty.project/commit/1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "message": "Updated ConnectionPool classes to use Pool strategies", "committedDate": "2020-09-15T10:57:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMjE3Nw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489222177", "body": "Overriding `listIterator(int)` is not necessary anymore, since we never use it, and we don't leak the `entries` field.", "bodyText": "Overriding listIterator(int) is not necessary anymore, since we never use it, and we don't leak the entries field.", "bodyHTML": "<p dir=\"auto\">Overriding <code>listIterator(int)</code> is not necessary anymore, since we never use it, and we don't leak the <code>entries</code> field.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:29:02Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -24,140 +24,78 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n-import java.util.ListIterator;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jetty.util.component.Dumpable;\n-import org.eclipse.jetty.util.component.DumpableCollection;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n-import org.eclipse.jetty.util.thread.Locker;\n \n /**\n- * A fast pool of objects, with optional support for\n- * multiplexing, max usage count and several optimized strategies plus\n- * an optional {@link ThreadLocal} cache of the last release entry.\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n  * <p>\n- * When the method {@link #close()} is called, all {@link Closeable}s in the pool\n- * are also closed.\n- * </p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n  * @param <T>\n  */\n public class Pool<T> implements AutoCloseable, Dumpable\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n-    {\n-        @Override\n-        public ListIterator<Entry> listIterator(int index)\n-        {\n-            try\n-            {\n-                return super.listIterator(index);\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                return listIterator();\n-            }\n-        }\n-    };\n-\n-    private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final StrategyType strategyType;\n-\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * with the normal strategy so the cache has no visible effect besides performance.\n+     * normally so the cache has no visible effect besides performance.\n      */\n-    private final Locker locker = new Locker();\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger nextIndex;\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum StrategyType\n-    {\n-        /**\n-         * A strategy that looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        FIRST,\n-\n-        /**\n-         * A strategy that looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * A strategy that uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * A strategy that looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategyType The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     */\n-    public Pool(StrategyType strategyType, int maxEntries)\n-    {\n-        this(strategyType, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategyType The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(StrategyType strategyType, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategyType = strategyType;\n-        this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzE0OA==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223148", "body": "There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".", "bodyText": "There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".", "bodyHTML": "<p dir=\"auto\">There is no \"normal\" strategy, I would rephrase: \"is iterated with the configured StrategyType\".</p>", "author": "sbordet", "createdAt": "2020-09-16T07:30:37Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -24,140 +24,78 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n-import java.util.ListIterator;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jetty.util.component.Dumpable;\n-import org.eclipse.jetty.util.component.DumpableCollection;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n-import org.eclipse.jetty.util.thread.Locker;\n \n /**\n- * A fast pool of objects, with optional support for\n- * multiplexing, max usage count and several optimized strategies plus\n- * an optional {@link ThreadLocal} cache of the last release entry.\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n  * <p>\n- * When the method {@link #close()} is called, all {@link Closeable}s in the pool\n- * are also closed.\n- * </p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n  * @param <T>\n  */\n public class Pool<T> implements AutoCloseable, Dumpable\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n-    {\n-        @Override\n-        public ListIterator<Entry> listIterator(int index)\n-        {\n-            try\n-            {\n-                return super.listIterator(index);\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                return listIterator();\n-            }\n-        }\n-    };\n-\n-    private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final StrategyType strategyType;\n-\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * with the normal strategy so the cache has no visible effect besides performance.\n+     * normally so the cache has no visible effect besides performance.\n      */\n-    private final Locker locker = new Locker();\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger nextIndex;\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum StrategyType\n-    {\n-        /**\n-         * A strategy that looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        FIRST,\n-\n-        /**\n-         * A strategy that looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * A strategy that uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * A strategy that looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategyType The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     */\n-    public Pool(StrategyType strategyType, int maxEntries)\n-    {\n-        this(strategyType, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategyType The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(StrategyType strategyType, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategyType = strategyType;\n-        this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzMzMw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223333", "body": "Javadocs.", "bodyText": "Javadocs.", "bodyHTML": "<p dir=\"auto\">Javadocs.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:30:59Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -56,38 +51,98 @@\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n+    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n+    {\n+        @Override\n+        public ListIterator<Entry> listIterator(int index)\n+        {\n+            try\n+            {\n+                return super.listIterator(index);\n+            }\n+            catch (IndexOutOfBoundsException e)\n+            {\n+                return listIterator();\n+            }\n+        }\n+    };\n+\n+    private final int maxEntries;\n+    private final AtomicInteger pending = new AtomicInteger();\n+    private final StrategyType strategyType;\n+\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * normally so the cache has no visible effect besides performance.\n+     * with the normal strategy so the cache has no visible effect besides performance.\n      */\n-    private final ThreadLocal<List<Entry>> cache;\n     private final Locker locker = new Locker();\n-    private final int maxEntries;\n-    private final int cacheSize;\n-    private final AtomicInteger pending = new AtomicInteger();\n+    private final ThreadLocal<Entry> cache;\n+    private final AtomicInteger nextIndex;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n+    public enum StrategyType", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -24,140 +24,78 @@ import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n-import java.util.ListIterator;\n import java.util.Objects;\n import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jetty.util.component.Dumpable;\n-import org.eclipse.jetty.util.component.DumpableCollection;\n import org.eclipse.jetty.util.log.Log;\n import org.eclipse.jetty.util.log.Logger;\n-import org.eclipse.jetty.util.thread.Locker;\n \n /**\n- * A fast pool of objects, with optional support for\n- * multiplexing, max usage count and several optimized strategies plus\n- * an optional {@link ThreadLocal} cache of the last release entry.\n+ * A fast container of poolable objects, with optional support for\n+ * multiplexing, max usage count and thread-local caching.\n  * <p>\n- * When the method {@link #close()} is called, all {@link Closeable}s in the pool\n- * are also closed.\n- * </p>\n+ * The thread-local caching mechanism is about remembering up to N previously\n+ * used entries into a thread-local single-threaded collection.\n+ * When that collection is not empty, its entries are removed one by one\n+ * during acquisition until an entry that can be acquired is found.\n+ * This can greatly speed up acquisition when both the acquisition and the\n+ * release of the entries is done on the same thread as this avoids iterating\n+ * the global, thread-safe collection of entries.\n  * @param <T>\n  */\n public class Pool<T> implements AutoCloseable, Dumpable\n {\n     private static final Logger LOGGER = Log.getLogger(Pool.class);\n \n-    private final List<Entry> entries = new CopyOnWriteArrayList<Entry>()\n-    {\n-        @Override\n-        public ListIterator<Entry> listIterator(int index)\n-        {\n-            try\n-            {\n-                return super.listIterator(index);\n-            }\n-            catch (IndexOutOfBoundsException e)\n-            {\n-                return listIterator();\n-            }\n-        }\n-    };\n-\n-    private final int maxEntries;\n-    private final AtomicInteger pending = new AtomicInteger();\n-    private final StrategyType strategyType;\n-\n+    private final List<Entry> sharedList = new CopyOnWriteArrayList<>();\n     /*\n      * The cache is used to avoid hammering on the first index of the entry list.\n      * Caches can become poisoned (i.e.: containing entries that are in use) when\n      * the release isn't done by the acquiring thread or when the entry pool is\n      * undersized compared to the load applied on it.\n      * When an entry can't be found in the cache, the global list is iterated\n-     * with the normal strategy so the cache has no visible effect besides performance.\n+     * normally so the cache has no visible effect besides performance.\n      */\n-    private final Locker locker = new Locker();\n-    private final ThreadLocal<Entry> cache;\n-    private final AtomicInteger nextIndex;\n+    private final ThreadLocal<List<Entry>> cache;\n+    private final Lock lock = new ReentrantLock();\n+    private final int maxEntries;\n+    private final int cacheSize;\n     private volatile boolean closed;\n     private volatile int maxMultiplex = 1;\n     private volatile int maxUsageCount = -1;\n \n-    public enum StrategyType\n-    {\n-        /**\n-         * A strategy that looks for an entry always starting from the first entry.\n-         * It will favour the early entries in the pool, but may contend on them more.\n-         */\n-        FIRST,\n-\n-        /**\n-         * A strategy that looks for an entry by iterating from a random starting\n-         * index.  No entries are favoured and contention is reduced.\n-         */\n-        RANDOM,\n-\n-        /**\n-         * A strategy that uses the {@link Thread#getId()} of the current thread\n-         * to select a starting point for an entry search.  Whilst not as performant as\n-         * using the {@link ThreadLocal} cache, it may be suitable when the pool is substantially smaller\n-         * than the number of available threads.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        THREAD_ID,\n-\n-        /**\n-         * A strategy that looks for an entry by iterating from a starting point\n-         * that is incremented on every search. This gives similar results to the\n-         * random strategy but with more predictable behaviour.\n-         * No entries are favoured and contention is reduced.\n-         */\n-        ROUND_ROBIN,\n-    }\n-\n     /**\n-     * Construct a Pool with a specified lookup strategy and no\n-     * {@link ThreadLocal} cache.\n+     * Construct a Pool with the specified thread-local cache size.\n      *\n-     * @param strategyType The strategy to used for looking up entries.\n-     * @param maxEntries the maximum amount of entries that the pool will accept.\n-     */\n-    public Pool(StrategyType strategyType, int maxEntries)\n-    {\n-        this(strategyType, maxEntries, false);\n-    }\n-\n-    /**\n-     * Construct a Pool with the specified thread-local cache size and\n-     * an optional {@link ThreadLocal} cache.\n-     * @param strategyType The strategy to used for looking up entries.\n      * @param maxEntries the maximum amount of entries that the pool will accept.\n-     * @param cache True if a {@link ThreadLocal} cache should be used to try the most recently released entry.\n+     * @param cacheSize the thread-local cache size. A value less than 1 means the cache is disabled.\n      */\n-    public Pool(StrategyType strategyType, int maxEntries, boolean cache)\n+    public Pool(int maxEntries, int cacheSize)\n     {\n         this.maxEntries = maxEntries;\n-        this.strategyType = strategyType;\n-        this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.cacheSize = cacheSize;\n+        if (cacheSize > 0)\n+            this.cache = ThreadLocal.withInitial(() -> new ArrayList<Entry>(cacheSize));\n+        else\n+            this.cache = null;\n     }\n \n-    public int getReservedCount()\n+    public int getPendingConnectionCount()\n     {\n-        return pending.get();\n+        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n     }\n \n-    public int getIdleCount()\n+    public int getIdleConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isIdle).count();\n+        return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseCount()\n+    public int getInUseConnectionCount()\n     {\n-        return (int)entries.stream().filter(Entry::isInUse).count();\n+        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..130315dcc1 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -83,19 +90,19 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             this.cache = null;\n     }\n \n-    public int getPendingConnectionCount()\n+    public int getReservedCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> entry.getPooled() == null).count();\n+        return pending.get();\n     }\n \n-    public int getIdleConnectionCount()\n+    public int getIdleCount()\n     {\n         return (int)sharedList.stream().filter(Entry::isIdle).count();\n     }\n \n-    public int getInUseConnectionCount()\n+    public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(entry -> !entry.isIdle()).count();\n+        return (int)sharedList.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 130315dcc1..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -97,12 +141,12 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n     public int getIdleCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isIdle).count();\n+        return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n     public int getInUseCount()\n     {\n-        return (int)sharedList.stream().filter(Entry::isInUse).count();\n+        return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n     public int getMaxEntries()\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -149,6 +149,11 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    public int getClosedCount()\n+    {\n+        return (int)entries.stream().filter(Entry::isClosed).count();\n+    }\n+\n     public int getMaxEntries()\n     {\n         return maxEntries;\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -131,74 +129,154 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         this.maxEntries = maxEntries;\n         this.strategyType = strategyType;\n         this.cache = cache ? new ThreadLocal<>() : null;\n-        nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n+        this.nextIndex = strategyType == StrategyType.ROUND_ROBIN ? new AtomicInteger() : null;\n     }\n \n+    /**\n+     * @return the number of reserved entries\n+     */\n+    @ManagedAttribute(\"The number of reserved entries\")\n     public int getReservedCount()\n     {\n         return (int)entries.stream().filter(Entry::isReserved).count();\n     }\n \n+    /**\n+     * @return the number of idle entries\n+     */\n+    @ManagedAttribute(\"The number of idle entries\")\n     public int getIdleCount()\n     {\n         return (int)entries.stream().filter(Entry::isIdle).count();\n     }\n \n+    /**\n+     * @return the number of in-use entries\n+     */\n+    @ManagedAttribute(\"The number of in-use entries\")\n     public int getInUseCount()\n     {\n         return (int)entries.stream().filter(Entry::isInUse).count();\n     }\n \n+    /**\n+     * @return the number of closed entries\n+     */\n+    @ManagedAttribute(\"The number of closed entries\")\n     public int getClosedCount()\n     {\n         return (int)entries.stream().filter(Entry::isClosed).count();\n     }\n \n+    /**\n+     * @return the maximum number of entries\n+     */\n+    @ManagedAttribute(\"The maximum number of entries\")\n     public int getMaxEntries()\n     {\n         return maxEntries;\n     }\n \n+    /**\n+     * @return the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @ManagedAttribute(\"The default maximum multiplex count of entries\")\n+    @Deprecated\n     public int getMaxMultiplex()\n     {\n-        return maxMultiplex;\n+        return maxMultiplex == -1 ? 1 : maxMultiplex;\n     }\n \n+    /**\n+     * <p>Retrieves the max multiplex count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max multiplex count for the given pooled object\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxMultiplex(T pooled)\n+    {\n+        return getMaxMultiplex();\n+    }\n+\n+    /**\n+     * <p>Sets the default maximum multiplex count for the Pool's entries.</p>\n+     *\n+     * @param maxMultiplex the default maximum multiplex count of entries\n+     * @deprecated Multiplex functionalities will be removed\n+     */\n+    @Deprecated\n     public final void setMaxMultiplex(int maxMultiplex)\n     {\n         if (maxMultiplex < 1)\n             throw new IllegalArgumentException(\"Max multiplex must be >= 1\");\n-        this.maxMultiplex = maxMultiplex;\n+        try (AutoLock l = lock.lock())\n+        {\n+            if (closed)\n+                return;\n+\n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support multiplexing\");\n+\n+            this.maxMultiplex = maxMultiplex;\n+        }\n     }\n \n     /**\n-     * Get the maximum number of times the entries of the pool\n-     * can be acquired.\n-     * @return the max usage count.\n+     * <p>Returns the maximum number of times the entries of the pool\n+     * can be acquired.</p>\n+     *\n+     * @return the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @ManagedAttribute(\"The default maximum usage count of entries\")\n+    @Deprecated\n     public int getMaxUsageCount()\n     {\n-        return maxUsageCount;\n+        return maxUsage;\n+    }\n+\n+    /**\n+     * <p>Retrieves the max usage count for the given pooled object.</p>\n+     *\n+     * @param pooled the pooled object\n+     * @return the max usage count for the given pooled object\n+     * @deprecated MaxUsage functionalities will be removed\n+     */\n+    @Deprecated\n+    protected int getMaxUsageCount(T pooled)\n+    {\n+        return getMaxUsageCount();\n     }\n \n     /**\n-     * Change the max usage count of the pool's entries. All existing\n-     * idle entries over this new max usage are removed and closed.\n-     * @param maxUsageCount the max usage count.\n+     * <p>Sets the maximum usage count for the Pool's entries.</p>\n+     * <p>All existing idle entries that have a usage count larger\n+     * than this new value are removed from the Pool and closed.</p>\n+     *\n+     * @param maxUsageCount the default maximum usage count of entries\n+     * @deprecated MaxUsage functionalities will be removed\n      */\n+    @Deprecated\n     public final void setMaxUsageCount(int maxUsageCount)\n     {\n         if (maxUsageCount == 0)\n             throw new IllegalArgumentException(\"Max usage count must be != 0\");\n-        this.maxUsageCount = maxUsageCount;\n \n         // Iterate the entries, remove overused ones and collect a list of the closeable removed ones.\n         List<Closeable> copy;\n-        try (Locker.Lock l = locker.lock())\n+        try (AutoLock l = lock.lock())\n         {\n             if (closed)\n                 return;\n \n+            if (entries.stream().anyMatch(MonoEntry.class::isInstance))\n+                throw new IllegalStateException(\"Pool entries do not support max usage\");\n+\n+            this.maxUsage = maxUsageCount;\n+\n             copy = entries.stream()\n                 .filter(entry -> entry.isIdleAndOverUsed() && remove(entry) && entry.pooled instanceof Closeable)\n                 .map(entry -> (Closeable)entry.pooled)\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489223906", "body": "Add `@deprecated` javadoc too.", "bodyText": "Add @deprecated javadoc too.", "bodyHTML": "<p dir=\"auto\">Add <code>@deprecated</code> javadoc too.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:31:56Z", "path": "jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java", "diffHunk": "@@ -176,14 +231,15 @@ public Entry reserve(int allotment)\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMyMDE3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489320173", "bodyText": "I guess we can't just remove it... will do in 10", "author": "gregw", "createdAt": "2020-09-16T10:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 3b70245478..5c118efdd9 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -231,7 +166,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n-    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -128,44 +179,48 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Create a new disabled slot into the pool. The returned entry\n-     * won't be acquirable as long as {@link Entry#enable(Object)}\n-     * has not been called.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n      *\n-     * @param maxReservations the max desired number of reserved entries,\n+     * @param allotment the desired allotment, where each entry handles an allotment of maxMultiplex,\n      * or a negative number to always trigger the reservation of a new entry.\n      * @return a disabled entry that is contained in the pool,\n      * or null if the pool is closed or if the pool already contains\n-     * {@link #getMaxEntries()} entries.\n+     * {@link #getMaxEntries()} entries, or the allotment has already been reserved\n      */\n-    public Entry reserve(int maxReservations)\n+    public Entry reserve(int allotment)\n     {\n-        if (maxReservations >= 0 && getPendingConnectionCount() >= maxReservations)\n-            return null;\n-\n-        lock.lock();\n-        try\n-        {\n-            if (!closed && sharedList.size() < maxEntries)\n-            {\n-                Entry entry = new Entry();\n-                sharedList.add(entry);\n-                return entry;\n-            }\n-            return null;\n-        }\n-        finally\n+        try (Locker.Lock l = locker.lock())\n         {\n-            lock.unlock();\n+            if (closed)\n+                return null;\n+\n+            int space = maxEntries - entries.size();\n+            if (space <= 0)\n+                return null;\n+\n+            // The pending count is an AtomicInteger that is only ever incremented here with\n+            // the lock held.  Thus the pending count can be reduced immediately after the\n+            // test below, but never incremented.  Thus the allotment limit can be enforced.\n+            if (allotment >= 0 && (pending.get() * getMaxMultiplex()) >= allotment)\n+                return null;\n+            pending.incrementAndGet();\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n     }\n \n     /**\n      * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     *\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n      * @param idx the index of the entry to acquire.\n      * @return the specified entry or null if there is none at the specified index or if it is not available.\n      */\n+    @Deprecated\n     public Entry acquireAt(int idx)\n     {\n         if (closed)\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 5c118efdd9..fc0b63368a 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -173,7 +228,7 @@ public class Pool<T> implements AutoCloseable, Dumpable\n \n         try\n         {\n-            Entry entry = sharedList.get(idx);\n+            Entry entry = entries.get(idx);\n             if (entry.tryAcquire())\n                 return entry;\n         }\n", "next_change": {"commit": "f3f918ade2245524f8b6046ae7629645f4f05a7d", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex fc0b63368a..25c3a92eae 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +214,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "0ff1bfdd5e4d6db6b6dd78279b6317fe3bbf9c57", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 25c3a92eae..0cc0cb2426 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,6 +214,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "a26731c5eaaf1ec50d5e6beec1f07543913e88b6", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 0cc0cb2426..bd7be03f26 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -214,31 +241,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "447823316da54172b50d11396b1cbfb6bd432965", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex bd7be03f26..9a9752cad4 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -241,6 +241,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "f836f87754bd73c575be7e894da49dade0a6ac45", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 9a9752cad4..16cde6abb5 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -242,28 +234,30 @@ public class Pool<T> implements AutoCloseable, Dumpable\n     }\n \n     /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     * Create a new disabled slot into the pool.\n+     * The returned entry must ultimately have the {@link Entry#enable(Object, boolean)}\n+     * method called or be removed via {@link Pool.Entry#remove()} or\n+     * {@link Pool#remove(Pool.Entry)}.\n+     *\n+     * @return a disabled entry that is contained in the pool,\n+     * or null if the pool is closed or if the pool already contains\n+     * {@link #getMaxEntries()} entries\n      */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n+    public Entry reserve()\n     {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n+        try (AutoLock l = lock.lock())\n         {\n-            // no entry at that index\n+            if (closed)\n+                return null;\n+\n+            // If we have no space\n+            if (entries.size() >= maxEntries)\n+                return null;\n+\n+            Entry entry = new Entry();\n+            entries.add(entry);\n+            return entry;\n         }\n-        return null;\n     }\n \n     /**\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex 16cde6abb5..d6b4937773 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -260,6 +270,31 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n+    /**\n+     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n+     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n+     * @param idx the index of the entry to acquire.\n+     * @return the specified entry or null if there is none at the specified index or if it is not available.\n+     */\n+    @Deprecated\n+    public Entry acquireAt(int idx)\n+    {\n+        if (closed)\n+            return null;\n+\n+        try\n+        {\n+            Entry entry = entries.get(idx);\n+            if (entry.tryAcquire())\n+                return entry;\n+        }\n+        catch (IndexOutOfBoundsException e)\n+        {\n+            // no entry at that index\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex d6b4937773..c7d59f1586 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -270,31 +265,6 @@ public class Pool<T> implements AutoCloseable, Dumpable\n         }\n     }\n \n-    /**\n-     * Acquire the entry from the pool at the specified index. This method bypasses the thread-local mechanism.\n-     * @deprecated No longer supported. Instead use a {@link StrategyType} to configure the pool.\n-     * @param idx the index of the entry to acquire.\n-     * @return the specified entry or null if there is none at the specified index or if it is not available.\n-     */\n-    @Deprecated\n-    public Entry acquireAt(int idx)\n-    {\n-        if (closed)\n-            return null;\n-\n-        try\n-        {\n-            Entry entry = entries.get(idx);\n-            if (entry.tryAcquire())\n-                return entry;\n-        }\n-        catch (IndexOutOfBoundsException e)\n-        {\n-            // no entry at that index\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Acquire an entry from the pool.\n      * Only enabled entries will be returned from this method and their enable method must not be called.\n", "next_change": {"commit": "e2690cc420ccc47a8c42be2a7e46634cb4449970", "changed_code": [{"header": "diff --git a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\nindex c7d59f1586..556ad61f1d 100644\n--- a/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n+++ b/jetty-util/src/main/java/org/eclipse/jetty/util/Pool.java\n", "chunk": "@@ -259,15 +342,27 @@ public class Pool<T> implements AutoCloseable, Dumpable\n             if (entries.size() >= maxEntries)\n                 return null;\n \n-            Entry entry = new Entry();\n+            Entry entry = newEntry();\n             entries.add(entry);\n             return entry;\n         }\n     }\n \n+    private Entry newEntry()\n+    {\n+        // Do not allow more than 2 implementations of Entry, otherwise call sites in Pool\n+        // referencing Entry methods will become mega-morphic and kill the performance.\n+        if (maxMultiplex >= 0 || maxUsage >= 0)\n+            return new MultiEntry();\n+        return new MonoEntry();\n+    }\n+\n     /**\n-     * Acquire an entry from the pool.\n-     * Only enabled entries will be returned from this method and their enable method must not be called.\n+     * <p>Acquires an entry from the pool.</p>\n+     * <p>Only enabled entries will be returned from this method\n+     * and their {@link Entry#enable(Object, boolean)}\n+     * method must not be called.</p>\n+     *\n      * @return an entry from the pool or null if none is available.\n      */\n     public Entry acquire()\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTM3Mw==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489225373", "body": "new Pool<>(...) is enough, remove type parameter.", "bodyText": "new Pool<>(...) is enough, remove type parameter.", "bodyHTML": "<p dir=\"auto\">new Pool&lt;&gt;(...) is enough, remove type parameter.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:34:39Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -40,20 +50,27 @@\n \n public class PoolTest\n {\n-    public static Stream<Object[]> cacheSize()\n+\n+    interface Factory\n+    {\n+        Pool<String> getPool(int maxSize);\n+    }\n+\n+    public static Stream<Object[]> strategy()\n     {\n         List<Object[]> data = new ArrayList<>();\n-        data.add(new Object[]{0});\n-        data.add(new Object[]{1});\n-        data.add(new Object[]{2});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(RANDOM, s)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s, true)});\n+        data.add(new Object[]{(Factory)s -> new Pool<String>(ROUND_ROBIN, s)});", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 78d94fd337..1259c8503c 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -19,103 +19,48 @@\n package org.eclipse.jetty.util;\n \n import java.io.Closeable;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.stream.Stream;\n \n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n \n import static java.util.stream.Collectors.toList;\n-import static org.eclipse.jetty.util.Pool.StrategyType.FIRST;\n-import static org.eclipse.jetty.util.Pool.StrategyType.RANDOM;\n-import static org.eclipse.jetty.util.Pool.StrategyType.ROUND_ROBIN;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.greaterThan;\n import static org.hamcrest.Matchers.is;\n-import static org.hamcrest.Matchers.lessThanOrEqualTo;\n-import static org.hamcrest.Matchers.not;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.sameInstance;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class PoolTest\n {\n \n-    interface Factory\n+    @Test\n+    public void testAcquireRelease()\n     {\n-        Pool<String> getPool(int maxSize);\n-    }\n-\n-    public static Stream<Object[]> strategy()\n-    {\n-        List<Object[]> data = new ArrayList<>();\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s)});\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(RANDOM, s)});\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(FIRST, s, true)});\n-        data.add(new Object[]{(Factory)s -> new Pool<String>(ROUND_ROBIN, s)});\n-        return data.stream();\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(value = \"strategy\")\n-    public void testAcquireRelease(Factory factory)\n-    {\n-        Pool<String> pool = factory.getPool(1);\n-        pool.reserve(-1).enable(\"aaa\", false);\n-        assertThat(pool.size(), is(1));\n-        assertThat(pool.getReservedCount(), is(0));\n-        assertThat(pool.getIdleCount(), is(1));\n-        assertThat(pool.getInUseCount(), is(0));\n+        Pool<String> pool = new Pool<>(1,0);\n+        pool.reserve(-1).enable(\"aaa\");\n \n+        assertThat(pool.values().stream().findFirst().get().isIdle(), is(true));\n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(pool.size(), is(1));\n-        assertThat(pool.getReservedCount(), is(0));\n-        assertThat(pool.getIdleCount(), is(0));\n-        assertThat(pool.getInUseCount(), is(1));\n-\n-        assertNull(pool.acquire());\n-\n-        e1.release();\n-        assertThat(pool.size(), is(1));\n-        assertThat(pool.getReservedCount(), is(0));\n-        assertThat(pool.getIdleCount(), is(1));\n-        assertThat(pool.getInUseCount(), is(0));\n-\n-        assertThrows(IllegalStateException.class, e1::release);\n-\n+        assertThat(pool.values().stream().findFirst().get().isIdle(), is(false));\n+        assertThat(pool.acquire(), nullValue());\n+        assertThat(pool.release(e1), is(true));\n+        assertThat(pool.values().stream().findFirst().get().isIdle(), is(true));\n+        assertThrows(IllegalStateException.class, () -> pool.release(e1));\n         Pool<String>.Entry e2 = pool.acquire();\n         assertThat(e2.getPooled(), equalTo(\"aaa\"));\n-        assertThat(pool.size(), is(1));\n-        assertThat(pool.getReservedCount(), is(0));\n-        assertThat(pool.getIdleCount(), is(0));\n-        assertThat(pool.getInUseCount(), is(1));\n-\n-        pool.release(e2);\n-        assertThat(pool.size(), is(1));\n-        assertThat(pool.getReservedCount(), is(0));\n-        assertThat(pool.getIdleCount(), is(1));\n-        assertThat(pool.getInUseCount(), is(0));\n-\n-        assertThrows(IllegalStateException.class, () -> pool.release(e2));\n+        assertThat(pool.release(e2), is(true));\n+        assertThrows(NullPointerException.class, () -> pool.release(null));\n     }\n \n-    @ParameterizedTest\n-    @MethodSource(value = \"strategy\")\n-    public void testRemoveBeforeRelease(Factory factory)\n+    @Test\n+    public void testRemoveBeforeRelease()\n     {\n-        Pool<String> pool = factory.getPool(1);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        Pool<String> pool = new Pool<>(1,0);\n+        pool.reserve(-1).enable(\"aaa\");\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(pool.remove(e1), is(true));\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 1259c8503c..4d0ad42273 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -31,36 +35,77 @@ import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.sameInstance;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class PoolTest\n {\n+    public static Stream<Object[]> cacheSize()\n+    {\n+        List<Object[]> data = new ArrayList<>();\n+        data.add(new Object[]{0});\n+        data.add(new Object[]{1});\n+        data.add(new Object[]{2});\n+        return data.stream();\n+    }\n \n-    @Test\n-    public void testAcquireRelease()\n+    @ParameterizedTest\n+    @MethodSource(value = \"cacheSize\")\n+    public void testCache(int cacheSize)\n     {\n-        Pool<String> pool = new Pool<>(1,0);\n-        pool.reserve(-1).enable(\"aaa\");\n+        System.err.println(cacheSize);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"cacheSize\")\n+    public void testAcquireRelease(int cacheSize)\n+    {\n+        Pool<String> pool = new Pool<>(1,cacheSize);\n+        pool.reserve(-1).enable(\"aaa\", false);\n+        assertThat(pool.size(), is(1));\n+        assertThat(pool.getReservedCount(), is(0));\n+        assertThat(pool.getIdleCount(), is(1));\n+        assertThat(pool.getInUseCount(), is(0));\n \n-        assertThat(pool.values().stream().findFirst().get().isIdle(), is(true));\n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(pool.values().stream().findFirst().get().isIdle(), is(false));\n-        assertThat(pool.acquire(), nullValue());\n-        assertThat(pool.release(e1), is(true));\n-        assertThat(pool.values().stream().findFirst().get().isIdle(), is(true));\n-        assertThrows(IllegalStateException.class, () -> pool.release(e1));\n+        assertThat(pool.size(), is(1));\n+        assertThat(pool.getReservedCount(), is(0));\n+        assertThat(pool.getIdleCount(), is(0));\n+        assertThat(pool.getInUseCount(), is(1));\n+\n+        assertNull(pool.acquire());\n+\n+        e1.release();\n+        assertThat(pool.size(), is(1));\n+        assertThat(pool.getReservedCount(), is(0));\n+        assertThat(pool.getIdleCount(), is(1));\n+        assertThat(pool.getInUseCount(), is(0));\n+\n+        assertThrows(IllegalStateException.class, e1::release);\n+\n         Pool<String>.Entry e2 = pool.acquire();\n         assertThat(e2.getPooled(), equalTo(\"aaa\"));\n-        assertThat(pool.release(e2), is(true));\n-        assertThrows(NullPointerException.class, () -> pool.release(null));\n+        assertThat(pool.size(), is(1));\n+        assertThat(pool.getReservedCount(), is(0));\n+        assertThat(pool.getIdleCount(), is(0));\n+        assertThat(pool.getInUseCount(), is(1));\n+\n+        pool.release(e2);\n+        assertThat(pool.size(), is(1));\n+        assertThat(pool.getReservedCount(), is(0));\n+        assertThat(pool.getIdleCount(), is(1));\n+        assertThat(pool.getInUseCount(), is(0));\n+\n+        assertThrows(IllegalStateException.class, () -> pool.release(e2));\n     }\n \n-    @Test\n-    public void testRemoveBeforeRelease()\n+    @ParameterizedTest\n+    @MethodSource(value = \"cacheSize\")\n+    public void testRemoveBeforeRelease(int cacheSize)\n     {\n-        Pool<String> pool = new Pool<>(1,0);\n-        pool.reserve(-1).enable(\"aaa\");\n+        Pool<String> pool = new Pool<>(1, cacheSize);\n+        pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(pool.remove(e1), is(true));\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 4d0ad42273..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -101,10 +111,10 @@ public class PoolTest\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testRemoveBeforeRelease(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testRemoveBeforeRelease(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n", "next_change": {"commit": "403d5ec318ffaa20f1f2c0b62df217cfc99ebbe0", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 00071f247a..52abccdde8 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -115,7 +114,7 @@ public class PoolTest\n     public void testRemoveBeforeRelease(Factory factory)\n     {\n         Pool<String> pool = factory.getPool(1);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve().enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(pool.remove(e1), is(true));\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 52abccdde8..719ae61db1 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -113,10 +129,10 @@ public class PoolTest\n     @MethodSource(value = \"strategy\")\n     public void testRemoveBeforeRelease(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n-        pool.reserve().enable(\"aaa\", false);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n+        pool.reserve(-1).enable(new CloseableHolder(\"aaa\"), false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(pool.remove(e1), is(true));\n         assertThat(pool.remove(e1), is(false));\n         assertThat(pool.release(e1), is(false));\n", "next_change": {"commit": "058a488c3079d18e418a367944dd86aed5743e86", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 719ae61db1..4d5b661528 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -130,7 +125,7 @@ public class PoolTest\n     public void testRemoveBeforeRelease(Factory factory)\n     {\n         Pool<CloseableHolder> pool = factory.getPool(1);\n-        pool.reserve(-1).enable(new CloseableHolder(\"aaa\"), false);\n+        pool.reserve().enable(new CloseableHolder(\"aaa\"), false);\n \n         Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(pool.remove(e1), is(true));\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 4d0ad42273..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -114,10 +124,10 @@ public class PoolTest\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testCloseBeforeRelease(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testCloseBeforeRelease(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n", "next_change": {"commit": "403d5ec318ffaa20f1f2c0b62df217cfc99ebbe0", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 00071f247a..52abccdde8 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -128,7 +127,7 @@ public class PoolTest\n     public void testCloseBeforeRelease(Factory factory)\n     {\n         Pool<String> pool = factory.getPool(1);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve().enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(pool.size(), is(1));\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 52abccdde8..719ae61db1 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -126,21 +142,22 @@ public class PoolTest\n     @MethodSource(value = \"strategy\")\n     public void testCloseBeforeRelease(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n-        pool.reserve().enable(\"aaa\", false);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n+        pool.reserve().enable(new CloseableHolder(\"aaa\"), false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(pool.size(), is(1));\n         pool.close();\n         assertThat(pool.size(), is(0));\n         assertThat(pool.release(e1), is(false));\n+        assertThat(e1.getPooled().closed, is(true));\n     }\n \n     @ParameterizedTest\n     @MethodSource(value = \"strategy\")\n     public void testMaxPoolSize(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n         assertThat(pool.size(), is(0));\n         assertThat(pool.reserve(), notNullValue());\n         assertThat(pool.size(), is(1));\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 1259c8503c..4d0ad42273 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -68,11 +113,12 @@ public class PoolTest\n         assertThat(pool.release(e1), is(false));\n     }\n \n-    @Test\n-    public void testCloseBeforeRelease()\n+    @ParameterizedTest\n+    @MethodSource(value = \"cacheSize\")\n+    public void testCloseBeforeRelease(int cacheSize)\n     {\n-        Pool<String> pool = new Pool<>(1,0);\n-        pool.reserve(-1).enable(\"aaa\");\n+        Pool<String> pool = new Pool<>(1, cacheSize);\n+        pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(pool.size(), is(1));\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 4d0ad42273..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -114,10 +124,10 @@ public class PoolTest\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testCloseBeforeRelease(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testCloseBeforeRelease(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n", "next_change": {"commit": "403d5ec318ffaa20f1f2c0b62df217cfc99ebbe0", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 00071f247a..52abccdde8 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -128,7 +127,7 @@ public class PoolTest\n     public void testCloseBeforeRelease(Factory factory)\n     {\n         Pool<String> pool = factory.getPool(1);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve().enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(pool.size(), is(1));\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 52abccdde8..719ae61db1 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -126,21 +142,22 @@ public class PoolTest\n     @MethodSource(value = \"strategy\")\n     public void testCloseBeforeRelease(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n-        pool.reserve().enable(\"aaa\", false);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n+        pool.reserve().enable(new CloseableHolder(\"aaa\"), false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(pool.size(), is(1));\n         pool.close();\n         assertThat(pool.size(), is(0));\n         assertThat(pool.release(e1), is(false));\n+        assertThat(e1.getPooled().closed, is(true));\n     }\n \n     @ParameterizedTest\n     @MethodSource(value = \"strategy\")\n     public void testMaxPoolSize(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n         assertThat(pool.size(), is(0));\n         assertThat(pool.reserve(), notNullValue());\n         assertThat(pool.size(), is(1));\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjQxNQ==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489226415", "body": "This test contains an unused `e2` variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing `e1`, or that `e2 == e1`, etc.", "bodyText": "This test contains an unused e2 variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing e1, or that e2 == e1, etc.", "bodyHTML": "<p dir=\"auto\">This test contains an unused <code>e2</code> variable that I would instead add to the asserts, for example, to confirm that it is in use even after removing <code>e1</code>, or that <code>e2 == e1</code>, etc.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:36:34Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -331,34 +347,44 @@ public void testMaxUsageCount(int cacheSize)\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testMaxMultiplex(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testMaxMultiplex(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(2, cacheSize);\n+        Pool<String> pool = factory.getPool(2);\n         pool.setMaxMultiplex(3);\n-        pool.reserve(-1).enable(\"aaa\", false);\n-        pool.reserve(-1).enable(\"bbb\", false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n-        Pool<String>.Entry e2 = pool.acquire();\n-        Pool<String>.Entry e3 = pool.acquire();\n-        Pool<String>.Entry e4 = pool.acquire();\n-        assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(e1, sameInstance(e2));\n-        assertThat(e1, sameInstance(e3));\n-        assertThat(e4.getPooled(), equalTo(\"bbb\"));\n-        assertThat(pool.release(e1), is(true));\n-        Pool<String>.Entry e5 = pool.acquire();\n-        assertThat(e2, sameInstance(e5));\n-        Pool<String>.Entry e6 = pool.acquire();\n-        assertThat(e4, sameInstance(e6));\n+        Map<String, AtomicInteger> counts = new HashMap<>();\n+        AtomicInteger a = new AtomicInteger();\n+        AtomicInteger b = new AtomicInteger();\n+        counts.put(\"a\", a);\n+        counts.put(\"b\", b);\n+        pool.reserve(-1).enable(\"a\", false);\n+        pool.reserve(-1).enable(\"b\", false);\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), greaterThan(0));\n+        assertThat(a.get(), lessThanOrEqualTo(3));\n+        assertThat(b.get(), greaterThan(0));\n+        assertThat(b.get(), lessThanOrEqualTo(3));\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), is(3));\n+        assertThat(b.get(), is(3));\n+\n+        assertNull(pool.acquire());\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testRemoveMultiplexed(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testRemoveMultiplexed(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.reserve(-1).enable(\"aaa\", false);", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 78d94fd337..1259c8503c 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -346,47 +250,35 @@ public class PoolTest\n         assertThat(pool.release(e1Copy), is(false));\n     }\n \n-    @ParameterizedTest\n-    @MethodSource(value = \"strategy\")\n-    public void testMaxMultiplex(Factory factory)\n+    @Test\n+    public void testMaxMultiplex()\n     {\n-        Pool<String> pool = factory.getPool(2);\n+        Pool<String> pool = new Pool<>(2, 0);\n         pool.setMaxMultiplex(3);\n+        pool.reserve(-1).enable(\"aaa\");\n+        pool.reserve(-1).enable(\"bbb\");\n \n-        Map<String, AtomicInteger> counts = new HashMap<>();\n-        AtomicInteger a = new AtomicInteger();\n-        AtomicInteger b = new AtomicInteger();\n-        counts.put(\"a\", a);\n-        counts.put(\"b\", b);\n-        pool.reserve(-1).enable(\"a\", false);\n-        pool.reserve(-1).enable(\"b\", false);\n-\n-        counts.get(pool.acquire().getPooled()).incrementAndGet();\n-        counts.get(pool.acquire().getPooled()).incrementAndGet();\n-        counts.get(pool.acquire().getPooled()).incrementAndGet();\n-        counts.get(pool.acquire().getPooled()).incrementAndGet();\n-\n-        assertThat(a.get(), greaterThan(0));\n-        assertThat(a.get(), lessThanOrEqualTo(3));\n-        assertThat(b.get(), greaterThan(0));\n-        assertThat(b.get(), lessThanOrEqualTo(3));\n-\n-        counts.get(pool.acquire().getPooled()).incrementAndGet();\n-        counts.get(pool.acquire().getPooled()).incrementAndGet();\n-\n-        assertThat(a.get(), is(3));\n-        assertThat(b.get(), is(3));\n-\n-        assertNull(pool.acquire());\n+        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<String>.Entry e2 = pool.acquire();\n+        Pool<String>.Entry e3 = pool.acquire();\n+        Pool<String>.Entry e4 = pool.acquire();\n+        assertThat(e1.getPooled(), equalTo(\"aaa\"));\n+        assertThat(e1, sameInstance(e2));\n+        assertThat(e1, sameInstance(e3));\n+        assertThat(e4.getPooled(), equalTo(\"bbb\"));\n+        assertThat(pool.release(e1), is(true));\n+        Pool<String>.Entry e5 = pool.acquire();\n+        assertThat(e2, sameInstance(e5));\n+        Pool<String>.Entry e6 = pool.acquire();\n+        assertThat(e4, sameInstance(e6));\n     }\n \n-    @ParameterizedTest\n-    @MethodSource(value = \"strategy\")\n-    public void testRemoveMultiplexed(Factory factory)\n+    @Test\n+    public void testRemoveMultiplexed()\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<String> pool = new Pool<>(1, 0);\n         pool.setMaxMultiplex(2);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve(-1).enable(\"aaa\");\n \n         Pool<String>.Entry e1 = pool.acquire();\n         Pool<String>.Entry e2 = pool.acquire();\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 1259c8503c..4d0ad42273 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -273,12 +361,13 @@ public class PoolTest\n         assertThat(e4, sameInstance(e6));\n     }\n \n-    @Test\n-    public void testRemoveMultiplexed()\n+    @ParameterizedTest\n+    @MethodSource(value = \"cacheSize\")\n+    public void testRemoveMultiplexed(int cacheSize)\n     {\n-        Pool<String> pool = new Pool<>(1, 0);\n+        Pool<String> pool = new Pool<>(1, cacheSize);\n         pool.setMaxMultiplex(2);\n-        pool.reserve(-1).enable(\"aaa\");\n+        pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         Pool<String>.Entry e2 = pool.acquire();\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 4d0ad42273..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -338,39 +347,54 @@ public class PoolTest\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testMaxMultiplex(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testMaxMultiplex(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(2, cacheSize);\n+        Pool<String> pool = factory.getPool(2);\n         pool.setMaxMultiplex(3);\n-        pool.reserve(-1).enable(\"aaa\", false);\n-        pool.reserve(-1).enable(\"bbb\", false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n-        Pool<String>.Entry e2 = pool.acquire();\n-        Pool<String>.Entry e3 = pool.acquire();\n-        Pool<String>.Entry e4 = pool.acquire();\n-        assertThat(e1.getPooled(), equalTo(\"aaa\"));\n-        assertThat(e1, sameInstance(e2));\n-        assertThat(e1, sameInstance(e3));\n-        assertThat(e4.getPooled(), equalTo(\"bbb\"));\n-        assertThat(pool.release(e1), is(true));\n-        Pool<String>.Entry e5 = pool.acquire();\n-        assertThat(e2, sameInstance(e5));\n-        Pool<String>.Entry e6 = pool.acquire();\n-        assertThat(e4, sameInstance(e6));\n+        Map<String, AtomicInteger> counts = new HashMap<>();\n+        AtomicInteger a = new AtomicInteger();\n+        AtomicInteger b = new AtomicInteger();\n+        counts.put(\"a\", a);\n+        counts.put(\"b\", b);\n+        pool.reserve(-1).enable(\"a\", false);\n+        pool.reserve(-1).enable(\"b\", false);\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), greaterThan(0));\n+        assertThat(a.get(), lessThanOrEqualTo(3));\n+        assertThat(b.get(), greaterThan(0));\n+        assertThat(b.get(), lessThanOrEqualTo(3));\n+\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+        counts.get(pool.acquire().getPooled()).incrementAndGet();\n+\n+        assertThat(a.get(), is(3));\n+        assertThat(b.get(), is(3));\n+\n+        assertNull(pool.acquire());\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testRemoveMultiplexed(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testRemoveMultiplexed(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n+        assertThat(e1, notNullValue());\n         Pool<String>.Entry e2 = pool.acquire();\n+        assertThat(e2, notNullValue());\n+        assertThat(e2, sameInstance(e1));\n+        assertThat(e2.getUsageCount(), is(2));\n+\n         assertThat(pool.values().stream().findFirst().get().isIdle(), is(false));\n \n         assertThat(pool.remove(e1), is(false));\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 00071f247a..719ae61db1 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -384,13 +433,13 @@ public class PoolTest\n     @MethodSource(value = \"strategy\")\n     public void testRemoveMultiplexed(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve().enable(new CloseableHolder(\"aaa\"), false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(e1, notNullValue());\n-        Pool<String>.Entry e2 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e2 = pool.acquire();\n         assertThat(e2, notNullValue());\n         assertThat(e2, sameInstance(e1));\n         assertThat(e2.getUsageCount(), is(2));\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNzM1Ng==", "url": "https://github.com/eclipse/jetty.project/pull/5218#discussion_r489227356", "body": "This test contains an unused variable `e2` that I would use in asserts, at least to verify that `e2 == e1`.", "bodyText": "This test contains an unused variable e2 that I would use in asserts, at least to verify that e2 == e1.", "bodyHTML": "<p dir=\"auto\">This test contains an unused variable <code>e2</code> that I would use in asserts, at least to verify that <code>e2 == e1</code>.</p>", "author": "sbordet", "createdAt": "2020-09-16T07:38:19Z", "path": "jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java", "diffHunk": "@@ -506,10 +532,10 @@ public void testMultiplexMaxUsageReachedAcquireThenReleaseThenRemove(int cacheSi\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testUsageCountAfterReachingMaxMultiplexLimit(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n         pool.reserve(-1).enable(\"aaa\", false);", "originalCommit": "1ef761ed10d5d818a7c3e63a0d5769a00e6630af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2fe01626a5a54583c844b92ae96aa32664366fb1", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 78d94fd337..1259c8503c 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -531,14 +416,13 @@ public class PoolTest\n         assertThat(pool.size(), is(0));\n     }\n \n-    @ParameterizedTest\n-    @MethodSource(value = \"strategy\")\n-    public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n+    @Test\n+    public void testUsageCountAfterReachingMaxMultiplexLimit()\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<String> pool = new Pool<>(1, 0);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve(-1).enable(\"aaa\");\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n", "next_change": {"commit": "cd42fd1635c75d2b509d2d97fdce5b8a65104628", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 1259c8503c..4d0ad42273 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -416,13 +512,14 @@ public class PoolTest\n         assertThat(pool.size(), is(0));\n     }\n \n-    @Test\n-    public void testUsageCountAfterReachingMaxMultiplexLimit()\n+    @ParameterizedTest\n+    @MethodSource(value = \"cacheSize\")\n+    public void testUsageCountAfterReachingMaxMultiplexLimit(int cacheSize)\n     {\n-        Pool<String> pool = new Pool<>(1, 0);\n+        Pool<String> pool = new Pool<>(1, cacheSize);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n-        pool.reserve(-1).enable(\"aaa\");\n+        pool.reserve(-1).enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n", "next_change": {"commit": "ba22c08fde5362fe2e89e9c417d2a90658c74283", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 4d0ad42273..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -513,10 +537,10 @@ public class PoolTest\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testUsageCountAfterReachingMaxMultiplexLimit(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(1, cacheSize);\n+        Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n         pool.reserve(-1).enable(\"aaa\", false);\n", "next_change": {"commit": "403d5ec318ffaa20f1f2c0b62df217cfc99ebbe0", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 00071f247a..52abccdde8 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -543,7 +585,7 @@ public class PoolTest\n         Pool<String> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve().enable(\"aaa\", false);\n \n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 52abccdde8..719ae61db1 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -582,14 +589,14 @@ public class PoolTest\n     @MethodSource(value = \"strategy\")\n     public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n-        pool.reserve().enable(\"aaa\", false);\n+        pool.reserve().enable(new CloseableHolder(\"aaa\"), false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n-        Pool<String>.Entry e2 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e2 = pool.acquire();\n         assertThat(e2, sameInstance(e1));\n         assertThat(e1.getUsageCount(), is(2));\n         assertThat(pool.acquire(), nullValue());\n", "next_change": null}]}}]}}, {"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 4d0ad42273..00071f247a 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -524,25 +548,25 @@ public class PoolTest\n         Pool<String>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n         Pool<String>.Entry e2 = pool.acquire();\n+        assertThat(e2, sameInstance(e1));\n         assertThat(e1.getUsageCount(), is(2));\n         assertThat(pool.acquire(), nullValue());\n         assertThat(e1.getUsageCount(), is(2));\n     }\n \n-    @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testConfigLimits(int cacheSize)\n+    @Test\n+    public void testConfigLimits()\n     {\n-        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(1, 0).setMaxMultiplex(0));\n-        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(1, 0).setMaxMultiplex(-1));\n-        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(1, 0).setMaxUsageCount(0));\n+        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(FIRST, 1).setMaxMultiplex(0));\n+        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(FIRST, 1).setMaxMultiplex(-1));\n+        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(FIRST, 1).setMaxUsageCount(0));\n     }\n \n     @ParameterizedTest\n-    @MethodSource(value = \"cacheSize\")\n-    public void testAcquireWithCreator(int cacheSize)\n+    @MethodSource(value = \"strategy\")\n+    public void testAcquireWithCreator(Factory factory)\n     {\n-        Pool<String> pool = new Pool<>(2, cacheSize);\n+        Pool<String> pool = factory.getPool(2);\n \n         assertThat(pool.size(), is(0));\n         assertThat(pool.acquire(e -> null), nullValue());\n", "next_change": {"commit": "0dec883fdad0951b212545ce76deda748c0c4957", "changed_code": [{"header": "diff --git a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\nindex 00071f247a..719ae61db1 100644\n--- a/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n+++ b/jetty-util/src/test/java/org/eclipse/jetty/util/PoolTest.java\n", "chunk": "@@ -540,40 +589,79 @@ public class PoolTest\n     @MethodSource(value = \"strategy\")\n     public void testUsageCountAfterReachingMaxMultiplexLimit(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(1);\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n         pool.setMaxMultiplex(2);\n         pool.setMaxUsageCount(10);\n-        pool.reserve(-1).enable(\"aaa\", false);\n+        pool.reserve().enable(new CloseableHolder(\"aaa\"), false);\n \n-        Pool<String>.Entry e1 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire();\n         assertThat(e1.getUsageCount(), is(1));\n-        Pool<String>.Entry e2 = pool.acquire();\n+        Pool<CloseableHolder>.Entry e2 = pool.acquire();\n         assertThat(e2, sameInstance(e1));\n         assertThat(e1.getUsageCount(), is(2));\n         assertThat(pool.acquire(), nullValue());\n         assertThat(e1.getUsageCount(), is(2));\n     }\n \n+    @ParameterizedTest\n+    @MethodSource(value = \"strategy\")\n+    public void testDynamicMaxUsageCountChangeOverflowMaxInt(Factory factory)\n+    {\n+        Pool<CloseableHolder> pool = factory.getPool(1);\n+        Pool<CloseableHolder>.Entry entry = pool.reserve();\n+        entry.enable(new CloseableHolder(\"aaa\"), false);\n+        entry.setUsageCount(Integer.MAX_VALUE);\n+\n+        Pool<CloseableHolder>.Entry acquired1 = pool.acquire();\n+        assertThat(acquired1, notNullValue());\n+        assertThat(pool.release(acquired1), is(true));\n+\n+        pool.setMaxUsageCount(1);\n+        Pool<CloseableHolder>.Entry acquired2 = pool.acquire();\n+        assertThat(acquired2, nullValue());\n+        assertThat(entry.getPooled().closed, is(true));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"strategy\")\n+    public void testDynamicMaxUsageCountChangeSweep(Factory factory)\n+    {\n+        Pool<CloseableHolder> pool = factory.getPool(2);\n+        Pool<CloseableHolder>.Entry entry1 = pool.reserve();\n+        entry1.enable(new CloseableHolder(\"aaa\"), false);\n+        Pool<CloseableHolder>.Entry entry2 = pool.reserve();\n+        entry2.enable(new CloseableHolder(\"bbb\"), false);\n+\n+        Pool<CloseableHolder>.Entry acquired1 = pool.acquire();\n+        assertThat(acquired1, notNullValue());\n+        assertThat(pool.release(acquired1), is(true));\n+\n+        assertThat(pool.size(), is(2));\n+        pool.setMaxUsageCount(1);\n+        assertThat(pool.size(), is(1));\n+        assertThat(entry1.getPooled().closed ^ entry2.getPooled().closed, is(true));\n+    }\n+\n     @Test\n     public void testConfigLimits()\n     {\n-        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(FIRST, 1).setMaxMultiplex(0));\n-        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(FIRST, 1).setMaxMultiplex(-1));\n-        assertThrows(IllegalArgumentException.class, () -> new Pool<String>(FIRST, 1).setMaxUsageCount(0));\n+        assertThrows(IllegalArgumentException.class, () -> new Pool<CloseableHolder>(FIRST, 1).setMaxMultiplex(0));\n+        assertThrows(IllegalArgumentException.class, () -> new Pool<CloseableHolder>(FIRST, 1).setMaxMultiplex(-1));\n+        assertThrows(IllegalArgumentException.class, () -> new Pool<CloseableHolder>(FIRST, 1).setMaxUsageCount(0));\n     }\n \n     @ParameterizedTest\n     @MethodSource(value = \"strategy\")\n     public void testAcquireWithCreator(Factory factory)\n     {\n-        Pool<String> pool = factory.getPool(2);\n+        Pool<CloseableHolder> pool = factory.getPool(2);\n \n         assertThat(pool.size(), is(0));\n         assertThat(pool.acquire(e -> null), nullValue());\n         assertThat(pool.size(), is(0));\n \n-        Pool<String>.Entry e1 = pool.acquire(e -> \"e1\");\n-        assertThat(e1.getPooled(), is(\"e1\"));\n+        Pool<CloseableHolder>.Entry e1 = pool.acquire(e -> new CloseableHolder(\"e1\"));\n+        assertThat(e1.getPooled().value, is(\"e1\"));\n         assertThat(pool.size(), is(1));\n         assertThat(pool.getReservedCount(), is(0));\n         assertThat(pool.getInUseCount(), is(1));\n", "next_change": null}]}}]}}]}}]}}, {"oid": "f9773d5ae3ab72c189fae474bd138951b5b5e73a", "url": "https://github.com/eclipse/jetty.project/commit/f9773d5ae3ab72c189fae474bd138951b5b5e73a", "message": "Small javadocs fixes.\n\nSigned-off-by: Simone Bordet <simone.bordet@gmail.com>", "committedDate": "2020-09-16T07:40:14Z", "type": "commit"}, {"oid": "4504fee50b8ebd30becb0e402a7d831bded3e1ea", "url": "https://github.com/eclipse/jetty.project/commit/4504fee50b8ebd30becb0e402a7d831bded3e1ea", "message": "Merge branch 'jetty-9.4.x' into jetty-9.4.x-PoolStrategy", "committedDate": "2020-09-16T10:00:27Z", "type": "commit"}, {"oid": "6c90442d5b368d3d6274acfd81893d37d6755951", "url": "https://github.com/eclipse/jetty.project/commit/6c90442d5b368d3d6274acfd81893d37d6755951", "message": "Updates from review", "committedDate": "2020-09-16T10:13:12Z", "type": "commit"}, {"oid": "21f93c6df1faf2612fa510fa8df28de25877ac8e", "url": "https://github.com/eclipse/jetty.project/commit/21f93c6df1faf2612fa510fa8df28de25877ac8e", "message": "javadoc", "committedDate": "2020-09-16T16:24:44Z", "type": "commit"}]}