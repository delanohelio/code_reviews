{"pr_number": 1280, "pr_title": "Integration of WebSockets POC into Helidon 2.0", "pr_author": "spericas", "pr_createdAt": "2020-01-08T16:30:20Z", "pr_url": "https://github.com/oracle/helidon/pull/1280", "timeline": [{"oid": "302cd1ec01513a32796a10b33562f91571e069cd", "url": "https://github.com/oracle/helidon/commit/302cd1ec01513a32796a10b33562f91571e069cd", "message": "Initial integration of Tyrus integration POC into 2.0 branch.", "committedDate": "2020-01-07T21:00:28Z", "type": "commit"}, {"oid": "0d6080d8dc0bc2b7818f3ffab5efda107580bb69", "url": "https://github.com/oracle/helidon/commit/0d6080d8dc0bc2b7818f3ffab5efda107580bb69", "message": "Merge branch 'master' into websockets20", "committedDate": "2020-01-08T14:02:38Z", "type": "commit"}, {"oid": "423a91e00393b34df7174395988abec4ccd62778", "url": "https://github.com/oracle/helidon/commit/423a91e00393b34df7174395988abec4ccd62778", "message": "Moved new dependencies to parent POM, fixed copyright and checkstyle problems.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-08T14:24:21Z", "type": "commit"}, {"oid": "0b717818ed3d86e8f59c6294dc1ee1ee94fbff33", "url": "https://github.com/oracle/helidon/commit/0b717818ed3d86e8f59c6294dc1ee1ee94fbff33", "message": "Some changes to the webserver engine to handle websocket connections.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-08T16:25:38Z", "type": "commit"}, {"oid": "467059ecbbe5327bbb8fd6dc8e6cceec31457767", "url": "https://github.com/oracle/helidon/commit/467059ecbbe5327bbb8fd6dc8e6cceec31457767", "message": "Fixed copyright and checkstyle.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-08T16:42:04Z", "type": "commit"}, {"oid": "c34dce5495edeb056850c8a08aaadaff0d61ddf4", "url": "https://github.com/oracle/helidon/commit/c34dce5495edeb056850c8a08aaadaff0d61ddf4", "message": "A few more copyright fixes.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-08T17:50:14Z", "type": "commit"}, {"oid": "d19f47db73dbca03fcd96a04cb6c21a8a266d702", "url": "https://github.com/oracle/helidon/commit/d19f47db73dbca03fcd96a04cb6c21a8a266d702", "message": "Spotbugs fix.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-08T18:53:41Z", "type": "commit"}, {"oid": "37a0de214526c55c523146017afaa344da6b4fd6", "url": "https://github.com/oracle/helidon/commit/37a0de214526c55c523146017afaa344da6b4fd6", "message": "Moving up to WebSockets API 1.1.2.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-08T20:22:07Z", "type": "commit"}, {"oid": "938d6f8461c4bfb147eeb5edff9d3ce29fb61756", "url": "https://github.com/oracle/helidon/commit/938d6f8461c4bfb147eeb5edff9d3ce29fb61756", "message": "Created base class for tests. Improved testing for EchoService.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-09T16:56:19Z", "type": "commit"}, {"oid": "077141012649538f66e2a2f7d16adee443f3bfd7", "url": "https://github.com/oracle/helidon/commit/077141012649538f66e2a2f7d16adee443f3bfd7", "message": "Basic support for WebSocket programmatic API. New and improved testing that includes verification of encoders and decoders.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-10T14:43:48Z", "type": "commit"}, {"oid": "7e0d81d4acab59263d18869b9821242f7749fdd3", "url": "https://github.com/oracle/helidon/commit/7e0d81d4acab59263d18869b9821242f7749fdd3", "message": "New routing tests. Some additional changes to test framework.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-10T19:46:31Z", "type": "commit"}, {"oid": "7c5079435eaeca96117ab1ab1e127a68e94923d0", "url": "https://github.com/oracle/helidon/commit/7c5079435eaeca96117ab1ab1e127a68e94923d0", "message": "Filter out any flush buffers in the count.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-13T14:18:45Z", "type": "commit"}, {"oid": "30dcb6b338545d71a0046f908829a0d44a1e2093", "url": "https://github.com/oracle/helidon/commit/30dcb6b338545d71a0046f908829a0d44a1e2093", "message": "Merging with master for PR 1259.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-14T15:12:26Z", "type": "commit"}, {"oid": "989d88141882f9761531a6fd0046adc3e011646e", "url": "https://github.com/oracle/helidon/commit/989d88141882f9761531a6fd0046adc3e011646e", "message": "Initial work to support WebSocket in Helidon MP.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-17T21:07:31Z", "type": "commit"}, {"oid": "ccbda1eb35cc155741251e253676f3535c606f18", "url": "https://github.com/oracle/helidon/commit/ccbda1eb35cc155741251e253676f3535c606f18", "message": "Tyrus component provider to integrate with CDI. Changes to JerseySupport to ignore websocket handshakes. MP server test.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-22T16:45:59Z", "type": "commit"}, {"oid": "507c2df2889ddc995c350621c75cee738f442b44", "url": "https://github.com/oracle/helidon/commit/507c2df2889ddc995c350621c75cee738f442b44", "message": "Support for scanning programmatic endpoints and applications. Allow @ApplicationPath annotation on subclasses of ServerApplicationConfig. Some test changes.", "committedDate": "2020-01-23T16:03:08Z", "type": "commit"}, {"oid": "89c7f697e631c7e2a968c6bf463c265cd255d51b", "url": "https://github.com/oracle/helidon/commit/89c7f697e631c7e2a968c6bf463c265cd255d51b", "message": "Testing websocket applications and programmatic endpoints.", "committedDate": "2020-01-23T19:48:19Z", "type": "commit"}, {"oid": "7345fc9112aee02cede40c9b1890eb32537410f9", "url": "https://github.com/oracle/helidon/commit/7345fc9112aee02cede40c9b1890eb32537410f9", "message": "Extended server builder to allow manually setting a websocket application. Updated corresponding test.", "committedDate": "2020-01-23T20:31:25Z", "type": "commit"}, {"oid": "af077c6255fad9746c1ed588be8f15ef231935bf", "url": "https://github.com/oracle/helidon/commit/af077c6255fad9746c1ed588be8f15ef231935bf", "message": "New MP example that uses REST and WebSockets. Some other minor changes.", "committedDate": "2020-01-24T18:41:29Z", "type": "commit"}, {"oid": "0f2693feb4f5583c2937b4ddba942d13acdcb924", "url": "https://github.com/oracle/helidon/commit/0f2693feb4f5583c2937b4ddba942d13acdcb924", "message": "Fixed copyright problems.", "committedDate": "2020-01-27T14:49:09Z", "type": "commit"}, {"oid": "f3d456af7a3a289a189774cddfe5c51d009dcbb4", "url": "https://github.com/oracle/helidon/commit/f3d456af7a3a289a189774cddfe5c51d009dcbb4", "message": "Make @ServerEndpoint annotation a bean-defining annotation in CDI so that scanning discovers endpoints even if not annotated with a CDI scope. This is the same we currently do for @Path in JAX-RS. Simplified example a bit.", "committedDate": "2020-01-27T19:15:05Z", "type": "commit"}, {"oid": "1e343ecbe8ceac340d02142ca53c27672fea76d4", "url": "https://github.com/oracle/helidon/commit/1e343ecbe8ceac340d02142ca53c27672fea76d4", "message": "New Helidon SE example that uses the WebSocket programmatic API.", "committedDate": "2020-01-28T14:53:38Z", "type": "commit"}, {"oid": "8c4a878216ca536d08c583653a02e8e28da33f3e", "url": "https://github.com/oracle/helidon/commit/8c4a878216ca536d08c583653a02e8e28da33f3e", "message": "Merging with master.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-28T15:20:03Z", "type": "commit"}, {"oid": "4ea25ce005511f8488665dabf8f9ec28565372fe", "url": "https://github.com/oracle/helidon/commit/4ea25ce005511f8488665dabf8f9ec28565372fe", "message": "Initial doc for websocket support in Helidon SE and MP.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-29T16:59:47Z", "type": "commit"}, {"oid": "d6e23e8273a9eee9dad35c1234350dcaeeedec8c", "url": "https://github.com/oracle/helidon/commit/d6e23e8273a9eee9dad35c1234350dcaeeedec8c", "message": "Fixed copyright.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-01-29T18:26:19Z", "type": "commit"}, {"oid": "22865ca8d7a4607769e9a42a1d34481fdbf2872f", "url": "https://github.com/oracle/helidon/commit/22865ca8d7a4607769e9a42a1d34481fdbf2872f", "message": "Dropped support @ApplicationPath on websocket classes in favor of @RoutingPath/@RoutingName.", "committedDate": "2020-01-30T16:22:15Z", "type": "commit"}, {"oid": "71e4f442143fa8c954648dbef4521987052d6cc9", "url": "https://github.com/oracle/helidon/commit/71e4f442143fa8c954648dbef4521987052d6cc9", "message": "Initial support for executor services in Helidon MP. In MP, websocket endpoint methods are no longer called using Netty threads.", "committedDate": "2020-01-30T22:34:36Z", "type": "commit"}, {"oid": "70e696eeca2dc8e76720ee9a17acfa6ac617b308", "url": "https://github.com/oracle/helidon/commit/70e696eeca2dc8e76720ee9a17acfa6ac617b308", "message": "Updated tests to verify threads in which endpoint methods are called.", "committedDate": "2020-01-31T13:20:28Z", "type": "commit"}, {"oid": "0d0e215cfb326c55d421d679515926ec947caa61", "url": "https://github.com/oracle/helidon/commit/0d0e215cfb326c55d421d679515926ec947caa61", "message": "Updated docs explaining websocket threading model for SE and MP.", "committedDate": "2020-01-31T13:39:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MTU4NQ==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374051585", "body": "I do not think the `.flavor()` method is good. We do not control the time when the flavor is configured and this is not the intention (`HelidonFeatures` task is to list features of Helidon, not to handle the flavor of Helidon).\r\nAlso the approach for thread pools is to use one of the existing `ThreadPoolSupplier` classes, that already handle lazy initiialization.\r\nIf you do not need an executor in SE, than why is this method in this class? It should be in the CDI extension for WebSockets, and the `TyrusSupport` class should only provider features to handle the SE model (with capability to build the MP model on top of it).", "bodyText": "I do not think the .flavor() method is good. We do not control the time when the flavor is configured and this is not the intention (HelidonFeatures task is to list features of Helidon, not to handle the flavor of Helidon).\nAlso the approach for thread pools is to use one of the existing ThreadPoolSupplier classes, that already handle lazy initiialization.\nIf you do not need an executor in SE, than why is this method in this class? It should be in the CDI extension for WebSockets, and the TyrusSupport class should only provider features to handle the SE model (with capability to build the MP model on top of it).", "bodyHTML": "<p dir=\"auto\">I do not think the <code>.flavor()</code> method is good. We do not control the time when the flavor is configured and this is not the intention (<code>HelidonFeatures</code> task is to list features of Helidon, not to handle the flavor of Helidon).<br>\nAlso the approach for thread pools is to use one of the existing <code>ThreadPoolSupplier</code> classes, that already handle lazy initiialization.<br>\nIf you do not need an executor in SE, than why is this method in this class? It should be in the CDI extension for WebSockets, and the <code>TyrusSupport</code> class should only provider features to handle the SE model (with capability to build the MP model on top of it).</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:28:11Z", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\nindex fea5753246..b85bdd318f 100644\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n", "chunk": "@@ -201,25 +206,6 @@ public class TyrusSupport implements Service {\n         }\n     }\n \n-    /**\n-     * Creates executor service for Websocket in MP. No executor for SE.\n-     *\n-     * @return Executor service or {@code null}.\n-     */\n-    private static ExecutorService createExecutorService() {\n-        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n-            Config executorConfig = ((Config) ConfigProvider.getConfig())\n-                    .get(\"websocket.executor-service\");\n-\n-            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n-                    .name(\"websocket\")\n-                    .config(executorConfig)\n-                    .build()\n-                    .get());\n-        }\n-        return DEFAULT_THREAD_POOL.get();\n-    }\n-\n     /**\n      * A Helidon handler that integrates with Tyrus and can process WebSocket\n      * upgrade requests.\n", "next_change": {"commit": "701a01cdaea3968d213f7e6a6efeb1f6c11d43fd", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\nindex b85bdd318f..9994b783fa 100644\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n", "chunk": "@@ -202,7 +238,7 @@ public class TyrusSupport implements Service {\n             });\n \n             // Create TyrusSupport using WebSocket engine\n-            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs, extensions);\n         }\n     }\n \n", "next_change": {"commit": "eb05050fa8a998b42f9a52b8278f87456a61ea5e", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\ndeleted file mode 100644\nindex 9994b783fa..0000000000\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ /dev/null\n", "chunk": "@@ -1,317 +0,0 @@\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.helidon.webserver.tyrus;\n-\n-import java.net.URI;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.logging.Logger;\n-\n-import javax.websocket.DeploymentException;\n-import javax.websocket.Extension;\n-import javax.websocket.server.HandshakeRequest;\n-import javax.websocket.server.ServerEndpointConfig;\n-\n-import io.helidon.webserver.Handler;\n-import io.helidon.webserver.Routing;\n-import io.helidon.webserver.ServerRequest;\n-import io.helidon.webserver.ServerResponse;\n-import io.helidon.webserver.Service;\n-\n-import org.glassfish.tyrus.core.RequestContext;\n-import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n-import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n-import org.glassfish.tyrus.server.TyrusServerContainer;\n-import org.glassfish.tyrus.spi.Connection;\n-import org.glassfish.tyrus.spi.WebSocketEngine;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-/**\n- * Class TyrusSupport implemented as a Helidon service.\n- */\n-public class TyrusSupport implements Service {\n-    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n-\n-    /**\n-     * A zero-length buffer indicates a connection flush to Helidon.\n-     */\n-    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n-\n-    private final WebSocketEngine engine;\n-    private final TyrusHandler handler = new TyrusHandler();\n-    private Set<Class<?>> endpointClasses;\n-    private Set<ServerEndpointConfig> endpointConfigs;\n-    private Set<Extension> extensions;\n-\n-    /**\n-     * Create from another instance.\n-     *\n-     * @param other The other instance.\n-     */\n-    protected TyrusSupport(TyrusSupport other) {\n-        this.engine = other.engine;\n-        this.endpointClasses = other.endpointClasses;\n-        this.endpointConfigs = other.endpointConfigs;\n-        this.extensions = other.extensions;\n-    }\n-\n-    TyrusSupport(\n-            WebSocketEngine engine,\n-            Set<Class<?>> endpointClasses,\n-            Set<ServerEndpointConfig> endpointConfigs,\n-            Set<Extension> extensions) {\n-        this.engine = engine;\n-        this.endpointClasses = endpointClasses;\n-        this.endpointConfigs = endpointConfigs;\n-        this.extensions = extensions;\n-    }\n-\n-    /**\n-     * Register our WebSocket handler for all routes. Once a request is received,\n-     * it will be forwarded to the next handler if not a protocol upgrade request.\n-     *\n-     * @param routingRules Routing rules to update.\n-     */\n-    @Override\n-    public void update(Routing.Rules routingRules) {\n-        LOGGER.info(\"Updating TyrusSupport routing routes\");\n-        routingRules.any(handler);\n-    }\n-\n-    /**\n-     * Access to endpoint classes.\n-     *\n-     * @return Immutable set of end endpoint classes.\n-     */\n-    public Set<Class<?>> endpointClasses() {\n-        return Collections.unmodifiableSet(endpointClasses);\n-    }\n-\n-    /**\n-     * Access to endpoint configs.\n-     *\n-     * @return Immutable set of end endpoint configs.\n-     */\n-    public Set<ServerEndpointConfig> endpointConfigs() {\n-        return Collections.unmodifiableSet(endpointConfigs);\n-    }\n-\n-    /**\n-     * Access to extensions.\n-     *\n-     * @return Immutable set of extensions.\n-     */\n-    public Set<Extension> extensions() {\n-        return Collections.unmodifiableSet(extensions);\n-    }\n-\n-    /**\n-     * Returns executor service, can be overridden.\n-     *\n-     * @return Executor service or {@code null}.\n-     */\n-    protected ExecutorService executorService() {\n-        return null;\n-    }\n-\n-    /**\n-     * Creates a builder for this class.\n-     *\n-     * @return A builder for this class.\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Builder for convenient way to create {@link TyrusSupport}.\n-     */\n-    public static class Builder implements io.helidon.common.Builder<TyrusSupport> {\n-\n-        private Set<Class<?>> endpointClasses = new HashSet<>();\n-        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n-        private Set<Extension> extensions = new HashSet<>();\n-\n-        private Builder() {\n-        }\n-\n-        /**\n-         * Register an endpoint class.\n-         *\n-         * @param endpointClass The class.\n-         * @return The builder.\n-         */\n-        public Builder register(Class<?> endpointClass) {\n-            endpointClasses.add(endpointClass);\n-            return this;\n-        }\n-\n-        /**\n-         * Register an endpoint config.\n-         *\n-         * @param endpointConfig The endpoint config.\n-         * @return The builder.\n-         */\n-        public Builder register(ServerEndpointConfig endpointConfig) {\n-            endpointConfigs.add(endpointConfig);\n-            return this;\n-        }\n-\n-        /**\n-         * Register an extension.\n-         *\n-         * @param extension The extension.\n-         * @return The builder.\n-         */\n-        public Builder register(Extension extension) {\n-            extensions.add(extension);\n-            return this;\n-        }\n-\n-        @Override\n-        public TyrusSupport build() {\n-            // a purposefully mutable extensions\n-            Set<Extension> installedExtensions = new HashSet<>(extensions);\n-            // Create container and WebSocket engine\n-            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n-                private final WebSocketEngine engine =\n-                        TyrusWebSocketEngine.builder(this).build();\n-\n-                @Override\n-                public void register(Class<?> endpointClass) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public void register(ServerEndpointConfig serverEndpointConfig) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public Set<Extension> getInstalledExtensions() {\n-                    return installedExtensions;\n-                }\n-\n-                @Override\n-                public WebSocketEngine getWebSocketEngine() {\n-                    return engine;\n-                }\n-            };\n-\n-            // Register classes with context path \"/\"\n-            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n-            endpointClasses.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-            endpointConfigs.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-\n-            // Create TyrusSupport using WebSocket engine\n-            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs, extensions);\n-        }\n-    }\n-\n-    /**\n-     * A Helidon handler that integrates with Tyrus and can process WebSocket\n-     * upgrade requests.\n-     */\n-    private class TyrusHandler implements Handler {\n-\n-        /**\n-         * Process a server request/response.\n-         *\n-         * @param req an HTTP server request.\n-         * @param res an HTTP server response.\n-         */\n-        @Override\n-        public void accept(ServerRequest req, ServerResponse res) {\n-            // Skip this handler if not an upgrade request\n-            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n-            if (secWebSocketKey.isEmpty()) {\n-                req.next();\n-                return;\n-            }\n-\n-            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n-\n-            // Create Tyrus request context and copy request headers\n-            RequestContext requestContext = RequestContext.Builder.create()\n-                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n-                    .build();\n-            req.headers().toMap().forEach((key, value) -> requestContext.getHeaders().put(key, value));\n-\n-            // Use Tyrus to process a WebSocket upgrade request\n-            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n-            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n-\n-            // Respond to upgrade request using response from Tyrus\n-            res.status(upgradeResponse.getStatus());\n-            upgradeResponse.getHeaders().forEach((key, value) -> res.headers().add(key, value));\n-            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n-            res.send(publisherWriter);\n-\n-            // Write reason for failure if not successful\n-            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n-                String reason = upgradeResponse.getReasonPhrase();\n-                if (reason != null) {\n-                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n-                }\n-            }\n-\n-            // Flush upgrade response\n-            publisherWriter.write(FLUSH_BUFFER, null);\n-\n-            // Setup the WebSocket connection and subscriber, calls @onOpen\n-            ExecutorService executorService = executorService();\n-            if (executorService != null) {\n-                CompletableFuture<Connection> future =\n-                        CompletableFuture.supplyAsync(\n-                                () -> upgradeInfo.createConnection(publisherWriter,\n-                                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)),\n-                                executorService);\n-                future.thenAccept(c -> {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(c, executorService);\n-                    req.content().subscribe(subscriber);\n-                });\n-            } else {\n-                Connection connection = upgradeInfo.createConnection(publisherWriter,\n-                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason));\n-                if (connection != null) {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(connection);\n-                    req.content().subscribe(subscriber);\n-                }\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MTk4MA==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374051980", "body": "Please use `Optional.isEmpty()`", "bodyText": "Please use Optional.isEmpty()", "bodyHTML": "<p dir=\"auto\">Please use <code>Optional.isEmpty()</code></p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:29:08Z", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\nindex fea5753246..b85bdd318f 100644\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n", "chunk": "@@ -236,7 +222,7 @@ public class TyrusSupport implements Service {\n         public void accept(ServerRequest req, ServerResponse res) {\n             // Skip this handler if not an upgrade request\n             Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n-            if (!secWebSocketKey.isPresent()) {\n+            if (secWebSocketKey.isEmpty()) {\n                 req.next();\n                 return;\n             }\n", "next_change": {"commit": "eb05050fa8a998b42f9a52b8278f87456a61ea5e", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\ndeleted file mode 100644\nindex b85bdd318f..0000000000\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ /dev/null\n", "chunk": "@@ -1,281 +0,0 @@\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.helidon.webserver.tyrus;\n-\n-import java.net.URI;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.logging.Logger;\n-\n-import javax.websocket.DeploymentException;\n-import javax.websocket.server.HandshakeRequest;\n-import javax.websocket.server.ServerEndpointConfig;\n-\n-import io.helidon.webserver.Handler;\n-import io.helidon.webserver.Routing;\n-import io.helidon.webserver.ServerRequest;\n-import io.helidon.webserver.ServerResponse;\n-import io.helidon.webserver.Service;\n-\n-import org.glassfish.tyrus.core.RequestContext;\n-import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n-import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n-import org.glassfish.tyrus.server.TyrusServerContainer;\n-import org.glassfish.tyrus.spi.Connection;\n-import org.glassfish.tyrus.spi.WebSocketEngine;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-/**\n- * Class TyrusSupport implemented as a Helidon service.\n- */\n-public class TyrusSupport implements Service {\n-    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n-\n-    /**\n-     * A zero-length buffer indicates a connection flush to Helidon.\n-     */\n-    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n-\n-    private final WebSocketEngine engine;\n-    private final TyrusHandler handler = new TyrusHandler();\n-    private Set<Class<?>> endpointClasses;\n-    private Set<ServerEndpointConfig> endpointConfigs;\n-\n-    /**\n-     * Create from another instance.\n-     *\n-     * @param other The other instance.\n-     */\n-    protected TyrusSupport(TyrusSupport other) {\n-        this.engine = other.engine;\n-        this.endpointClasses = other.endpointClasses;\n-        this.endpointConfigs = other.endpointConfigs;\n-    }\n-\n-    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n-        this.engine = engine;\n-        this.endpointClasses = endpointClasses;\n-        this.endpointConfigs = endpointConfigs;\n-    }\n-\n-    /**\n-     * Register our WebSocket handler for all routes. Once a request is received,\n-     * it will be forwarded to the next handler if not a protocol upgrade request.\n-     *\n-     * @param routingRules Routing rules to update.\n-     */\n-    @Override\n-    public void update(Routing.Rules routingRules) {\n-        LOGGER.info(\"Updating TyrusSupport routing routes\");\n-        routingRules.any(handler);\n-    }\n-\n-    /**\n-     * Access to endpoint classes.\n-     *\n-     * @return Immutable set of end endpoint classes.\n-     */\n-    public Set<Class<?>> endpointClasses() {\n-        return Collections.unmodifiableSet(endpointClasses);\n-    }\n-\n-    /**\n-     * Access to endpoint configs.\n-     *\n-     * @return Immutable set of end endpoint configs.\n-     */\n-    public Set<ServerEndpointConfig> endpointConfigs() {\n-        return Collections.unmodifiableSet(endpointConfigs);\n-    }\n-\n-    /**\n-     * Returns executor service, can be overridden.\n-     *\n-     * @return Executor service or {@code null}.\n-     */\n-    protected ExecutorService executorService() {\n-        return null;\n-    }\n-\n-    /**\n-     * Creates a builder for this class.\n-     *\n-     * @return A builder for this class.\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Builder for convenient way to create {@link TyrusSupport}.\n-     */\n-    public static class Builder implements io.helidon.common.Builder<TyrusSupport> {\n-\n-        private Set<Class<?>> endpointClasses = new HashSet<>();\n-        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n-\n-        private Builder() {\n-        }\n-\n-        /**\n-         * Register an endpoint class.\n-         *\n-         * @param endpointClass The class.\n-         * @return The builder.\n-         */\n-        public Builder register(Class<?> endpointClass) {\n-            endpointClasses.add(endpointClass);\n-            return this;\n-        }\n-\n-        /**\n-         * Register an endpoint config.\n-         *\n-         * @param endpointConfig The endpoint config.\n-         * @return The builder.\n-         */\n-        public Builder register(ServerEndpointConfig endpointConfig) {\n-            endpointConfigs.add(endpointConfig);\n-            return this;\n-        }\n-\n-        @Override\n-        public TyrusSupport build() {\n-            // Create container and WebSocket engine\n-            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n-                private final WebSocketEngine engine =\n-                        TyrusWebSocketEngine.builder(this).build();\n-\n-                @Override\n-                public void register(Class<?> endpointClass) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public void register(ServerEndpointConfig serverEndpointConfig) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public WebSocketEngine getWebSocketEngine() {\n-                    return engine;\n-                }\n-            };\n-\n-            // Register classes with context path \"/\"\n-            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n-            endpointClasses.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-            endpointConfigs.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-\n-            // Create TyrusSupport using WebSocket engine\n-            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n-        }\n-    }\n-\n-    /**\n-     * A Helidon handler that integrates with Tyrus and can process WebSocket\n-     * upgrade requests.\n-     */\n-    private class TyrusHandler implements Handler {\n-\n-        /**\n-         * Process a server request/response.\n-         *\n-         * @param req an HTTP server request.\n-         * @param res an HTTP server response.\n-         */\n-        @Override\n-        public void accept(ServerRequest req, ServerResponse res) {\n-            // Skip this handler if not an upgrade request\n-            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n-            if (secWebSocketKey.isEmpty()) {\n-                req.next();\n-                return;\n-            }\n-\n-            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n-\n-            // Create Tyrus request context and copy request headers\n-            RequestContext requestContext = RequestContext.Builder.create()\n-                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n-                    .build();\n-            req.headers().toMap().forEach((key, value) -> requestContext.getHeaders().put(key, value));\n-\n-            // Use Tyrus to process a WebSocket upgrade request\n-            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n-            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n-\n-            // Respond to upgrade request using response from Tyrus\n-            res.status(upgradeResponse.getStatus());\n-            upgradeResponse.getHeaders().forEach((key, value) -> res.headers().add(key, value));\n-            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n-            res.send(publisherWriter);\n-\n-            // Write reason for failure if not successful\n-            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n-                String reason = upgradeResponse.getReasonPhrase();\n-                if (reason != null) {\n-                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n-                }\n-            }\n-\n-            // Flush upgrade response\n-            publisherWriter.write(FLUSH_BUFFER, null);\n-\n-            // Setup the WebSocket connection and subscriber, calls @onOpen\n-            ExecutorService executorService = executorService();\n-            if (executorService != null) {\n-                CompletableFuture<Connection> future =\n-                        CompletableFuture.supplyAsync(\n-                                () -> upgradeInfo.createConnection(publisherWriter,\n-                                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)),\n-                                executorService);\n-                future.thenAccept(c -> {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(c, executorService);\n-                    req.content().subscribe(subscriber);\n-                });\n-            } else {\n-                Connection connection = upgradeInfo.createConnection(publisherWriter,\n-                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason));\n-                if (connection != null) {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(connection);\n-                    req.content().subscribe(subscriber);\n-                }\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MjM5NQ==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374052395", "body": "use `req.headers().toMap().forEach((key, value) -> ...)`", "bodyText": "use req.headers().toMap().forEach((key, value) -> ...)", "bodyHTML": "<p dir=\"auto\">use <code>req.headers().toMap().forEach((key, value) -&gt; ...)</code></p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:30:11Z", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {\n+                req.next();\n+                return;\n+            }\n+\n+            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n+\n+            // Create Tyrus request context and copy request headers\n+            RequestContext requestContext = RequestContext.Builder.create()\n+                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n+                    .build();\n+            req.headers().toMap().entrySet().forEach(e ->", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\nindex fea5753246..b85bdd318f 100644\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n", "chunk": "@@ -247,8 +233,7 @@ public class TyrusSupport implements Service {\n             RequestContext requestContext = RequestContext.Builder.create()\n                     .requestURI(URI.create(req.path().toString()))      // excludes context path\n                     .build();\n-            req.headers().toMap().entrySet().forEach(e ->\n-                    requestContext.getHeaders().put(e.getKey(), e.getValue()));\n+            req.headers().toMap().forEach((key, value) -> requestContext.getHeaders().put(key, value));\n \n             // Use Tyrus to process a WebSocket upgrade request\n             final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n", "next_change": {"commit": "eb05050fa8a998b42f9a52b8278f87456a61ea5e", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\ndeleted file mode 100644\nindex b85bdd318f..0000000000\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ /dev/null\n", "chunk": "@@ -1,281 +0,0 @@\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.helidon.webserver.tyrus;\n-\n-import java.net.URI;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.logging.Logger;\n-\n-import javax.websocket.DeploymentException;\n-import javax.websocket.server.HandshakeRequest;\n-import javax.websocket.server.ServerEndpointConfig;\n-\n-import io.helidon.webserver.Handler;\n-import io.helidon.webserver.Routing;\n-import io.helidon.webserver.ServerRequest;\n-import io.helidon.webserver.ServerResponse;\n-import io.helidon.webserver.Service;\n-\n-import org.glassfish.tyrus.core.RequestContext;\n-import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n-import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n-import org.glassfish.tyrus.server.TyrusServerContainer;\n-import org.glassfish.tyrus.spi.Connection;\n-import org.glassfish.tyrus.spi.WebSocketEngine;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-/**\n- * Class TyrusSupport implemented as a Helidon service.\n- */\n-public class TyrusSupport implements Service {\n-    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n-\n-    /**\n-     * A zero-length buffer indicates a connection flush to Helidon.\n-     */\n-    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n-\n-    private final WebSocketEngine engine;\n-    private final TyrusHandler handler = new TyrusHandler();\n-    private Set<Class<?>> endpointClasses;\n-    private Set<ServerEndpointConfig> endpointConfigs;\n-\n-    /**\n-     * Create from another instance.\n-     *\n-     * @param other The other instance.\n-     */\n-    protected TyrusSupport(TyrusSupport other) {\n-        this.engine = other.engine;\n-        this.endpointClasses = other.endpointClasses;\n-        this.endpointConfigs = other.endpointConfigs;\n-    }\n-\n-    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n-        this.engine = engine;\n-        this.endpointClasses = endpointClasses;\n-        this.endpointConfigs = endpointConfigs;\n-    }\n-\n-    /**\n-     * Register our WebSocket handler for all routes. Once a request is received,\n-     * it will be forwarded to the next handler if not a protocol upgrade request.\n-     *\n-     * @param routingRules Routing rules to update.\n-     */\n-    @Override\n-    public void update(Routing.Rules routingRules) {\n-        LOGGER.info(\"Updating TyrusSupport routing routes\");\n-        routingRules.any(handler);\n-    }\n-\n-    /**\n-     * Access to endpoint classes.\n-     *\n-     * @return Immutable set of end endpoint classes.\n-     */\n-    public Set<Class<?>> endpointClasses() {\n-        return Collections.unmodifiableSet(endpointClasses);\n-    }\n-\n-    /**\n-     * Access to endpoint configs.\n-     *\n-     * @return Immutable set of end endpoint configs.\n-     */\n-    public Set<ServerEndpointConfig> endpointConfigs() {\n-        return Collections.unmodifiableSet(endpointConfigs);\n-    }\n-\n-    /**\n-     * Returns executor service, can be overridden.\n-     *\n-     * @return Executor service or {@code null}.\n-     */\n-    protected ExecutorService executorService() {\n-        return null;\n-    }\n-\n-    /**\n-     * Creates a builder for this class.\n-     *\n-     * @return A builder for this class.\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Builder for convenient way to create {@link TyrusSupport}.\n-     */\n-    public static class Builder implements io.helidon.common.Builder<TyrusSupport> {\n-\n-        private Set<Class<?>> endpointClasses = new HashSet<>();\n-        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n-\n-        private Builder() {\n-        }\n-\n-        /**\n-         * Register an endpoint class.\n-         *\n-         * @param endpointClass The class.\n-         * @return The builder.\n-         */\n-        public Builder register(Class<?> endpointClass) {\n-            endpointClasses.add(endpointClass);\n-            return this;\n-        }\n-\n-        /**\n-         * Register an endpoint config.\n-         *\n-         * @param endpointConfig The endpoint config.\n-         * @return The builder.\n-         */\n-        public Builder register(ServerEndpointConfig endpointConfig) {\n-            endpointConfigs.add(endpointConfig);\n-            return this;\n-        }\n-\n-        @Override\n-        public TyrusSupport build() {\n-            // Create container and WebSocket engine\n-            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n-                private final WebSocketEngine engine =\n-                        TyrusWebSocketEngine.builder(this).build();\n-\n-                @Override\n-                public void register(Class<?> endpointClass) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public void register(ServerEndpointConfig serverEndpointConfig) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public WebSocketEngine getWebSocketEngine() {\n-                    return engine;\n-                }\n-            };\n-\n-            // Register classes with context path \"/\"\n-            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n-            endpointClasses.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-            endpointConfigs.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-\n-            // Create TyrusSupport using WebSocket engine\n-            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n-        }\n-    }\n-\n-    /**\n-     * A Helidon handler that integrates with Tyrus and can process WebSocket\n-     * upgrade requests.\n-     */\n-    private class TyrusHandler implements Handler {\n-\n-        /**\n-         * Process a server request/response.\n-         *\n-         * @param req an HTTP server request.\n-         * @param res an HTTP server response.\n-         */\n-        @Override\n-        public void accept(ServerRequest req, ServerResponse res) {\n-            // Skip this handler if not an upgrade request\n-            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n-            if (secWebSocketKey.isEmpty()) {\n-                req.next();\n-                return;\n-            }\n-\n-            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n-\n-            // Create Tyrus request context and copy request headers\n-            RequestContext requestContext = RequestContext.Builder.create()\n-                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n-                    .build();\n-            req.headers().toMap().forEach((key, value) -> requestContext.getHeaders().put(key, value));\n-\n-            // Use Tyrus to process a WebSocket upgrade request\n-            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n-            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n-\n-            // Respond to upgrade request using response from Tyrus\n-            res.status(upgradeResponse.getStatus());\n-            upgradeResponse.getHeaders().forEach((key, value) -> res.headers().add(key, value));\n-            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n-            res.send(publisherWriter);\n-\n-            // Write reason for failure if not successful\n-            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n-                String reason = upgradeResponse.getReasonPhrase();\n-                if (reason != null) {\n-                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n-                }\n-            }\n-\n-            // Flush upgrade response\n-            publisherWriter.write(FLUSH_BUFFER, null);\n-\n-            // Setup the WebSocket connection and subscriber, calls @onOpen\n-            ExecutorService executorService = executorService();\n-            if (executorService != null) {\n-                CompletableFuture<Connection> future =\n-                        CompletableFuture.supplyAsync(\n-                                () -> upgradeInfo.createConnection(publisherWriter,\n-                                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)),\n-                                executorService);\n-                future.thenAccept(c -> {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(c, executorService);\n-                    req.content().subscribe(subscriber);\n-                });\n-            } else {\n-                Connection connection = upgradeInfo.createConnection(publisherWriter,\n-                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason));\n-                if (connection != null) {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(connection);\n-                    req.content().subscribe(subscriber);\n-                }\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MzI3Ng==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374053276", "body": "I am not sure I understand this - why do you use an executor service, when you call `get` on the result? You are blocking the current thread anyways, why not just call the statement directly?\r\nAlso this seems to be an issue for our WebServer, as you should never block", "bodyText": "I am not sure I understand this - why do you use an executor service, when you call get on the result? You are blocking the current thread anyways, why not just call the statement directly?\nAlso this seems to be an issue for our WebServer, as you should never block", "bodyHTML": "<p dir=\"auto\">I am not sure I understand this - why do you use an executor service, when you call <code>get</code> on the result? You are blocking the current thread anyways, why not just call the statement directly?<br>\nAlso this seems to be an issue for our WebServer, as you should never block</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:32:25Z", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {\n+                req.next();\n+                return;\n+            }\n+\n+            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n+\n+            // Create Tyrus request context and copy request headers\n+            RequestContext requestContext = RequestContext.Builder.create()\n+                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n+                    .build();\n+            req.headers().toMap().entrySet().forEach(e ->\n+                    requestContext.getHeaders().put(e.getKey(), e.getValue()));\n+\n+            // Use Tyrus to process a WebSocket upgrade request\n+            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n+            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n+\n+            // Respond to upgrade request using response from Tyrus\n+            res.status(upgradeResponse.getStatus());\n+            upgradeResponse.getHeaders().entrySet().forEach(e ->\n+                    res.headers().add(e.getKey(), e.getValue()));\n+            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n+            res.send(publisherWriter);\n+\n+            // Write reason for failure if not successful\n+            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n+                String reason = upgradeResponse.getReasonPhrase();\n+                if (reason != null) {\n+                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n+                }\n+            }\n+\n+            // Flush upgrade response\n+            publisherWriter.write(FLUSH_BUFFER, null);\n+\n+            // Setup the WebSocket connection and internally the ReaderHandler\n+            Connection connection;\n+            if (executorService != null) {\n+                try {\n+                    // Set up connection and call @onOpen\n+                    Future<Connection> future = executorService.submit(() ->\n+                            upgradeInfo.createConnection(publisherWriter,\n+                                    closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)));\n+                    connection = future.get();      // Need to sync here", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\nindex fea5753246..b85bdd318f 100644\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n", "chunk": "@@ -272,28 +256,25 @@ public class TyrusSupport implements Service {\n             // Flush upgrade response\n             publisherWriter.write(FLUSH_BUFFER, null);\n \n-            // Setup the WebSocket connection and internally the ReaderHandler\n-            Connection connection;\n+            // Setup the WebSocket connection and subscriber, calls @onOpen\n+            ExecutorService executorService = executorService();\n             if (executorService != null) {\n-                try {\n-                    // Set up connection and call @onOpen\n-                    Future<Connection> future = executorService.submit(() ->\n-                            upgradeInfo.createConnection(publisherWriter,\n-                                    closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)));\n-                    connection = future.get();      // Need to sync here\n-                } catch (InterruptedException | ExecutionException e) {\n-                    LOGGER.warning(\"Unable to create websocket connection\");\n-                    throw new RuntimeException(e);\n-                }\n+                CompletableFuture<Connection> future =\n+                        CompletableFuture.supplyAsync(\n+                                () -> upgradeInfo.createConnection(publisherWriter,\n+                                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)),\n+                                executorService);\n+                future.thenAccept(c -> {\n+                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(c, executorService);\n+                    req.content().subscribe(subscriber);\n+                });\n             } else {\n-                connection = upgradeInfo.createConnection(publisherWriter,\n+                Connection connection = upgradeInfo.createConnection(publisherWriter,\n                         closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason));\n-            }\n-\n-            // Set up reader to pass data back to Tyrus\n-            if (connection != null) {\n-                TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(connection, executorService);\n-                req.content().subscribe(subscriber);\n+                if (connection != null) {\n+                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(connection);\n+                    req.content().subscribe(subscriber);\n+                }\n             }\n         }\n     }\n", "next_change": {"commit": "eb05050fa8a998b42f9a52b8278f87456a61ea5e", "changed_code": [{"header": "diff --git a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java b/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\ndeleted file mode 100644\nindex b85bdd318f..0000000000\n--- a/webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java\n+++ /dev/null\n", "chunk": "@@ -1,281 +0,0 @@\n-/*\n- * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.helidon.webserver.tyrus;\n-\n-import java.net.URI;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.logging.Logger;\n-\n-import javax.websocket.DeploymentException;\n-import javax.websocket.server.HandshakeRequest;\n-import javax.websocket.server.ServerEndpointConfig;\n-\n-import io.helidon.webserver.Handler;\n-import io.helidon.webserver.Routing;\n-import io.helidon.webserver.ServerRequest;\n-import io.helidon.webserver.ServerResponse;\n-import io.helidon.webserver.Service;\n-\n-import org.glassfish.tyrus.core.RequestContext;\n-import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n-import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n-import org.glassfish.tyrus.server.TyrusServerContainer;\n-import org.glassfish.tyrus.spi.Connection;\n-import org.glassfish.tyrus.spi.WebSocketEngine;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-/**\n- * Class TyrusSupport implemented as a Helidon service.\n- */\n-public class TyrusSupport implements Service {\n-    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n-\n-    /**\n-     * A zero-length buffer indicates a connection flush to Helidon.\n-     */\n-    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n-\n-    private final WebSocketEngine engine;\n-    private final TyrusHandler handler = new TyrusHandler();\n-    private Set<Class<?>> endpointClasses;\n-    private Set<ServerEndpointConfig> endpointConfigs;\n-\n-    /**\n-     * Create from another instance.\n-     *\n-     * @param other The other instance.\n-     */\n-    protected TyrusSupport(TyrusSupport other) {\n-        this.engine = other.engine;\n-        this.endpointClasses = other.endpointClasses;\n-        this.endpointConfigs = other.endpointConfigs;\n-    }\n-\n-    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n-        this.engine = engine;\n-        this.endpointClasses = endpointClasses;\n-        this.endpointConfigs = endpointConfigs;\n-    }\n-\n-    /**\n-     * Register our WebSocket handler for all routes. Once a request is received,\n-     * it will be forwarded to the next handler if not a protocol upgrade request.\n-     *\n-     * @param routingRules Routing rules to update.\n-     */\n-    @Override\n-    public void update(Routing.Rules routingRules) {\n-        LOGGER.info(\"Updating TyrusSupport routing routes\");\n-        routingRules.any(handler);\n-    }\n-\n-    /**\n-     * Access to endpoint classes.\n-     *\n-     * @return Immutable set of end endpoint classes.\n-     */\n-    public Set<Class<?>> endpointClasses() {\n-        return Collections.unmodifiableSet(endpointClasses);\n-    }\n-\n-    /**\n-     * Access to endpoint configs.\n-     *\n-     * @return Immutable set of end endpoint configs.\n-     */\n-    public Set<ServerEndpointConfig> endpointConfigs() {\n-        return Collections.unmodifiableSet(endpointConfigs);\n-    }\n-\n-    /**\n-     * Returns executor service, can be overridden.\n-     *\n-     * @return Executor service or {@code null}.\n-     */\n-    protected ExecutorService executorService() {\n-        return null;\n-    }\n-\n-    /**\n-     * Creates a builder for this class.\n-     *\n-     * @return A builder for this class.\n-     */\n-    public static Builder builder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Builder for convenient way to create {@link TyrusSupport}.\n-     */\n-    public static class Builder implements io.helidon.common.Builder<TyrusSupport> {\n-\n-        private Set<Class<?>> endpointClasses = new HashSet<>();\n-        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n-\n-        private Builder() {\n-        }\n-\n-        /**\n-         * Register an endpoint class.\n-         *\n-         * @param endpointClass The class.\n-         * @return The builder.\n-         */\n-        public Builder register(Class<?> endpointClass) {\n-            endpointClasses.add(endpointClass);\n-            return this;\n-        }\n-\n-        /**\n-         * Register an endpoint config.\n-         *\n-         * @param endpointConfig The endpoint config.\n-         * @return The builder.\n-         */\n-        public Builder register(ServerEndpointConfig endpointConfig) {\n-            endpointConfigs.add(endpointConfig);\n-            return this;\n-        }\n-\n-        @Override\n-        public TyrusSupport build() {\n-            // Create container and WebSocket engine\n-            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n-                private final WebSocketEngine engine =\n-                        TyrusWebSocketEngine.builder(this).build();\n-\n-                @Override\n-                public void register(Class<?> endpointClass) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public void register(ServerEndpointConfig serverEndpointConfig) {\n-                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n-                }\n-\n-                @Override\n-                public WebSocketEngine getWebSocketEngine() {\n-                    return engine;\n-                }\n-            };\n-\n-            // Register classes with context path \"/\"\n-            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n-            endpointClasses.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-            endpointConfigs.forEach(c -> {\n-                try {\n-                    // Context path handled by Helidon based on app's routes\n-                    engine.register(c, \"/\");\n-                } catch (DeploymentException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-\n-            // Create TyrusSupport using WebSocket engine\n-            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n-        }\n-    }\n-\n-    /**\n-     * A Helidon handler that integrates with Tyrus and can process WebSocket\n-     * upgrade requests.\n-     */\n-    private class TyrusHandler implements Handler {\n-\n-        /**\n-         * Process a server request/response.\n-         *\n-         * @param req an HTTP server request.\n-         * @param res an HTTP server response.\n-         */\n-        @Override\n-        public void accept(ServerRequest req, ServerResponse res) {\n-            // Skip this handler if not an upgrade request\n-            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n-            if (secWebSocketKey.isEmpty()) {\n-                req.next();\n-                return;\n-            }\n-\n-            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n-\n-            // Create Tyrus request context and copy request headers\n-            RequestContext requestContext = RequestContext.Builder.create()\n-                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n-                    .build();\n-            req.headers().toMap().forEach((key, value) -> requestContext.getHeaders().put(key, value));\n-\n-            // Use Tyrus to process a WebSocket upgrade request\n-            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n-            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n-\n-            // Respond to upgrade request using response from Tyrus\n-            res.status(upgradeResponse.getStatus());\n-            upgradeResponse.getHeaders().forEach((key, value) -> res.headers().add(key, value));\n-            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n-            res.send(publisherWriter);\n-\n-            // Write reason for failure if not successful\n-            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n-                String reason = upgradeResponse.getReasonPhrase();\n-                if (reason != null) {\n-                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n-                }\n-            }\n-\n-            // Flush upgrade response\n-            publisherWriter.write(FLUSH_BUFFER, null);\n-\n-            // Setup the WebSocket connection and subscriber, calls @onOpen\n-            ExecutorService executorService = executorService();\n-            if (executorService != null) {\n-                CompletableFuture<Connection> future =\n-                        CompletableFuture.supplyAsync(\n-                                () -> upgradeInfo.createConnection(publisherWriter,\n-                                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)),\n-                                executorService);\n-                future.thenAccept(c -> {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(c, executorService);\n-                    req.content().subscribe(subscriber);\n-                });\n-            } else {\n-                Connection connection = upgradeInfo.createConnection(publisherWriter,\n-                        closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason));\n-                if (connection != null) {\n-                    TyrusReaderSubscriber subscriber = new TyrusReaderSubscriber(connection);\n-                    req.content().subscribe(subscriber);\n-                }\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTUyMw==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055523", "body": "WebSocket support should not be part of Helidon MicroProfile server.\r\nThis adds an unwanted dependency on Tyrus for MP implementation.\r\nPlease extract WebSocket support into a separate module.", "bodyText": "WebSocket support should not be part of Helidon MicroProfile server.\nThis adds an unwanted dependency on Tyrus for MP implementation.\nPlease extract WebSocket support into a separate module.", "bodyHTML": "<p dir=\"auto\">WebSocket support should not be part of Helidon MicroProfile server.<br>\nThis adds an unwanted dependency on Tyrus for MP implementation.<br>\nPlease extract WebSocket support into a separate module.</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:38:05Z", "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "diffHunk": "@@ -69,6 +71,20 @@ static Server create(Class<? extends Application>... applicationClasses) throws\n         return builder.build();\n     }\n \n+    /**\n+     * Create a server instance using a Websocket application class.\n+     *\n+     * @param applicationClass websocket application class\n+     * @return server instance to be started\n+     * @throws MpException in case the server fails to be created\n+     * @see #builder()\n+     */\n+    static Server create(Class<? extends ServerApplicationConfig> applicationClass) throws MpException {", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d88f6503d8c6d954bf0e7ad107413ddc2a02d531", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java b/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java\nindex 6cc436dbf2..d17f689cda 100644\n--- a/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java\n+++ b/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java\n", "chunk": "@@ -71,20 +70,6 @@ public interface Server {\n         return builder.build();\n     }\n \n-    /**\n-     * Create a server instance using a Websocket application class.\n-     *\n-     * @param applicationClass websocket application class\n-     * @return server instance to be started\n-     * @throws MpException in case the server fails to be created\n-     * @see #builder()\n-     */\n-    static Server create(Class<? extends ServerApplicationConfig> applicationClass) throws MpException {\n-        Builder builder = builder();\n-        builder.websocketApplication(applicationClass);\n-        return builder.build();\n-    }\n-\n     /**\n      * Create a server instance for discovered JAX-RS application (through CDI).\n      *\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTY0OA==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055648", "body": "Remove from Server. WebSocket should be handled in a separate module.", "bodyText": "Remove from Server. WebSocket should be handled in a separate module.", "bodyHTML": "<p dir=\"auto\">Remove from Server. WebSocket should be handled in a separate module.</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:38:27Z", "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "diffHunk": "@@ -366,6 +383,20 @@ public Builder addApplication(Application application) {\n             return this;\n         }\n \n+        /**\n+         * Registers a WebSocket application in the server. At most one application can be registered.\n+         *\n+         * @param wsApplication websocket application\n+         * @return modified builder\n+         */\n+        public Builder websocketApplication(Class<? extends ServerApplicationConfig> wsApplication) {", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d88f6503d8c6d954bf0e7ad107413ddc2a02d531", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java b/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java\nindex 6cc436dbf2..d17f689cda 100644\n--- a/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java\n+++ b/microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java\n", "chunk": "@@ -383,20 +389,6 @@ public interface Server {\n             return this;\n         }\n \n-        /**\n-         * Registers a WebSocket application in the server. At most one application can be registered.\n-         *\n-         * @param wsApplication websocket application\n-         * @return modified builder\n-         */\n-        public Builder websocketApplication(Class<? extends ServerApplicationConfig> wsApplication) {\n-            if (this.wsApplication != null) {\n-                throw new IllegalStateException(\"Cannot register more than one websocket application\");\n-            }\n-            this.wsApplication = wsApplication;\n-            return this;\n-        }\n-\n         /**\n          * If any application or resource class is added through this builder, applications discovered by CDI are ignored.\n          * You can change this behavior by setting the retain discovered applications to {@code true}.\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTg3MQ==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055871", "body": "Extract into a separate module, use `WebSocketCdiExtension` in that module to setup everything", "bodyText": "Extract into a separate module, use WebSocketCdiExtension in that module to setup everything", "bodyHTML": "<p dir=\"auto\">Extract into a separate module, use <code>WebSocketCdiExtension</code> in that module to setup everything</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:39:01Z", "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java", "diffHunk": "@@ -117,6 +126,9 @@ private void startServer(@Observes @Priority(PLATFORM_AFTER + 100) @Initialized(\n         // register static content if configured\n         registerStaticContent();\n \n+        // register websocket endpoints", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d88f6503d8c6d954bf0e7ad107413ddc2a02d531", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\nindex e4afd8160a..8d3e8a6cfa 100644\n--- a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n+++ b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n", "chunk": "@@ -126,9 +121,6 @@ public class ServerCdiExtension implements Extension {\n         // register static content if configured\n         registerStaticContent();\n \n-        // register websocket endpoints\n-        registerWebSockets(beanManager, serverConfig);\n-\n         // start the webserver\n         WebServer.Builder wsBuilder = WebServer.builder(routingBuilder.build());\n         wsBuilder.config(serverConfig);\n", "next_change": {"commit": "54ebcfefcdaee6f8918273e3969599f5db182e32", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\nindex 8d3e8a6cfa..1cb357e3d4 100644\n--- a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n+++ b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n", "chunk": "@@ -109,18 +111,18 @@ public class ServerCdiExtension implements Extension {\n \n         ServerConfiguration serverConfig = serverConfigBuilder.build();\n \n-        // JAX-RS applications (and resources)\n-        registerJaxRsApplications(beanManager, serverConfig);\n-\n-        // reactive services\n-        registerWebServerServices(beanManager, serverConfig);\n-\n         // redirect to the first page when root is accessed (if configured)\n         registerDefaultRedirect();\n \n         // register static content if configured\n         registerStaticContent();\n \n+        // reactive services\n+        registerWebServerServices(beanManager, serverConfig);\n+\n+        // JAX-RS applications (and resources)\n+        registerJaxRsApplications(beanManager, serverConfig);\n+\n         // start the webserver\n         WebServer.Builder wsBuilder = WebServer.builder(routingBuilder.build());\n         wsBuilder.config(serverConfig);\n", "next_change": {"commit": "0b95aea9170aac7318e73908171be853f5811c41", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\nindex 1cb357e3d4..a40b2cea73 100644\n--- a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n+++ b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n", "chunk": "@@ -118,17 +115,16 @@ public class ServerCdiExtension implements Extension {\n         registerStaticContent();\n \n         // reactive services\n-        registerWebServerServices(beanManager, serverConfig);\n+        registerWebServerServices(beanManager);\n \n         // JAX-RS applications (and resources)\n-        registerJaxRsApplications(beanManager, serverConfig);\n+        registerJaxRsApplications(beanManager);\n \n         // start the webserver\n-        WebServer.Builder wsBuilder = WebServer.builder(routingBuilder.build());\n-        wsBuilder.config(serverConfig);\n+        serverBuilder.routing(routingBuilder.build());\n \n-        namedRoutings.forEach(wsBuilder::addNamedRouting);\n-        webserver = wsBuilder.build();\n+        namedRoutings.forEach(serverBuilder::addNamedRouting);\n+        webserver = serverBuilder.build();\n \n         try {\n             webserver.start().toCompletableFuture().get();\n", "next_change": {"commit": "eb05050fa8a998b42f9a52b8278f87456a61ea5e", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\nindex a40b2cea73..2899e126b7 100644\n--- a/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n+++ b/microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java\n", "chunk": "@@ -121,7 +194,7 @@ public class ServerCdiExtension implements Extension {\n         registerJaxRsApplications(beanManager);\n \n         // start the webserver\n-        serverBuilder.routing(routingBuilder.build());\n+        serverBuilder.addRouting(routingBuilder.build());\n \n         namedRoutings.forEach(serverBuilder::addNamedRouting);\n         webserver = serverBuilder.build();\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NjE4Nw==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056187", "body": "There should be no dependency on tyrus or websocket in Helidon MP Server.", "bodyText": "There should be no dependency on tyrus or websocket in Helidon MP Server.", "bodyHTML": "<p dir=\"auto\">There should be no dependency on tyrus or websocket in Helidon MP Server.</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:39:53Z", "path": "microprofile/server/src/main/java/module-info.java", "diffHunk": "@@ -38,9 +36,15 @@\n     // there is now a hardcoded dependency on Weld, to configure additional bean defining annotation\n     requires java.management;\n \n+    requires io.helidon.microprofile.tyrus;", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/module-info.java b/microprofile/server/src/main/java/module-info.java\nindex cd48031310..b0241663e3 100644\n--- a/microprofile/server/src/main/java/module-info.java\n+++ b/microprofile/server/src/main/java/module-info.java\n", "chunk": "@@ -36,10 +36,6 @@ module io.helidon.microprofile.server {\n     // there is now a hardcoded dependency on Weld, to configure additional bean defining annotation\n     requires java.management;\n \n-    requires io.helidon.microprofile.tyrus;\n-    requires io.helidon.webserver.tyrus;\n-    requires jakarta.websocket.api;\n-\n     exports io.helidon.microprofile.server;\n \n     provides javax.enterprise.inject.spi.Extension with\n", "next_change": {"commit": "7d2f70897f4fb647539650b89d72cd042c26af91", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/module-info.java b/microprofile/server/src/main/java/module-info.java\nindex b0241663e3..5158ce58fb 100644\n--- a/microprofile/server/src/main/java/module-info.java\n+++ b/microprofile/server/src/main/java/module-info.java\n", "chunk": "@@ -26,15 +26,18 @@ module io.helidon.microprofile.server {\n \n     requires transitive io.helidon.microprofile.cdi;\n \n-    requires transitive cdi.api;\n+    requires io.helidon.config.mp;\n+    requires io.helidon.microprofile.config;\n+    requires transitive jakarta.enterprise.cdi.api;\n     requires transitive java.ws.rs;\n-    requires javax.interceptor.api;\n+    requires jakarta.interceptor.api;\n \n     requires java.logging;\n     requires io.helidon.common.serviceloader;\n \n     // there is now a hardcoded dependency on Weld, to configure additional bean defining annotation\n     requires java.management;\n+    requires microprofile.config.api;\n \n     exports io.helidon.microprofile.server;\n \n", "next_change": {"commit": "4dfb573d17a90f99db67e5d815a760784a7f1bfd", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/module-info.java b/microprofile/server/src/main/java/module-info.java\nindex 5158ce58fb..c04977b3a6 100644\n--- a/microprofile/server/src/main/java/module-info.java\n+++ b/microprofile/server/src/main/java/module-info.java\n", "chunk": "@@ -46,5 +46,5 @@ module io.helidon.microprofile.server {\n             io.helidon.microprofile.server.JaxRsCdiExtension;\n \n     // needed when running with modules - to make private methods accessible\n-    opens io.helidon.microprofile.server to weld.core.impl;\n+    opens io.helidon.microprofile.server to weld.core.impl, io.helidon.microprofile.cdi;\n }\n", "next_change": {"commit": "57fde8fe429476aeef578b986074ce0e7a2111b7", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/module-info.java b/microprofile/server/src/main/java/module-info.java\nindex c04977b3a6..62cb1f9190 100644\n--- a/microprofile/server/src/main/java/module-info.java\n+++ b/microprofile/server/src/main/java/module-info.java\n", "chunk": "@@ -41,7 +43,7 @@ module io.helidon.microprofile.server {\n \n     exports io.helidon.microprofile.server;\n \n-    provides javax.enterprise.inject.spi.Extension with\n+    provides jakarta.enterprise.inject.spi.Extension with\n             io.helidon.microprofile.server.ServerCdiExtension,\n             io.helidon.microprofile.server.JaxRsCdiExtension;\n \n", "next_change": {"commit": "87cadbd2fbc893bd203f907a0156fcc56578a7c2", "changed_code": [{"header": "diff --git a/microprofile/server/src/main/java/module-info.java b/microprofile/server/src/main/java/module-info.java\nindex 62cb1f9190..ddbda79c48 100644\n--- a/microprofile/server/src/main/java/module-info.java\n+++ b/microprofile/server/src/main/java/module-info.java\n", "chunk": "@@ -48,5 +49,5 @@ module io.helidon.microprofile.server {\n             io.helidon.microprofile.server.JaxRsCdiExtension;\n \n     // needed when running with modules - to make private methods accessible\n-    opens io.helidon.microprofile.server to weld.core.impl, io.helidon.microprofile.cdi;\n+    opens io.helidon.microprofile.server to weld.core.impl, org.glassfish.hk2.utilities, io.helidon.microprofile.cdi;\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njg2Ng==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056866", "body": "Do not use `info` level, unless it is an information needed for every user on every startup.\r\nThis seems to be debug information.\r\nYou can list Tyrus applications in info - but only when actually registering them (e.g. by the time we have the complete list).", "bodyText": "Do not use info level, unless it is an information needed for every user on every startup.\nThis seems to be debug information.\nYou can list Tyrus applications in info - but only when actually registering them (e.g. by the time we have the complete list).", "bodyHTML": "<p dir=\"auto\">Do not use <code>info</code> level, unless it is an information needed for every user on every startup.<br>\nThis seems to be debug information.<br>\nYou can list Tyrus applications in info - but only when actually registering them (e.g. by the time we have the complete list).</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:41:40Z", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY5NTAzNg==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374695036", "bodyText": "Yes, these were all misuses of logging for development.", "author": "spericas", "createdAt": "2020-02-04T14:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njg2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njk3Mw==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056973", "body": "see above - do not use info level", "bodyText": "see above - do not use info level", "bodyHTML": "<p dir=\"auto\">see above - do not use info level</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:41:54Z", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NzAxMw==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374057013", "body": "see above - do not use info level", "bodyText": "see above - do not use info level", "bodyHTML": "<p dir=\"auto\">see above - do not use info level</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:41:59Z", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);\n+        appBuilder.updateApplicationClass(applicationClass);\n+    }\n+\n+    /**\n+     * Collect annotated endpoints.\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointClasses(@Observes @WithAnnotations(ServerEndpoint.class) ProcessAnnotatedType<?> endpoint) {\n+        LOGGER.info(() -> \"Annotated endpoint found \" + endpoint.getAnnotatedType().getJavaClass());", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NzA1NA==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374057054", "body": "see above - do not use info level", "bodyText": "see above - do not use info level", "bodyHTML": "<p dir=\"auto\">see above - do not use info level</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:42:04Z", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);\n+        appBuilder.updateApplicationClass(applicationClass);\n+    }\n+\n+    /**\n+     * Collect annotated endpoints.\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointClasses(@Observes @WithAnnotations(ServerEndpoint.class) ProcessAnnotatedType<?> endpoint) {\n+        LOGGER.info(() -> \"Annotated endpoint found \" + endpoint.getAnnotatedType().getJavaClass());\n+        appBuilder.annotatedEndpoint(endpoint.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Collects programmatic endpoints .\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointConfig(@Observes ProcessAnnotatedType<? extends Endpoint> endpoint) {\n+        LOGGER.info(() -> \"Programmatic endpoint found \" + endpoint.getAnnotatedType().getJavaClass());", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1ODgzMg==", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374058832", "body": "This looks like a candidate for `finest`, not `fine`.\r\nAlso when constructing a message in log levels lower than `info`, please use lambda:\r\n`LOGGER.finest(() -> \"...\"  + msg);` to avoid string concatenation on every single byte buffer received", "bodyText": "This looks like a candidate for finest, not fine.\nAlso when constructing a message in log levels lower than info, please use lambda:\nLOGGER.finest(() -> \"...\"  + msg); to avoid string concatenation on every single byte buffer received", "bodyHTML": "<p dir=\"auto\">This looks like a candidate for <code>finest</code>, not <code>fine</code>.<br>\nAlso when constructing a message in log levels lower than <code>info</code>, please use lambda:<br>\n<code>LOGGER.finest(() -&gt; \"...\"  + msg);</code> to avoid string concatenation on every single byte buffer received</p>", "author": "tomas-langer", "createdAt": "2020-02-03T11:46:19Z", "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "diffHunk": "@@ -178,14 +198,49 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n             }\n \n             if (msg instanceof LastHttpContent) {\n-                requestContext.publisher().complete();\n-                requestContext = null; // just to be sure that current http req/res session doesn't interfere with other ones\n+                if (!isWebSocketUpgrade) {\n+                    requestContext.publisher().complete();\n+                    requestContext = null; // just to be sure that current http req/res session doesn't interfere with other ones\n+                }\n             } else if (!content.isReadable()) {\n                 // this is here to handle the case when the content is not readable but we didn't\n                 // exceptionally complete the publisher and close the connection\n                 throw new IllegalStateException(\"It is not expected to not have readable content.\");\n             }\n         }\n+\n+        // We receive a raw bytebuf if connection was upgraded to WebSockets\n+        if (msg instanceof ByteBuf) {\n+            if (!isWebSocketUpgrade) {\n+                throw new IllegalStateException(\"Received ByteBuf without upgrading to WebSockets\");\n+            }\n+            // Simply forward raw bytebuf to Tyrus for processing\n+            LOGGER.fine(\"Received ByteBuf of WebSockets connection\" + msg);", "originalCommit": "0d0e215cfb326c55d421d679515926ec947caa61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac", "changed_code": [{"header": "diff --git a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\nindex 18fd9ffb46..bd5e071227 100644\n--- a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n+++ b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n", "chunk": "@@ -215,7 +215,7 @@ public class ForwardingHandler extends SimpleChannelInboundHandler<Object> {\n                 throw new IllegalStateException(\"Received ByteBuf without upgrading to WebSockets\");\n             }\n             // Simply forward raw bytebuf to Tyrus for processing\n-            LOGGER.fine(\"Received ByteBuf of WebSockets connection\" + msg);\n+            LOGGER.finest(() -> \"Received ByteBuf of WebSockets connection\" + msg);\n             requestContext.publisher().submit((ByteBuf) msg);\n         }\n     }\n", "next_change": {"commit": "b32feb0252119c4fbe53035c4458b755bf5c8d45", "changed_code": [{"header": "diff --git a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\nindex bd5e071227..8de9d2d582 100644\n--- a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n+++ b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n", "chunk": "@@ -220,6 +227,16 @@ public class ForwardingHandler extends SimpleChannelInboundHandler<Object> {\n         }\n     }\n \n+    private static void checkDecoderResult(HttpRequest request) {\n+        DecoderResult decoderResult = request.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            LOGGER.info(String.format(\"Request %s to %s rejected: %s\", request.method()\n+                            .asciiName(), request.uri(), decoderResult.cause().getMessage()));\n+            throw new BadRequestException(String.format(\"Request was rejected: %s\", decoderResult.cause().getMessage()),\n+                    decoderResult.cause());\n+        }\n+    }\n+\n     /**\n      * Find and remove the WebSockets handshake handler. Note that the handler's implementation\n      * class is package private, so we look for it by name. Handshake is done in Helidon using\n", "next_change": {"commit": "fa30f1a7c7e04b95377fbf324aa50f89fdcb49bd", "changed_code": [{"header": "diff --git a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\nindex 8de9d2d582..822fc7d140 100644\n--- a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n+++ b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n", "chunk": "@@ -244,7 +401,7 @@ public class ForwardingHandler extends SimpleChannelInboundHandler<Object> {\n      *\n      * @param ctx Channel handler context.\n      */\n-    private static void removeHandshakeHandler(ChannelHandlerContext ctx) {\n+    private void removeHandshakeHandler(ChannelHandlerContext ctx) {\n         ChannelHandler handshakeHandler = null;\n         for (Iterator<Map.Entry<String, ChannelHandler>> it = ctx.pipeline().iterator(); it.hasNext();) {\n             ChannelHandler handler = it.next().getValue();\n", "next_change": {"commit": "eb05050fa8a998b42f9a52b8278f87456a61ea5e", "changed_code": [{"header": "diff --git a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\nindex 822fc7d140..3f2aaa9646 100644\n--- a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n+++ b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n", "chunk": "@@ -394,51 +484,42 @@ public class ForwardingHandler extends SimpleChannelInboundHandler<Object> {\n         }\n     }\n \n-    /**\n-     * Find and remove the WebSockets handshake handler. Note that the handler's implementation\n-     * class is package private, so we look for it by name. Handshake is done in Helidon using\n-     * Tyrus' code instead of here.\n-     *\n-     * @param ctx Channel handler context.\n-     */\n-    private void removeHandshakeHandler(ChannelHandlerContext ctx) {\n-        ChannelHandler handshakeHandler = null;\n-        for (Iterator<Map.Entry<String, ChannelHandler>> it = ctx.pipeline().iterator(); it.hasNext();) {\n-            ChannelHandler handler = it.next().getValue();\n-            if (handler.getClass().getName().endsWith(\"WebSocketServerProtocolHandshakeHandler\")) {\n-                handshakeHandler = handler;\n-                break;\n-            }\n-        }\n-        if (handshakeHandler != null) {\n-            ctx.pipeline().remove(handshakeHandler);\n-        } else {\n-            LOGGER.warning(() -> log(\"Unable to remove WebSockets handshake handler from pipeline\", ctx));\n-        }\n-    }\n+    private void send100Continue(ChannelHandlerContext ctx,\n+                                        HttpRequest request) {\n+\n+        TransportResponse transportResponse = directHandlers.handler(DirectHandler.EventType.CONTINUE)\n+                .handle(new DirectHandlerRequest(request),\n+                        DirectHandler.EventType.CONTINUE,\n+                        Http.Status.CONTINUE_100,\n+                        \"\");\n \n-    private static void send100Continue(ChannelHandlerContext ctx) {\n-        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, CONTINUE);\n-        ctx.write(response);\n+        FullHttpResponse response = toNettyResponse(transportResponse);\n+        // we should flush this immediately, as we need the client to send entity\n+        ctx.writeAndFlush(response);\n     }\n \n     /**\n-     * Returns a 400 (Bad Request) response with a message as content.\n+     * Returns a 400 (Bad Request) response with a message as content. Message is encoded using\n+     * HTML entities to prevent potential XSS attacks even if content type is text/plain.\n      *\n      * @param ctx Channel context.\n-     * @param message The message.\n+     * @param request Netty HTTP request\n+     * @param t associated throwable\n      */\n-    private void send400BadRequest(ChannelHandlerContext ctx, String message) {\n-        byte[] entity = message.getBytes(StandardCharsets.UTF_8);\n-        FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST, Unpooled.wrappedBuffer(entity));\n-        response.headers().add(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n-        response.headers().add(HttpHeaderNames.CONTENT_LENGTH, entity.length);\n+    private void send400BadRequest(ChannelHandlerContext ctx, HttpRequest request, Throwable t) {\n+        TransportResponse handlerResponse = directHandlers.handler(DirectHandler.EventType.BAD_REQUEST)\n+                .handle(new DirectHandlerRequest(request),\n+                        DirectHandler.EventType.BAD_REQUEST,\n+                        Http.Status.BAD_REQUEST_400,\n+                        t);\n+\n+        FullHttpResponse response = toNettyResponse(handlerResponse);\n+        // 400 -> close connection\n         response.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n-        ctx.write(response)\n-                .addListener(future -> {\n-                    ctx.flush();\n-                    ctx.close();\n-                });\n+\n+        ctx.writeAndFlush(response)\n+                .addListener(future -> ctx.close());\n+\n         failPublisher(new Error(\"400: Bad request\"));\n     }\n \n", "next_change": {"commit": "d7dc47b0a559fc08af2a73839cbb28a3e1ede65c", "changed_code": [{"header": "diff --git a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\nindex 3f2aaa9646..8971dbce36 100644\n--- a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n+++ b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n", "chunk": "@@ -520,7 +524,9 @@ public class ForwardingHandler extends SimpleChannelInboundHandler<Object> {\n         ctx.writeAndFlush(response)\n                 .addListener(future -> ctx.close());\n \n-        failPublisher(new Error(\"400: Bad request\"));\n+        Error error = new Error(\"400: Bad request\");\n+        LOGGER.log(Level.WARNING, error, error::getMessage);\n+        failPublisher(error);\n     }\n \n     /**\n", "next_change": {"commit": "d8843ada05feef43ec9c340648a07c4fc21a5581", "changed_code": [{"header": "diff --git a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\nindex 8971dbce36..24086faa37 100644\n--- a/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n+++ b/webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java\n", "chunk": "@@ -524,8 +521,13 @@ public class ForwardingHandler extends SimpleChannelInboundHandler<Object> {\n         ctx.writeAndFlush(response)\n                 .addListener(future -> ctx.close());\n \n+        // Log simple warning and more details if FINE level set\n         Error error = new Error(\"400: Bad request\");\n-        LOGGER.log(Level.WARNING, error, error::getMessage);\n+        LOGGER.log(Level.WARNING, error::getMessage);\n+        if (LOGGER.isLoggable(Level.FINE)) {\n+            LOGGER.log(Level.FINE, message, error);\n+        }\n+\n         failPublisher(error);\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "3e2d7867d805a388237d46ddcb599bbd1151a65f", "url": "https://github.com/oracle/helidon/commit/3e2d7867d805a388237d46ddcb599bbd1151a65f", "message": "Minor improvements and fixes to logging calls.", "committedDate": "2020-02-04T14:22:39Z", "type": "commit"}, {"oid": "0f9a2f5df5d17400278e03affc5c1dc9a5bf24f6", "url": "https://github.com/oracle/helidon/commit/0f9a2f5df5d17400278e03affc5c1dc9a5bf24f6", "message": "Ensure Netty's thread is not blocked when setting up a connection in MP.", "committedDate": "2020-02-04T15:09:27Z", "type": "commit"}, {"oid": "09534885d4a6b362a86dcb78b1fb298a57bdcf14", "url": "https://github.com/oracle/helidon/commit/09534885d4a6b362a86dcb78b1fb298a57bdcf14", "message": "Fixed checkstyle.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-02-04T15:13:54Z", "type": "commit"}, {"oid": "946db23e8bbcfa6b3acd4c812ec30e6942915d83", "url": "https://github.com/oracle/helidon/commit/946db23e8bbcfa6b3acd4c812ec30e6942915d83", "message": "Re-shuffled code to remove dependency with websockets API and Tyrus in microprofile's server module. Use CDI events between modules for loose coupling.", "committedDate": "2020-02-05T20:50:15Z", "type": "commit"}, {"oid": "363e5b91d0bf94d209c8d129626adfa06d12b047", "url": "https://github.com/oracle/helidon/commit/363e5b91d0bf94d209c8d129626adfa06d12b047", "message": "Dropped support for websockets in Server.Builder. Created subclass for TyrusSupport in MP. Fixed tests.", "committedDate": "2020-02-06T16:49:17Z", "type": "commit"}, {"oid": "8f6051e8ed26f8c487fbb6c0d4dd0c2467b16d4e", "url": "https://github.com/oracle/helidon/commit/8f6051e8ed26f8c487fbb6c0d4dd0c2467b16d4e", "message": "Fixed spotbugs error.", "committedDate": "2020-02-06T18:32:44Z", "type": "commit"}, {"oid": "3d874d67744cdaa957d2cd02dd4171b610ec0c75", "url": "https://github.com/oracle/helidon/commit/3d874d67744cdaa957d2cd02dd4171b610ec0c75", "message": "Removed unused method and updated docs.", "committedDate": "2020-02-07T13:20:40Z", "type": "commit"}, {"oid": "9515f52ec7e283728774e0c7be692fb9195734f0", "url": "https://github.com/oracle/helidon/commit/9515f52ec7e283728774e0c7be692fb9195734f0", "message": "Removed unused class.", "committedDate": "2020-02-07T13:28:25Z", "type": "commit"}, {"oid": "1456226e7215eef56cf1926b2f0208ef74625472", "url": "https://github.com/oracle/helidon/commit/1456226e7215eef56cf1926b2f0208ef74625472", "message": "Renamed module from tyrus to websocket. Restored transitive dependencies in MP server.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-02-13T14:41:56Z", "type": "commit"}, {"oid": "1456226e7215eef56cf1926b2f0208ef74625472", "url": "https://github.com/oracle/helidon/commit/1456226e7215eef56cf1926b2f0208ef74625472", "message": "Renamed module from tyrus to websocket. Restored transitive dependencies in MP server.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-02-13T14:41:56Z", "type": "forcePushed"}]}