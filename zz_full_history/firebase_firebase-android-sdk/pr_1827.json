{"pr_number": 1827, "pr_title": "initial implementation of reflective decoder", "pr_author": "James201311", "pr_createdAt": "2020-07-28T14:58:36Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1827", "merge_commit": "977a59077a6ea07620479b349b7542270e6cf508", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTIxMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461755213", "body": "Will fields overwrite the methods that were just read above?", "bodyText": "Will fields overwrite the methods that were just read above?", "bodyHTML": "<p dir=\"auto\">Will fields overwrite the methods that were just read above?</p>", "author": "vkryachko", "createdAt": "2020-07-28T17:36:07Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,214 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);", "originalCommit": "82b6254984e08a0ff226c67330480f728b88e280", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5ODMzMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461798333", "bodyText": "no, it won't. Fields will only be written when their associated setter methods were not found.", "author": "James201311", "createdAt": "2020-07-28T18:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex dd2710d23..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-\n-          String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (isInLine(fieldDescriptor)) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n-          } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-          }\n-        }\n-        refs.put(fieldName, ref);\n-      }\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        FieldRef<?> ref = refs.get(fieldName);\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        ReflectiveFieldSetter fieldSetter = entry.getValue();\n-        if (fieldSetter == null) {\n-          throw new RuntimeException(\"FieldSetter for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref == null) {\n-          throw new RuntimeException(\"FieldRef for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref instanceof FieldRef.Boxed) {\n-          Object val = creationCtx.get((FieldRef.Boxed<?>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(int.class)) {\n-          int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(long.class)) {\n-          long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(short.class)) {\n-          short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(double.class)) {\n-          double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(float.class)) {\n-          float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(char.class)) {\n-          char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(boolean.class)) {\n-          boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-          fieldSetter.set(instance, val);\n-        } else {\n-          throw new EncodingException(fieldType + \" not supported.\");\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex dd2710d23..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-\n-          String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (isInLine(fieldDescriptor)) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n-          } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-          }\n-        }\n-        refs.put(fieldName, ref);\n-      }\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        FieldRef<?> ref = refs.get(fieldName);\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        ReflectiveFieldSetter fieldSetter = entry.getValue();\n-        if (fieldSetter == null) {\n-          throw new RuntimeException(\"FieldSetter for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref == null) {\n-          throw new RuntimeException(\"FieldRef for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref instanceof FieldRef.Boxed) {\n-          Object val = creationCtx.get((FieldRef.Boxed<?>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(int.class)) {\n-          int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(long.class)) {\n-          long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(short.class)) {\n-          short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(double.class)) {\n-          double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(float.class)) {\n-          float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(char.class)) {\n-          char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(boolean.class)) {\n-          boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-          fieldSetter.set(instance, val);\n-        } else {\n-          throw new EncodingException(fieldType + \" not supported.\");\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTYyMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461755621", "body": "We don't want to include all annotations in the descriptor, only ones that are themselves annotated with `@ExtraProperty`.", "bodyText": "We don't want to include all annotations in the descriptor, only ones that are themselves annotated with @ExtraProperty.", "bodyHTML": "<p dir=\"auto\">We don't want to include all annotations in the descriptor, only ones that are themselves annotated with <code>@ExtraProperty</code>.</p>", "author": "vkryachko", "createdAt": "2020-07-28T17:36:51Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,214 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);\n+      decodeFields(ctx);\n+      return getTypeCreator(ctx.getTypeToken());\n+    }\n+\n+    private void readMethods(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        Method[] methods = currentClass.getDeclaredMethods();\n+        for (Method method : methods) {\n+          if (!shouldIncludeSetter(method)) {\n+            continue;\n+          }\n+\n+          String fieldName = fieldName(method);\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(\n+                fieldName,\n+                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));", "originalCommit": "82b6254984e08a0ff226c67330480f728b88e280", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5OTU3NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461799574", "bodyText": "Great, then @Encodable.Field should be annoated with @ExtraProperty as well, since it is the extra property of the field even if it's an internal annotation.", "author": "James201311", "createdAt": "2020-07-28T18:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex dd2710d23..08b97369a 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -77,8 +77,8 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n                 fieldName,\n                 buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n           }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n+          if (reflectiveSetters.get(fieldName) == null) {\n+            reflectiveSetters.put(fieldName, ReflectiveMethodSetter.of(method));\n           }\n         }\n         currentClass = currentClass.getSuperclass();\n", "next_change": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex 08b97369a..7539c440f 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -70,15 +68,9 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n           if (!shouldIncludeSetter(method)) {\n             continue;\n           }\n-\n           String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n-          }\n-          if (reflectiveSetters.get(fieldName) == null) {\n-            reflectiveSetters.put(fieldName, ReflectiveMethodSetter.of(method));\n+          if (!fieldContexts.containsKey(fieldName)) {\n+            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n           }\n         }\n         currentClass = currentClass.getSuperclass();\n", "next_change": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex 7539c440f..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,250 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-          String fieldName = fieldName(method);\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        decodeField(ctx, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void decodeField(\n-        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n-      FieldRef<TField> ref;\n-      if (fieldType.equals(int.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n-      } else if (fieldType.equals(long.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n-      } else if (fieldType.equals(short.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n-      } else if (fieldType.equals(double.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n-      } else if (fieldType.equals(float.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n-      } else if (fieldType.equals(boolean.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n-      } else {\n-        TypeToken<TField> fieldTypeToken =\n-            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n-        if (fieldContext.isInline()) {\n-          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n-            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-          } else {\n-            throw new IllegalArgumentException(\n-                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-          }\n-        } else {\n-          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-        }\n-      }\n-      fieldContext.putFieldRef(ref);\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-        throw new EncodingException(\n-            \"Class \"\n-                + ctx.getTypeToken()\n-                + \"does not have type variable \"\n-                + ((TypeVariable) type).getName());\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        setField(creationCtx, instance, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void setField(\n-        CreationContext creationCtx,\n-        Object instance,\n-        ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      FieldRef<TField> ref = fieldContext.getFieldRef();\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      ReflectiveSetter<TField> fieldSetter = fieldContext.getReflectiveSetter();\n-      if (ref instanceof FieldRef.Boxed) {\n-        TField val = creationCtx.get((FieldRef.Boxed<TField>) ref);\n-        fieldSetter.set(instance, val);\n-      } else if (fieldType.equals(int.class)) {\n-        int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-        fieldSetter.set(instance, (TField) (Integer) val);\n-      } else if (fieldType.equals(long.class)) {\n-        long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-        fieldSetter.set(instance, (TField) (Long) val);\n-      } else if (fieldType.equals(short.class)) {\n-        short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-        fieldSetter.set(instance, (TField) (Short) val);\n-      } else if (fieldType.equals(double.class)) {\n-        double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-        fieldSetter.set(instance, (TField) (Double) val);\n-      } else if (fieldType.equals(float.class)) {\n-        float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-        fieldSetter.set(instance, (TField) (Float) val);\n-      } else if (fieldType.equals(char.class)) {\n-        char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-        fieldSetter.set(instance, (TField) (Character) val);\n-      } else if (fieldType.equals(boolean.class)) {\n-        boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-        fieldSetter.set(instance, (TField) (Boolean) val);\n-      } else {\n-        throw new EncodingException(fieldType + \" not supported.\");\n-      }\n-    }\n-  }\n-\n-  private static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex dd2710d23..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-\n-          String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (isInLine(fieldDescriptor)) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n-          } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-          }\n-        }\n-        refs.put(fieldName, ref);\n-      }\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        FieldRef<?> ref = refs.get(fieldName);\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        ReflectiveFieldSetter fieldSetter = entry.getValue();\n-        if (fieldSetter == null) {\n-          throw new RuntimeException(\"FieldSetter for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref == null) {\n-          throw new RuntimeException(\"FieldRef for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref instanceof FieldRef.Boxed) {\n-          Object val = creationCtx.get((FieldRef.Boxed<?>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(int.class)) {\n-          int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(long.class)) {\n-          long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(short.class)) {\n-          short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(double.class)) {\n-          double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(float.class)) {\n-          float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(char.class)) {\n-          char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(boolean.class)) {\n-          boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-          fieldSetter.set(instance, val);\n-        } else {\n-          throw new EncodingException(fieldType + \" not supported.\");\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NjAwNA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461756004", "body": "same here", "bodyText": "same here", "bodyHTML": "<p dir=\"auto\">same here</p>", "author": "vkryachko", "createdAt": "2020-07-28T17:37:32Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,214 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);\n+      decodeFields(ctx);\n+      return getTypeCreator(ctx.getTypeToken());\n+    }\n+\n+    private void readMethods(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        Method[] methods = currentClass.getDeclaredMethods();\n+        for (Method method : methods) {\n+          if (!shouldIncludeSetter(method)) {\n+            continue;\n+          }\n+\n+          String fieldName = fieldName(method);\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(\n+                fieldName,\n+                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n+          }\n+          if (fieldSetters.get(fieldName) == null) {\n+            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n+          }\n+        }\n+        currentClass = currentClass.getSuperclass();\n+      }\n+    }\n+\n+    private void readFields(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        for (Field field : currentClass.getDeclaredFields()) {\n+          if (!shouldIncludeField(field)) {\n+            continue;\n+          }\n+          String fieldName = field.getName();\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(\n+                fieldName,\n+                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));", "originalCommit": "82b6254984e08a0ff226c67330480f728b88e280", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex dd2710d23..08b97369a 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -98,8 +98,8 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n                 fieldName,\n                 buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));\n           }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n+          if (reflectiveSetters.get(fieldName) == null) {\n+            reflectiveSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n           }\n         }\n         currentClass = currentClass.getSuperclass();\n", "next_change": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex 08b97369a..7539c440f 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -93,13 +85,8 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n             continue;\n           }\n           String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));\n-          }\n-          if (reflectiveSetters.get(fieldName) == null) {\n-            reflectiveSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n+          if (!fieldContexts.containsKey(fieldName)) {\n+            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n           }\n         }\n         currentClass = currentClass.getSuperclass();\n", "next_change": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex 7539c440f..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,250 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-          String fieldName = fieldName(method);\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        decodeField(ctx, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void decodeField(\n-        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n-      FieldRef<TField> ref;\n-      if (fieldType.equals(int.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n-      } else if (fieldType.equals(long.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n-      } else if (fieldType.equals(short.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n-      } else if (fieldType.equals(double.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n-      } else if (fieldType.equals(float.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n-      } else if (fieldType.equals(boolean.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n-      } else {\n-        TypeToken<TField> fieldTypeToken =\n-            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n-        if (fieldContext.isInline()) {\n-          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n-            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-          } else {\n-            throw new IllegalArgumentException(\n-                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-          }\n-        } else {\n-          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-        }\n-      }\n-      fieldContext.putFieldRef(ref);\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-        throw new EncodingException(\n-            \"Class \"\n-                + ctx.getTypeToken()\n-                + \"does not have type variable \"\n-                + ((TypeVariable) type).getName());\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        setField(creationCtx, instance, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void setField(\n-        CreationContext creationCtx,\n-        Object instance,\n-        ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      FieldRef<TField> ref = fieldContext.getFieldRef();\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      ReflectiveSetter<TField> fieldSetter = fieldContext.getReflectiveSetter();\n-      if (ref instanceof FieldRef.Boxed) {\n-        TField val = creationCtx.get((FieldRef.Boxed<TField>) ref);\n-        fieldSetter.set(instance, val);\n-      } else if (fieldType.equals(int.class)) {\n-        int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-        fieldSetter.set(instance, (TField) (Integer) val);\n-      } else if (fieldType.equals(long.class)) {\n-        long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-        fieldSetter.set(instance, (TField) (Long) val);\n-      } else if (fieldType.equals(short.class)) {\n-        short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-        fieldSetter.set(instance, (TField) (Short) val);\n-      } else if (fieldType.equals(double.class)) {\n-        double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-        fieldSetter.set(instance, (TField) (Double) val);\n-      } else if (fieldType.equals(float.class)) {\n-        float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-        fieldSetter.set(instance, (TField) (Float) val);\n-      } else if (fieldType.equals(char.class)) {\n-        char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-        fieldSetter.set(instance, (TField) (Character) val);\n-      } else if (fieldType.equals(boolean.class)) {\n-        boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-        fieldSetter.set(instance, (TField) (Boolean) val);\n-      } else {\n-        throw new EncodingException(fieldType + \" not supported.\");\n-      }\n-    }\n-  }\n-\n-  private static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}}, {"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex 08b97369a..7539c440f 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -107,45 +94,45 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n     }\n \n     private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (entry.getValue().isDecodedInline()) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n+      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n+        decodeField(ctx, fieldContext);\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <TField> void decodeField(\n+        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n+      Class<TField> fieldType = fieldContext.getFieldRawType();\n+      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n+      FieldRef<TField> ref;\n+      if (fieldType.equals(int.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n+      } else if (fieldType.equals(long.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n+      } else if (fieldType.equals(short.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n+      } else if (fieldType.equals(double.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n+      } else if (fieldType.equals(float.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n+      } else if (fieldType.equals(boolean.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n+      } else {\n+        TypeToken<TField> fieldTypeToken =\n+            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n+        if (fieldContext.isInline()) {\n+          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n+            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n+            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n           } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n+            throw new IllegalArgumentException(\n+                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n           }\n+        } else {\n+          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n         }\n-        refs.put(fieldName, ref);\n       }\n+      fieldContext.putFieldRef(ref);\n     }\n \n     private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n", "next_change": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex 7539c440f..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,250 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-          String fieldName = fieldName(method);\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        decodeField(ctx, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void decodeField(\n-        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n-      FieldRef<TField> ref;\n-      if (fieldType.equals(int.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n-      } else if (fieldType.equals(long.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n-      } else if (fieldType.equals(short.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n-      } else if (fieldType.equals(double.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n-      } else if (fieldType.equals(float.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n-      } else if (fieldType.equals(boolean.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n-      } else {\n-        TypeToken<TField> fieldTypeToken =\n-            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n-        if (fieldContext.isInline()) {\n-          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n-            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-          } else {\n-            throw new IllegalArgumentException(\n-                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-          }\n-        } else {\n-          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-        }\n-      }\n-      fieldContext.putFieldRef(ref);\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-        throw new EncodingException(\n-            \"Class \"\n-                + ctx.getTypeToken()\n-                + \"does not have type variable \"\n-                + ((TypeVariable) type).getName());\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        setField(creationCtx, instance, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void setField(\n-        CreationContext creationCtx,\n-        Object instance,\n-        ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      FieldRef<TField> ref = fieldContext.getFieldRef();\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      ReflectiveSetter<TField> fieldSetter = fieldContext.getReflectiveSetter();\n-      if (ref instanceof FieldRef.Boxed) {\n-        TField val = creationCtx.get((FieldRef.Boxed<TField>) ref);\n-        fieldSetter.set(instance, val);\n-      } else if (fieldType.equals(int.class)) {\n-        int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-        fieldSetter.set(instance, (TField) (Integer) val);\n-      } else if (fieldType.equals(long.class)) {\n-        long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-        fieldSetter.set(instance, (TField) (Long) val);\n-      } else if (fieldType.equals(short.class)) {\n-        short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-        fieldSetter.set(instance, (TField) (Short) val);\n-      } else if (fieldType.equals(double.class)) {\n-        double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-        fieldSetter.set(instance, (TField) (Double) val);\n-      } else if (fieldType.equals(float.class)) {\n-        float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-        fieldSetter.set(instance, (TField) (Float) val);\n-      } else if (fieldType.equals(char.class)) {\n-        char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-        fieldSetter.set(instance, (TField) (Character) val);\n-      } else if (fieldType.equals(boolean.class)) {\n-        boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-        fieldSetter.set(instance, (TField) (Boolean) val);\n-      } else {\n-        throw new EncodingException(fieldType + \" not supported.\");\n-      }\n-    }\n-  }\n-\n-  private static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex dd2710d23..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,214 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-\n-          String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(\n-                fieldName,\n-                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));\n-          }\n-          if (fieldSetters.get(fieldName) == null) {\n-            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (isInLine(fieldDescriptor)) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n-          } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-          }\n-        }\n-        refs.put(fieldName, ref);\n-      }\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (Map.Entry<String, ReflectiveFieldSetter> entry : fieldSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        FieldRef<?> ref = refs.get(fieldName);\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        ReflectiveFieldSetter fieldSetter = entry.getValue();\n-        if (fieldSetter == null) {\n-          throw new RuntimeException(\"FieldSetter for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref == null) {\n-          throw new RuntimeException(\"FieldRef for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref instanceof FieldRef.Boxed) {\n-          Object val = creationCtx.get((FieldRef.Boxed<?>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(int.class)) {\n-          int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(long.class)) {\n-          long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(short.class)) {\n-          short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(double.class)) {\n-          double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(float.class)) {\n-          float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(char.class)) {\n-          char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(boolean.class)) {\n-          boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-          fieldSetter.set(instance, val);\n-        } else {\n-          throw new EncodingException(fieldType + \" not supported.\");\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzAyOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461807029", "body": "```suggestion\r\n```\r\n\r\nI don't think we want Field itseld to have this annotation.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @ExtraProperty\n          \n      \n    \n    \n  \n\nI don't think we want Field itseld to have this annotation.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">  </span><span class=\"pl-k x x-last\">@ExtraProperty</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">I don't think we want Field itseld to have this annotation.</p>", "author": "vkryachko", "createdAt": "2020-07-28T19:05:23Z", "path": "encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java", "diffHunk": "@@ -48,6 +48,7 @@\n   /** Field configuration. */\n   @Target(ElementType.METHOD)\n   @Retention(RetentionPolicy.RUNTIME)\n+  @ExtraProperty", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java b/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\nindex 7e79e44cc..f12dd25e5 100644\n--- a/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\n+++ b/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\n", "chunk": "@@ -48,7 +48,6 @@ public @interface Encodable {\n   /** Field configuration. */\n   @Target(ElementType.METHOD)\n   @Retention(RetentionPolicy.RUNTIME)\n-  @ExtraProperty\n   @interface Field {\n     /** Specifies a custom field name for a given property of a type. */\n     String name() default \"\";\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java b/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\nindex 7e79e44cc..f12dd25e5 100644\n--- a/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\n+++ b/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\n", "chunk": "@@ -48,7 +48,6 @@ public @interface Encodable {\n   /** Field configuration. */\n   @Target(ElementType.METHOD)\n   @Retention(RetentionPolicy.RUNTIME)\n-  @ExtraProperty\n   @interface Field {\n     /** Specifies a custom field name for a given property of a type. */\n     String name() default \"\";\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}, {"oid": "24a07db7da18e28bac53db55dc28fcf6295f6503", "committedDate": "2020-09-02 09:52:24 -0400", "message": "Extract core encoders api into a separate library. (#1930)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzgxOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461807818", "body": "We want to make sure the field name is consistent with whatever the reflective *encoder* does, can you make sure they are indeed consistent and if not, reconsile them?", "bodyText": "We want to make sure the field name is consistent with whatever the reflective encoder does, can you make sure they are indeed consistent and if not, reconsile them?", "bodyHTML": "<p dir=\"auto\">We want to make sure the field name is consistent with whatever the reflective <em>encoder</em> does, can you make sure they are indeed consistent and if not, reconsile them?</p>", "author": "vkryachko", "createdAt": "2020-07-28T19:06:50Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+class ReflectiveDecoderHelper {\n+  private ReflectiveDecoderHelper() {}\n+\n+  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n+    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n+    for (Annotation annotation : annotations) {\n+      if (annotation.annotationType().isAnnotationPresent(ExtraProperty.class)) {\n+        builder.withProperty(annotation);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static boolean isInLine(FieldDescriptor fieldDescriptor) {\n+    Encodable.Field annotation = fieldDescriptor.getProperty(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n+  }\n+\n+  static String fieldName(Method method) {", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNzg1NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461817854", "bodyText": "yes, they are consistent, but i will change the implementation to align with encoder as well.", "author": "James201311", "createdAt": "2020-07-28T19:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzgxOA=="}], "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\nindex 8ebf6a73b..6be263c08 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n", "chunk": "@@ -30,33 +29,18 @@ class ReflectiveDecoderHelper {\n   static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n     FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n     for (Annotation annotation : annotations) {\n-      if (annotation.annotationType().isAnnotationPresent(ExtraProperty.class)) {\n-        builder.withProperty(annotation);\n-      }\n+      builder.withProperty(annotation);\n     }\n     return builder.build();\n   }\n \n-  static boolean isInLine(FieldDescriptor fieldDescriptor) {\n-    Encodable.Field annotation = fieldDescriptor.getProperty(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-\n   static String fieldName(Method method) {\n     String methodName = method.getName();\n     final String prefix = \"set\";\n     if (!methodName.startsWith(prefix)) {\n       throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n     }\n-    String strippedName = methodName.substring(prefix.length());\n-    // Make sure the first word or upper-case prefix is converted to lower-case\n-    char[] chars = strippedName.toCharArray();\n-    int pos = 0;\n-    while (pos < chars.length && Character.isUpperCase(chars[pos])) {\n-      chars[pos] = Character.toLowerCase(chars[pos]);\n-      pos++;\n-    }\n-    return new String(chars);\n+    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n   }\n \n   static String decodingKey(AccessibleObject accessibleObject) {\n", "next_change": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 6be263c08..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      builder.withProperty(annotation);\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 8ebf6a73b..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      if (annotation.annotationType().isAnnotationPresent(ExtraProperty.class)) {\n-        builder.withProperty(annotation);\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static boolean isInLine(FieldDescriptor fieldDescriptor) {\n-    Encodable.Field annotation = fieldDescriptor.getProperty(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    String strippedName = methodName.substring(prefix.length());\n-    // Make sure the first word or upper-case prefix is converted to lower-case\n-    char[] chars = strippedName.toCharArray();\n-    int pos = 0;\n-    while (pos < chars.length && Character.isUpperCase(chars[pos])) {\n-      chars[pos] = Character.toLowerCase(chars[pos]);\n-      pos++;\n-    }\n-    return new String(chars);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwODQ0Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461808443", "body": "please make this an interface", "bodyText": "please make this an interface", "bodyHTML": "<p dir=\"auto\">please make this an interface</p>", "author": "vkryachko", "createdAt": "2020-07-28T19:08:03Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n+abstract class ReflectiveFieldSetter {", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\nindex ca06889ad..51a04e146 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n", "chunk": "@@ -16,86 +16,47 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n+import com.google.firebase.encoders.annotations.Encodable;\n import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n \n-abstract class ReflectiveFieldSetter {\n-\n-  abstract void set(@NonNull Object obj, @Nullable Object val);\n-\n-  abstract Class<?> getFieldRawType();\n-\n-  abstract Type getFieldGenericType();\n-\n-  private ReflectiveFieldSetter() {}\n+class ReflectiveFieldSetter implements ReflectiveSetter {\n+  private Field field;\n \n   @NonNull\n   static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new FieldSetter(field);\n+    return new ReflectiveFieldSetter(field);\n   }\n \n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Method setter) {\n-    return new MethodSetter(setter);\n+  private ReflectiveFieldSetter(Field field) {\n+    this.field = field;\n   }\n \n-  static class FieldSetter extends ReflectiveFieldSetter {\n-    private Field field;\n-\n-    FieldSetter(Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object value) {\n-      field.setAccessible(true);\n-      try {\n-        field.set(obj, value);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return field.getType();\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return field.getGenericType();\n+  @Override\n+  public void set(@NonNull Object obj, @Nullable Object value) {\n+    field.setAccessible(true);\n+    try {\n+      field.set(obj, value);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n     }\n   }\n \n-  static class MethodSetter extends ReflectiveFieldSetter {\n-    private Method method;\n-\n-    MethodSetter(Method method) {\n-      this.method = method;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object val) {\n-      method.setAccessible(true);\n-      try {\n-        method.invoke(obj, val);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      } catch (InvocationTargetException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n+  @NonNull\n+  @Override\n+  public Class<?> getFieldRawType() {\n+    return field.getType();\n+  }\n \n-    @Override\n-    Class<?> getFieldRawType() {\n-      return method.getParameterTypes()[0];\n-    }\n+  @Nullable\n+  @Override\n+  public Type getFieldGenericType() {\n+    return field.getGenericType();\n+  }\n \n-    @Override\n-    Type getFieldGenericType() {\n-      return method.getGenericParameterTypes()[0];\n-    }\n+  @Override\n+  public boolean isDecodedInline() {\n+    Encodable.Field annotation = field.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n   }\n }\n", "next_change": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\ndeleted file mode 100644\nindex 51a04e146..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ /dev/null\n", "chunk": "@@ -1,62 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-\n-class ReflectiveFieldSetter implements ReflectiveSetter {\n-  private Field field;\n-\n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new ReflectiveFieldSetter(field);\n-  }\n-\n-  private ReflectiveFieldSetter(Field field) {\n-    this.field = field;\n-  }\n-\n-  @Override\n-  public void set(@NonNull Object obj, @Nullable Object value) {\n-    field.setAccessible(true);\n-    try {\n-      field.set(obj, value);\n-    } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  @NonNull\n-  @Override\n-  public Class<?> getFieldRawType() {\n-    return field.getType();\n-  }\n-\n-  @Nullable\n-  @Override\n-  public Type getFieldGenericType() {\n-    return field.getGenericType();\n-  }\n-\n-  @Override\n-  public boolean isDecodedInline() {\n-    Encodable.Field annotation = field.getAnnotation(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\ndeleted file mode 100644\nindex ca06889ad..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ /dev/null\n", "chunk": "@@ -1,101 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-\n-abstract class ReflectiveFieldSetter {\n-\n-  abstract void set(@NonNull Object obj, @Nullable Object val);\n-\n-  abstract Class<?> getFieldRawType();\n-\n-  abstract Type getFieldGenericType();\n-\n-  private ReflectiveFieldSetter() {}\n-\n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new FieldSetter(field);\n-  }\n-\n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Method setter) {\n-    return new MethodSetter(setter);\n-  }\n-\n-  static class FieldSetter extends ReflectiveFieldSetter {\n-    private Field field;\n-\n-    FieldSetter(Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object value) {\n-      field.setAccessible(true);\n-      try {\n-        field.set(obj, value);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return field.getType();\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return field.getGenericType();\n-    }\n-  }\n-\n-  static class MethodSetter extends ReflectiveFieldSetter {\n-    private Method method;\n-\n-    MethodSetter(Method method) {\n-      this.method = method;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object val) {\n-      method.setAccessible(true);\n-      try {\n-        method.invoke(obj, val);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      } catch (InvocationTargetException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return method.getParameterTypes()[0];\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return method.getGenericParameterTypes()[0];\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwODczMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461808730", "body": "extract Field and MethodSetters into top level classes pls.", "bodyText": "extract Field and MethodSetters into top level classes pls.", "bodyHTML": "<p dir=\"auto\">extract Field and MethodSetters into top level classes pls.</p>", "author": "vkryachko", "createdAt": "2020-07-28T19:08:36Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n+abstract class ReflectiveFieldSetter {\n+\n+  abstract void set(@NonNull Object obj, @Nullable Object val);\n+\n+  abstract Class<?> getFieldRawType();\n+\n+  abstract Type getFieldGenericType();\n+\n+  private ReflectiveFieldSetter() {}\n+\n+  @NonNull\n+  static ReflectiveFieldSetter of(@NonNull Field field) {\n+    return new FieldSetter(field);\n+  }\n+\n+  @NonNull\n+  static ReflectiveFieldSetter of(@NonNull Method setter) {\n+    return new MethodSetter(setter);\n+  }\n+\n+  static class FieldSetter extends ReflectiveFieldSetter {", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\nindex ca06889ad..51a04e146 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n", "chunk": "@@ -16,86 +16,47 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n+import com.google.firebase.encoders.annotations.Encodable;\n import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n \n-abstract class ReflectiveFieldSetter {\n-\n-  abstract void set(@NonNull Object obj, @Nullable Object val);\n-\n-  abstract Class<?> getFieldRawType();\n-\n-  abstract Type getFieldGenericType();\n-\n-  private ReflectiveFieldSetter() {}\n+class ReflectiveFieldSetter implements ReflectiveSetter {\n+  private Field field;\n \n   @NonNull\n   static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new FieldSetter(field);\n+    return new ReflectiveFieldSetter(field);\n   }\n \n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Method setter) {\n-    return new MethodSetter(setter);\n+  private ReflectiveFieldSetter(Field field) {\n+    this.field = field;\n   }\n \n-  static class FieldSetter extends ReflectiveFieldSetter {\n-    private Field field;\n-\n-    FieldSetter(Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object value) {\n-      field.setAccessible(true);\n-      try {\n-        field.set(obj, value);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return field.getType();\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return field.getGenericType();\n+  @Override\n+  public void set(@NonNull Object obj, @Nullable Object value) {\n+    field.setAccessible(true);\n+    try {\n+      field.set(obj, value);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n     }\n   }\n \n-  static class MethodSetter extends ReflectiveFieldSetter {\n-    private Method method;\n-\n-    MethodSetter(Method method) {\n-      this.method = method;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object val) {\n-      method.setAccessible(true);\n-      try {\n-        method.invoke(obj, val);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      } catch (InvocationTargetException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n+  @NonNull\n+  @Override\n+  public Class<?> getFieldRawType() {\n+    return field.getType();\n+  }\n \n-    @Override\n-    Class<?> getFieldRawType() {\n-      return method.getParameterTypes()[0];\n-    }\n+  @Nullable\n+  @Override\n+  public Type getFieldGenericType() {\n+    return field.getGenericType();\n+  }\n \n-    @Override\n-    Type getFieldGenericType() {\n-      return method.getGenericParameterTypes()[0];\n-    }\n+  @Override\n+  public boolean isDecodedInline() {\n+    Encodable.Field annotation = field.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n   }\n }\n", "next_change": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\ndeleted file mode 100644\nindex 51a04e146..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ /dev/null\n", "chunk": "@@ -1,62 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-\n-class ReflectiveFieldSetter implements ReflectiveSetter {\n-  private Field field;\n-\n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new ReflectiveFieldSetter(field);\n-  }\n-\n-  private ReflectiveFieldSetter(Field field) {\n-    this.field = field;\n-  }\n-\n-  @Override\n-  public void set(@NonNull Object obj, @Nullable Object value) {\n-    field.setAccessible(true);\n-    try {\n-      field.set(obj, value);\n-    } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  @NonNull\n-  @Override\n-  public Class<?> getFieldRawType() {\n-    return field.getType();\n-  }\n-\n-  @Nullable\n-  @Override\n-  public Type getFieldGenericType() {\n-    return field.getGenericType();\n-  }\n-\n-  @Override\n-  public boolean isDecodedInline() {\n-    Encodable.Field annotation = field.getAnnotation(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\ndeleted file mode 100644\nindex ca06889ad..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ /dev/null\n", "chunk": "@@ -1,101 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-\n-abstract class ReflectiveFieldSetter {\n-\n-  abstract void set(@NonNull Object obj, @Nullable Object val);\n-\n-  abstract Class<?> getFieldRawType();\n-\n-  abstract Type getFieldGenericType();\n-\n-  private ReflectiveFieldSetter() {}\n-\n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new FieldSetter(field);\n-  }\n-\n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Method setter) {\n-    return new MethodSetter(setter);\n-  }\n-\n-  static class FieldSetter extends ReflectiveFieldSetter {\n-    private Field field;\n-\n-    FieldSetter(Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object value) {\n-      field.setAccessible(true);\n-      try {\n-        field.set(obj, value);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return field.getType();\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return field.getGenericType();\n-    }\n-  }\n-\n-  static class MethodSetter extends ReflectiveFieldSetter {\n-    private Method method;\n-\n-    MethodSetter(Method method) {\n-      this.method = method;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object val) {\n-      method.setAccessible(true);\n-      try {\n-        method.invoke(obj, val);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      } catch (InvocationTargetException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return method.getParameterTypes()[0];\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return method.getGenericParameterTypes()[0];\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"oid": "e8959edf460da975591882c26cf3f251060884d8", "url": "https://github.com/firebase/firebase-android-sdk/commit/e8959edf460da975591882c26cf3f251060884d8", "message": "address comments", "committedDate": "2020-07-28T20:13:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMxNzIxNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462317216", "body": "imo we should throw an `EncodingException` if the type is not allowed by the annotation", "bodyText": "imo we should throw an EncodingException if the type is not allowed by the annotation", "bodyHTML": "<p dir=\"auto\">imo we should throw an <code>EncodingException</code> if the type is not allowed by the annotation</p>", "author": "vkryachko", "createdAt": "2020-07-29T13:55:09Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java", "diffHunk": "@@ -17,19 +17,47 @@\n import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n class ReflectiveDecoderHelper {\n   private ReflectiveDecoderHelper() {}\n \n-  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n+  static FieldDescriptor buildFieldDescriptor(Method method) {\n+    String decodingKey = decodingKey(method);\n+    Annotation[] annotations = method.getDeclaredAnnotations();\n     FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n     for (Annotation annotation : annotations) {\n-      builder.withProperty(annotation);\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 063d25827..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,126 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(Method method) {\n-    String decodingKey = decodingKey(method);\n-    Annotation[] annotations = method.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static FieldDescriptor buildFieldDescriptor(Field field) {\n-    String decodingKey = decodingKey(field);\n-    Annotation[] annotations = field.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(field.getType())) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 063d25827..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,126 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(Method method) {\n-    String decodingKey = decodingKey(method);\n-    Annotation[] annotations = method.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static FieldDescriptor buildFieldDescriptor(Field field) {\n-    String decodingKey = decodingKey(field);\n-    Annotation[] annotations = field.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(field.getType())) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyMDQ1OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462320459", "body": "these methods look very similar, could they be merged into one? afaict, the only thing that is specific to `method` vs `field` is the return type, the rest can be generalized to `java.lang.reflect.AccessibleObject`, i.e. the method signature would be `buildFieldDescriptor(AccessibleObject element, Class<?> type)`, wdyt?", "bodyText": "these methods look very similar, could they be merged into one? afaict, the only thing that is specific to method vs field is the return type, the rest can be generalized to java.lang.reflect.AccessibleObject, i.e. the method signature would be buildFieldDescriptor(AccessibleObject element, Class<?> type), wdyt?", "bodyHTML": "<p dir=\"auto\">these methods look very similar, could they be merged into one? afaict, the only thing that is specific to <code>method</code> vs <code>field</code> is the return type, the rest can be generalized to <code>java.lang.reflect.AccessibleObject</code>, i.e. the method signature would be <code>buildFieldDescriptor(AccessibleObject element, Class&lt;?&gt; type)</code>, wdyt?</p>", "author": "vkryachko", "createdAt": "2020-07-29T13:59:27Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java", "diffHunk": "@@ -17,19 +17,47 @@\n import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n class ReflectiveDecoderHelper {\n   private ReflectiveDecoderHelper() {}\n \n-  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n+  static FieldDescriptor buildFieldDescriptor(Method method) {\n+    String decodingKey = decodingKey(method);\n+    Annotation[] annotations = method.getDeclaredAnnotations();\n     FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n     for (Annotation annotation : annotations) {\n-      builder.withProperty(annotation);\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n+          builder.withProperty(annotation);\n+        }\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static FieldDescriptor buildFieldDescriptor(Field field) {", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 063d25827..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,126 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(Method method) {\n-    String decodingKey = decodingKey(method);\n-    Annotation[] annotations = method.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static FieldDescriptor buildFieldDescriptor(Field field) {\n-    String decodingKey = decodingKey(field);\n-    Annotation[] annotations = field.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(field.getType())) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 063d25827..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,126 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(Method method) {\n-    String decodingKey = decodingKey(method);\n-    Annotation[] annotations = method.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static FieldDescriptor buildFieldDescriptor(Field field) {\n-    String decodingKey = decodingKey(field);\n-    Annotation[] annotations = field.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(field.getType())) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyODMxMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462328313", "body": "This looks like a lot of bookkeeping spread across 3 maps, is it ever the case that only a subset of these maps contains a certain key? if not consider merging into one map", "bodyText": "This looks like a lot of bookkeeping spread across 3 maps, is it ever the case that only a subset of these maps contains a certain key? if not consider merging into one map", "bodyHTML": "<p dir=\"auto\">This looks like a lot of bookkeeping spread across 3 maps, is it ever the case that only a subset of these maps contains a certain key? if not consider merging into one map</p>", "author": "vkryachko", "createdAt": "2020-07-29T14:10:05Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,210 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyMDk1NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462420954", "bodyText": "Great call, I will wrap them into a ReflectiveDecoderFieldContext, which will also make the ReflectiveSetter be a single purpose setter.", "author": "James201311", "createdAt": "2020-07-29T16:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyODMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex e433b0019..7539c440f 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -46,9 +46,7 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n \n   private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n \n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n+    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n \n     private ReflectiveObjectDecoderImpl() {}\n \n", "next_change": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex 7539c440f..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,250 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-          String fieldName = fieldName(method);\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        decodeField(ctx, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void decodeField(\n-        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n-      FieldRef<TField> ref;\n-      if (fieldType.equals(int.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n-      } else if (fieldType.equals(long.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n-      } else if (fieldType.equals(short.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n-      } else if (fieldType.equals(double.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n-      } else if (fieldType.equals(float.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n-      } else if (fieldType.equals(boolean.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n-      } else {\n-        TypeToken<TField> fieldTypeToken =\n-            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n-        if (fieldContext.isInline()) {\n-          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n-            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-          } else {\n-            throw new IllegalArgumentException(\n-                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-          }\n-        } else {\n-          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-        }\n-      }\n-      fieldContext.putFieldRef(ref);\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-        throw new EncodingException(\n-            \"Class \"\n-                + ctx.getTypeToken()\n-                + \"does not have type variable \"\n-                + ((TypeVariable) type).getName());\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        setField(creationCtx, instance, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void setField(\n-        CreationContext creationCtx,\n-        Object instance,\n-        ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      FieldRef<TField> ref = fieldContext.getFieldRef();\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      ReflectiveSetter<TField> fieldSetter = fieldContext.getReflectiveSetter();\n-      if (ref instanceof FieldRef.Boxed) {\n-        TField val = creationCtx.get((FieldRef.Boxed<TField>) ref);\n-        fieldSetter.set(instance, val);\n-      } else if (fieldType.equals(int.class)) {\n-        int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-        fieldSetter.set(instance, (TField) (Integer) val);\n-      } else if (fieldType.equals(long.class)) {\n-        long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-        fieldSetter.set(instance, (TField) (Long) val);\n-      } else if (fieldType.equals(short.class)) {\n-        short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-        fieldSetter.set(instance, (TField) (Short) val);\n-      } else if (fieldType.equals(double.class)) {\n-        double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-        fieldSetter.set(instance, (TField) (Double) val);\n-      } else if (fieldType.equals(float.class)) {\n-        float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-        fieldSetter.set(instance, (TField) (Float) val);\n-      } else if (fieldType.equals(char.class)) {\n-        char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-        fieldSetter.set(instance, (TField) (Character) val);\n-      } else if (fieldType.equals(boolean.class)) {\n-        boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-        fieldSetter.set(instance, (TField) (Boolean) val);\n-      } else {\n-        throw new EncodingException(fieldType + \" not supported.\");\n-      }\n-    }\n-  }\n-\n-  private static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex e433b0019..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,210 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-\n-          String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(fieldName, buildFieldDescriptor(method));\n-          }\n-          if (reflectiveSetters.get(fieldName) == null) {\n-            reflectiveSetters.put(fieldName, ReflectiveMethodSetter.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(fieldName, buildFieldDescriptor(field));\n-          }\n-          if (reflectiveSetters.get(fieldName) == null) {\n-            reflectiveSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (entry.getValue().isDecodedInline()) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n-          } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-          }\n-        }\n-        refs.put(fieldName, ref);\n-      }\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        FieldRef<?> ref = refs.get(fieldName);\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        ReflectiveSetter fieldSetter = entry.getValue();\n-        if (fieldSetter == null) {\n-          throw new RuntimeException(\"FieldSetter for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref == null) {\n-          throw new RuntimeException(\"FieldRef for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref instanceof FieldRef.Boxed) {\n-          Object val = creationCtx.get((FieldRef.Boxed<?>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(int.class)) {\n-          int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(long.class)) {\n-          long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(short.class)) {\n-          short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(double.class)) {\n-          double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(float.class)) {\n-          float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(char.class)) {\n-          char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(boolean.class)) {\n-          boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-          fieldSetter.set(instance, val);\n-        } else {\n-          throw new EncodingException(fieldType + \" not supported.\");\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzMjM4Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462332382", "body": "don't we want to throw a meaningful exception in the case we could not find the TypeVariable in the class definition? By \"meaningful\" I mean, not the generic on that `TypeToken.of` will throw, but rather something along the lines of \"class foo<T,U,V> does not have type variable W\".", "bodyText": "don't we want to throw a meaningful exception in the case we could not find the TypeVariable in the class definition? By \"meaningful\" I mean, not the generic on that TypeToken.of will throw, but rather something along the lines of \"class foo<T,U,V> does not have type variable W\".", "bodyHTML": "<p dir=\"auto\">don't we want to throw a meaningful exception in the case we could not find the TypeVariable in the class definition? By \"meaningful\" I mean, not the generic on that <code>TypeToken.of</code> will throw, but rather something along the lines of \"class foo&lt;T,U,V&gt; does not have type variable W\".</p>", "author": "vkryachko", "createdAt": "2020-07-29T14:15:02Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,210 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);\n+      decodeFields(ctx);\n+      return getTypeCreator(ctx.getTypeToken());\n+    }\n+\n+    private void readMethods(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        Method[] methods = currentClass.getDeclaredMethods();\n+        for (Method method : methods) {\n+          if (!shouldIncludeSetter(method)) {\n+            continue;\n+          }\n+\n+          String fieldName = fieldName(method);\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(fieldName, buildFieldDescriptor(method));\n+          }\n+          if (reflectiveSetters.get(fieldName) == null) {\n+            reflectiveSetters.put(fieldName, ReflectiveMethodSetter.of(method));\n+          }\n+        }\n+        currentClass = currentClass.getSuperclass();\n+      }\n+    }\n+\n+    private void readFields(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        for (Field field : currentClass.getDeclaredFields()) {\n+          if (!shouldIncludeField(field)) {\n+            continue;\n+          }\n+          String fieldName = field.getName();\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(fieldName, buildFieldDescriptor(field));\n+          }\n+          if (reflectiveSetters.get(fieldName) == null) {\n+            reflectiveSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n+          }\n+        }\n+        currentClass = currentClass.getSuperclass();\n+      }\n+    }\n+\n+    private void decodeFields(ObjectDecoderContext<T> ctx) {\n+      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n+        String fieldName = entry.getKey();\n+        Class<?> fieldType = entry.getValue().getFieldRawType();\n+        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n+        if (fieldDescriptor == null) {\n+          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n+        }\n+        FieldRef<?> ref;\n+        if (fieldType.equals(int.class)) {\n+          ref = ctx.decodeInteger(fieldDescriptor);\n+        } else if (fieldType.equals(long.class)) {\n+          ref = ctx.decodeLong(fieldDescriptor);\n+        } else if (fieldType.equals(short.class)) {\n+          ref = ctx.decodeShort(fieldDescriptor);\n+        } else if (fieldType.equals(double.class)) {\n+          ref = ctx.decodeDouble(fieldDescriptor);\n+        } else if (fieldType.equals(float.class)) {\n+          ref = ctx.decodeFloat(fieldDescriptor);\n+        } else if (fieldType.equals(boolean.class)) {\n+          ref = ctx.decodeBoolean(fieldDescriptor);\n+        } else {\n+          TypeToken<?> fieldTypeToken =\n+              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n+          if (entry.getValue().isDecodedInline()) {\n+            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n+              @SuppressWarnings(\"unchecked\")\n+              TypeToken.ClassToken<Object> classToken =\n+                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n+              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n+            } else {\n+              throw new IllegalArgumentException(\n+                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n+            }\n+          } else {\n+            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n+          }\n+        }\n+        refs.put(fieldName, ref);\n+      }\n+    }\n+\n+    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n+      if (type instanceof TypeVariable) {\n+        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n+        for (int i = 0; i < typeVariables.length; i++) {\n+          if (typeVariables[i].equals(type)) {\n+            return ctx.getTypeArgument(i);", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex e433b0019..7539c440f 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -103,45 +94,45 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n     }\n \n     private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (entry.getValue().isDecodedInline()) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n+      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n+        decodeField(ctx, fieldContext);\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <TField> void decodeField(\n+        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n+      Class<TField> fieldType = fieldContext.getFieldRawType();\n+      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n+      FieldRef<TField> ref;\n+      if (fieldType.equals(int.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n+      } else if (fieldType.equals(long.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n+      } else if (fieldType.equals(short.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n+      } else if (fieldType.equals(double.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n+      } else if (fieldType.equals(float.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n+      } else if (fieldType.equals(boolean.class)) {\n+        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n+      } else {\n+        TypeToken<TField> fieldTypeToken =\n+            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n+        if (fieldContext.isInline()) {\n+          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n+            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n+            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n           } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n+            throw new IllegalArgumentException(\n+                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n           }\n+        } else {\n+          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n         }\n-        refs.put(fieldName, ref);\n       }\n+      fieldContext.putFieldRef(ref);\n     }\n \n     private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n", "next_change": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex 7539c440f..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,250 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-          String fieldName = fieldName(method);\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        decodeField(ctx, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void decodeField(\n-        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n-      FieldRef<TField> ref;\n-      if (fieldType.equals(int.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n-      } else if (fieldType.equals(long.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n-      } else if (fieldType.equals(short.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n-      } else if (fieldType.equals(double.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n-      } else if (fieldType.equals(float.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n-      } else if (fieldType.equals(boolean.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n-      } else {\n-        TypeToken<TField> fieldTypeToken =\n-            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n-        if (fieldContext.isInline()) {\n-          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n-            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-          } else {\n-            throw new IllegalArgumentException(\n-                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-          }\n-        } else {\n-          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-        }\n-      }\n-      fieldContext.putFieldRef(ref);\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-        throw new EncodingException(\n-            \"Class \"\n-                + ctx.getTypeToken()\n-                + \"does not have type variable \"\n-                + ((TypeVariable) type).getName());\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        setField(creationCtx, instance, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void setField(\n-        CreationContext creationCtx,\n-        Object instance,\n-        ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      FieldRef<TField> ref = fieldContext.getFieldRef();\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      ReflectiveSetter<TField> fieldSetter = fieldContext.getReflectiveSetter();\n-      if (ref instanceof FieldRef.Boxed) {\n-        TField val = creationCtx.get((FieldRef.Boxed<TField>) ref);\n-        fieldSetter.set(instance, val);\n-      } else if (fieldType.equals(int.class)) {\n-        int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-        fieldSetter.set(instance, (TField) (Integer) val);\n-      } else if (fieldType.equals(long.class)) {\n-        long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-        fieldSetter.set(instance, (TField) (Long) val);\n-      } else if (fieldType.equals(short.class)) {\n-        short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-        fieldSetter.set(instance, (TField) (Short) val);\n-      } else if (fieldType.equals(double.class)) {\n-        double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-        fieldSetter.set(instance, (TField) (Double) val);\n-      } else if (fieldType.equals(float.class)) {\n-        float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-        fieldSetter.set(instance, (TField) (Float) val);\n-      } else if (fieldType.equals(char.class)) {\n-        char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-        fieldSetter.set(instance, (TField) (Character) val);\n-      } else if (fieldType.equals(boolean.class)) {\n-        boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-        fieldSetter.set(instance, (TField) (Boolean) val);\n-      } else {\n-        throw new EncodingException(fieldType + \" not supported.\");\n-      }\n-    }\n-  }\n-\n-  private static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}}, {"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex e433b0019..7539c440f 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n", "chunk": "@@ -152,6 +143,11 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n             return ctx.getTypeArgument(i);\n           }\n         }\n+        throw new EncodingException(\n+            \"Class \"\n+                + ctx.getTypeToken()\n+                + \"does not have type variable \"\n+                + ((TypeVariable) type).getName());\n       }\n       return TypeToken.of(type);\n     }\n", "next_change": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex 7539c440f..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,250 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, ReflectiveDecoderFieldContext> fieldContexts = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-          String fieldName = fieldName(method);\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (!fieldContexts.containsKey(fieldName)) {\n-            fieldContexts.put(fieldName, ReflectiveDecoderFieldContextImpl.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        decodeField(ctx, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void decodeField(\n-        ObjectDecoderContext<T> ctx, ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      FieldDescriptor fieldDescriptor = fieldContext.getFieldDescriptor();\n-      FieldRef<TField> ref;\n-      if (fieldType.equals(int.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeInteger(fieldDescriptor);\n-      } else if (fieldType.equals(long.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeLong(fieldDescriptor);\n-      } else if (fieldType.equals(short.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeShort(fieldDescriptor);\n-      } else if (fieldType.equals(double.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeDouble(fieldDescriptor);\n-      } else if (fieldType.equals(float.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeFloat(fieldDescriptor);\n-      } else if (fieldType.equals(boolean.class)) {\n-        ref = (FieldRef<TField>) ctx.decodeBoolean(fieldDescriptor);\n-      } else {\n-        TypeToken<TField> fieldTypeToken =\n-            (TypeToken<TField>) getFieldTypeToken(fieldContext.getFieldGenericType(), ctx);\n-        if (fieldContext.isInline()) {\n-          if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-            TypeToken.ClassToken<Object> classToken = (TypeToken.ClassToken<Object>) fieldTypeToken;\n-            ref = (FieldRef<TField>) ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-          } else {\n-            throw new IllegalArgumentException(\n-                \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-          }\n-        } else {\n-          ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-        }\n-      }\n-      fieldContext.putFieldRef(ref);\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-        throw new EncodingException(\n-            \"Class \"\n-                + ctx.getTypeToken()\n-                + \"does not have type variable \"\n-                + ((TypeVariable) type).getName());\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (ReflectiveDecoderFieldContext<?> fieldContext : fieldContexts.values()) {\n-        setField(creationCtx, instance, fieldContext);\n-      }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <TField> void setField(\n-        CreationContext creationCtx,\n-        Object instance,\n-        ReflectiveDecoderFieldContext<TField> fieldContext) {\n-      FieldRef<TField> ref = fieldContext.getFieldRef();\n-      Class<TField> fieldType = fieldContext.getFieldRawType();\n-      ReflectiveSetter<TField> fieldSetter = fieldContext.getReflectiveSetter();\n-      if (ref instanceof FieldRef.Boxed) {\n-        TField val = creationCtx.get((FieldRef.Boxed<TField>) ref);\n-        fieldSetter.set(instance, val);\n-      } else if (fieldType.equals(int.class)) {\n-        int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-        fieldSetter.set(instance, (TField) (Integer) val);\n-      } else if (fieldType.equals(long.class)) {\n-        long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-        fieldSetter.set(instance, (TField) (Long) val);\n-      } else if (fieldType.equals(short.class)) {\n-        short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-        fieldSetter.set(instance, (TField) (Short) val);\n-      } else if (fieldType.equals(double.class)) {\n-        double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-        fieldSetter.set(instance, (TField) (Double) val);\n-      } else if (fieldType.equals(float.class)) {\n-        float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-        fieldSetter.set(instance, (TField) (Float) val);\n-      } else if (fieldType.equals(char.class)) {\n-        char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-        fieldSetter.set(instance, (TField) (Character) val);\n-      } else if (fieldType.equals(boolean.class)) {\n-        boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-        fieldSetter.set(instance, (TField) (Boolean) val);\n-      } else {\n-        throw new EncodingException(fieldType + \" not supported.\");\n-      }\n-    }\n-  }\n-\n-  private static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\ndeleted file mode 100644\nindex e433b0019..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,210 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.CreationContext;\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.decoders.ObjectDecoder;\n-import com.google.firebase.decoders.ObjectDecoderContext;\n-import com.google.firebase.decoders.TypeCreator;\n-import com.google.firebase.decoders.TypeToken;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n-\n-  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n-\n-  private ReflectiveObjectDecoderProvider() {}\n-\n-  @NonNull\n-  @Override\n-  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n-    return new ReflectiveObjectDecoderImpl<>();\n-  }\n-\n-  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n-\n-    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n-    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n-\n-    private ReflectiveObjectDecoderImpl() {}\n-\n-    @NonNull\n-    @Override\n-    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n-      Class<T> clazz = ctx.getTypeToken().getRawType();\n-      readMethods(clazz);\n-      readFields(clazz);\n-      decodeFields(ctx);\n-      return getTypeCreator(ctx.getTypeToken());\n-    }\n-\n-    private void readMethods(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        Method[] methods = currentClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-          if (!shouldIncludeSetter(method)) {\n-            continue;\n-          }\n-\n-          String fieldName = fieldName(method);\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(fieldName, buildFieldDescriptor(method));\n-          }\n-          if (reflectiveSetters.get(fieldName) == null) {\n-            reflectiveSetters.put(fieldName, ReflectiveMethodSetter.of(method));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void readFields(Class<T> clazz) {\n-      Class<? super T> currentClass = clazz;\n-      while (currentClass != Object.class && currentClass != null) {\n-        for (Field field : currentClass.getDeclaredFields()) {\n-          if (!shouldIncludeField(field)) {\n-            continue;\n-          }\n-          String fieldName = field.getName();\n-          if (descriptors.get(fieldName) == null) {\n-            descriptors.put(fieldName, buildFieldDescriptor(field));\n-          }\n-          if (reflectiveSetters.get(fieldName) == null) {\n-            reflectiveSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n-          }\n-        }\n-        currentClass = currentClass.getSuperclass();\n-      }\n-    }\n-\n-    private void decodeFields(ObjectDecoderContext<T> ctx) {\n-      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n-        if (fieldDescriptor == null) {\n-          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n-        }\n-        FieldRef<?> ref;\n-        if (fieldType.equals(int.class)) {\n-          ref = ctx.decodeInteger(fieldDescriptor);\n-        } else if (fieldType.equals(long.class)) {\n-          ref = ctx.decodeLong(fieldDescriptor);\n-        } else if (fieldType.equals(short.class)) {\n-          ref = ctx.decodeShort(fieldDescriptor);\n-        } else if (fieldType.equals(double.class)) {\n-          ref = ctx.decodeDouble(fieldDescriptor);\n-        } else if (fieldType.equals(float.class)) {\n-          ref = ctx.decodeFloat(fieldDescriptor);\n-        } else if (fieldType.equals(boolean.class)) {\n-          ref = ctx.decodeBoolean(fieldDescriptor);\n-        } else {\n-          TypeToken<?> fieldTypeToken =\n-              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n-          if (entry.getValue().isDecodedInline()) {\n-            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n-              @SuppressWarnings(\"unchecked\")\n-              TypeToken.ClassToken<Object> classToken =\n-                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n-              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n-            } else {\n-              throw new IllegalArgumentException(\n-                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n-            }\n-          } else {\n-            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n-          }\n-        }\n-        refs.put(fieldName, ref);\n-      }\n-    }\n-\n-    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n-      if (type instanceof TypeVariable) {\n-        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n-        for (int i = 0; i < typeVariables.length; i++) {\n-          if (typeVariables[i].equals(type)) {\n-            return ctx.getTypeArgument(i);\n-          }\n-        }\n-      }\n-      return TypeToken.of(type);\n-    }\n-\n-    private TypeCreator<T> getTypeCreator(TypeToken.ClassToken<T> classToken) {\n-      return (creationCtx -> {\n-        T instance = ReflectiveInitializer.newInstance(classToken);\n-        setFields(creationCtx, instance);\n-        return instance;\n-      });\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void setFields(CreationContext creationCtx, Object instance) {\n-      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n-        String fieldName = entry.getKey();\n-        FieldRef<?> ref = refs.get(fieldName);\n-        Class<?> fieldType = entry.getValue().getFieldRawType();\n-        ReflectiveSetter fieldSetter = entry.getValue();\n-        if (fieldSetter == null) {\n-          throw new RuntimeException(\"FieldSetter for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref == null) {\n-          throw new RuntimeException(\"FieldRef for field:\" + fieldName + \" is null.\");\n-        }\n-        if (ref instanceof FieldRef.Boxed) {\n-          Object val = creationCtx.get((FieldRef.Boxed<?>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(int.class)) {\n-          int val = creationCtx.getInteger((FieldRef.Primitive<Integer>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(long.class)) {\n-          long val = creationCtx.getLong((FieldRef.Primitive<Long>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(short.class)) {\n-          short val = creationCtx.getShort((FieldRef.Primitive<Short>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(double.class)) {\n-          double val = creationCtx.getDouble((FieldRef.Primitive<Double>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(float.class)) {\n-          float val = creationCtx.getFloat((FieldRef.Primitive<Float>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(char.class)) {\n-          char val = creationCtx.getChar((FieldRef.Primitive<Character>) ref);\n-          fieldSetter.set(instance, val);\n-        } else if (fieldType.equals(boolean.class)) {\n-          boolean val = creationCtx.getBoolean((FieldRef.Primitive<Boolean>) ref);\n-          fieldSetter.set(instance, val);\n-        } else {\n-          throw new EncodingException(fieldType + \" not supported.\");\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzMzMxNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462333317", "body": "This is not a very good exception, let's tell the developer what is wrong in each case and how they could fix it.", "bodyText": "This is not a very good exception, let's tell the developer what is wrong in each case and how they could fix it.", "bodyHTML": "<p dir=\"auto\">This is not a very good exception, let's tell the developer what is wrong in each case and how they could fix it.</p>", "author": "vkryachko", "createdAt": "2020-07-29T14:16:11Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.TypeToken;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class ReflectiveInitializer {\n+\n+  @NonNull\n+  static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    try {\n+      Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      return constructor.newInstance();\n+    } catch (NoSuchMethodException e) {\n+      // TODO: try JVM sun.misc.Unsafe to allocate an instance\n+      throw new RuntimeException(e);", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex f8deb48dc..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -25,16 +26,22 @@ final class ReflectiveInitializer {\n   static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n     try {\n       Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      constructor.setAccessible(true);\n       return constructor.newInstance();\n     } catch (NoSuchMethodException e) {\n       // TODO: try JVM sun.misc.Unsafe to allocate an instance\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\n+          \"Class \"\n+              + classToken\n+              + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex f8deb48dc..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -25,16 +26,22 @@ final class ReflectiveInitializer {\n   static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n     try {\n       Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      constructor.setAccessible(true);\n       return constructor.newInstance();\n     } catch (NoSuchMethodException e) {\n       // TODO: try JVM sun.misc.Unsafe to allocate an instance\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\n+          \"Class \"\n+              + classToken\n+              + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzNTc3Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462335777", "body": "food fo thought(no immediate action required): it seems that it could be useful to just store the `inline` flag inside the field descriptor. This will help by:\r\n* not needing a method here\r\n* and furthermore would allow us to remove the `decodeInline()` method altogether making the api surface smaller and the implementation below simpler.\r\n\r\nwdyt?", "bodyText": "food fo thought(no immediate action required): it seems that it could be useful to just store the inline flag inside the field descriptor. This will help by:\n\nnot needing a method here\nand furthermore would allow us to remove the decodeInline() method altogether making the api surface smaller and the implementation below simpler.\n\nwdyt?", "bodyHTML": "<p dir=\"auto\">food fo thought(no immediate action required): it seems that it could be useful to just store the <code>inline</code> flag inside the field descriptor. This will help by:</p>\n<ul dir=\"auto\">\n<li>not needing a method here</li>\n<li>and furthermore would allow us to remove the <code>decodeInline()</code> method altogether making the api surface smaller and the implementation below simpler.</li>\n</ul>\n<p dir=\"auto\">wdyt?</p>", "author": "vkryachko", "createdAt": "2020-07-29T14:19:30Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java", "diffHunk": "@@ -0,0 +1,31 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import java.lang.reflect.Type;\n+\n+interface ReflectiveSetter {\n+  void set(@NonNull Object obj, @Nullable Object val);\n+\n+  @NonNull\n+  Class<?> getFieldRawType();\n+\n+  @Nullable\n+  Type getFieldGenericType();\n+\n+  boolean isDecodedInline();", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\nindex f7ea25217..20690916b 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\n", "chunk": "@@ -16,16 +16,7 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n-import java.lang.reflect.Type;\n \n-interface ReflectiveSetter {\n-  void set(@NonNull Object obj, @Nullable Object val);\n-\n-  @NonNull\n-  Class<?> getFieldRawType();\n-\n-  @Nullable\n-  Type getFieldGenericType();\n-\n-  boolean isDecodedInline();\n+interface ReflectiveSetter<T> {\n+  void set(@NonNull Object obj, @Nullable T val);\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\nindex f7ea25217..20690916b 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\n", "chunk": "@@ -16,16 +16,7 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n-import java.lang.reflect.Type;\n \n-interface ReflectiveSetter {\n-  void set(@NonNull Object obj, @Nullable Object val);\n-\n-  @NonNull\n-  Class<?> getFieldRawType();\n-\n-  @Nullable\n-  Type getFieldGenericType();\n-\n-  boolean isDecodedInline();\n+interface ReflectiveSetter<T> {\n+  void set(@NonNull Object obj, @Nullable T val);\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4Mjc2MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462482761", "body": "is it something you intend to actually do, if not consider removing this todo", "bodyText": "is it something you intend to actually do, if not consider removing this todo", "bodyHTML": "<p dir=\"auto\">is it something you intend to actually do, if not consider removing this todo</p>", "author": "vkryachko", "createdAt": "2020-07-29T17:55:37Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class ReflectiveInitializer {\n+\n+  @NonNull\n+  static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    try {\n+      Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      return constructor.newInstance();\n+    } catch (NoSuchMethodException e) {\n+      // TODO: try JVM sun.misc.Unsafe to allocate an instance", "originalCommit": "f39d5f7f508683773b394180d3f787eb83295972", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b8881..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -26,6 +26,7 @@ final class ReflectiveInitializer {\n   static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n     try {\n       Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      constructor.setAccessible(true);\n       return constructor.newInstance();\n     } catch (NoSuchMethodException e) {\n       // TODO: try JVM sun.misc.Unsafe to allocate an instance\n", "next_change": null}, {"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b8881..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -33,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b8881..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -26,6 +26,7 @@ final class ReflectiveInitializer {\n   static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n     try {\n       Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      constructor.setAccessible(true);\n       return constructor.newInstance();\n     } catch (NoSuchMethodException e) {\n       // TODO: try JVM sun.misc.Unsafe to allocate an instance\n", "next_change": null}, {"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b8881..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -33,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MzExOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462483118", "body": "Looks like you missed all these cases, like constructor is not public, etc.", "bodyText": "Looks like you missed all these cases, like constructor is not public, etc.", "bodyHTML": "<p dir=\"auto\">Looks like you missed all these cases, like constructor is not public, etc.</p>", "author": "vkryachko", "createdAt": "2020-07-29T17:56:09Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class ReflectiveInitializer {\n+\n+  @NonNull\n+  static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    try {\n+      Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      return constructor.newInstance();\n+    } catch (NoSuchMethodException e) {\n+      // TODO: try JVM sun.misc.Unsafe to allocate an instance\n+      throw new EncodingException(\n+          \"Class \"\n+              + classToken\n+              + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n+              + \"sure these constructors are not stripped.\");\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    } catch (InstantiationException e) {\n+      throw new RuntimeException(e);\n+    } catch (InvocationTargetException e) {\n+      throw new RuntimeException(e);\n+    }", "originalCommit": "f39d5f7f508683773b394180d3f787eb83295972", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b8881..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -33,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b8881..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -33,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNDU5OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462534598", "body": "nit: it's common to name these things with `Impl`, not `Imp`\r\n```suggestion\r\nclass ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\r\n```", "bodyText": "nit: it's common to name these things with Impl, not Imp\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {\n          \n          \n            \n            class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {", "bodyHTML": "<p dir=\"auto\">nit: it's common to name these things with <code>Impl</code>, not <code>Imp</code></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k\">class</span> <span class=\"pl-en x x-first x-last\">ReflectiveDecoderFieldContextImp</span>&lt;T&gt; <span class=\"pl-k\">implements</span> <span class=\"pl-e\">ReflectiveDecoderFieldContext&lt;<span class=\"pl-smi\">T</span>&gt;</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">class</span> <span class=\"pl-en x x-first x-last\">ReflectiveDecoderFieldContextImpl</span>&lt;T&gt; <span class=\"pl-k\">implements</span> <span class=\"pl-e\">ReflectiveDecoderFieldContext&lt;<span class=\"pl-smi\">T</span>&gt;</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vkryachko", "createdAt": "2020-07-29T19:26:11Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java", "diffHunk": "@@ -0,0 +1,181 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {", "originalCommit": "8ccca1ddd84589c39adda98065c856024e25b6b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\nsimilarity index 92%\nrename from encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java\nrename to encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\nindex f542041c0..6688e4956 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\n", "chunk": "@@ -29,7 +29,7 @@ import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Set;\n \n-class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {\n+class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n   private FieldDescriptor fieldDescriptor;\n   private ReflectiveSetter<T> setter;\n   private FieldRef<T> fieldRef;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java\ndeleted file mode 100644\nindex f542041c0..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java\n+++ /dev/null\n", "chunk": "@@ -1,181 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {\n-  private FieldDescriptor fieldDescriptor;\n-  private ReflectiveSetter<T> setter;\n-  private FieldRef<T> fieldRef;\n-  private Type genericType;\n-  private Class<T> rawType;\n-  private boolean inline;\n-\n-  public static ReflectiveDecoderFieldContextImp<?> of(Method method) {\n-    return new ReflectiveDecoderFieldContextImp(method);\n-  }\n-\n-  public static ReflectiveDecoderFieldContextImp<?> of(Field field) {\n-    return new ReflectiveDecoderFieldContextImp(field);\n-  }\n-\n-  private ReflectiveDecoderFieldContextImp(Method method) {\n-    this.fieldDescriptor = buildFieldDescriptor(method);\n-    this.genericType = method.getGenericParameterTypes()[0];\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n-    this.rawType = rawType;\n-    this.inline = inline(method);\n-    method.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            method.invoke(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          } catch (InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  private ReflectiveDecoderFieldContextImp(Field field) {\n-    this.fieldDescriptor = buildFieldDescriptor(field);\n-    this.genericType = field.getGenericType();\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) field.getType();\n-    this.rawType = rawType;\n-    this.inline = inline(field);\n-    field.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            field.set(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  @Override\n-  public Class<T> getFieldRawType() {\n-    return rawType;\n-  }\n-\n-  @Override\n-  public Type getFieldGenericType() {\n-    return genericType;\n-  }\n-\n-  @Override\n-  public FieldDescriptor getFieldDescriptor() {\n-    return fieldDescriptor;\n-  }\n-\n-  @Override\n-  public ReflectiveSetter<T> getReflectiveSetter() {\n-    return setter;\n-  }\n-\n-  @Override\n-  public FieldRef<T> getFieldRef() {\n-    return fieldRef;\n-  }\n-\n-  @Override\n-  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n-    FieldRef<T> old = this.fieldRef;\n-    this.fieldRef = fieldRef;\n-    return old;\n-  }\n-\n-  @Override\n-  public boolean isInline() {\n-    return inline;\n-  }\n-\n-  private static boolean inline(AccessibleObject accessibleObject) {\n-    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-\n-  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n-    Class<?> type;\n-    if (accessibleObject instanceof Field) {\n-      type = ((Field) accessibleObject).getType();\n-    } else if (accessibleObject instanceof Method) {\n-      type = ((Method) accessibleObject).getParameterTypes()[0];\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    String decodingKey = decodingKey(accessibleObject);\n-    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n-          builder.withProperty(annotation);\n-        } else {\n-          throw new EncodingException(\n-              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  private static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462535975", "body": "We have to preserve the cause chain to make the error more useful, I would suggest something like this in all cases below:\r\n```java\r\n} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {\r\n  throw new EncodingException(\"Could not instantiate type \" + classToken, e);\r\n}\r\n```\r\n\r\nnote the second parameter to the exception constructor.", "bodyText": "We have to preserve the cause chain to make the error more useful, I would suggest something like this in all cases below:\n} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {\n  throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n}\nnote the second parameter to the exception constructor.", "bodyHTML": "<p dir=\"auto\">We have to preserve the cause chain to make the error more useful, I would suggest something like this in all cases below:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {\n  throw new EncodingException(&quot;Could not instantiate type &quot; + classToken, e);\n}\"><pre>} <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">IllegalAccessException</span> <span class=\"pl-k\">|</span> <span class=\"pl-smi\">InstantiationException</span> <span class=\"pl-k\">|</span> <span class=\"pl-smi\">InvocationTargetException</span> e) {\n  <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">EncodingException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Could not instantiate type <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> classToken, e);\n}</pre></div>\n<p dir=\"auto\">note the second parameter to the exception constructor.</p>", "author": "vkryachko", "createdAt": "2020-07-29T19:28:44Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -35,11 +36,11 @@\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n               + \"sure these constructors are not stripped.\");\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(e.toString());", "originalCommit": "8ccca1ddd84589c39adda98065c856024e25b6b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNzk3Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462537976", "bodyText": "pls also add the e argument to the catch block above.", "author": "vkryachko", "createdAt": "2020-07-29T19:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1NjU4Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462556583", "bodyText": "Multi-catch requires API level 19.", "author": "James201311", "createdAt": "2020-07-29T20:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3Mzg0OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462573848", "bodyText": "No really, if you set language level to java 8, the desugarer will kick in and desugar to java 6.\ni.e.  see https://github.com/firebase/firebase-android-sdk/blob/master/firebase-common/firebase-common.gradle#L49", "author": "vkryachko", "createdAt": "2020-07-29T20:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex d5573aba8..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -34,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex d5573aba8..52f0215a6 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n", "chunk": "@@ -34,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"oid": "97a17d59375265e7aa131b984c5190b1a047e671", "url": "https://github.com/firebase/firebase-android-sdk/commit/97a17d59375265e7aa131b984c5190b1a047e671", "message": "initial implementation of reflective decoder", "committedDate": "2020-07-31T19:44:56Z", "type": "forcePushed"}, {"oid": "450e41594933ffc889446112fb2e57f08c6409f2", "url": "https://github.com/firebase/firebase-android-sdk/commit/450e41594933ffc889446112fb2e57f08c6409f2", "message": "initial implementation of reflective decoder", "committedDate": "2020-07-31T20:00:35Z", "type": "commit"}, {"oid": "450e41594933ffc889446112fb2e57f08c6409f2", "url": "https://github.com/firebase/firebase-android-sdk/commit/450e41594933ffc889446112fb2e57f08c6409f2", "message": "initial implementation of reflective decoder", "committedDate": "2020-07-31T20:00:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4NTQzNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465085435", "body": "Consider just making constructors public and remove these methods", "bodyText": "Consider just making constructors public and remove these methods", "bodyHTML": "<p dir=\"auto\">Consider just making constructors public and remove these methods</p>", "author": "vkryachko", "createdAt": "2020-08-04T14:18:52Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n+  private FieldDescriptor fieldDescriptor;\n+  private ReflectiveSetter<T> setter;\n+  private FieldRef<T> fieldRef;\n+  private Type genericType;\n+  private Class<T> rawType;\n+  private boolean inline;\n+\n+  public static ReflectiveDecoderFieldContextImpl<?> of(Method method) {\n+    return new ReflectiveDecoderFieldContextImpl(method);\n+  }\n+\n+  public static ReflectiveDecoderFieldContextImpl<?> of(Field field) {\n+    return new ReflectiveDecoderFieldContextImpl(field);\n+  }", "originalCommit": "450e41594933ffc889446112fb2e57f08c6409f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\ndeleted file mode 100644\nindex 6688e4956..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,181 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n-  private FieldDescriptor fieldDescriptor;\n-  private ReflectiveSetter<T> setter;\n-  private FieldRef<T> fieldRef;\n-  private Type genericType;\n-  private Class<T> rawType;\n-  private boolean inline;\n-\n-  public static ReflectiveDecoderFieldContextImpl<?> of(Method method) {\n-    return new ReflectiveDecoderFieldContextImpl(method);\n-  }\n-\n-  public static ReflectiveDecoderFieldContextImpl<?> of(Field field) {\n-    return new ReflectiveDecoderFieldContextImpl(field);\n-  }\n-\n-  private ReflectiveDecoderFieldContextImpl(Method method) {\n-    this.fieldDescriptor = buildFieldDescriptor(method);\n-    this.genericType = method.getGenericParameterTypes()[0];\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n-    this.rawType = rawType;\n-    this.inline = inline(method);\n-    method.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            method.invoke(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          } catch (InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  private ReflectiveDecoderFieldContextImpl(Field field) {\n-    this.fieldDescriptor = buildFieldDescriptor(field);\n-    this.genericType = field.getGenericType();\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) field.getType();\n-    this.rawType = rawType;\n-    this.inline = inline(field);\n-    field.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            field.set(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  @Override\n-  public Class<T> getFieldRawType() {\n-    return rawType;\n-  }\n-\n-  @Override\n-  public Type getFieldGenericType() {\n-    return genericType;\n-  }\n-\n-  @Override\n-  public FieldDescriptor getFieldDescriptor() {\n-    return fieldDescriptor;\n-  }\n-\n-  @Override\n-  public ReflectiveSetter<T> getReflectiveSetter() {\n-    return setter;\n-  }\n-\n-  @Override\n-  public FieldRef<T> getFieldRef() {\n-    return fieldRef;\n-  }\n-\n-  @Override\n-  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n-    FieldRef<T> old = this.fieldRef;\n-    this.fieldRef = fieldRef;\n-    return old;\n-  }\n-\n-  @Override\n-  public boolean isInline() {\n-    return inline;\n-  }\n-\n-  private static boolean inline(AccessibleObject accessibleObject) {\n-    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-\n-  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n-    Class<?> type;\n-    if (accessibleObject instanceof Field) {\n-      type = ((Field) accessibleObject).getType();\n-    } else if (accessibleObject instanceof Method) {\n-      type = ((Method) accessibleObject).getParameterTypes()[0];\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    String decodingKey = decodingKey(accessibleObject);\n-    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n-          builder.withProperty(annotation);\n-        } else {\n-          throw new EncodingException(\n-              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  private static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\ndeleted file mode 100644\nindex 6688e4956..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,181 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n-  private FieldDescriptor fieldDescriptor;\n-  private ReflectiveSetter<T> setter;\n-  private FieldRef<T> fieldRef;\n-  private Type genericType;\n-  private Class<T> rawType;\n-  private boolean inline;\n-\n-  public static ReflectiveDecoderFieldContextImpl<?> of(Method method) {\n-    return new ReflectiveDecoderFieldContextImpl(method);\n-  }\n-\n-  public static ReflectiveDecoderFieldContextImpl<?> of(Field field) {\n-    return new ReflectiveDecoderFieldContextImpl(field);\n-  }\n-\n-  private ReflectiveDecoderFieldContextImpl(Method method) {\n-    this.fieldDescriptor = buildFieldDescriptor(method);\n-    this.genericType = method.getGenericParameterTypes()[0];\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n-    this.rawType = rawType;\n-    this.inline = inline(method);\n-    method.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            method.invoke(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          } catch (InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  private ReflectiveDecoderFieldContextImpl(Field field) {\n-    this.fieldDescriptor = buildFieldDescriptor(field);\n-    this.genericType = field.getGenericType();\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) field.getType();\n-    this.rawType = rawType;\n-    this.inline = inline(field);\n-    field.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            field.set(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  @Override\n-  public Class<T> getFieldRawType() {\n-    return rawType;\n-  }\n-\n-  @Override\n-  public Type getFieldGenericType() {\n-    return genericType;\n-  }\n-\n-  @Override\n-  public FieldDescriptor getFieldDescriptor() {\n-    return fieldDescriptor;\n-  }\n-\n-  @Override\n-  public ReflectiveSetter<T> getReflectiveSetter() {\n-    return setter;\n-  }\n-\n-  @Override\n-  public FieldRef<T> getFieldRef() {\n-    return fieldRef;\n-  }\n-\n-  @Override\n-  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n-    FieldRef<T> old = this.fieldRef;\n-    this.fieldRef = fieldRef;\n-    return old;\n-  }\n-\n-  @Override\n-  public boolean isInline() {\n-    return inline;\n-  }\n-\n-  private static boolean inline(AccessibleObject accessibleObject) {\n-    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-\n-  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n-    Class<?> type;\n-    if (accessibleObject instanceof Field) {\n-      type = ((Field) accessibleObject).getType();\n-    } else if (accessibleObject instanceof Method) {\n-      type = ((Method) accessibleObject).getParameterTypes()[0];\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    String decodingKey = decodingKey(accessibleObject);\n-    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n-          builder.withProperty(annotation);\n-        } else {\n-          throw new EncodingException(\n-              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  private static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NjAwNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465766006", "body": "Looks like you're not using it for anything, consider removing altogether", "bodyText": "Looks like you're not using it for anything, consider removing altogether", "bodyHTML": "<p dir=\"auto\">Looks like you're not using it for anything, consider removing altogether</p>", "author": "vkryachko", "createdAt": "2020-08-05T14:24:54Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,23 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.ObjectDecoder;\n+\n+interface ObjectDecoderProvider {", "originalCommit": "450e41594933ffc889446112fb2e57f08c6409f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5OTI1OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465799258", "bodyText": "I was trying to align with the behaviour of ReflectiveEncoder, but it turns out it's redundant. I will remove them.", "author": "James201311", "createdAt": "2020-08-05T15:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NjAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java\ndeleted file mode 100644\nindex 320718534..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,23 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.ObjectDecoder;\n-\n-interface ObjectDecoderProvider {\n-  @NonNull\n-  <T> ObjectDecoder<T> get(@NonNull Class<T> type);\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java\ndeleted file mode 100644\nindex 320718534..000000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,23 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.ObjectDecoder;\n-\n-interface ObjectDecoderProvider {\n-  @NonNull\n-  <T> ObjectDecoder<T> get(@NonNull Class<T> type);\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2Njc5Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465766792", "body": "Same here, consider removing the interface and renaming the `Impl` class to this name.", "bodyText": "Same here, consider removing the interface and renaming the Impl class to this name.", "bodyHTML": "<p dir=\"auto\">Same here, consider removing the interface and renaming the <code>Impl</code> class to this name.</p>", "author": "vkryachko", "createdAt": "2020-08-05T14:25:57Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java", "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Type;\n+\n+interface ReflectiveDecoderFieldContext<T> {", "originalCommit": "450e41594933ffc889446112fb2e57f08c6409f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\nindex 918291a97..4de1f3a07 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\n", "chunk": "@@ -15,22 +15,152 @@\n package com.google.firebase.encoders.reflective;\n \n import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n-interface ReflectiveDecoderFieldContext<T> {\n+class ReflectiveDecoderFieldContext<T> {\n+  private FieldDescriptor fieldDescriptor;\n+  private ReflectiveSetter<T> setter;\n+  private FieldRef<T> fieldRef;\n+  private Type genericType;\n+  private Class<T> rawType;\n+  private boolean inline;\n \n-  Class<T> getFieldRawType();\n+  ReflectiveDecoderFieldContext(Method method) {\n+    this.fieldDescriptor = buildFieldDescriptor(method);\n+    this.genericType = method.getGenericParameterTypes()[0];\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n+    this.rawType = rawType;\n+    this.inline = inline(method);\n+    method.setAccessible(true);\n+    this.setter =\n+        (obj, val) -> {\n+          try {\n+            method.invoke(obj, val);\n+          } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+          } catch (InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+  }\n \n-  Type getFieldGenericType();\n+  ReflectiveDecoderFieldContext(Field field) {\n+    this.fieldDescriptor = buildFieldDescriptor(field);\n+    this.genericType = field.getGenericType();\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> rawType = (Class<T>) field.getType();\n+    this.rawType = rawType;\n+    this.inline = inline(field);\n+    field.setAccessible(true);\n+    this.setter =\n+        (obj, val) -> {\n+          try {\n+            field.set(obj, val);\n+          } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+  }\n \n-  FieldDescriptor getFieldDescriptor();\n+  public Class<T> getFieldRawType() {\n+    return rawType;\n+  }\n \n-  ReflectiveSetter<T> getReflectiveSetter();\n+  public Type getFieldGenericType() {\n+    return genericType;\n+  }\n \n-  FieldRef<T> getFieldRef();\n+  public FieldDescriptor getFieldDescriptor() {\n+    return fieldDescriptor;\n+  }\n \n-  FieldRef<T> putFieldRef(FieldRef<T> fieldRef);\n+  public ReflectiveSetter<T> getReflectiveSetter() {\n+    return setter;\n+  }\n \n-  boolean isInline();\n+  public FieldRef<T> getFieldRef() {\n+    return fieldRef;\n+  }\n+\n+  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n+    FieldRef<T> old = this.fieldRef;\n+    this.fieldRef = fieldRef;\n+    return old;\n+  }\n+\n+  public boolean isInline() {\n+    return inline;\n+  }\n+\n+  private static boolean inline(AccessibleObject accessibleObject) {\n+    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n+  }\n+\n+  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n+    Class<?> type;\n+    if (accessibleObject instanceof Field) {\n+      type = ((Field) accessibleObject).getType();\n+    } else if (accessibleObject instanceof Method) {\n+      type = ((Method) accessibleObject).getParameterTypes()[0];\n+    } else {\n+      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n+    }\n+    String decodingKey = decodingKey(accessibleObject);\n+    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n+    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n+    for (Annotation annotation : annotations) {\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n+          builder.withProperty(annotation);\n+        } else {\n+          throw new EncodingException(\n+              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n+        }\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  private static String decodingKey(AccessibleObject accessibleObject) {\n+    String key;\n+    if (accessibleObject instanceof Field) {\n+      key = ((Field) accessibleObject).getName();\n+    } else if (accessibleObject instanceof Method) {\n+      key = fieldName((Method) accessibleObject);\n+    } else {\n+      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n+    }\n+    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n+      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n+      if (annotation != null && annotation.name().length() > 0) {\n+        key = annotation.name();\n+      }\n+    }\n+    return key;\n+  }\n+\n+  private static String fieldName(Method method) {\n+    String methodName = method.getName();\n+    final String prefix = \"set\";\n+    if (!methodName.startsWith(prefix)) {\n+      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n+    }\n+    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n+  }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\nindex 918291a97..4de1f3a07 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\n", "chunk": "@@ -15,22 +15,152 @@\n package com.google.firebase.encoders.reflective;\n \n import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n-interface ReflectiveDecoderFieldContext<T> {\n+class ReflectiveDecoderFieldContext<T> {\n+  private FieldDescriptor fieldDescriptor;\n+  private ReflectiveSetter<T> setter;\n+  private FieldRef<T> fieldRef;\n+  private Type genericType;\n+  private Class<T> rawType;\n+  private boolean inline;\n \n-  Class<T> getFieldRawType();\n+  ReflectiveDecoderFieldContext(Method method) {\n+    this.fieldDescriptor = buildFieldDescriptor(method);\n+    this.genericType = method.getGenericParameterTypes()[0];\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n+    this.rawType = rawType;\n+    this.inline = inline(method);\n+    method.setAccessible(true);\n+    this.setter =\n+        (obj, val) -> {\n+          try {\n+            method.invoke(obj, val);\n+          } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+          } catch (InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+  }\n \n-  Type getFieldGenericType();\n+  ReflectiveDecoderFieldContext(Field field) {\n+    this.fieldDescriptor = buildFieldDescriptor(field);\n+    this.genericType = field.getGenericType();\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> rawType = (Class<T>) field.getType();\n+    this.rawType = rawType;\n+    this.inline = inline(field);\n+    field.setAccessible(true);\n+    this.setter =\n+        (obj, val) -> {\n+          try {\n+            field.set(obj, val);\n+          } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+  }\n \n-  FieldDescriptor getFieldDescriptor();\n+  public Class<T> getFieldRawType() {\n+    return rawType;\n+  }\n \n-  ReflectiveSetter<T> getReflectiveSetter();\n+  public Type getFieldGenericType() {\n+    return genericType;\n+  }\n \n-  FieldRef<T> getFieldRef();\n+  public FieldDescriptor getFieldDescriptor() {\n+    return fieldDescriptor;\n+  }\n \n-  FieldRef<T> putFieldRef(FieldRef<T> fieldRef);\n+  public ReflectiveSetter<T> getReflectiveSetter() {\n+    return setter;\n+  }\n \n-  boolean isInline();\n+  public FieldRef<T> getFieldRef() {\n+    return fieldRef;\n+  }\n+\n+  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n+    FieldRef<T> old = this.fieldRef;\n+    this.fieldRef = fieldRef;\n+    return old;\n+  }\n+\n+  public boolean isInline() {\n+    return inline;\n+  }\n+\n+  private static boolean inline(AccessibleObject accessibleObject) {\n+    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n+  }\n+\n+  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n+    Class<?> type;\n+    if (accessibleObject instanceof Field) {\n+      type = ((Field) accessibleObject).getType();\n+    } else if (accessibleObject instanceof Method) {\n+      type = ((Method) accessibleObject).getParameterTypes()[0];\n+    } else {\n+      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n+    }\n+    String decodingKey = decodingKey(accessibleObject);\n+    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n+    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n+    for (Annotation annotation : annotations) {\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n+          builder.withProperty(annotation);\n+        } else {\n+          throw new EncodingException(\n+              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n+        }\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  private static String decodingKey(AccessibleObject accessibleObject) {\n+    String key;\n+    if (accessibleObject instanceof Field) {\n+      key = ((Field) accessibleObject).getName();\n+    } else if (accessibleObject instanceof Method) {\n+      key = fieldName((Method) accessibleObject);\n+    } else {\n+      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n+    }\n+    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n+      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n+      if (annotation != null && annotation.name().length() > 0) {\n+        key = annotation.name();\n+      }\n+    }\n+    return key;\n+  }\n+\n+  private static String fieldName(Method method) {\n+    String methodName = method.getName();\n+    final String prefix = \"set\";\n+    if (!methodName.startsWith(prefix)) {\n+      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n+    }\n+    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n+  }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"oid": "4812230cbbf626d779bd2ae5169f38761926c224", "url": "https://github.com/firebase/firebase-android-sdk/commit/4812230cbbf626d779bd2ae5169f38761926c224", "message": "address commnets", "committedDate": "2020-08-05T15:08:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4ODg5Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r466088896", "body": "```suggestion\r\n        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not registered.\");\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");\n          \n          \n            \n                    throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not registered.\");", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">EncodingException</span>(ctx<span class=\"pl-k\">.</span>getTypeToken()<span class=\"pl-k\">.</span>getRawType() <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> is not <span class=\"x x-first x-last\">register</span>.<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">EncodingException</span>(ctx<span class=\"pl-k\">.</span>getTypeToken()<span class=\"pl-k\">.</span>getRawType() <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> is not <span class=\"x x-first x-last\">registered</span>.<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vkryachko", "createdAt": "2020-08-06T01:15:15Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java", "diffHunk": "@@ -20,15 +20,21 @@\n import com.google.firebase.decoders.DecoderConfig;\n import com.google.firebase.decoders.ObjectDecoder;\n import com.google.firebase.decoders.ValueDecoder;\n+import com.google.firebase.encoders.EncodingException;\n import java.lang.annotation.Annotation;\n import java.util.HashMap;\n import java.util.Map;\n \n public final class JsonDataDecoderBuilder implements DecoderConfig<JsonDataDecoderBuilder> {\n+  private static final ObjectDecoder<Object> DEFAULT_FALLBACK_DECODER =\n+      (ctx) -> {\n+        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");", "originalCommit": "4812230cbbf626d779bd2ae5169f38761926c224", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0926ff5722de44fa3f164ba77eeb71044642f988", "changed_code": [{"header": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\nindex 62462fb67..2f9cbed2c 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n", "chunk": "@@ -28,7 +28,7 @@ import java.util.Map;\n public final class JsonDataDecoderBuilder implements DecoderConfig<JsonDataDecoderBuilder> {\n   private static final ObjectDecoder<Object> DEFAULT_FALLBACK_DECODER =\n       (ctx) -> {\n-        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");\n+        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not registered.\");\n       };\n   private final HashMap<Class<?>, ObjectDecoder<?>> objectDecoders = new HashMap<>();\n   private final HashMap<Class<?>, ValueDecoder<?>> valueDecoders = new HashMap<>();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "977a59077a6ea07620479b349b7542270e6cf508", "changed_code": [{"header": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\nindex 62462fb67..2f9cbed2c 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n", "chunk": "@@ -28,7 +28,7 @@ import java.util.Map;\n public final class JsonDataDecoderBuilder implements DecoderConfig<JsonDataDecoderBuilder> {\n   private static final ObjectDecoder<Object> DEFAULT_FALLBACK_DECODER =\n       (ctx) -> {\n-        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");\n+        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not registered.\");\n       };\n   private final HashMap<Class<?>, ObjectDecoder<?>> objectDecoders = new HashMap<>();\n   private final HashMap<Class<?>, ValueDecoder<?>> valueDecoders = new HashMap<>();\n", "next_change": null}]}, "commits_in_main": [{"oid": "977a59077a6ea07620479b349b7542270e6cf508", "message": "Merge commit", "committedDate": null}]}, {"oid": "0926ff5722de44fa3f164ba77eeb71044642f988", "url": "https://github.com/firebase/firebase-android-sdk/commit/0926ff5722de44fa3f164ba77eeb71044642f988", "message": "Update encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n\nCo-authored-by: Vladimir Kryachko <vkryachko@google.com>", "committedDate": "2020-08-06T14:17:15Z", "type": "commit"}]}