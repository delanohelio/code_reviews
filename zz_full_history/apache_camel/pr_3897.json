{"pr_number": 3897, "pr_title": "CAMEL-13934 camel-minio - Component to store/load files from blob store", "pr_author": "Nayananga", "pr_createdAt": "2020-06-07T21:45:18Z", "pr_url": "https://github.com/apache/camel/pull/3897", "timeline": [{"oid": "18ec4f679abc44faac6792ddc5a619a880e05e93", "url": "https://github.com/apache/camel/commit/18ec4f679abc44faac6792ddc5a619a880e05e93", "message": "Replaced redundant checks with centralized lambdas", "committedDate": "2020-08-08T16:44:10Z", "type": "forcePushed"}, {"oid": "4e7587acde63bffaa8966d15689af206cb9577d9", "url": "https://github.com/apache/camel/commit/4e7587acde63bffaa8966d15689af206cb9577d9", "message": "Changed the error message in checkAndSetRegistryClient in MinioComponent.java", "committedDate": "2020-08-08T17:17:25Z", "type": "commit"}, {"oid": "9f619c84b46945598c63f1d7ad04cdefa1329d39", "url": "https://github.com/apache/camel/commit/9f619c84b46945598c63f1d7ad04cdefa1329d39", "message": "Fixed article issues in minio-component.adoc and unused parameter", "committedDate": "2020-08-08T17:46:46Z", "type": "commit"}, {"oid": "5ce02877a27e4c44242760f1bd7af412bd220664", "url": "https://github.com/apache/camel/commit/5ce02877a27e4c44242760f1bd7af412bd220664", "message": "Mimicked aws2-s3 component, ran mvn clean install -DskipTests", "committedDate": "2020-08-09T03:36:30Z", "type": "commit"}, {"oid": "ae457d0c7b0907f3ede8722baf1eec49803d60d4", "url": "https://github.com/apache/camel/commit/ae457d0c7b0907f3ede8722baf1eec49803d60d4", "message": "Minor fixes", "committedDate": "2020-08-09T06:27:38Z", "type": "commit"}, {"oid": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "url": "https://github.com/apache/camel/commit/7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "message": "Resolved a TODO", "committedDate": "2020-08-09T16:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470795", "body": "This class can be removed.", "bodyText": "This class can be removed.", "bodyHTML": "<p dir=\"auto\">This class can be removed.</p>", "author": "oscerd", "createdAt": "2020-06-08T05:56:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n+ * this component can consume from.\n+ */\n+public class EventBusHelper {", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjQzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437672436", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDk1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470950", "body": "You can use directly Component annotation without the whole package.", "bodyText": "You can use directly Component annotation without the whole package.", "bodyHTML": "<p dir=\"auto\">You can use directly Component annotation without the whole package.</p>", "author": "oscerd", "createdAt": "2020-06-08T05:57:13Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Map;\n+\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.Endpoint;\n+\n+import org.apache.camel.support.DefaultComponent;\n+\n+@org.apache.camel.spi.annotations.Component(\"MinIO\")", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436471145", "body": "Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.", "bodyText": "Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.", "bodyHTML": "<p dir=\"auto\">Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.</p>", "author": "oscerd", "createdAt": "2020-06-08T05:58:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.support.DefaultConsumer;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+public class MinIOConsumer extends DefaultConsumer {\n+    private final MinIOEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n+\n+    private ExecutorService executorService;\n+\n+    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg1MQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437673851", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "ece2cb7569d380486b4a0187ac97b3fac0574bbd", "url": "https://github.com/apache/camel/commit/ece2cb7569d380486b4a0187ac97b3fac0574bbd", "message": "Added auto generated files", "committedDate": "2020-06-10T04:13:01Z", "type": "forcePushed"}, {"oid": "2acf3087813b7b772b0efa5415212d4aa26495cd", "url": "https://github.com/apache/camel/commit/2acf3087813b7b772b0efa5415212d4aa26495cd", "message": "Updated minio-component.adoc file", "committedDate": "2020-06-12T13:33:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjMzMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466333", "body": "Maybe `firstVersion` could be set to `3.5.0` or something like that.", "bodyText": "Maybe firstVersion could be set to 3.5.0 or something like that.", "bodyHTML": "<p dir=\"auto\">Maybe <code>firstVersion</code> could be set to <code>3.5.0</code> or something like that.</p>", "author": "DenisIstomin", "createdAt": "2020-06-12T14:50:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466644", "body": "And maybe scheme could be lowercase, like \"minio\"", "bodyText": "And maybe scheme could be lowercase, like \"minio\"", "bodyHTML": "<p dir=\"auto\">And maybe scheme could be lowercase, like \"minio\"</p>", "author": "DenisIstomin", "createdAt": "2020-06-12T14:51:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "url": "https://github.com/apache/camel/commit/c26cc5d467d572180ba8a6a0d42bf52967b32010", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-12T20:41:12Z", "type": "forcePushed"}, {"oid": "39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "url": "https://github.com/apache/camel/commit/39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-13T06:41:19Z", "type": "forcePushed"}, {"oid": "1e7d342708e717f9299d7b55ef435ac776e616e9", "url": "https://github.com/apache/camel/commit/1e7d342708e717f9299d7b55ef435ac776e616e9", "message": "Recommended changes done", "committedDate": "2020-06-13T07:28:48Z", "type": "forcePushed"}, {"oid": "a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "url": "https://github.com/apache/camel/commit/a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "message": "Recommended changes done", "committedDate": "2020-06-13T08:03:57Z", "type": "forcePushed"}, {"oid": "c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "url": "https://github.com/apache/camel/commit/c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-13T22:09:26Z", "type": "forcePushed"}, {"oid": "d965cdf77194a40ee48877e4551ef97e63c692e7", "url": "https://github.com/apache/camel/commit/d965cdf77194a40ee48877e4551ef97e63c692e7", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-14T03:07:03Z", "type": "forcePushed"}, {"oid": "557c54ccc663f5b0b044f80629973afd8ceacb28", "url": "https://github.com/apache/camel/commit/557c54ccc663f5b0b044f80629973afd8ceacb28", "message": "Code reformatted", "committedDate": "2020-06-18T04:28:40Z", "type": "forcePushed"}, {"oid": "c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "url": "https://github.com/apache/camel/commit/c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "message": "Updated imports", "committedDate": "2020-06-18T21:18:28Z", "type": "forcePushed"}, {"oid": "1fe1eda807af55348e41b0a61fd601003f7e1360", "url": "https://github.com/apache/camel/commit/1fe1eda807af55348e41b0a61fd601003f7e1360", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-06-19T16:16:43Z", "type": "forcePushed"}, {"oid": "f46f2996d879c333635e764484ec74d5deb2b890", "url": "https://github.com/apache/camel/commit/f46f2996d879c333635e764484ec74d5deb2b890", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-24T22:11:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445202915", "body": "@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\r\n```\r\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\r\n            listObjectsRequest.bucket(bucketName);\r\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\r\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\r\n``` ", "bodyText": "@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/oscerd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/oscerd\">@oscerd</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/DenisIstomin/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/DenisIstomin\">@DenisIstomin</a> What kind of approach suitable here? AWS2 S3 component have use something like this</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"ListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\n\"><pre><code>ListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\n</code></pre></div>", "author": "Nayananga", "createdAt": "2020-06-24T22:18:37Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwMjk1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445302954", "bodyText": "you could use https://docs.min.io/docs/java-client-api-reference.html#listObjects @Nayananga", "author": "oscerd", "createdAt": "2020-06-25T04:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -40,147 +60,204 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n         String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges = null;\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+        if (isNotEmpty(objectName)) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n+\n+        } else {\n \n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n             }\n \n-        } else {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n \n-            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n+            }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (marker == null) {\n-                marker = results.iterator();\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n             }\n-            exchanges = pollMarker(bucketName, minioClient);\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n-            }\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n \n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n \n-    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n-        LOG.trace(\"Resuming from marker: {}\", marker);\n-        Queue<Object> bucketQueue = null;\n-        while (marker.hasNext()) {\n-            Item item = marker.next().get();\n-            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-            try {\n-                InputStream resumeStream = minioClient.getObject(bucketName,\n-                        item.objectName(),\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n-\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n             }\n         }\n-        // no more data so clear marker\n-        marker = null;\n-        return bucketQueue;\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-                }\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                        continuationToken = minioObjectSummary.objectName();\n+                    }\n+                } while (minioObjectSummaries.hasNext());\n             }\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n+            }\n+\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n-            throw e;\n         }\n \n         return answer;\n     }\n \n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n+    public int processBatch(Queue<Object> exchanges) {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..2575058ae15 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -259,9 +267,9 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 2575058ae15..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -274,6 +260,27 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445307693", "body": "Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?", "bodyText": "Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?", "bodyHTML": "<p dir=\"auto\">Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/oscerd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/oscerd\">@oscerd</a>, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?</p>", "author": "Nayananga", "createdAt": "2020-06-25T05:00:48Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwODYzNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445308634", "bodyText": "Hello @Nayananga , yes it is ok. You can do that and then process the result as a batch, like the S3 AWS2 component does.", "author": "oscerd", "createdAt": "2020-06-25T05:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMDY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445310644", "bodyText": "Thank you, is it okay to queue all the bucket objects (may take lot memory I guess) then send to  processBatch(CastUtils.cast(exchanges))? because in minio I had to queue each object in a Queue<Object> until iterator.hasNext() return false", "author": "Nayananga", "createdAt": "2020-06-25T05:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMTc5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445311790", "bodyText": "Not all the objects in one call, you need to define a limit for the batch, like setMaxKeys in AWS2 S3 component https://github.com/apache/camel/blob/master/components/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Consumer.java#L88", "author": "oscerd", "createdAt": "2020-06-25T05:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -40,147 +60,204 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n         String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges = null;\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+        if (isNotEmpty(objectName)) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n+\n+        } else {\n \n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n             }\n \n-        } else {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n \n-            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n+            }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (marker == null) {\n-                marker = results.iterator();\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n             }\n-            exchanges = pollMarker(bucketName, minioClient);\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n-            }\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n \n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n \n-    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n-        LOG.trace(\"Resuming from marker: {}\", marker);\n-        Queue<Object> bucketQueue = null;\n-        while (marker.hasNext()) {\n-            Item item = marker.next().get();\n-            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-            try {\n-                InputStream resumeStream = minioClient.getObject(bucketName,\n-                        item.objectName(),\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n-\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n             }\n         }\n-        // no more data so clear marker\n-        marker = null;\n-        return bucketQueue;\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-                }\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                        continuationToken = minioObjectSummary.objectName();\n+                    }\n+                } while (minioObjectSummaries.hasNext());\n             }\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n+            }\n+\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n-            throw e;\n         }\n \n         return answer;\n     }\n \n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n+    public int processBatch(Queue<Object> exchanges) {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..2575058ae15 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -259,9 +267,9 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 2575058ae15..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -274,6 +260,27 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": null}]}}]}}]}}, {"oid": "7174a3c85fdc5148e794521a6e86ca82d3520f2f", "url": "https://github.com/apache/camel/commit/7174a3c85fdc5148e794521a6e86ca82d3520f2f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-25T21:54:51Z", "type": "forcePushed"}, {"oid": "58e3d1b028374ac69716844c063623003d33c19f", "url": "https://github.com/apache/camel/commit/58e3d1b028374ac69716844c063623003d33c19f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-27T21:34:59Z", "type": "forcePushed"}, {"oid": "6040d1fa742dea91463f02238c51de4ef432b5e6", "url": "https://github.com/apache/camel/commit/6040d1fa742dea91463f02238c51de4ef432b5e6", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-28T09:42:08Z", "type": "forcePushed"}, {"oid": "303b36dc012fe0439b1ef3f9127489227fade0cc", "url": "https://github.com/apache/camel/commit/303b36dc012fe0439b1ef3f9127489227fade0cc", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-07-02T20:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0OTY3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449649678", "body": "Maybe you should avoid using `assert`. It is not enabled by default. It would be better to handle that with `if` condition.", "bodyText": "Maybe you should avoid using assert. It is not enabled by default. It would be better to handle that with if condition.", "bodyHTML": "<p dir=\"auto\">Maybe you should avoid using <code>assert</code>. It is not enabled by default. It would be better to handle that with <code>if</code> condition.</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:15:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -49,116 +60,167 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        MinioClient minioClient = getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        InputStream minioObject = null;\n-        Queue<Exchange> exchanges = null;\n-\n-        if (bucketExists(minioClient, bucketName)) {\n-            LOG.trace(\"Bucket {} exists\", bucketName);\n-        } else {\n-            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n-        }\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n+        if (isNotEmpty(objectName)) {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n-                if (minioObject != null) {\n-                    exchanges = createExchanges(minioObject, objectName);\n-                }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n \n-            } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n-                throw e;\n+        } else {\n \n-            } finally {\n-                //must be closed after use to release network resources.\n-                try {\n-                    assert minioObject != null;\n-                    minioObject.close();\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n \n-                } catch (IOException e) {\n-                    LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n-                }\n-            }\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n \n-        } else {\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n             }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n+            }\n \n-        assert CastUtils.cast(exchanges) != null;\n-        return processBatch(CastUtils.cast(exchanges));\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n+\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n+            }\n+        }\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n-\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n+                        continuationToken = minioObjectSummary.objectName();\n                     }\n+                } while (minioObjectSummaries.hasNext());\n+            }\n \n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n-                }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..6430df91e7d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -223,7 +228,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 totalCounter += messageCounter;\n             }\n \n-        } catch (Throwable e) {\n+        } catch (Exception e) {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6430df91e7d..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -232,10 +222,6 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n         }\n \n         return answer;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDM4Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650386", "body": "Maybe [try-with-resources](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) could be used here. It would be nice to reduce nesting.", "bodyText": "Maybe try-with-resources could be used here. It would be nice to reduce nesting.", "bodyHTML": "<p dir=\"auto\">Maybe <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\" rel=\"nofollow\">try-with-resources</a> could be used here. It would be nice to reduce nesting.</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:18:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;\n+        String bucketName = getConfiguration().getBucketName();\n+        MinioClient minioClient = getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        InputStream minioObject = null;\n+        Queue<Exchange> exchanges = null;\n+\n+        if (bucketExists(minioClient, bucketName)) {\n+            LOG.trace(\"Bucket {} exists\", bucketName);\n+        } else {\n+            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n+        }\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            try {\n+                minioObject = getObject(bucketName, minioClient, objectName);\n+                if (minioObject != null) {\n+                    exchanges = createExchanges(minioObject, objectName);\n+                }\n+\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                throw e;\n+\n+            } finally {\n+                //must be closed after use to release network resources.\n+                try {\n+                    assert minioObject != null;\n+                    minioObject.close();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -49,116 +60,167 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        MinioClient minioClient = getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        InputStream minioObject = null;\n-        Queue<Exchange> exchanges = null;\n-\n-        if (bucketExists(minioClient, bucketName)) {\n-            LOG.trace(\"Bucket {} exists\", bucketName);\n-        } else {\n-            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n-        }\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n+        if (isNotEmpty(objectName)) {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n-                if (minioObject != null) {\n-                    exchanges = createExchanges(minioObject, objectName);\n-                }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n \n-            } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n-                throw e;\n+        } else {\n \n-            } finally {\n-                //must be closed after use to release network resources.\n-                try {\n-                    assert minioObject != null;\n-                    minioObject.close();\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n \n-                } catch (IOException e) {\n-                    LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n-                }\n-            }\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n \n-        } else {\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n             }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n+            }\n \n-        assert CastUtils.cast(exchanges) != null;\n-        return processBatch(CastUtils.cast(exchanges));\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n+\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n+            }\n+        }\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n-\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n+                        continuationToken = minioObjectSummary.objectName();\n                     }\n+                } while (minioObjectSummaries.hasNext());\n+            }\n \n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n-                }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..6430df91e7d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -223,7 +228,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 totalCounter += messageCounter;\n             }\n \n-        } catch (Throwable e) {\n+        } catch (Exception e) {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6430df91e7d..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -232,10 +222,6 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n         }\n \n         return answer;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDk3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650977", "body": "Typo: retrieve", "bodyText": "Typo: retrieve", "bodyHTML": "<p dir=\"auto\">Typo: retrieve</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:20:17Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import io.minio.GetObjectTagsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.messages.Tags;\n+import jdk.internal.org.jline.utils.Log;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -43,23 +46,27 @@ import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.IOHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n- * Store and retrie objects from Minio Storage Service using Minio SDK.\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Qualified url\")\n+    @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String url; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -55,24 +53,16 @@ import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n /**\n  * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:bucketName\",\n         category = {Category.CLOUD, Category.FILE})\n-\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Bucket name\")\n-    @Metadata(required = true)\n-    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n \n     public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449651579", "body": "Looks like that test should fail, because there are no messages being sent.", "bodyText": "Looks like that test should fail, because there are no messages being sent.", "bodyHTML": "<p dir=\"auto\">Looks like that test should fail, because there are no messages being sent.</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:22:46Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit4.CamelTestSupport;\n+import org.junit.Test;\n+\n+public class MinioComponentTest extends CamelTestSupport {\n+\n+    @Test\n+    public void testMinio() throws Exception {\n+        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n+        mock.expectedMinimumMessageCount(1);\n+\n+        assertMockEndpointsSatisfied();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc2MDE4NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449760185", "bodyText": "ack, I haven't look into tests yet, I'll work on these asap :)", "author": "Nayananga", "createdAt": "2020-07-04T10:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "url": "https://github.com/apache/camel/commit/eb8a5eab91055dbefb8eb2a664bc6efc02068922", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-07-07T20:00:00Z", "type": "forcePushed"}, {"oid": "9a61617593bd21370a09598b54c766d167a9484c", "url": "https://github.com/apache/camel/commit/9a61617593bd21370a09598b54c766d167a9484c", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-07-09T14:43:55Z", "type": "forcePushed"}, {"oid": "c03064959bc92443b06333578b1c3a212adb8012", "url": "https://github.com/apache/camel/commit/c03064959bc92443b06333578b1c3a212adb8012", "message": "Updated to Minio 7.1.0", "committedDate": "2020-07-09T23:42:26Z", "type": "forcePushed"}, {"oid": "6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "url": "https://github.com/apache/camel/commit/6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-07-10T18:45:31Z", "type": "forcePushed"}, {"oid": "6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "url": "https://github.com/apache/camel/commit/6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "message": "Include integration Tests", "committedDate": "2020-07-13T22:08:02Z", "type": "forcePushed"}, {"oid": "311972bb833e08423b081d8268f686355cdcc161", "url": "https://github.com/apache/camel/commit/311972bb833e08423b081d8268f686355cdcc161", "message": "Code Reformatted", "committedDate": "2020-07-15T23:25:21Z", "type": "forcePushed"}, {"oid": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "url": "https://github.com/apache/camel/commit/3878b763e4e472b798d59f32e77fe5d52b7d4446", "message": "Ran Integration tests", "committedDate": "2020-07-16T22:20:43Z", "type": "forcePushed"}, {"oid": "aa7ba42bf24225df0036f6164360b5067781d18b", "url": "https://github.com/apache/camel/commit/aa7ba42bf24225df0036f6164360b5067781d18b", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-07-19T04:14:27Z", "type": "forcePushed"}, {"oid": "0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "url": "https://github.com/apache/camel/commit/0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "message": "Added documentation", "committedDate": "2020-07-19T18:43:50Z", "type": "forcePushed"}, {"oid": "e6028a86cd2018454b7d0d65938785171b6d02ab", "url": "https://github.com/apache/camel/commit/e6028a86cd2018454b7d0d65938785171b6d02ab", "message": "Minor changes to the tests", "committedDate": "2020-07-24T15:58:23Z", "type": "forcePushed"}, {"oid": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "url": "https://github.com/apache/camel/commit/ca963a048e1beb422fdf86ed84790523e9fd4b76", "message": "Fixed typo", "committedDate": "2020-07-25T18:22:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyODIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460728216", "body": "labels are missing here, for example `producer`, `consumer`, `common` ..etc", "bodyText": "labels are missing here, for example producer, consumer, common ..etc", "bodyHTML": "<p dir=\"auto\">labels are missing here, for example <code>producer</code>, <code>consumer</code>, <code>common</code> ..etc</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:29:11Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..ee18fe1d920 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -29,36 +29,35 @@ import org.apache.camel.spi.UriParams;\n @UriParams\n public class MinioConfiguration implements Cloneable {\n \n-    @UriParam\n+    @UriParam(label = \"common\")\n     private String endpoint;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private Integer proxyPort;\n+    @UriParam(label = \"common\")\n+    private boolean secure;\n+    @UriParam(label = \"common\")\n+    private String region;\n+    @UriParam(label = \"common\")\n+    private OkHttpClient customHttpClient;\n \n     @UriParam(label = \"security\", secret = true)\n     private String accessKey;\n     @UriParam(label = \"security\", secret = true)\n     private String secretKey;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean secure;\n-\n-    @UriParam\n-    private String region;\n-\n-    @UriParam\n-    private OkHttpClient customHttpClient;\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n \n     private String bucketName;\n-    @UriParam(defaultValue = \"true\")\n+    @UriParam(label = \"common\", defaultValue = \"true\")\n     private boolean autoCreateBucket = true;\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n     private boolean objectLock;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n+    private String policy;\n+    @UriParam(label = \"common\")\n     private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private ServerSideEncryption serverSideEncryption;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n     @UriParam(label = \"consumer\")\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex ee18fe1d920..4e37e980bcd 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -60,6 +64,10 @@ public class MinioConfiguration implements Cloneable {\n     @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n     @UriParam(label = \"consumer\")\n     private String objectName;\n     @UriParam(label = \"consumer\")\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyOTQyOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460729429", "body": "Please avoid wildcard import", "bodyText": "Please avoid wildcard import", "bodyHTML": "<p dir=\"auto\">Please avoid wildcard import</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:31:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,18 +16,28 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n-\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import io.minio.BucketExistsArgs;\n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n import io.minio.GetObjectArgs;\n import io.minio.ListObjectsArgs;\n+import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n+import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n", "next_change": {"commit": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..df0a7d9d105 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -35,7 +35,6 @@ import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n import io.minio.Result;\n-import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex df0a7d9d105..e98b295b961 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -39,9 +39,11 @@ import io.minio.errors.MinioException;\n import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.CastUtils;\n import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.URISupport;\n", "next_change": {"commit": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex e98b295b961..b3cc1c85157 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -42,6 +42,7 @@ import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.EmptyAsyncCallback;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.CastUtils;\n", "next_change": {"commit": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex b3cc1c85157..f82d5fd3385 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -48,6 +49,7 @@ import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.CastUtils;\n import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.URISupport;\n+import org.apache.commons.compress.utils.IOUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731257", "body": "Should we handle this exception as well?", "bodyText": "Should we handle this exception as well?", "bodyHTML": "<p dir=\"auto\">Should we handle this exception as well?</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:34:15Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODI0Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088247", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().removeObject(removeObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2OTIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464269216", "bodyText": "What I mean here, does it make sense to handle it through  getExceptionHandler().handleException", "author": "omarsmak", "createdAt": "2020-08-03T08:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxNDAyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464614021", "bodyText": "Hi, @omarsmak I was mimicking this line. should I keep this or change it to maybe LOG.warn?", "author": "Nayananga", "createdAt": "2020-08-03T19:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4NjIxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464886215", "bodyText": "@Nayananga my question is about catching Exception e, do you need your consumer to ignore all exceptions (as the case now) or you need your consumer to throw  and halt camel process in case minio client throw any exceptions other than MinioException? My gut feeling, you may just need to remove catch (Exception e) block and only handle MinioException as you are currently doing, by that camel will halt its process in any unexpected process.", "author": "omarsmak", "createdAt": "2020-08-04T08:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNTU3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466215578", "bodyText": "Hi @omarsmak, thank you for your suggestion. I did some changes :)", "author": "Nayananga", "createdAt": "2020-08-06T07:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,88 +307,62 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n+        if (isEmpty(destinationBucketName)) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n \n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n+        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -340,27 +348,30 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 ? getConfiguration().getDestinationObjectName()\n                 : srcObjectName;\n \n-\n         LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n                 srcBucketName, srcObjectName, destinationBucketName);\n \n         CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                copySourceBuilder::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, copySourceBuilder::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, copySourceBuilder::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, copySourceBuilder::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, copySourceBuilder::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag,\n+                copySourceBuilder::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                copySourceBuilder::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                copySourceBuilder::unmodifiedSince);\n \n         CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n                 .source(copySourceBuilder.build())\n                 .bucket(getConfiguration().getDestinationBucketName())\n                 .object(destinationObjectName);\n \n-        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryption, copyObjectRequest::sse);\n \n         getMinioClient().copyObject(copyObjectRequest.build());\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731754", "body": "Same here, should handle this exception as well?", "bodyText": "Same here, should handle this exception as well?", "bodyHTML": "<p dir=\"auto\">Same here, should handle this exception as well?</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:35:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");\n+        }\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) {\n+        String destinationBucketName = getConfiguration().getDestinationBucketName();\n+        if (destinationBucketName == null) {\n+            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n+        }\n+\n+        try {\n+            // set destination object name as source object name, if not specified\n+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                    ? getConfiguration().getDestinationObjectName()\n+                    : srcObjectName;\n+\n+\n+            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+            }\n+            if (getConfiguration().getOffset() != 0) {\n+                copySourceBuilder.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                copySourceBuilder.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                copySourceBuilder.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+            }\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .source(copySourceBuilder.build())\n+                    .bucket(getConfiguration().getDestinationBucketName())\n+                    .object(destinationObjectName);\n+\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n+            }\n+\n+            getMinioClient().copyObject(copyObjectRequest.build());\n+\n+        } catch (Exception e) {\n+            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODM1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088357", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().copyObject(copyObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDUyMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464620523", "bodyText": "I'll remove this error handle since this is redundant", "author": "Nayananga", "createdAt": "2020-08-03T19:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,88 +307,62 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n+        if (isEmpty(destinationBucketName)) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n \n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n+        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -340,27 +348,30 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 ? getConfiguration().getDestinationObjectName()\n                 : srcObjectName;\n \n-\n         LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n                 srcBucketName, srcObjectName, destinationBucketName);\n \n         CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                copySourceBuilder::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, copySourceBuilder::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, copySourceBuilder::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, copySourceBuilder::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, copySourceBuilder::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag,\n+                copySourceBuilder::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                copySourceBuilder::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                copySourceBuilder::unmodifiedSince);\n \n         CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n                 .source(copySourceBuilder.build())\n                 .bucket(getConfiguration().getDestinationBucketName())\n                 .object(destinationObjectName);\n \n-        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryption, copyObjectRequest::sse);\n \n         getMinioClient().copyObject(copyObjectRequest.build());\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MDMyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460740321", "body": "I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to `> 0` instead. Same for the other checks", "bodyText": "I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to > 0 instead. Same for the other checks", "bodyHTML": "<p dir=\"auto\">I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to <code>&gt; 0</code> instead. Same for the other checks</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:49:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,30 +239,14 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -239,14 +242,17 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                getObjectRequest::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, getObjectRequest::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, getObjectRequest::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, getObjectRequest::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, getObjectRequest::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag, getObjectRequest::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                getObjectRequest::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex bfa3be1d631..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -258,20 +246,41 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0Nzk0OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460747948", "body": "Perhaps we can use `isNotEmpty` from `org.apache.camel.util.ObjectHelper` to check for nulls or emptyness", "bodyText": "Perhaps we can use isNotEmpty from org.apache.camel.util.ObjectHelper to check for nulls or emptyness", "bodyHTML": "<p dir=\"auto\">Perhaps we can use <code>isNotEmpty</code> from <code>org.apache.camel.util.ObjectHelper</code> to check for nulls or emptyness</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:01:43Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,30 +239,14 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -239,14 +242,17 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                getObjectRequest::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, getObjectRequest::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, getObjectRequest::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, getObjectRequest::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, getObjectRequest::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag, getObjectRequest::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                getObjectRequest::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex bfa3be1d631..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -258,20 +246,41 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MDQxMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460750413", "body": "I don't see any reason to null the client here, isn't? ", "bodyText": "I don't see any reason to null the client here, isn't?", "bodyHTML": "<p dir=\"auto\">I don't see any reason to null the client here, isn't?</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:06:05Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -109,27 +113,25 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         if (bucketExists(bucketName)) {\n             LOG.trace(\"Bucket {} already exists\", bucketName);\n         } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n+            if (getConfiguration().isAutoCreateBucket()) {\n                 LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n                 makeBucket(bucketName);\n                 LOG.trace(\"Bucket created\");\n+            } else {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+\n             }\n         }\n \n-        if (getConfiguration().getPolicy() != null) {\n+        if (isNotEmpty(getConfiguration().getPolicy())) {\n+            LOG.trace(\"Updating bucket {} with policy {}\", bucketName, configuration.getPolicy());\n             setBucketPolicy(bucketName);\n+            LOG.trace(\"Bucket policy updated\");\n         }\n     }\n \n     @Override\n     public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n         super.doStop();\n     }\n \n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..8e77b779c57 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -139,8 +130,10 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return createExchange(getExchangePattern(), minioObject, objectName);\n     }\n \n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n+    public Exchange createExchange(\n+            ExchangePattern pattern,\n+            InputStream minioObject, String objectName)\n+            throws Exception {\n         LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n \n         Exchange exchange = super.createExchange(pattern);\n", "next_change": {"commit": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 8e77b779c57..5a3a10be9d1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -130,10 +128,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return createExchange(getExchangePattern(), minioObject, objectName);\n     }\n \n-    public Exchange createExchange(\n-            ExchangePattern pattern,\n-            InputStream minioObject, String objectName)\n-            throws Exception {\n+    public Exchange createExchange(ExchangePattern pattern, InputStream minioObject, String objectName) throws Exception {\n         LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n \n         Exchange exchange = super.createExchange(pattern);\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 5a3a10be9d1..bb67186fdc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -124,37 +118,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         super.doStop();\n     }\n \n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern, InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            message.setBody(readInputStream(minioObject));\n-            if (getConfiguration().isAutoCloseBody()) {\n-                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                    @Override\n-                    public void onDone(Exchange exchange) {\n-                        IOHelper.close(minioObject);\n-                    }\n-                });\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n     public MinioConfiguration getConfiguration() {\n         return configuration;\n     }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MTMxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460751316", "body": "please don't print the stack trace here, instead handle the exception.", "bodyText": "please don't print the stack trace here, instead handle the exception.", "bodyHTML": "<p dir=\"auto\">please don't print the stack trace here, instead handle the exception.</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:07:49Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -161,7 +163,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n             } catch (IOException e) {\n                 // TODO Auto-generated catch block\n-                e.printStackTrace();\n+                LOG.warn(\"Error setting message body\");\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -150,20 +140,14 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         getObjectStat(objectName, message);\n \n         if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutoCloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n+            message.setBody(readInputStream(minioObject));\n+            if (getConfiguration().isAutoCloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(minioObject);\n+                    }\n+                });\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c03dbc18109..bb67186fdc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -125,38 +118,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         super.doStop();\n     }\n \n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            message.setBody(readInputStream(minioObject));\n-            if (getConfiguration().isAutoCloseBody()) {\n-                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                    @Override\n-                    public void onDone(Exchange exchange) {\n-                        IOHelper.close(minioObject);\n-                    }\n-                });\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n     public MinioConfiguration getConfiguration() {\n         return configuration;\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NDgyNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460754824", "body": "`versionId` is not used here", "bodyText": "versionId is not used here", "bodyHTML": "<p dir=\"auto\"><code>versionId</code> is not used here</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:14:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -227,25 +234,23 @@ public class MinioProducer extends DefaultProducer {\n             ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n \n             Message message = getMessageForResponse(exchange);\n-            if (copyObjectResult.versionId() != null) {\n+            if (isNotEmpty(copyObjectResult.versionId())) {\n                 message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n             }\n         }\n     }\n \n     private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-        final String sourceKey = determineObjectName(exchange);\n-        final String versionId = determineVersionId(exchange);\n         if (getConfiguration().isPojoRequest()) {\n             RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (payload != null) {\n+            if (isNotEmpty(payload)) {\n                 minioClient.removeObject(payload.build());\n                 Message message = getMessageForResponse(exchange);\n                 message.setBody(true);\n             }\n         } else {\n-\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n             minioClient.removeObject(RemoveObjectArgs.builder()\n                     .bucket(bucketName)\n                     .object(sourceKey).build());\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NjczMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460756730", "body": "`isNotEmpty` as I mentioned earlier would make more sense here", "bodyText": "isNotEmpty as I mentioned earlier would make more sense here", "bodyHTML": "<p dir=\"auto\"><code>isNotEmpty</code> as I mentioned earlier would make more sense here</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:17:20Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -381,32 +385,32 @@ public class MinioProducer extends DefaultProducer {\n         Map<String, String> objectMetadata = new HashMap<>();\n \n         Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (contentLength != null) {\n+        if (isNotEmpty(contentLength)) {\n             objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n         }\n \n         String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (contentType != null) {\n+        if (isNotEmpty(contentType)) {\n             objectMetadata.put(\"Content-Type\", contentType);\n         }\n \n         String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (cacheControl != null) {\n+        if (isNotEmpty(cacheControl)) {\n             objectMetadata.put(\"Cache-Control\", cacheControl);\n         }\n \n         String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (contentDisposition != null) {\n+        if (isNotEmpty(contentDisposition)) {\n             objectMetadata.put(\"Content-Disposition\", contentDisposition);\n         }\n \n         String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (contentEncoding != null) {\n+        if (isNotEmpty(contentEncoding)) {\n             objectMetadata.put(\"Content-Encoding\", contentEncoding);\n         }\n \n         String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (contentMD5 != null) {\n+        if (isNotEmpty(contentMD5)) {\n             objectMetadata.put(\"Content-Md5\", contentMD5);\n         }\n \n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 1e19e06c13b..5ed607a5381 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -418,11 +422,11 @@ public class MinioProducer extends DefaultProducer {\n     }\n \n     /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n+     * Reads the bucket name from the header of the given exchange. If not provided, it's read from the endpoint\n+     * configuration.\n      *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n+     * @param  exchange                 The exchange to read the header from.\n+     * @return                          The bucket name.\n      * @throws IllegalArgumentException if the header could not be determined.\n      */\n     private String determineBucketName(final Exchange exchange) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1Nzg3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460757877", "body": "this check here is not needed. `ObjectHelper.isEmpty(bucketName)` will check if string is empty or null", "bodyText": "this check here is not needed. ObjectHelper.isEmpty(bucketName) will check if string is empty or null", "bodyHTML": "<p dir=\"auto\">this check here is not needed. <code>ObjectHelper.isEmpty(bucketName)</code> will check if string is empty or null</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:19:21Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -424,24 +428,23 @@ public class MinioProducer extends DefaultProducer {\n     private String determineBucketName(final Exchange exchange) {\n         String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n \n-        if (ObjectHelper.isEmpty(bucketName)) {\n-            bucketName = getConfiguration().getBucketName();\n-            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-        }\n-\n-        if (bucketName == null) {\n-            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        if (isEmpty(bucketName)) {\n+            if (isNotEmpty(getConfiguration().getBucketName())) {\n+                bucketName = getConfiguration().getBucketName();\n+                LOG.trace(\"Minio Bucket name header is missing, using default one {}\", bucketName);\n+            } else {\n+                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+            }\n         }\n-\n         return bucketName;\n     }\n \n     private String determineObjectName(final Exchange exchange) {\n         String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (ObjectHelper.isEmpty(objectName)) {\n+        if (isEmpty(objectName)) {\n             objectName = getConfiguration().getKeyName();\n         }\n-        if (objectName == null) {\n+        if (isEmpty(objectName)) {\n             throw new IllegalArgumentException(\"Minio Key header is missing.\");\n         }\n         return objectName;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460759163", "body": "why is it `1024` bits here? Can you please move this into constant and with some comment why you opted for `1024`bits?", "bodyText": "why is it 1024 bits here? Can you please move this into constant and with some comment why you opted for 1024bits?", "bodyHTML": "<p dir=\"auto\">why is it <code>1024</code> bits here? Can you please move this into constant and with some comment why you opted for <code>1024</code>bits?</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:21:29Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineObjectName(final Exchange exchange) {\n+        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+        if (ObjectHelper.isEmpty(objectName)) {\n+            objectName = getConfiguration().getKeyName();\n+        }\n+        if (objectName == null) {\n+            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n+        }\n+        return objectName;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private String determineVersionId(final Exchange exchange) {\n+        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n+        if (versionId == null) {\n+            versionId = getConfiguration().getVersionId();\n+        }\n+\n+        return versionId;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113257", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113295", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -449,25 +452,16 @@ public class MinioProducer extends DefaultProducer {\n \n     private String determineStorageClass(final Exchange exchange) {\n         String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (storageClass == null) {\n+        if (isEmpty(storageClass)) {\n             storageClass = getConfiguration().getStorageClass();\n         }\n \n         return storageClass;\n     }\n \n-    private String determineVersionId(final Exchange exchange) {\n-        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n-        if (versionId == null) {\n-            versionId = getConfiguration().getVersionId();\n-        }\n-\n-        return versionId;\n-    }\n-\n     private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[1024];\n+        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n         int count;\n         while ((count = inputStream.read(bytes)) > 0) {\n             out.write(bytes, 0, count);\n", "next_change": {"commit": "99e08d0237368053b32935bfdb3106b67e7222d4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 1e19e06c13b..b2d11ac703a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -459,28 +481,32 @@ public class MinioProducer extends DefaultProducer {\n         return storageClass;\n     }\n \n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n+    private long determineLengthInputStream(InputStream is) throws IOException {\n+        if (!is.markSupported()) {\n+            return -1;\n         }\n-        return out;\n+        if (is instanceof ByteArrayInputStream) {\n+            return is.available();\n+        }\n+        long size = 0;\n+        try {\n+            is.mark(MinioConstants.BYTE_ARRAY_LENGTH);\n+            int i = is.available();\n+            while (i > 0) {\n+                long skip = is.skip(i);\n+                size += skip;\n+                i = is.available();\n+            }\n+        } finally {\n+            is.reset();\n+        }\n+        return size;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n \n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioProducerToString)) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n     @Override\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NTMwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460765307", "body": "This class name is weird for the client impl. If this the remote client from the factory, something like `MinioRemoteClientImpl` would make more sense", "bodyText": "This class name is weird for the client impl. If this the remote client from the factory, something like MinioRemoteClientImpl would make more sense", "bodyHTML": "<p dir=\"auto\">This class name is weird for the client impl. If this the remote client from the factory, something like <code>MinioRemoteClientImpl</code> would make more sense</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:32:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766063", "body": "I wonder accessKeys, same as region are not required?", "bodyText": "I wonder accessKeys, same as region are not required?", "bodyHTML": "<p dir=\"auto\">I wonder accessKeys, same as region are not required?</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:33:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+    private final MinioConfiguration configuration;\n+\n+    /**\n+     * Constructor that uses the config file.\n+     */\n+    public GetMinioClient(MinioConfiguration configuration) {\n+        LOG.trace(\"Creating an Minio client.\");\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Getting the minio client.\n+     *\n+     * @return Minio Client.\n+     */\n+    @Override\n+    public MinioClient getMinioClient() {\n+        if (configuration.getEndpoint() != null) {\n+            MinioClient.Builder minioClientRequest = MinioClient.builder();\n+\n+            if (configuration.getProxyPort() != null) {\n+                minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n+            } else {\n+                minioClientRequest.endpoint(configuration.getEndpoint());\n+            }\n+            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMDMyMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464100320", "bodyText": "Hi @omarsmak sorry, I didn't get this question?", "author": "Nayananga", "createdAt": "2020-08-02T17:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MDYwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464270607", "bodyText": "What I mean here, are the accessKey, secretKey and region are required in order to initiate the client? What happens if one of these is null or not set?", "author": "omarsmak", "createdAt": "2020-08-03T08:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMzg2NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464623864", "bodyText": "@omarsmak, As per Java Client API Reference you can create MinioClient with or without accessKey, secretKey (namely anonymous access) or region.", "author": "Nayananga", "createdAt": "2020-08-03T19:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNjIwNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466216204", "bodyText": "@omarsmak is it okay to mark this as resolved?", "author": "Nayananga", "createdAt": "2020-08-06T07:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjU1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766557", "body": "Please add more cases for region, secretKey .. etc", "bodyText": "Please add more cases for region, secretKey .. etc", "bodyHTML": "<p dir=\"auto\">Please add more cases for region, secretKey .. etc</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:34:22Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinioComponentConfigurationTest extends CamelTestSupport {\n+\n+    @Test\n+    public void createEndpointWithMinimalConfiguration() throws Exception {\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex a30b0f5a702..18ddc54c8d4 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -28,6 +33,25 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n+        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n+        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n+        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n+\n+    @Test\n+    public void createEndpointWithCredentialsAndClientExistInRegistry() throws Exception {\n+        final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n+\n+        MinioClient client = MinioClient.builder()\n+                .endpoint(properties.getProperty(\"endpoint\"))\n+                .build();\n+        context.getRegistry().bind(\"minioClient\", client);\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint)component.createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n+\n+        assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n+        assertSame(client, endpoint.getConfiguration().getMinioClient());\n+    }\n }\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex 18ddc54c8d4..caf6af39d3e 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -49,7 +50,8 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n                 .build();\n         context.getRegistry().bind(\"minioClient\", client);\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n-        MinioEndpoint endpoint = (MinioEndpoint)component.createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n \n         assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n         assertSame(client, endpoint.getConfiguration().getMinioClient());\n", "next_change": {"commit": "96eb5704825443ea891a04d108771bbcab2890d0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex caf6af39d3e..5ba72edd593 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -56,4 +56,22 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n         assertSame(client, endpoint.getConfiguration().getMinioClient());\n     }\n+\n+    @Test\n+    void createEndpoinWthAutowiredDisabledAndClientExistInRegistry() throws Exception {\n+        final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n+\n+        context.setAutowiredEnabled(false);\n+        MinioClient client = MinioClient.builder()\n+                .endpoint(properties.getProperty(\"endpoint\"))\n+                .build();\n+        context.getRegistry().bind(\"minioClient\", client);\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\n+                        \"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1&endpoint=https://play.min.io\");\n+        context.setAutowiredEnabled(true);\n+        assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n+        assertNull(endpoint.getConfiguration().getMinioClient());\n+    }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3NTgzMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460775832", "body": "These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:\r\n```\r\nprivate void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer<String> fn) {\r\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\r\n            fn.accept(configuration.getMatchETag());\r\n        }\r\n    }\r\n```  \r\nAnd then somewhere in the code:\r\n```\r\ncheckMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);\r\n```", "bodyText": "These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:\nprivate void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer<String> fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n\nAnd then somewhere in the code:\ncheckMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);", "bodyHTML": "<p dir=\"auto\">These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer&lt;String&gt; fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n\"><pre><code>private void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer&lt;String&gt; fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n</code></pre></div>\n<p dir=\"auto\">And then somewhere in the code:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"checkMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);\n\"><pre><code>checkMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);\n</code></pre></div>", "author": "omarsmak", "createdAt": "2020-07-27T09:50:46Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char) c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        minioClient.makeBucket(makeBucketRequest.build());\n+    }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n+    }\n+\n+    private void getObjectStat(String objectName, Message message) throws Exception {\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -248,30 +250,14 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), statObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), statObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), statObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), statObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), statObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), statObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), statObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), statObjectRequest::unmodifiedSince);\n \n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..0f4f069f776 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -250,14 +212,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), statObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), statObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), statObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), statObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), statObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), statObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), statObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), statObjectRequest::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                statObjectRequest::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, statObjectRequest::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, statObjectRequest::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, statObjectRequest::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, statObjectRequest::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag,\n+                statObjectRequest::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                statObjectRequest::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                statObjectRequest::unmodifiedSince);\n \n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n", "next_change": {"commit": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f4f069f776..41ff62fc6f1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -225,22 +245,22 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n                 statObjectRequest::unmodifiedSince);\n \n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+        StatObjectResponse stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.object());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucket());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.headers().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.headers().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.size());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.headers().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.headers().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.headers().get(\"cache-control\"));\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.headers().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.headers().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.headers().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.headers().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463681735", "body": "Not sure about this, might lead to `NullPointerException`s", "bodyText": "Not sure about this, might lead to NullPointerExceptions", "bodyHTML": "<p dir=\"auto\">Not sure about this, might lead to <code>NullPointerException</code>s</p>", "author": "zregvart", "createdAt": "2020-07-31T15:34:12Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NDMzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463684336", "bodyText": "No, this is fine, we are using similar approach for component with Extension for validation like this https://github.com/apache/camel/blob/master/components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Component.java#L35", "author": "oscerd", "createdAt": "2020-07-31T15:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692222", "body": "I would suggest to reformat it like this:\r\n```\r\n    @Override\r\n    protected Result verifyParameters(Map<String, Object> parameters) {\r\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\r\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\r\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\r\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\r\n\r\n        // Validate using the catalog\r\n        super.verifyParametersAgainstCatalog(builder, parameters);\r\n\r\n        return builder.build();\r\n    }\r\n```", "bodyText": "I would suggest to reformat it like this:\n    @Override\n    protected Result verifyParameters(Map<String, Object> parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }", "bodyHTML": "<p dir=\"auto\">I would suggest to reformat it like this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    @Override\n    protected Result verifyParameters(Map&lt;String, Object&gt; parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(&quot;accessKey&quot;, parameters))\n                                             .error(ResultErrorHelper.requiresOption(&quot;secretKey&quot;, parameters))\n                                             .error(ResultErrorHelper.requiresOption(&quot;region&quot;, parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }\n\"><pre><code>    @Override\n    protected Result verifyParameters(Map&lt;String, Object&gt; parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }\n</code></pre></div>", "author": "DenisIstomin", "createdAt": "2020-07-31T15:53:27Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+\n+import io.minio.MinioClient;\n+import io.minio.errors.MinioException;\n+import org.apache.camel.component.extension.verifier.DefaultComponentVerifierExtension;\n+import org.apache.camel.component.extension.verifier.ResultBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n+\n+public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n+\n+    public MinioComponentVerifierExtension() {\n+        this(\"minio\");\n+    }\n+\n+    public MinioComponentVerifierExtension(String scheme) {\n+        super(scheme);\n+    }\n+\n+    // *********************************\n+    // Parameters validation\n+    // *********************************\n+\n+    @Override", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5Mjg0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692845", "bodyText": "And the same below", "author": "DenisIstomin", "createdAt": "2020-07-31T15:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nindex f4bf952a507..cc97d5ecf25 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n", "chunk": "@@ -42,8 +45,10 @@ public class MinioComponentVerifierExtension extends DefaultComponentVerifierExt\n     @Override\n     protected Result verifyParameters(Map<String, Object> parameters) {\n \n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters)).error(ResultErrorHelper.requiresOption(\"region\", parameters));\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n+                .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n \n         // Validate using the catalog\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NDMwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463694308", "body": "This is TODO comment?", "bodyText": "This is TODO comment?", "bodyHTML": "<p dir=\"auto\">This is TODO comment?</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T15:57:10Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -62,7 +66,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String bucketName; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -55,24 +53,16 @@ import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n /**\n  * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:bucketName\",\n         category = {Category.CLOUD, Category.FILE})\n-\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Bucket name\")\n-    @Metadata(required = true)\n-    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n \n     public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NTYwOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463695609", "body": "Looks like it could be simplified:\r\n```\r\nReader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));\r\n```", "bodyText": "Looks like it could be simplified:\nReader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));", "bodyHTML": "<p dir=\"auto\">Looks like it could be simplified:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));\n\"><pre><code>Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));\n</code></pre></div>", "author": "DenisIstomin", "createdAt": "2020-07-31T15:59:40Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -215,7 +217,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n                 textBuilder.append((char) c);\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -189,32 +173,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.minioClient = minioClient;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n-    }\n-\n-    /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n-     */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n-    }\n-\n-    public int getMaxConnections() {\n-        return maxConnections;\n-    }\n-\n-    /**\n-     * Set the maxConnections parameter in the minio client configuration\n-     */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n-    }\n-\n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n", "next_change": {"commit": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c03dbc18109..5a3a10be9d1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -173,6 +171,32 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.minioClient = minioClient;\n     }\n \n+    MinioClient createMinioClient() {\n+        if (isNotEmpty(configuration.getEndpoint())) {\n+            MinioClient.Builder minioClientRequest = MinioClient.builder();\n+\n+            if (isNotEmpty(configuration.getProxyPort())) {\n+                minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(),\n+                        configuration.isSecure());\n+            } else {\n+                minioClientRequest.endpoint(configuration.getEndpoint());\n+            }\n+            if (isNotEmpty(configuration.getAccessKey()) && isNotEmpty(configuration.getSecretKey())) {\n+                minioClientRequest.credentials(configuration.getAccessKey(), configuration.getSecretKey());\n+            }\n+            if (isNotEmpty(configuration.getRegion())) {\n+                minioClientRequest.region(configuration.getRegion());\n+            }\n+            if (isNotEmpty(configuration.getCustomHttpClient())) {\n+                minioClientRequest.httpClient(configuration.getCustomHttpClient());\n+            }\n+            return minioClientRequest.build();\n+\n+        } else {\n+            throw new IllegalArgumentException(\"Endpoint must be specified\");\n+        }\n+    }\n+\n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 5a3a10be9d1..bb67186fdc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -197,7 +160,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private String readInputStream(InputStream minioObject) throws IOException {\n+    String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n             int c;\n", "next_change": {"commit": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex bb67186fdc6..3c01e8b922a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -160,17 +153,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n     private boolean bucketExists(String bucketName) throws Exception {\n         return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5OTg5Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463699896", "body": "Please avoid `star import` usage.", "bodyText": "Please avoid star import usage.", "bodyHTML": "<p dir=\"auto\">Please avoid <code>star import</code> usage.</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T16:08:36Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.Message;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex d449212a70a..3191fd6c874 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,7 +28,10 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n", "next_change": {"commit": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 3191fd6c874..4ae951b2e15 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -29,6 +29,7 @@ import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 4ae951b2e15..86ddc683415 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,12 +28,11 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-\n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n \n", "next_change": {"commit": "c40364a59815239e63d959faa982cb5212a217a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/localTests/MinioComponentIntegrationTest.java\nsimilarity index 86%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/localTests/MinioComponentIntegrationTest.java\nindex 86ddc683415..88da95ca254 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/localTests/MinioComponentIntegrationTest.java\n", "chunk": "@@ -33,8 +31,7 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioComponentIntegrationTest extends CamelTestSupport {\n+class MinioComponentIntegrationTest extends MinioTestContainerSupport {\n \n     @EndpointInject(\"direct:start\")\n     private ProducerTemplate template;\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700750", "body": "It would be nice to extract all credentials into `.properties` file", "bodyText": "It would be nice to extract all credentials into .properties file", "bodyHTML": "<p dir=\"auto\">It would be nice to extract all credentials into <code>.properties</code> file</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:19Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMjAxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464112015", "bodyText": "Hi @DenisIstomin, How can I do that?", "author": "Nayananga", "createdAt": "2020-08-02T19:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MjE5NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464272194", "bodyText": "An example here", "author": "omarsmak", "createdAt": "2020-08-03T08:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzNzgyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466837828", "bodyText": "@omarsmak, @DenisIstomin I have put minio_key.properties file in test/resources file along with the log4j2.properties file,\nendpoint=https://play.min.io\naccessKey=Q3AM3UQ867SPQQA43P2F\nsecretKey=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\nregion=us-west-1\n\nbut then it throws this error java.lang.Exception: Make sure to supply minio endpoint and credentials as throws in this line. Any suggestions?", "author": "Nayananga", "createdAt": "2020-08-07T06:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MDE4Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466840183", "bodyText": "Hi this problem solved", "author": "Nayananga", "createdAt": "2020-08-07T06:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..4884ebd3455 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -29,12 +31,13 @@ import org.junit.jupiter.api.Test;\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n \n     @BindToRegistry(\"minioClient\")\n     MinioClient client = MinioClient.builder()\n-            .endpoint(\"https://play.min.io\")\n-            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-            .region(\"us-west-1\")\n+            .endpoint(properties.getProperty(\"endpoint\"))\n+            .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n+            .region(properties.getProperty(\"region\"))\n             .build();\n \n     @EndpointInject\n", "next_change": {"commit": "c40364a59815239e63d959faa982cb5212a217a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioConsumerIntegrationTest.java\nsimilarity index 84%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioConsumerIntegrationTest.java\nindex 4884ebd3455..f09ba432466 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -46,11 +45,11 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n     @EndpointInject(\"mock:result\")\n     private MockEndpoint result;\n \n-    public MinioConsumerIntegrationTest() throws Exception {\n+    MinioConsumerIntegrationTest() throws Exception {\n     }\n \n     @Test\n-    public void sendIn() throws Exception {\n+    void sendIn() throws Exception {\n         result.expectedMessageCount(3);\n \n         template.send(\"direct:putObject\", exchange -> {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDk4Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700982", "body": "Please resolve this TODO", "bodyText": "Please resolve this TODO", "bodyHTML": "<p dir=\"auto\">Please resolve this TODO</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:47Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                // TODO: Check why this is not working", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..3843b62940a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -72,10 +78,8 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n             public void configure() {\n                 String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n-                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n-\n-                // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint);\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).to(\"mock:result\");\n \n             }\n         };\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3843b62940a..366e26d3993 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -79,7 +79,8 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n                 String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint);\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).to(\"mock:result\");\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\")\n+                        .startupOrder(2).to(\"mock:result\");\n \n             }\n         };\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3ODgwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463978808", "body": "```suggestion\r\n    private boolean autoCloseBody = true;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean autocloseBody = true;\n          \n          \n            \n                private boolean autoCloseBody = true;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">autocloseBody</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">autoCloseBody</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "dmvolod", "createdAt": "2020-08-01T16:41:18Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam\n+    private String region;\n+\n+    @UriParam\n+    private OkHttpClient customHttpClient;\n+\n+    private String bucketName;\n+    @UriParam(defaultValue = \"true\")\n+    private boolean autoCreateBucket = true;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean objectLock;\n+\n+    @UriParam\n+    private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n+    @UriParam\n+    private ServerSideEncryption serverSideEncryption;\n+\n+    @UriParam\n+    private MinioClient minioClient;\n+\n+    @UriParam(label = \"consumer\")\n+    private String objectName;\n+    @UriParam(label = \"consumer\")\n+    private String delimiter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeUserMetadata;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeVersions;\n+    @UriParam(label = \"consumer\")\n+    private String prefix;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean recursive;\n+    @UriParam(label = \"consumer\")\n+    private String startAfter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean useVersion1;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeFolders;\n+    @UriParam(label = \"consumer\")\n+    private long offset;\n+    @UriParam(label = \"consumer\")\n+    private long length;\n+    @UriParam(label = \"consumer\")\n+    private String matchETag;\n+    @UriParam(label = \"consumer\")\n+    private String notMatchETag;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime modifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime unModifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private String destinationBucketName;\n+    @UriParam(label = \"consumer\")\n+    private String destinationObjectName;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean deleteAfterRead = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean includeBody = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean autocloseBody = true;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..ee18fe1d920 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -99,30 +100,23 @@ public class MinioConfiguration implements Cloneable {\n     private boolean deleteAfterRead = true;\n     @UriParam(label = \"consumer\", defaultValue = \"false\")\n     private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean bypassGovernanceMode;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n     private boolean includeBody = true;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autocloseBody = true;\n+    private boolean autoCloseBody = true;\n \n     @UriParam(label = \"producer\")\n     private String keyName;\n     @UriParam(label = \"producer\")\n     private boolean deleteAfterWrite;\n-    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n-    private long partSize = 25 * 1024 * 1024;\n-    @UriParam\n-    private String policy;\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n     private MinioOperations operation;\n-\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"producer\", defaultValue = \"false\")\n     private boolean pojoRequest;\n-    private String versionId;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean bypassGovernanceMode;\n-\n \n     public String getEndpoint() {\n         return endpoint;\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex ee18fe1d920..364dc5f30c3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -113,7 +121,8 @@ public class MinioConfiguration implements Cloneable {\n     private boolean deleteAfterWrite;\n     @UriParam(label = \"producer\")\n     private String storageClass;\n-    @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n+    @UriParam(label = \"producer\",\n+              enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n     private MinioOperations operation;\n     @UriParam(label = \"producer\", defaultValue = \"false\")\n     private boolean pojoRequest;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980253", "body": "I saw this implementation in large number of components, developed by @omarsmak, @oscerd and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.\r\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.", "bodyText": "I saw this implementation in large number of components, developed by @omarsmak, @oscerd and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.", "bodyHTML": "<p dir=\"auto\">I saw this implementation in large number of components, developed by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/omarsmak/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/omarsmak\">@omarsmak</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/oscerd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/oscerd\">@oscerd</a> and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.<br>\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.</p>", "author": "dmvolod", "createdAt": "2020-08-01T16:58:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);\n+    }\n+\n+    public MinioComponent(CamelContext context) {\n+        super(context);\n+        registerExtension(new MinioComponentVerifierExtension());\n+\n+    }\n+\n+    @Override\n+    protected MinioEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n+        if (remaining == null || remaining.trim().length() == 0) {\n+            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n+        }\n+\n+        final MinioConfiguration configuration = this.configuration != null ? this.configuration.copy() : new MinioConfiguration();\n+        configuration.setBucketName(remaining);\n+        MinioEndpoint endpoint = new MinioEndpoint(uri, this, configuration);\n+        setProperties(endpoint, parameters);\n+        checkAndSetRegistryClient(configuration, endpoint);\n+\n+        return endpoint;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    /**\n+     * The component configuration\n+     */\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n+            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n+            if (clients.size() == 1) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MTMyNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463981326", "bodyText": "I introduced the autoDisvoverCliebt for this situation in 3.5.0. in case it is false, that method won't be called", "author": "oscerd", "createdAt": "2020-08-01T17:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4MDc2Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464280762", "bodyText": "@dmvolod yes, I agree, this error message could be misleading, I think error message could be changed if there are two cases, one for more than one MinioClient instance and other one for in case there is no instance of MinioClient.", "author": "omarsmak", "createdAt": "2020-08-03T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NDY1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r467484654", "bodyText": "Hi all,\nif (clients.size() > 1) {\n                LOG.debug(\"Found more than one MinioClient instance in the registry, getting the first one...\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else if (clients.size() == 1) {\n                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else {\n                LOG.debug(\"No MinioClient instance in the registry\");\n            }\n\nis this approach okay?", "author": "Nayananga", "createdAt": "2020-08-08T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..2c7c096201d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -76,10 +78,12 @@ public class MinioComponent extends DefaultComponent {\n     }\n \n     private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n             LOG.debug(\"Looking for an MinioClient instance in the registry\");\n             Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() == 1) {\n+            if (clients.size() > 1) {\n+                LOG.debug(\"Found more than one MinioClient instance in the registry\");\n+            } else if (clients.size() == 1) {\n                 LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                 configuration.setMinioClient(clients.stream().findFirst().get());\n             } else {\n", "next_change": {"commit": "96eb5704825443ea891a04d108771bbcab2890d0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 2c7c096201d..a87608b6eb0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -76,21 +70,4 @@ public class MinioComponent extends DefaultComponent {\n     public void setConfiguration(MinioConfiguration configuration) {\n         this.configuration = configuration;\n     }\n-\n-    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n-            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n-            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() > 1) {\n-                LOG.debug(\"Found more than one MinioClient instance in the registry\");\n-            } else if (clients.size() == 1) {\n-                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n-                configuration.setMinioClient(clients.stream().findFirst().get());\n-            } else {\n-                LOG.debug(\"No MinioClient instance in the registry\");\n-            }\n-        } else {\n-            LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n-        }\n-    }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDUyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980528", "body": "@Nayananga a little bit confusing about key name and key value. The same as for `LENGTH`", "bodyText": "@Nayananga a little bit confusing about key name and key value. The same as for LENGTH", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Nayananga/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Nayananga\">@Nayananga</a> a little bit confusing about key name and key value. The same as for <code>LENGTH</code></p>", "author": "dmvolod", "createdAt": "2020-08-01T17:01:42Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+/**\n+ * Constants used in Camel Minio module\n+ */\n+public interface MinioConstants {\n+\n+    String BUCKET_NAME = \"CamelMinioBucketName\";\n+    String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n+    String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    String CONTENT_TYPE = \"CamelMinioContentType\";\n+    String E_TAG = \"CamelMinioETag\";\n+    String OBJECT_NAME = \"CamelMinioObjectName\";\n+    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n+    String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    String VERSION_ID = \"CamelMinioVersionId\";\n+    String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    String MINIO_OPERATION = \"CamelMinioOperation\";\n+    String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    String OFFSET = \"CamelMinioRangeStart\";", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex ddc90808d2d..a9e16731984 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -40,6 +41,6 @@ public interface MinioConstants {\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioRangeStart\";\n-    String LENGTH = \"CamelMinioRangeEnd\";\n+    String OFFSET = \"CamelMinioOffset\";\n+    String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": {"commit": "73b5e0f88924fa999e85896fd610097324e83ff7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex a9e16731984..545d17d2239 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -16,31 +16,104 @@\n  */\n package org.apache.camel.component.minio;\n \n+import org.apache.camel.spi.Metadata;\n+\n /**\n  * Constants used in Camel Minio module\n  */\n public interface MinioConstants {\n \n     int BYTE_ARRAY_LENGTH = 1024;\n+    @Metadata(description = \"*Producer:* The bucket Name which this object will be stored or which will be used for the current operation. \"\n+                            +\n+                            \"*Consumer:* The name of the bucket in which this object is contained.\",\n+              javaType = \"String\")\n     String BUCKET_NAME = \"CamelMinioBucketName\";\n+    @Metadata(label = \"producer\", description = \"The bucket Destination Name which will be used for the current operation.\",\n+              javaType = \"String\")\n     String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n+    @Metadata(description = \"*Producer:* The content control of this object. \" +\n+                            \"*Consumer:* The *optional* Cache-Control HTTP header which allows the user to\\n\" +\n+                            \"specify caching behavior along the HTTP request/reply chain.\",\n+              javaType = \"String\")\n     String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    @Metadata(description = \"*Producer:* The content disposition of this object. \" +\n+                            \"*Consumer:* The *optional* Content-Disposition HTTP header, which specifies\\n\" +\n+                            \"presentational information such as the recommended filename for the\\n\" +\n+                            \"object to be saved as.\",\n+              javaType = \"String\")\n     String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    @Metadata(description = \"*Producer:* The content encoding of this object. \" +\n+                            \"*Consumer:* The *optional* Content-Encoding HTTP header specifying what content\\n\" +\n+                            \"encodings have been applied to the object and what decoding mechanisms\\n\" +\n+                            \"must be applied in order to obtain the media-type referenced by the\\n\" +\n+                            \"Content-Type field.\",\n+              javaType = \"String\")\n     String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    @Metadata(description = \"*Producer:* The content length of this object. \" +\n+                            \"*Consumer:* The Content-Length HTTP header indicating the size of the associated\\n\" +\n+                            \"object in bytes.\",\n+              javaType = \"Long\")\n     String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    @Metadata(description = \"*Producer:* The md5 checksum of this object. \" +\n+                            \"*Consumer:* The base64 encoded 128-bit MD5 digest of the associated object (content\\n\" +\n+                            \"- not including headers) according to RFC 1864. This data is used as a\\n\" +\n+                            \"message integrity check to verify that the data received by Minio is\\n\" +\n+                            \"the same data that the caller sent.\",\n+              javaType = \"String\")\n     String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    @Metadata(description = \"*Producer:* The content type of this object. \" +\n+                            \"*Consumer:* The Content-Type HTTP header, which indicates the type of content stored\\n\" +\n+                            \"in the associated object. The value of this header is a standard MIME\\n\" +\n+                            \"type.\",\n+              javaType = \"String\")\n     String CONTENT_TYPE = \"CamelMinioContentType\";\n+    @Metadata(description = \"*Producer:* The ETag value for the newly uploaded object. \" +\n+                            \"*Consumer:* The hex encoded 128-bit MD5 digest of the associated object according to\\n\" +\n+                            \"RFC 1864. This data is used as an integrity check to verify that the\\n\" +\n+                            \"data received by the caller is the same data that was sent by Minio\",\n+              javaType = \"String\")\n     String E_TAG = \"CamelMinioETag\";\n+    @Metadata(description = \"*Producer:* The key under which this object will be stored or which will be used for the current operation. \"\n+                            +\n+                            \"*Consumer:* The key under which this object is stored.\",\n+              javaType = \"String\")\n     String OBJECT_NAME = \"CamelMinioObjectName\";\n+    @Metadata(label = \"producer\", description = \"The Destination key which will be used for the current operation.\",\n+              javaType = \"String\")\n     String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n+    @Metadata(description = \"*Producer:* The last modified timestamp of this object. \" +\n+                            \"*Consumer:* The value of the Last-Modified header, indicating the date and time at\\n\" +\n+                            \"which Minio last recorded a modification to the associated object.\",\n+              javaType = \"java.util.Date\")\n     String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    @Metadata(label = \"producer\", description = \"The storage class of this object.\", javaType = \"String\")\n     String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    @Metadata(description = \"*Producer:* The version Id of the object to be stored or returned from the current operation. \" +\n+                            \"*Consumer:* The version ID of the associated Minio object if available. Version\\n\" +\n+                            \"IDs are only assigned to objects when an object is uploaded to an Minio bucket that has object versioning enabled.\",\n+              javaType = \"String\")\n     String VERSION_ID = \"CamelMinioVersionId\";\n+    @Metadata(label = \"producer\", description = \"The canned acl that will be applied to the object. see\\n\" +\n+                                                \"`com.amazonaws.services.s3.model.CannedAccessControlList` for allowed\\n\" +\n+                                                \"values.\",\n+              javaType = \"String\")\n     String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    @Metadata(label = \"producer\", description = \"The operation to perform.\",\n+              javaType = \"org.apache.camel.component.minio.MinioOperations\")\n     String MINIO_OPERATION = \"CamelMinioOperation\";\n+    @Metadata(description = \"*Producer:* Sets the server-side encryption algorithm when encrypting\\n\" +\n+                            \"the object using Minio-managed keys. For example use AES256. \" +\n+                            \"*Consumer:* The server-side encryption algorithm when encrypting the\\n\" +\n+                            \"object using Minio-managed keys.\",\n+              javaType = \"String\")\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    @Metadata(description = \"The expiration time\", javaType = \"String\")\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    @Metadata(description = \"The replication status\", javaType = \"String\")\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    @Metadata(label = \"producer\", description = \"The offset\", javaType = \"String\")\n     String OFFSET = \"CamelMinioOffset\";\n+    @Metadata(label = \"producer\", description = \"The length\", javaType = \"String\")\n     String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NTY5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464275690", "body": "@Nayananga a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the `@Disabled`. An example, take a look at this [component IT tests](https://github.com/apache/camel/tree/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob). You will need to add a maven profile that will run IT tests that end with IT [here](https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/pom.xml#L87). And then, you can add a [Util class](https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/BlobTestUtils.java#L40) to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:\r\n`mvn clean test -PfullTests` ", "bodyText": "@Nayananga a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the @Disabled. An example, take a look at this component IT tests. You will need to add a maven profile that will run IT tests that end with IT here. And then, you can add a Util class to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:\nmvn clean test -PfullTests", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Nayananga/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Nayananga\">@Nayananga</a> a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the <code>@Disabled</code>. An example, take a look at this <a href=\"https://github.com/apache/camel/tree/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob\">component IT tests</a>. You will need to add a maven profile that will run IT tests that end with IT <a href=\"https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/pom.xml#L87\">here</a>. And then, you can add a <a href=\"https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/BlobTestUtils.java#L40\">Util class</a> to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:<br>\n<code>mvn clean test -PfullTests</code></p>", "author": "omarsmak", "createdAt": "2020-08-03T08:45:16Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.UUID;\n+\n+import javax.crypto.KeyGenerator;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.PutObjectArgs;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.minio.MinioOperations;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 9593d44cb13..7fec2fc9332 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -49,13 +55,15 @@ import static org.junit.jupiter.api.Assertions.fail;\n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n \n+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n     final ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n     String key = UUID.randomUUID().toString();\n+\n     @BindToRegistry(\"minioClient\")\n     MinioClient minioClient =\n             MinioClient.builder()\n-                    .endpoint(\"https://play.min.io\")\n-                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+                    .endpoint(properties.getProperty(\"endpoint\"))\n+                    .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n                     .build();\n     @EndpointInject\n     private ProducerTemplate template;\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 7fec2fc9332..226927fb7e2 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -60,11 +60,10 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n     String key = UUID.randomUUID().toString();\n \n     @BindToRegistry(\"minioClient\")\n-    MinioClient minioClient =\n-            MinioClient.builder()\n-                    .endpoint(properties.getProperty(\"endpoint\"))\n-                    .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n-                    .build();\n+    MinioClient minioClient = MinioClient.builder()\n+            .endpoint(properties.getProperty(\"endpoint\"))\n+            .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n+            .build();\n     @EndpointInject\n     private ProducerTemplate template;\n \n", "next_change": {"commit": "c40364a59815239e63d959faa982cb5212a217a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nsimilarity index 93%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 226927fb7e2..aa75e775901 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -64,17 +63,18 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n             .endpoint(properties.getProperty(\"endpoint\"))\n             .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n             .build();\n+\n     @EndpointInject\n     private ProducerTemplate template;\n \n     @EndpointInject(\"mock:result\")\n     private MockEndpoint result;\n \n-    public MinioCopyObjectCustomerKeyOperationIntegrationTest() throws IOException {\n+    MinioCopyObjectCustomerKeyOperationIntegrationTest() throws IOException {\n     }\n \n     @Test\n-    public void sendIn() throws Exception {\n+    void sendIn() throws Exception {\n \n         result.expectedMessageCount(1);\n \n", "next_change": null}]}}]}}]}}, {"oid": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "url": "https://github.com/apache/camel/commit/fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-03T18:42:35Z", "type": "forcePushed"}, {"oid": "c0038995d0dd7129eade273ff2039a79e00d49f6", "url": "https://github.com/apache/camel/commit/c0038995d0dd7129eade273ff2039a79e00d49f6", "message": "Code simplified", "committedDate": "2020-08-06T07:48:09Z", "type": "forcePushed"}, {"oid": "d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "url": "https://github.com/apache/camel/commit/d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-06T18:25:17Z", "type": "forcePushed"}, {"oid": "0e860b49082c2ce8ae735e48cfb746850711f22e", "url": "https://github.com/apache/camel/commit/0e860b49082c2ce8ae735e48cfb746850711f22e", "message": "Removed redundant check", "committedDate": "2020-08-07T05:02:20Z", "type": "forcePushed"}, {"oid": "1535a16a62132c3be469a43230d0507eba76063c", "url": "https://github.com/apache/camel/commit/1535a16a62132c3be469a43230d0507eba76063c", "message": "Added component basic sketch", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "228df3f1623107af49b9755bf053b063e3375dda", "url": "https://github.com/apache/camel/commit/228df3f1623107af49b9755bf053b063e3375dda", "message": "Ran mvn clean install -Pfastinstall", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "0fd206c77f5d3fa320bad1cd34683710c229b2cf", "url": "https://github.com/apache/camel/commit/0fd206c77f5d3fa320bad1cd34683710c229b2cf", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "url": "https://github.com/apache/camel/commit/90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "message": "Added existing implementation and fixed build failures", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1e66a510a172e04b1bbeece7e1a5d330944daf14", "url": "https://github.com/apache/camel/commit/1e66a510a172e04b1bbeece7e1a5d330944daf14", "message": "Code reformatted", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "c6a9b5ac3b4d5a128c045495008174d905492576", "url": "https://github.com/apache/camel/commit/c6a9b5ac3b4d5a128c045495008174d905492576", "message": "Updated imports", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "cfce4fb8f46ec8057652ad366b47bbc93da82849", "url": "https://github.com/apache/camel/commit/cfce4fb8f46ec8057652ad366b47bbc93da82849", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "url": "https://github.com/apache/camel/commit/1328d8106703a3d90d671d8d32c5eaa7419fa147", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "843335696c2da037e026ad7cc0318cf36494b183", "url": "https://github.com/apache/camel/commit/843335696c2da037e026ad7cc0318cf36494b183", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "2de2427460630152d5be00c6c33bad22c015f2cd", "url": "https://github.com/apache/camel/commit/2de2427460630152d5be00c6c33bad22c015f2cd", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "url": "https://github.com/apache/camel/commit/bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "152fd8b381686621d3de6a6300323fe89f42720b", "url": "https://github.com/apache/camel/commit/152fd8b381686621d3de6a6300323fe89f42720b", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "url": "https://github.com/apache/camel/commit/cce1852e6ad88c7c3a35134e8b0771f3a216e754", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "0acedfcedaaf81796626b5f205f187b1262137ec", "url": "https://github.com/apache/camel/commit/0acedfcedaaf81796626b5f205f187b1262137ec", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "url": "https://github.com/apache/camel/commit/acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "message": "Added new implementations for MinioProducer", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "url": "https://github.com/apache/camel/commit/45beb5ddeaad938003b700bcf4f34b1da4105be3", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "url": "https://github.com/apache/camel/commit/c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "message": "Updated to Minio 7.1.0", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "6972439ee57658ed13ff58c89df749dfafbfa18b", "url": "https://github.com/apache/camel/commit/6972439ee57658ed13ff58c89df749dfafbfa18b", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "f4aea6f0902b2108a296a183973813785969618b", "url": "https://github.com/apache/camel/commit/f4aea6f0902b2108a296a183973813785969618b", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "url": "https://github.com/apache/camel/commit/9dd0f1297a490222db92d0e8aee5919403fdcda7", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "3e2463ac08dfe95e015a7c22394bba783110e159", "url": "https://github.com/apache/camel/commit/3e2463ac08dfe95e015a7c22394bba783110e159", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "217cea4fdb007779cfeaa3f709c8b5111de0ec22", "url": "https://github.com/apache/camel/commit/217cea4fdb007779cfeaa3f709c8b5111de0ec22", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "a118ffe604943fd210497c88aaf14265888eceb8", "url": "https://github.com/apache/camel/commit/a118ffe604943fd210497c88aaf14265888eceb8", "message": "ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "f2e79fda016b69999310571208bcda56d08251a4", "url": "https://github.com/apache/camel/commit/f2e79fda016b69999310571208bcda56d08251a4", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "08f2029caf83805ec099e160924b48da294350d8", "url": "https://github.com/apache/camel/commit/08f2029caf83805ec099e160924b48da294350d8", "message": "Integration test fixed", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "url": "https://github.com/apache/camel/commit/dbe1b9d6a59d2d844b774b48c576d31519b8239e", "message": "Updated code to mimic the AWS2 s3 component", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "5e215f54a6df69b8da845a48ab9966c6f5afdef8", "url": "https://github.com/apache/camel/commit/5e215f54a6df69b8da845a48ab9966c6f5afdef8", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "0c39393a1c2b10699825ca6286d2d5f3c0062dab", "url": "https://github.com/apache/camel/commit/0c39393a1c2b10699825ca6286d2d5f3c0062dab", "message": "Ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "url": "https://github.com/apache/camel/commit/bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "url": "https://github.com/apache/camel/commit/c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "url": "https://github.com/apache/camel/commit/6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "message": "Added documentation", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "url": "https://github.com/apache/camel/commit/166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "message": "Minor changes to the tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "429db9080e37920a959ef6837141e7ed94357f9d", "url": "https://github.com/apache/camel/commit/429db9080e37920a959ef6837141e7ed94357f9d", "message": "Fixed typo", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "585e4deebddd6999431c35a3b5a8f3ce72f1f974", "url": "https://github.com/apache/camel/commit/585e4deebddd6999431c35a3b5a8f3ce72f1f974", "message": "Added missing labels", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "d09d6135cbb90dde34b080b393621fa69c16777d", "url": "https://github.com/apache/camel/commit/d09d6135cbb90dde34b080b393621fa69c16777d", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c627c28ed07400606c1f31ef1a6a6e0ce975da10", "url": "https://github.com/apache/camel/commit/c627c28ed07400606c1f31ef1a6a6e0ce975da10", "message": "Removed wildcard imports", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "e01c571ced63b6f85456cb419085ad2a5db9df3d", "url": "https://github.com/apache/camel/commit/e01c571ced63b6f85456cb419085ad2a5db9df3d", "message": "Removed redundant error handling and extracted removeObject method in MinioConsumer.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "652ceb5290bc403dfa12cc3dfc27447163f07e20", "url": "https://github.com/apache/camel/commit/652ceb5290bc403dfa12cc3dfc27447163f07e20", "message": "Renamed GetMinioClient.java to MinioRemoteClientImpl.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5a8af2544004b9d92e26d5db558932c2bb446f4f", "url": "https://github.com/apache/camel/commit/5a8af2544004b9d92e26d5db558932c2bb446f4f", "message": "Renamed Offset and Length in MinioConstants.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "170ea27658ce31d585e0df8cddc599d6e2e63d74", "url": "https://github.com/apache/camel/commit/170ea27658ce31d585e0df8cddc599d6e2e63d74", "message": "Added more cases in MinioComponentConfigurationTest.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5c97f24959e7766acbc0e8159512233954d0ecbb", "url": "https://github.com/apache/camel/commit/5c97f24959e7766acbc0e8159512233954d0ecbb", "message": "Added new MinioConstant", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "1f08aa281662d69aecfdbad038df3b1d8add228b", "url": "https://github.com/apache/camel/commit/1f08aa281662d69aecfdbad038df3b1d8add228b", "message": "Replaced != 0 with > 0", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "fa241fb3e2068636d81e3e918a63414639c06eec", "url": "https://github.com/apache/camel/commit/fa241fb3e2068636d81e3e918a63414639c06eec", "message": "Handled processCommit exception", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "url": "https://github.com/apache/camel/commit/27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "message": "Handled createExchange exceptions", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "url": "https://github.com/apache/camel/commit/73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "message": "Reformatted code", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "7136941423266b6a21f290a250e1e0017e439219", "url": "https://github.com/apache/camel/commit/7136941423266b6a21f290a250e1e0017e439219", "message": "Code simplified", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "url": "https://github.com/apache/camel/commit/2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "url": "https://github.com/apache/camel/commit/56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "message": "Renamed autocloseBody to autoCloseBody in MinioConfiguration.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "409614e6426f1393c9c465c7dae4ff670902b2d2", "url": "https://github.com/apache/camel/commit/409614e6426f1393c9c465c7dae4ff670902b2d2", "message": "Minor fix", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "url": "https://github.com/apache/camel/commit/c308169b9ee19d93399a599b1a4df08e7816b5fd", "message": "Replaced == null / != null with isEmpty / isNotEmpty", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "url": "https://github.com/apache/camel/commit/c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "message": "Removed redundant check", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "b08f49d96a2ce88cc46a80decd169986249b5779", "url": "https://github.com/apache/camel/commit/b08f49d96a2ce88cc46a80decd169986249b5779", "message": "Extracted all credentials into minio_key.properties file", "committedDate": "2020-08-08T16:44:10Z", "type": "commit"}]}