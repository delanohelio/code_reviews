{"pr_number": 3897, "pr_title": "CAMEL-13934 camel-minio - Component to store/load files from blob store", "pr_author": "Nayananga", "pr_createdAt": "2020-06-07T21:45:18Z", "pr_url": "https://github.com/apache/camel/pull/3897", "merge_commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "timeline": [{"oid": "18ec4f679abc44faac6792ddc5a619a880e05e93", "url": "https://github.com/apache/camel/commit/18ec4f679abc44faac6792ddc5a619a880e05e93", "message": "Replaced redundant checks with centralized lambdas", "committedDate": "2020-08-08T16:44:10Z", "type": "forcePushed"}, {"oid": "4e7587acde63bffaa8966d15689af206cb9577d9", "url": "https://github.com/apache/camel/commit/4e7587acde63bffaa8966d15689af206cb9577d9", "message": "Changed the error message in checkAndSetRegistryClient in MinioComponent.java", "committedDate": "2020-08-08T17:17:25Z", "type": "commit"}, {"oid": "9f619c84b46945598c63f1d7ad04cdefa1329d39", "url": "https://github.com/apache/camel/commit/9f619c84b46945598c63f1d7ad04cdefa1329d39", "message": "Fixed article issues in minio-component.adoc and unused parameter", "committedDate": "2020-08-08T17:46:46Z", "type": "commit"}, {"oid": "5ce02877a27e4c44242760f1bd7af412bd220664", "url": "https://github.com/apache/camel/commit/5ce02877a27e4c44242760f1bd7af412bd220664", "message": "Mimicked aws2-s3 component, ran mvn clean install -DskipTests", "committedDate": "2020-08-09T03:36:30Z", "type": "commit"}, {"oid": "ae457d0c7b0907f3ede8722baf1eec49803d60d4", "url": "https://github.com/apache/camel/commit/ae457d0c7b0907f3ede8722baf1eec49803d60d4", "message": "Minor fixes", "committedDate": "2020-08-09T06:27:38Z", "type": "commit"}, {"oid": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "url": "https://github.com/apache/camel/commit/7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "message": "Resolved a TODO", "committedDate": "2020-08-09T16:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470795", "body": "This class can be removed.", "bodyText": "This class can be removed.", "bodyHTML": "<p dir=\"auto\">This class can be removed.</p>", "author": "oscerd", "createdAt": "2020-06-08T05:56:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n+ * this component can consume from.\n+ */\n+public class EventBusHelper {", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjQzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437672436", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\ndeleted file mode 100644\nindex 6f82b1d075c..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Consumer;\n-\n-/**\n- * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n- * this component can consume from.\n- */\n-public class EventBusHelper {\n-\n-    // TODO: Delete me when you implementy your custom component\n-\n-    private static EventBusHelper INSTANCE;\n-\n-    final private Set<Consumer> subscribers = ConcurrentHashMap.newKeySet();\n-\n-    private EventBusHelper() {\n-    }\n-\n-    public static EventBusHelper getInstance(){\n-        if (INSTANCE == null) {\n-            INSTANCE = new EventBusHelper();\n-        }\n-\n-        return INSTANCE;\n-    }\n-\n-    public <T> void subscribe(final Consumer<T> subscriber) {\n-        subscribers.add(subscriber);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> void publish(final T event){\n-        // Notify all subscribers\n-        subscribers.forEach(consumer -> publishSingleEvent(event, consumer));\n-    }\n-\n-    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber){\n-        subscriber.accept(event);\n-    }\n-\n-}\n\\ No newline at end of file\n", "next_change": {"commit": "ece2cb7569d380486b4a0187ac97b3fac0574bbd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\nnew file mode 100644\nindex 00000000000..6f82b1d075c\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n", "chunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n+ * this component can consume from.\n+ */\n+public class EventBusHelper {\n+\n+    // TODO: Delete me when you implementy your custom component\n+\n+    private static EventBusHelper INSTANCE;\n+\n+    final private Set<Consumer> subscribers = ConcurrentHashMap.newKeySet();\n+\n+    private EventBusHelper() {\n+    }\n+\n+    public static EventBusHelper getInstance(){\n+        if (INSTANCE == null) {\n+            INSTANCE = new EventBusHelper();\n+        }\n+\n+        return INSTANCE;\n+    }\n+\n+    public <T> void subscribe(final Consumer<T> subscriber) {\n+        subscribers.add(subscriber);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> void publish(final T event){\n+        // Notify all subscribers\n+        subscribers.forEach(consumer -> publishSingleEvent(event, consumer));\n+    }\n+\n+    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber){\n+        subscriber.accept(event);\n+    }\n+\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\nindex 6f82b1d075c..1b6a8a58d2a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n", "chunk": "@@ -49,12 +49,12 @@ public class EventBusHelper {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public <T> void publish(final T event){\n+    public <T> void publish(final T event) {\n         // Notify all subscribers\n         subscribers.forEach(consumer -> publishSingleEvent(event, consumer));\n     }\n \n-    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber){\n+    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber) {\n         subscriber.accept(event);\n     }\n \n", "next_change": {"commit": "c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\ndeleted file mode 100644\nindex 1b6a8a58d2a..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Consumer;\n-\n-/**\n- * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n- * this component can consume from.\n- */\n-final class EventBusHelper {\n-\n-    // TODO: Delete me when you implementy your custom component\n-\n-    private static EventBusHelper instance;\n-\n-    final Set<Consumer> subscribers = ConcurrentHashMap.newKeySet();\n-\n-    private EventBusHelper() {\n-    }\n-\n-    public static EventBusHelper getInstance() {\n-        if (instance == null) {\n-            instance = new EventBusHelper();\n-        }\n-\n-        return instance;\n-    }\n-\n-    public <T> void subscribe(final Consumer<T> subscriber) {\n-        subscribers.add(subscriber);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> void publish(final T event) {\n-        // Notify all subscribers\n-        subscribers.forEach(consumer -> publishSingleEvent(event, consumer));\n-    }\n-\n-    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber) {\n-        subscriber.accept(event);\n-    }\n-\n-}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\ndeleted file mode 100644\nindex 6f82b1d075c..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Consumer;\n-\n-/**\n- * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n- * this component can consume from.\n- */\n-public class EventBusHelper {\n-\n-    // TODO: Delete me when you implementy your custom component\n-\n-    private static EventBusHelper INSTANCE;\n-\n-    final private Set<Consumer> subscribers = ConcurrentHashMap.newKeySet();\n-\n-    private EventBusHelper() {\n-    }\n-\n-    public static EventBusHelper getInstance(){\n-        if (INSTANCE == null) {\n-            INSTANCE = new EventBusHelper();\n-        }\n-\n-        return INSTANCE;\n-    }\n-\n-    public <T> void subscribe(final Consumer<T> subscriber) {\n-        subscribers.add(subscriber);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> void publish(final T event){\n-        // Notify all subscribers\n-        subscribers.forEach(consumer -> publishSingleEvent(event, consumer));\n-    }\n-\n-    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber){\n-        subscriber.accept(event);\n-    }\n-\n-}\n\\ No newline at end of file\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDk1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470950", "body": "You can use directly Component annotation without the whole package.", "bodyText": "You can use directly Component annotation without the whole package.", "bodyHTML": "<p dir=\"auto\">You can use directly Component annotation without the whole package.</p>", "author": "oscerd", "createdAt": "2020-06-08T05:57:13Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Map;\n+\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.Endpoint;\n+\n+import org.apache.camel.support.DefaultComponent;\n+\n+@org.apache.camel.spi.annotations.Component(\"MinIO\")", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java b/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\nsimilarity index 62%\nrename from components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java\nrename to components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\nindex 3595bd418ab..ac89094a1ac 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java\n+++ b/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\n", "chunk": "@@ -14,22 +14,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.camel.openapi;\n \n-package org.apache.camel;\n-\n-import java.util.Map;\n+import java.util.List;\n \n import org.apache.camel.CamelContext;\n-import org.apache.camel.Endpoint;\n+import org.apache.camel.model.rest.RestDefinition;\n+\n+/**\n+ * Pluggable resolver for resolving rest and camel context either local or globally via JMX for the entire JVM\n+ */\n+public interface RestDefinitionsResolver {\n+\n+    String JMX_REST_DEFINITION_RESOLVER = \"jmx-rest-definition-resolver\";\n+\n+    List<RestDefinition> getRestDefinitions(CamelContext camelContext, String camelId) throws Exception;\n \n-import org.apache.camel.support.DefaultComponent;\n+    List<String> findCamelContexts() throws Exception;\n \n-@org.apache.camel.spi.annotations.Component(\"MinIO\")\n-public class MinIOComponent extends DefaultComponent {\n-    \n-    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        Endpoint endpoint = new MinIOEndpoint(uri, this);\n-        setProperties(endpoint, parameters);\n-        return endpoint;\n-    }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java b/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\nsimilarity index 62%\nrename from components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java\nrename to components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\nindex 3595bd418ab..ac89094a1ac 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java\n+++ b/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\n", "chunk": "@@ -14,22 +14,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.camel.openapi;\n \n-package org.apache.camel;\n-\n-import java.util.Map;\n+import java.util.List;\n \n import org.apache.camel.CamelContext;\n-import org.apache.camel.Endpoint;\n+import org.apache.camel.model.rest.RestDefinition;\n+\n+/**\n+ * Pluggable resolver for resolving rest and camel context either local or globally via JMX for the entire JVM\n+ */\n+public interface RestDefinitionsResolver {\n+\n+    String JMX_REST_DEFINITION_RESOLVER = \"jmx-rest-definition-resolver\";\n+\n+    List<RestDefinition> getRestDefinitions(CamelContext camelContext, String camelId) throws Exception;\n \n-import org.apache.camel.support.DefaultComponent;\n+    List<String> findCamelContexts() throws Exception;\n \n-@org.apache.camel.spi.annotations.Component(\"MinIO\")\n-public class MinIOComponent extends DefaultComponent {\n-    \n-    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        Endpoint endpoint = new MinIOEndpoint(uri, this);\n-        setProperties(endpoint, parameters);\n-        return endpoint;\n-    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436471145", "body": "Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.", "bodyText": "Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.", "bodyHTML": "<p dir=\"auto\">Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.</p>", "author": "oscerd", "createdAt": "2020-06-08T05:58:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.support.DefaultConsumer;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+public class MinIOConsumer extends DefaultConsumer {\n+    private final MinIOEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n+\n+    private ExecutorService executorService;\n+\n+    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg1MQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437673851", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\ndeleted file mode 100644\nindex f1c62ddb85a..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.RuntimeCamelException;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-public class MinIOConsumer extends DefaultConsumer {\n-    private final MinIOEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n-\n-    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n-        super(endpoint, processor);\n-        this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n-    }\n-\n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n-\n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n-\n-        try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n-        } finally {\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n-            }\n-        }\n-    }\n-}\n", "next_change": {"commit": "ece2cb7569d380486b4a0187ac97b3fac0574bbd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\nnew file mode 100644\nindex 00000000000..f1c62ddb85a\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\n", "chunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.support.DefaultConsumer;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+public class MinIOConsumer extends DefaultConsumer {\n+    private final MinIOEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n+\n+    private ExecutorService executorService;\n+\n+    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n+    }\n+\n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n+\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n+    }\n+\n+    @Override\n+    protected void doStop() throws Exception {\n+        super.doStop();\n+\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n+    }\n+\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n+\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            }\n+        }\n+    }\n+}\n", "next_change": {"commit": "557c54ccc663f5b0b044f80629973afd8ceacb28", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\ndeleted file mode 100644\nindex f1c62ddb85a..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.RuntimeCamelException;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-public class MinIOConsumer extends DefaultConsumer {\n-    private final MinIOEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n-\n-    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n-        super(endpoint, processor);\n-        this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n-    }\n-\n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n-\n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n-\n-        try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n-        } finally {\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\ndeleted file mode 100644\nindex f1c62ddb85a..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.RuntimeCamelException;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-public class MinIOConsumer extends DefaultConsumer {\n-    private final MinIOEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n-\n-    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n-        super(endpoint, processor);\n-        this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n-    }\n-\n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n-\n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n-\n-        try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n-        } finally {\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"oid": "ece2cb7569d380486b4a0187ac97b3fac0574bbd", "url": "https://github.com/apache/camel/commit/ece2cb7569d380486b4a0187ac97b3fac0574bbd", "message": "Added auto generated files", "committedDate": "2020-06-10T04:13:01Z", "type": "forcePushed"}, {"oid": "2acf3087813b7b772b0efa5415212d4aa26495cd", "url": "https://github.com/apache/camel/commit/2acf3087813b7b772b0efa5415212d4aa26495cd", "message": "Updated minio-component.adoc file", "committedDate": "2020-06-12T13:33:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjMzMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466333", "body": "Maybe `firstVersion` could be set to `3.5.0` or something like that.", "bodyText": "Maybe firstVersion could be set to 3.5.0 or something like that.", "bodyHTML": "<p dir=\"auto\">Maybe <code>firstVersion</code> could be set to <code>3.5.0</code> or something like that.</p>", "author": "DenisIstomin", "createdAt": "2020-06-12T14:50:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\ndeleted file mode 100644\nindex b7c90e3bb8d..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ /dev/null\n", "chunk": "@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n-import org.apache.camel.support.DefaultEndpoint;\n-import org.apache.camel.spi.Metadata;\n-import org.apache.camel.spi.UriEndpoint;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriPath;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * MinIO component which does bla bla.\n- *\n- * TODO: Update one line description above what the component does.\n- */\n-@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",\n-             consumerClass = MinIOConsumer.class, label = \"custom\")\n-public class MinIOEndpoint extends DefaultEndpoint {\n-    @UriPath @Metadata(required = true)\n-    private String name;\n-    @UriParam(defaultValue = \"10\")\n-    private int option = 10;\n-\n-    public MinIOEndpoint() {\n-    }\n-\n-    public MinIOEndpoint(String uri, MinIOComponent component) {\n-        super(uri, component);\n-    }\n-\n-    public Producer createProducer() throws Exception {\n-        return new MinIOProducer(this);\n-    }\n-\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        Consumer consumer = new MinIOConsumer(this, processor);\n-        configureConsumer(consumer);\n-        return consumer;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n-    }\n-\n-    public int getOption() {\n-        return option;\n-    }\n-\n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n-    }\n-}\n", "next_change": {"commit": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\nnew file mode 100644\nindex 00000000000..38d52c76f3d\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n", "chunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.DefaultEndpoint;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax = \"MinIO:name\",\n+             consumerClass = MinIOConsumer.class, label = \"custom\")\n+public class MinIOEndpoint extends DefaultEndpoint {\n+    @UriPath @Metadata(required = true)\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n+\n+    public MinIOEndpoint() {\n+    }\n+\n+    public MinIOEndpoint(String uri, MinIOComponent component) {\n+        super(uri, component);\n+    }\n+\n+    public Producer createProducer() throws Exception {\n+        return new MinIOProducer(this);\n+    }\n+\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinIOConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n+    }\n+\n+    /**\n+     * Some description of this option, and what it does\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Some description of this option, and what it does\n+     */\n+    public void setOption(int option) {\n+        this.option = option;\n+    }\n+\n+    public int getOption() {\n+        return option;\n+    }\n+\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n+    }\n+}\n", "next_change": {"commit": "c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nsimilarity index 75%\nrename from components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 38d52c76f3d..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -73,12 +80,8 @@ public class MinIOEndpoint extends DefaultEndpoint {\n         this.option = option;\n     }\n \n-    public int getOption() {\n-        return option;\n-    }\n-\n     public ExecutorService createExecutor() {\n         // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\ndeleted file mode 100644\nindex b7c90e3bb8d..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ /dev/null\n", "chunk": "@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n-import org.apache.camel.support.DefaultEndpoint;\n-import org.apache.camel.spi.Metadata;\n-import org.apache.camel.spi.UriEndpoint;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriPath;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * MinIO component which does bla bla.\n- *\n- * TODO: Update one line description above what the component does.\n- */\n-@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",\n-             consumerClass = MinIOConsumer.class, label = \"custom\")\n-public class MinIOEndpoint extends DefaultEndpoint {\n-    @UriPath @Metadata(required = true)\n-    private String name;\n-    @UriParam(defaultValue = \"10\")\n-    private int option = 10;\n-\n-    public MinIOEndpoint() {\n-    }\n-\n-    public MinIOEndpoint(String uri, MinIOComponent component) {\n-        super(uri, component);\n-    }\n-\n-    public Producer createProducer() throws Exception {\n-        return new MinIOProducer(this);\n-    }\n-\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        Consumer consumer = new MinIOConsumer(this, processor);\n-        configureConsumer(consumer);\n-        return consumer;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n-    }\n-\n-    public int getOption() {\n-        return option;\n-    }\n-\n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466644", "body": "And maybe scheme could be lowercase, like \"minio\"", "bodyText": "And maybe scheme could be lowercase, like \"minio\"", "bodyHTML": "<p dir=\"auto\">And maybe scheme could be lowercase, like \"minio\"</p>", "author": "DenisIstomin", "createdAt": "2020-06-12T14:51:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\ndeleted file mode 100644\nindex b7c90e3bb8d..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ /dev/null\n", "chunk": "@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n-import org.apache.camel.support.DefaultEndpoint;\n-import org.apache.camel.spi.Metadata;\n-import org.apache.camel.spi.UriEndpoint;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriPath;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * MinIO component which does bla bla.\n- *\n- * TODO: Update one line description above what the component does.\n- */\n-@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",\n-             consumerClass = MinIOConsumer.class, label = \"custom\")\n-public class MinIOEndpoint extends DefaultEndpoint {\n-    @UriPath @Metadata(required = true)\n-    private String name;\n-    @UriParam(defaultValue = \"10\")\n-    private int option = 10;\n-\n-    public MinIOEndpoint() {\n-    }\n-\n-    public MinIOEndpoint(String uri, MinIOComponent component) {\n-        super(uri, component);\n-    }\n-\n-    public Producer createProducer() throws Exception {\n-        return new MinIOProducer(this);\n-    }\n-\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        Consumer consumer = new MinIOConsumer(this, processor);\n-        configureConsumer(consumer);\n-        return consumer;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n-    }\n-\n-    public int getOption() {\n-        return option;\n-    }\n-\n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n-    }\n-}\n", "next_change": {"commit": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\nnew file mode 100644\nindex 00000000000..38d52c76f3d\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n", "chunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.DefaultEndpoint;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax = \"MinIO:name\",\n+             consumerClass = MinIOConsumer.class, label = \"custom\")\n+public class MinIOEndpoint extends DefaultEndpoint {\n+    @UriPath @Metadata(required = true)\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n+\n+    public MinIOEndpoint() {\n+    }\n+\n+    public MinIOEndpoint(String uri, MinIOComponent component) {\n+        super(uri, component);\n+    }\n+\n+    public Producer createProducer() throws Exception {\n+        return new MinIOProducer(this);\n+    }\n+\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinIOConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n+    }\n+\n+    /**\n+     * Some description of this option, and what it does\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Some description of this option, and what it does\n+     */\n+    public void setOption(int option) {\n+        this.option = option;\n+    }\n+\n+    public int getOption() {\n+        return option;\n+    }\n+\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n+    }\n+}\n", "next_change": {"commit": "c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nsimilarity index 75%\nrename from components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 38d52c76f3d..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -73,12 +80,8 @@ public class MinIOEndpoint extends DefaultEndpoint {\n         this.option = option;\n     }\n \n-    public int getOption() {\n-        return option;\n-    }\n-\n     public ExecutorService createExecutor() {\n         // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\ndeleted file mode 100644\nindex b7c90e3bb8d..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ /dev/null\n", "chunk": "@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n-import org.apache.camel.support.DefaultEndpoint;\n-import org.apache.camel.spi.Metadata;\n-import org.apache.camel.spi.UriEndpoint;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriPath;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * MinIO component which does bla bla.\n- *\n- * TODO: Update one line description above what the component does.\n- */\n-@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",\n-             consumerClass = MinIOConsumer.class, label = \"custom\")\n-public class MinIOEndpoint extends DefaultEndpoint {\n-    @UriPath @Metadata(required = true)\n-    private String name;\n-    @UriParam(defaultValue = \"10\")\n-    private int option = 10;\n-\n-    public MinIOEndpoint() {\n-    }\n-\n-    public MinIOEndpoint(String uri, MinIOComponent component) {\n-        super(uri, component);\n-    }\n-\n-    public Producer createProducer() throws Exception {\n-        return new MinIOProducer(this);\n-    }\n-\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        Consumer consumer = new MinIOConsumer(this, processor);\n-        configureConsumer(consumer);\n-        return consumer;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n-    }\n-\n-    public int getOption() {\n-        return option;\n-    }\n-\n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"oid": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "url": "https://github.com/apache/camel/commit/c26cc5d467d572180ba8a6a0d42bf52967b32010", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-12T20:41:12Z", "type": "forcePushed"}, {"oid": "39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "url": "https://github.com/apache/camel/commit/39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-13T06:41:19Z", "type": "forcePushed"}, {"oid": "1e7d342708e717f9299d7b55ef435ac776e616e9", "url": "https://github.com/apache/camel/commit/1e7d342708e717f9299d7b55ef435ac776e616e9", "message": "Recommended changes done", "committedDate": "2020-06-13T07:28:48Z", "type": "forcePushed"}, {"oid": "a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "url": "https://github.com/apache/camel/commit/a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "message": "Recommended changes done", "committedDate": "2020-06-13T08:03:57Z", "type": "forcePushed"}, {"oid": "c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "url": "https://github.com/apache/camel/commit/c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-13T22:09:26Z", "type": "forcePushed"}, {"oid": "d965cdf77194a40ee48877e4551ef97e63c692e7", "url": "https://github.com/apache/camel/commit/d965cdf77194a40ee48877e4551ef97e63c692e7", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-14T03:07:03Z", "type": "forcePushed"}, {"oid": "557c54ccc663f5b0b044f80629973afd8ceacb28", "url": "https://github.com/apache/camel/commit/557c54ccc663f5b0b044f80629973afd8ceacb28", "message": "Code reformatted", "committedDate": "2020-06-18T04:28:40Z", "type": "forcePushed"}, {"oid": "c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "url": "https://github.com/apache/camel/commit/c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "message": "Updated imports", "committedDate": "2020-06-18T21:18:28Z", "type": "forcePushed"}, {"oid": "1fe1eda807af55348e41b0a61fd601003f7e1360", "url": "https://github.com/apache/camel/commit/1fe1eda807af55348e41b0a61fd601003f7e1360", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-06-19T16:16:43Z", "type": "forcePushed"}, {"oid": "f46f2996d879c333635e764484ec74d5deb2b890", "url": "https://github.com/apache/camel/commit/f46f2996d879c333635e764484ec74d5deb2b890", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-24T22:11:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445202915", "body": "@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\r\n```\r\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\r\n            listObjectsRequest.bucket(bucketName);\r\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\r\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\r\n``` ", "bodyText": "@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/oscerd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/oscerd\">@oscerd</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/DenisIstomin/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/DenisIstomin\">@DenisIstomin</a> What kind of approach suitable here? AWS2 S3 component have use something like this</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"ListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\n\"><pre><code>ListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\n</code></pre></div>", "author": "Nayananga", "createdAt": "2020-06-24T22:18:37Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwMjk1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445302954", "bodyText": "you could use https://docs.min.io/docs/java-client-api-reference.html#listObjects @Nayananga", "author": "oscerd", "createdAt": "2020-06-25T04:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -53,129 +70,136 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n         String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges = null;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n+        if (isNotEmpty(objectName)) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n-            }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n \n         } else {\n \n             LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n-            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (marker == null) {\n-                marker = results.iterator();\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n             }\n-            exchanges = pollMarker(bucketName, minioClient);\n \n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n             if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n             }\n \n+            exchanges = createExchanges(listObjects.contents());\n         }\n         return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n-        LOG.trace(\"Resuming from marker: {}\", marker);\n-        Queue<Object> bucketQueue = null;\n-        while (marker.hasNext()) {\n-            Item item = marker.next().get();\n-            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-            try {\n-                InputStream resumeStream = minioClient.getObject(bucketName,\n-                        item.objectName(),\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n-\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n-            }\n-        }\n-        // no more data so clear marker\n-        marker = null;\n-        return bucketQueue;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n         }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n                 }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n             }\n+\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n-            throw e;\n         }\n \n         return answer;\n     }\n \n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n+    public int processBatch(Queue<Object> exchanges) {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n", "next_change": {"commit": "5ce02877a27e4c44242760f1bd7af412bd220664", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..b88ab25b4db 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -204,7 +248,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "7174a3c85fdc5148e794521a6e86ca82d3520f2f", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex b88ab25b4db..a9bb11c5e17 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -60,195 +40,154 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private String continuationToken;\n+    private Iterator<Result<Item>> marker;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n     }\n \n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        if (getConfiguration().isMoveAfterRead()) {\n-            String destinationBucketName = getConfiguration().getDestinationBucketName();\n-\n-            if (isNotEmpty(destinationBucketName)) {\n-\n-                if (bucketExists(destinationBucketName)) {\n-                    LOG.trace(\"Bucket [{}] already exists\", destinationBucketName);\n-                } else {\n-                    LOG.trace(\"Destination Bucket [{}] doesn't exist yet\", destinationBucketName);\n-\n-                    if (getConfiguration().isAutoCreateBucket()) {\n-                        // creates the new bucket because it doesn't exist yet\n-                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n-                        makeBucket(destinationBucketName);\n-                        LOG.trace(\"Destination Bucket created\");\n-                    } else {\n-                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n-                    }\n-                }\n-            } else {\n-                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n-            }\n-        }\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-    }\n-\n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (isNotEmpty(getConfiguration().getRegion())) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        getMinioClient().makeBucket(makeBucketRequest.build());\n-    }\n-    \n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        String bucketName = getConfiguration().getBucketName();\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n+        String bucketName = getConfiguration().getBucketName();\n         Queue<Exchange> exchanges;\n \n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n \n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n \n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n             }\n \n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n+        } else {\n \n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n+            if (marker == null) {\n+\n+                try {\n+                    Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                            getConfiguration().getPrefix(),\n+                            getConfiguration().isRecursive(),\n+                            getConfiguration().isUseVersion1()\n+                    );\n+\n+                    marker = results.iterator();\n+                } catch (Exception e) {\n+                    LOG.trace(\"Failed to get object list in bucket [{}], Error message [{}]\", bucketName, e);\n+                }\n             }\n \n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n+            LOG.trace(\"Resuming from marker: {}\", marker);\n+            Queue<Exchange> bucketQueue = new LinkedList<>();\n+            for (int i = 0; i < maxMessagesPerPoll; i++) {\n+                assert marker != null;\n+                if (marker.hasNext()) {\n+                    Item item = marker.next().get();\n+                    LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+                    try {\n+                        InputStream resumeStream = minioClient.getObject(\n+                                bucketName,\n+                                item.objectName(),\n+                                getConfiguration().getOffset(),\n+                                getConfiguration().getLength(),\n+                                getConfiguration().getServerSideEncryption());\n+\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        bucketQueue.add(exchange);\n+\n+                    } catch (Exception e) {\n+                        LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+                    }\n+                } else {\n+                    // no more data so clear marker\n+                    marker = null;\n+                }\n             }\n+\n             if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n             }\n \n-            exchanges = createExchanges(listObjects.contents());\n         }\n         return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n         answer.add(exchange);\n-        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n         }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n                     answer.add(exchange);\n                 }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n             }\n-\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n+            throw e;\n         }\n \n         return answer;\n     }\n \n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex a9bb11c5e17..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,278 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.InputStream;\n-import java.util.*;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.MinioClient;\n-import io.minio.Result;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Item;\n-import org.apache.camel.*;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.support.DefaultConsumer;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-    private Iterator<Result<Item>> marker;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n-        String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n-\n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n-            }\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (marker == null) {\n-\n-                try {\n-                    Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                            getConfiguration().getPrefix(),\n-                            getConfiguration().isRecursive(),\n-                            getConfiguration().isUseVersion1()\n-                    );\n-\n-                    marker = results.iterator();\n-                } catch (Exception e) {\n-                    LOG.trace(\"Failed to get object list in bucket [{}], Error message [{}]\", bucketName, e);\n-                }\n-            }\n-\n-            LOG.trace(\"Resuming from marker: {}\", marker);\n-            Queue<Exchange> bucketQueue = new LinkedList<>();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-                    try {\n-                        InputStream resumeStream = minioClient.getObject(\n-                                bucketName,\n-                                item.objectName(),\n-                                getConfiguration().getOffset(),\n-                                getConfiguration().getLength(),\n-                                getConfiguration().getServerSideEncryption());\n-\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n-                        bucketQueue.add(exchange);\n-\n-                    } catch (Exception e) {\n-                        LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n-                    }\n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n-                }\n-            }\n-\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n-            }\n-\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n-        answer.add(exchange);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n-                    answer.add(exchange);\n-                }\n-            }\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-            throw e;\n-        }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-        return answer;\n-    }\n-\n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n-        int total = exchanges.size();\n-\n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-            LOG.trace(\"Processing exchange [{}]...\", exchange);\n-            getAsyncProcessor().process(exchange, new AsyncCallback() {\n-                @Override\n-                public void done(boolean doneSync) {\n-                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n-                }\n-            });\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            if (getConfiguration().isMoveAfterRead()) {\n-                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n-\n-                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n-\n-                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n-\n-                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n-            }\n-            if (getConfiguration().isDeleteAfterRead()) {\n-                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n-\n-                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n-        }\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (cause != null) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioConsumerToString == null) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -40,147 +60,204 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n         String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges = null;\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+        if (isNotEmpty(objectName)) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n+\n+        } else {\n \n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n             }\n \n-        } else {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n \n-            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n+            }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (marker == null) {\n-                marker = results.iterator();\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n             }\n-            exchanges = pollMarker(bucketName, minioClient);\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n-            }\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n \n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n \n-    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n-        LOG.trace(\"Resuming from marker: {}\", marker);\n-        Queue<Object> bucketQueue = null;\n-        while (marker.hasNext()) {\n-            Item item = marker.next().get();\n-            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-            try {\n-                InputStream resumeStream = minioClient.getObject(bucketName,\n-                        item.objectName(),\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n-\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n             }\n         }\n-        // no more data so clear marker\n-        marker = null;\n-        return bucketQueue;\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-                }\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                        continuationToken = minioObjectSummary.objectName();\n+                    }\n+                } while (minioObjectSummaries.hasNext());\n             }\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n+            }\n+\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n-            throw e;\n         }\n \n         return answer;\n     }\n \n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n+    public int processBatch(Queue<Object> exchanges) {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..2575058ae15 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -259,9 +267,9 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 2575058ae15..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -274,6 +260,27 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": {"commit": "43a6574cbd699733dd174f60dcc5a87c68068e21", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 562d499a574..49647d77814 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -282,7 +285,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             }\n \n             // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+            exchange.getExchangeExtension().addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n                     processCommit(exchange);\n                 }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445307693", "body": "Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?", "bodyText": "Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?", "bodyHTML": "<p dir=\"auto\">Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/oscerd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/oscerd\">@oscerd</a>, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?</p>", "author": "Nayananga", "createdAt": "2020-06-25T05:00:48Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwODYzNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445308634", "bodyText": "Hello @Nayananga , yes it is ok. You can do that and then process the result as a batch, like the S3 AWS2 component does.", "author": "oscerd", "createdAt": "2020-06-25T05:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMDY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445310644", "bodyText": "Thank you, is it okay to queue all the bucket objects (may take lot memory I guess) then send to  processBatch(CastUtils.cast(exchanges))? because in minio I had to queue each object in a Queue<Object> until iterator.hasNext() return false", "author": "Nayananga", "createdAt": "2020-06-25T05:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMTc5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445311790", "bodyText": "Not all the objects in one call, you need to define a limit for the batch, like setMaxKeys in AWS2 S3 component https://github.com/apache/camel/blob/master/components/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Consumer.java#L88", "author": "oscerd", "createdAt": "2020-06-25T05:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -53,129 +70,136 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n         String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges = null;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n+        if (isNotEmpty(objectName)) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n-            }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n \n         } else {\n \n             LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n-            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (marker == null) {\n-                marker = results.iterator();\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n             }\n-            exchanges = pollMarker(bucketName, minioClient);\n \n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n             if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n             }\n \n+            exchanges = createExchanges(listObjects.contents());\n         }\n         return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n-        LOG.trace(\"Resuming from marker: {}\", marker);\n-        Queue<Object> bucketQueue = null;\n-        while (marker.hasNext()) {\n-            Item item = marker.next().get();\n-            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-            try {\n-                InputStream resumeStream = minioClient.getObject(bucketName,\n-                        item.objectName(),\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n-\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n-            }\n-        }\n-        // no more data so clear marker\n-        marker = null;\n-        return bucketQueue;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n         }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n                 }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n             }\n+\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n-            throw e;\n         }\n \n         return answer;\n     }\n \n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n+    public int processBatch(Queue<Object> exchanges) {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n", "next_change": {"commit": "5ce02877a27e4c44242760f1bd7af412bd220664", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..b88ab25b4db 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -204,7 +248,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "7174a3c85fdc5148e794521a6e86ca82d3520f2f", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex b88ab25b4db..a9bb11c5e17 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -60,195 +40,154 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private String continuationToken;\n+    private Iterator<Result<Item>> marker;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n     }\n \n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        if (getConfiguration().isMoveAfterRead()) {\n-            String destinationBucketName = getConfiguration().getDestinationBucketName();\n-\n-            if (isNotEmpty(destinationBucketName)) {\n-\n-                if (bucketExists(destinationBucketName)) {\n-                    LOG.trace(\"Bucket [{}] already exists\", destinationBucketName);\n-                } else {\n-                    LOG.trace(\"Destination Bucket [{}] doesn't exist yet\", destinationBucketName);\n-\n-                    if (getConfiguration().isAutoCreateBucket()) {\n-                        // creates the new bucket because it doesn't exist yet\n-                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n-                        makeBucket(destinationBucketName);\n-                        LOG.trace(\"Destination Bucket created\");\n-                    } else {\n-                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n-                    }\n-                }\n-            } else {\n-                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n-            }\n-        }\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-    }\n-\n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (isNotEmpty(getConfiguration().getRegion())) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        getMinioClient().makeBucket(makeBucketRequest.build());\n-    }\n-    \n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        String bucketName = getConfiguration().getBucketName();\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n+        String bucketName = getConfiguration().getBucketName();\n         Queue<Exchange> exchanges;\n \n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n \n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n \n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n             }\n \n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n+        } else {\n \n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n+            if (marker == null) {\n+\n+                try {\n+                    Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                            getConfiguration().getPrefix(),\n+                            getConfiguration().isRecursive(),\n+                            getConfiguration().isUseVersion1()\n+                    );\n+\n+                    marker = results.iterator();\n+                } catch (Exception e) {\n+                    LOG.trace(\"Failed to get object list in bucket [{}], Error message [{}]\", bucketName, e);\n+                }\n             }\n \n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n+            LOG.trace(\"Resuming from marker: {}\", marker);\n+            Queue<Exchange> bucketQueue = new LinkedList<>();\n+            for (int i = 0; i < maxMessagesPerPoll; i++) {\n+                assert marker != null;\n+                if (marker.hasNext()) {\n+                    Item item = marker.next().get();\n+                    LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+                    try {\n+                        InputStream resumeStream = minioClient.getObject(\n+                                bucketName,\n+                                item.objectName(),\n+                                getConfiguration().getOffset(),\n+                                getConfiguration().getLength(),\n+                                getConfiguration().getServerSideEncryption());\n+\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        bucketQueue.add(exchange);\n+\n+                    } catch (Exception e) {\n+                        LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+                    }\n+                } else {\n+                    // no more data so clear marker\n+                    marker = null;\n+                }\n             }\n+\n             if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n             }\n \n-            exchanges = createExchanges(listObjects.contents());\n         }\n         return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n         answer.add(exchange);\n-        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n         }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n                     answer.add(exchange);\n                 }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n             }\n-\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n+            throw e;\n         }\n \n         return answer;\n     }\n \n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex a9bb11c5e17..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,278 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.InputStream;\n-import java.util.*;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.MinioClient;\n-import io.minio.Result;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Item;\n-import org.apache.camel.*;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.support.DefaultConsumer;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-    private Iterator<Result<Item>> marker;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n-        String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n-\n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n-            }\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (marker == null) {\n-\n-                try {\n-                    Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                            getConfiguration().getPrefix(),\n-                            getConfiguration().isRecursive(),\n-                            getConfiguration().isUseVersion1()\n-                    );\n-\n-                    marker = results.iterator();\n-                } catch (Exception e) {\n-                    LOG.trace(\"Failed to get object list in bucket [{}], Error message [{}]\", bucketName, e);\n-                }\n-            }\n-\n-            LOG.trace(\"Resuming from marker: {}\", marker);\n-            Queue<Exchange> bucketQueue = new LinkedList<>();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-                    try {\n-                        InputStream resumeStream = minioClient.getObject(\n-                                bucketName,\n-                                item.objectName(),\n-                                getConfiguration().getOffset(),\n-                                getConfiguration().getLength(),\n-                                getConfiguration().getServerSideEncryption());\n-\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n-                        bucketQueue.add(exchange);\n-\n-                    } catch (Exception e) {\n-                        LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n-                    }\n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n-                }\n-            }\n-\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n-            }\n-\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n-        answer.add(exchange);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n-                    answer.add(exchange);\n-                }\n-            }\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-            throw e;\n-        }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-        return answer;\n-    }\n-\n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n-        int total = exchanges.size();\n-\n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-            LOG.trace(\"Processing exchange [{}]...\", exchange);\n-            getAsyncProcessor().process(exchange, new AsyncCallback() {\n-                @Override\n-                public void done(boolean doneSync) {\n-                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n-                }\n-            });\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            if (getConfiguration().isMoveAfterRead()) {\n-                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n-\n-                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n-\n-                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n-\n-                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n-            }\n-            if (getConfiguration().isDeleteAfterRead()) {\n-                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n-\n-                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n-        }\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (cause != null) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioConsumerToString == null) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -40,147 +60,204 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        MinioClient minioClient = getConfiguration().getMinioClient();\n-        String objectName = getConfiguration().getObjectName();\n         String bucketName = getConfiguration().getBucketName();\n-        Queue<Exchange> exchanges = null;\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+        if (isNotEmpty(objectName)) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                InputStream stream = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n+\n+        } else {\n \n-                exchanges = createExchanges(stream, objectName);\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n             }\n \n-        } else {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n \n-            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n+            }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (marker == null) {\n-                marker = results.iterator();\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n             }\n-            exchanges = pollMarker(bucketName, minioClient);\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n-            }\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n \n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n \n-    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n-        LOG.trace(\"Resuming from marker: {}\", marker);\n-        Queue<Object> bucketQueue = null;\n-        while (marker.hasNext()) {\n-            Item item = marker.next().get();\n-            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n-            try {\n-                InputStream resumeStream = minioClient.getObject(bucketName,\n-                        item.objectName(),\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-\n-                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n-\n-            } catch (Exception e) {\n-                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n             }\n         }\n-        // no more data so clear marker\n-        marker = null;\n-        return bucketQueue;\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-\n-        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n-                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n-                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n-\n-                if (includeMinioObject(minioObject)) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-                }\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                        continuationToken = minioObjectSummary.objectName();\n+                    }\n+                } while (minioObjectSummaries.hasNext());\n             }\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n+            }\n+\n         } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n             // ensure all previous gathered minio objects are closed\n             // if there was an exception creating the exchanges in this batch\n             minioObjects.forEach(IOHelper::close);\n-            throw e;\n         }\n \n         return answer;\n     }\n \n-    /**\n-     * Decide whether to include the MinioObjects in the results\n-     *\n-     * @param minioObject\n-     * @return true to include, false to exclude\n-     */\n-    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().isIncludeFolders()) {\n-            return true;\n-        } else {\n-            //Config says to ignore folders/directories\n-            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) throws Exception {\n+    public int processBatch(Queue<Object> exchanges) {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n             exchange.setProperty(Exchange.BATCH_INDEX, index);\n             exchange.setProperty(Exchange.BATCH_SIZE, total);\n", "next_change": {"commit": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..2575058ae15 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -259,9 +267,9 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 2575058ae15..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -274,6 +260,27 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": {"commit": "43a6574cbd699733dd174f60dcc5a87c68068e21", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 562d499a574..49647d77814 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -282,7 +285,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             }\n \n             // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+            exchange.getExchangeExtension().addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n                     processCommit(exchange);\n                 }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"oid": "7174a3c85fdc5148e794521a6e86ca82d3520f2f", "url": "https://github.com/apache/camel/commit/7174a3c85fdc5148e794521a6e86ca82d3520f2f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-25T21:54:51Z", "type": "forcePushed"}, {"oid": "58e3d1b028374ac69716844c063623003d33c19f", "url": "https://github.com/apache/camel/commit/58e3d1b028374ac69716844c063623003d33c19f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-27T21:34:59Z", "type": "forcePushed"}, {"oid": "6040d1fa742dea91463f02238c51de4ef432b5e6", "url": "https://github.com/apache/camel/commit/6040d1fa742dea91463f02238c51de4ef432b5e6", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-28T09:42:08Z", "type": "forcePushed"}, {"oid": "303b36dc012fe0439b1ef3f9127489227fade0cc", "url": "https://github.com/apache/camel/commit/303b36dc012fe0439b1ef3f9127489227fade0cc", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-07-02T20:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0OTY3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449649678", "body": "Maybe you should avoid using `assert`. It is not enabled by default. It would be better to handle that with `if` condition.", "bodyText": "Maybe you should avoid using assert. It is not enabled by default. It would be better to handle that with if condition.", "bodyHTML": "<p dir=\"auto\">Maybe you should avoid using <code>assert</code>. It is not enabled by default. It would be better to handle that with <code>if</code> condition.</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:15:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -62,102 +70,103 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        MinioClient minioClient = getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        InputStream minioObject = null;\n-        Queue<Exchange> exchanges = null;\n-\n-        if (bucketExists(minioClient, bucketName)) {\n-            LOG.trace(\"Bucket {} exists\", bucketName);\n-        } else {\n-            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n-        }\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n+        if (isNotEmpty(objectName)) {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n-                if (minioObject != null) {\n-                    exchanges = createExchanges(minioObject, objectName);\n-                }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n \n-            } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n-                throw e;\n+        } else {\n \n-            } finally {\n-                //must be closed after use to release network resources.\n-                try {\n-                    assert minioObject != null;\n-                    minioObject.close();\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n-                } catch (IOException e) {\n-                    LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n-                }\n-            }\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n \n-        } else {\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n             }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n \n-        assert CastUtils.cast(exchanges) != null;\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n         return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n-\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n                     }\n-\n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n                 }\n             }\n \n", "next_change": {"commit": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -143,31 +187,40 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n         String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n             if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n                     InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n                     Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-                }\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n             } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n                     // ignore if directory\n                     if (!minioObjectSummary.isDir()) {\n                         InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n                         Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n+                        continuationToken = minioObjectSummary.objectName();\n                     }\n-                }\n+                } while (minioObjectSummaries.hasNext());\n+            }\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..41dbdce96a5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -60,167 +45,117 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    int totalCounter;\n-    private String continuationToken;\n+    private Iterator<Result<Item>> marker;\n     private transient String minioConsumerToString;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        if (getConfiguration().isMoveAfterRead()) {\n-            String destinationBucketName = getConfiguration().getDestinationBucketName();\n-\n-            if (isNotEmpty(destinationBucketName)) {\n-\n-                if (bucketExists(destinationBucketName)) {\n-                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n-                } else {\n-                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n-\n-                    if (getConfiguration().isAutoCreateBucket()) {\n-                        // creates the new bucket because it doesn't exist yet\n-                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n-                        makeBucket(destinationBucketName);\n-                        LOG.trace(\"Destination Bucket created\");\n-                    } else {\n-                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n-                    }\n-                }\n-            } else {\n-                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n-            }\n-        }\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-    }\n-\n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (isNotEmpty(getConfiguration().getRegion())) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        getMinioClient().makeBucket(makeBucketRequest.build());\n-    }\n-\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n+        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n         MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-            return processBatch(CastUtils.cast(exchanges));\n+        String objectName = getConfiguration().getObjectName();\n+        InputStream minioObject;\n+        Queue<Exchange> exchanges = null;\n \n+        if (bucketExists(minioClient, bucketName)) {\n+            LOG.trace(\"Bucket {} exists\", bucketName);\n         } else {\n+            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n+        }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n+            try {\n+                minioObject = getObject(bucketName, minioClient, objectName);\n+                if (minioObject != null) {\n+                    exchanges = createExchanges(minioObject, objectName);\n+                    closeObject(minioObject);\n+                }\n \n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                throw e;\n \n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n             }\n+        } else {\n \n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+            if (marker == null) {\n+\n+                marker = listObjects(minioClient, bucketName).iterator();\n+                LOG.trace(\"Marker created...\");\n             }\n \n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-                continuationToken = null;\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.startAfter(continuationToken);\n-            }\n+            LOG.trace(\"Getting from marker...\");\n+            exchanges = createExchanges(marker);\n+        }\n \n-            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n+        assert CastUtils.cast(exchanges) != null;\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n \n-            if (listObjects.hasNext()) {\n-                exchanges = createExchanges(listObjects);\n-                if (LOG.isTraceEnabled()) {\n-                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n-                }\n-                return processBatch(CastUtils.cast(exchanges));\n+    private void closeObject(InputStream minioObject) {\n+        try {\n+            assert minioObject != null;\n+            minioObject.close();\n \n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-                return 0;\n-            }\n+        } catch (IOException e) {\n+            LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n         }\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n         answer.add(exchange);\n-        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n-        int messageCounter = 0;\n-        String bucketName = getConfiguration().getBucketName();\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n+\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n+\n         try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                do {\n-                    messageCounter++;\n-                    Item minioObjectSummary = minioObjectSummaries.next().get();\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                    continuationToken = minioObjectSummary.objectName();\n-                } while (minioObjectSummaries.hasNext());\n-            } else {\n-                do {\n-                    messageCounter++;\n-                    Item minioObjectSummary = minioObjectSummaries.next().get();\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+            String bucketName = getConfiguration().getBucketName();\n+            MinioClient minioClient = getMinioClient();\n+            for (int i = 0; i < maxMessagesPerPoll; i++) {\n+                assert marker != null;\n+                if (marker.hasNext()) {\n+                    Item item = marker.next().get();\n+                    String objectName = item.objectName();\n+                    InputStream minioObject;\n+                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n+\n+                    minioObject = getObject(bucketName, minioClient, objectName);\n+\n+                    if (minioObject != null) {\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n                         answer.add(exchange);\n-                        continuationToken = minioObjectSummary.objectName();\n+                    } else {\n+                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n                     }\n-                } while (minioObjectSummaries.hasNext());\n-            }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n-                totalCounter += messageCounter;\n+                } else {\n+                    // no more data so clear marker\n+                    marker = null;\n+                }\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "c03064959bc92443b06333578b1c3a212adb8012", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 41dbdce96a5..937a916576a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -75,86 +77,113 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n             try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n+                InputStream minioObject = getObject(bucketName, minioClient, objectName);\n                 if (minioObject != null) {\n                     exchanges = createExchanges(minioObject, objectName);\n-                    closeObject(minioObject);\n                 }\n \n             } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                LOG.warn(\"Failed to create exchanges in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n                 throw e;\n \n             }\n         } else {\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            try {\n+                LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n-            }\n+                ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                        .bucket(bucketName)\n+                        .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                        .includeVersions(getConfiguration().isIncludeVersions())\n+                        .recursive(getConfiguration().isRecursive())\n+                        .useApiVersion1(getConfiguration().isUseVersion1());\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n-            }\n+                if (getConfiguration().getDelimiter() != null) {\n+                    listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+                }\n \n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+                if (maxMessagesPerPoll > 0) {\n+                    listObjectRequest.maxKeys(maxMessagesPerPoll);\n+                }\n \n-        assert CastUtils.cast(exchanges) != null;\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+                if (getConfiguration().getPrefix() != null) {\n+                    listObjectRequest.prefix(getConfiguration().getPrefix());\n+                }\n \n-    private void closeObject(InputStream minioObject) {\n-        try {\n-            assert minioObject != null;\n-            minioObject.close();\n+                if (getConfiguration().getStartAfter() != null) {\n+                    listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                }\n+\n+                // if there was a marker from previous poll then use that to\n+                // continue from where we left last time\n+                if (continuationToken != null) {\n+                    LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                    listObjectRequest.continuationToken(continuationToken);\n+                }\n \n-        } catch (IOException e) {\n-            LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n+                // TODO: Check for validity of the statement\n+                ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+                if (listObjects.isTruncated()) {\n+                    continuationToken = listObjects.nextContinuationToken();\n+                    LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                } else {\n+                    // no more data so clear marker\n+                    continuationToken = null;\n+                }\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+                }\n+\n+                exchanges = createExchanges(listObjects.contents());\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to create exchanges in bucket {} with object list, Error message {}\", bucketName, e.getMessage());\n+                throw e;\n+            }\n         }\n+\n+        return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n \n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            GetObjectArgs.Builder minioObjectRequest = GetObjectArgs.builder().bucket(getConfiguration().getBucketName());\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n+                            .object(minioObjectSummary.objectName())\n+                            .build());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n+                                .object(minioObjectSummary.objectName())\n+                                .build());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n                     }\n-\n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n                 }\n             }\n \n", "next_change": {"commit": "aa7ba42bf24225df0036f6164360b5067781d18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 937a916576a..7536f78ba70 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -158,28 +137,22 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n         }\n-\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            GetObjectArgs.Builder minioObjectRequest = GetObjectArgs.builder().bucket(getConfiguration().getBucketName());\n             if (getConfiguration().isIncludeFolders()) {\n                 for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n-                            .object(minioObjectSummary.objectName())\n-                            .build());\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n                     Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-\n                 }\n             } else {\n                 for (Contents minioObjectSummary : minioObjectSummaries) {\n                     // ignore if directory\n                     if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n-                                .object(minioObjectSummary.objectName())\n-                                .build());\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n                         Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,366 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.InputStream;\n-import java.util.*;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (getConfiguration().getDelimiter() != null) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (getConfiguration().getPrefix() != null) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (getConfiguration().getStartAfter() != null) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (continuationToken != null) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n-\n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n-\n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-\n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-            }\n-        } catch (MinioException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n-        }\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n         try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n-\n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n-\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n-\n-            getMinioClient().copyObject(copyObjectRequest.build());\n-\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n         } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n-\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (cause != null) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioConsumerToString == null) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            }\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 41dbdce96a5..937a916576a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -163,13 +192,9 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             throw e;\n \n         } finally {\n-            // must be closed after use to release network resources.\n-            minioObjects.forEach(this::closeObject);\n-        }\n-\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages out of {} objects in this poll, Maximum objects per poll is: {}\",\n-                    minioObjects.size(), ((Collection<?>) objectsList).size(), maxMessagesPerPoll);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n         }\n \n         return answer;\n", "next_change": {"commit": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 937a916576a..0b94c606706 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -200,50 +178,35 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         return answer;\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        try {\n-            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                getObjectRequest.ssec(getConfiguration().getServerSideEncryption());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                getObjectRequest.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                getObjectRequest.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                getObjectRequest.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            return minioClient.getObject(getObjectRequest.build());\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting object: {} in bucket: {}, due: {}\", objectName, bucketName, e.getMessage());\n-            throw e;\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 0b94c606706..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -181,28 +186,28 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             getObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             getObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             getObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             getObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..41dbdce96a5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -228,27 +163,98 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             throw e;\n \n         } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n+            // must be closed after use to release network resources.\n+            minioObjects.forEach(this::closeObject);\n+        }\n+\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages out of {} objects in this poll, Maximum objects per poll is: {}\",\n+                    minioObjects.size(), ((Collection<?>) objectsList).size(), maxMessagesPerPoll);\n         }\n \n         return answer;\n     }\n \n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private List<Bucket> bucketList(MinioClient minioClient) throws Exception {\n+        try {\n+            return minioClient.listBuckets();\n+        } catch (Throwable e) {\n+            LOG.warn(\"Failed to get bucket list, Error message {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private Iterable<Result<Item>> listObjects(MinioClient minioClient, String bucketName) {\n+        try {\n+            return minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Failed to get object list in bucket {}, Error message {}\", bucketName, e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n-\n-        return minioClient.getObject(getObjectRequest.build());\n+        InputStream minioObject = null;\n+        if (getConfiguration().getOffset() != 0) {\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                minioObject = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+            } else {\n+                if (getConfiguration().getLength() != 0) {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getOffset(),\n+                            getConfiguration().getLength());\n+                } else {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getOffset());\n+                }\n+            }\n+        } else {\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                if (getConfiguration().getFileName() != null) {\n+                    minioClient.downloadObject(DownloadObjectArgs.builder()\n+                            .bucket(bucketName)\n+                            .object(objectName)\n+                            .ssec(getConfiguration().getServerSideEncryption())\n+                            .filename(getConfiguration().getFileName())\n+                            .build());\n+                } else {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getServerSideEncryption());\n+                }\n+            } else {\n+                if (getConfiguration().getFileName() != null) {\n+                    minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getFileName());\n+                } else {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName);\n+                }\n+            }\n+        }\n+        return minioObject;\n     }\n \n     @Override\n", "next_change": {"commit": "c03064959bc92443b06333578b1c3a212adb8012", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 41dbdce96a5..937a916576a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -185,76 +210,40 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         }\n     }\n \n-    private List<Bucket> bucketList(MinioClient minioClient) throws Exception {\n-        try {\n-            return minioClient.listBuckets();\n-        } catch (Throwable e) {\n-            LOG.warn(\"Failed to get bucket list, Error message {}\", e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n-    private Iterable<Result<Item>> listObjects(MinioClient minioClient, String bucketName) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         try {\n-            return minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        } catch (Throwable e) {\n-            LOG.warn(\"Failed to get object list in bucket {}, Error message {}\", bucketName, e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        InputStream minioObject = null;\n-        if (getConfiguration().getOffset() != 0) {\n             if (getConfiguration().getServerSideEncryption() != null) {\n-                minioObject = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-            } else {\n-                if (getConfiguration().getLength() != 0) {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getOffset(),\n-                            getConfiguration().getLength());\n-                } else {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getOffset());\n-                }\n+                getObjectRequest.ssec(getConfiguration().getServerSideEncryption());\n             }\n-        } else {\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                if (getConfiguration().getFileName() != null) {\n-                    minioClient.downloadObject(DownloadObjectArgs.builder()\n-                            .bucket(bucketName)\n-                            .object(objectName)\n-                            .ssec(getConfiguration().getServerSideEncryption())\n-                            .filename(getConfiguration().getFileName())\n-                            .build());\n-                } else {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getServerSideEncryption());\n-                }\n-            } else {\n-                if (getConfiguration().getFileName() != null) {\n-                    minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getFileName());\n-                } else {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName);\n-                }\n+            if (getConfiguration().getOffset() != 0) {\n+                getObjectRequest.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                getObjectRequest.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                getObjectRequest.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n             }\n+\n+            return minioClient.getObject(getObjectRequest.build());\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting object: {} in bucket: {}, due: {}\", objectName, bucketName, e.getMessage());\n+            throw e;\n         }\n-        return minioObject;\n     }\n \n     @Override\n", "next_change": {"commit": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 937a916576a..0b94c606706 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -200,50 +178,35 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         return answer;\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        try {\n-            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                getObjectRequest.ssec(getConfiguration().getServerSideEncryption());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                getObjectRequest.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                getObjectRequest.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                getObjectRequest.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            return minioClient.getObject(getObjectRequest.build());\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting object: {} in bucket: {}, due: {}\", objectName, bucketName, e.getMessage());\n-            throw e;\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 0b94c606706..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -181,28 +186,28 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             getObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             getObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             getObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             getObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -49,116 +60,167 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        MinioClient minioClient = getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        InputStream minioObject = null;\n-        Queue<Exchange> exchanges = null;\n-\n-        if (bucketExists(minioClient, bucketName)) {\n-            LOG.trace(\"Bucket {} exists\", bucketName);\n-        } else {\n-            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n-        }\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n+        if (isNotEmpty(objectName)) {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n-                if (minioObject != null) {\n-                    exchanges = createExchanges(minioObject, objectName);\n-                }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n \n-            } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n-                throw e;\n+        } else {\n \n-            } finally {\n-                //must be closed after use to release network resources.\n-                try {\n-                    assert minioObject != null;\n-                    minioObject.close();\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n \n-                } catch (IOException e) {\n-                    LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n-                }\n-            }\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n \n-        } else {\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n             }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n+            }\n \n-        assert CastUtils.cast(exchanges) != null;\n-        return processBatch(CastUtils.cast(exchanges));\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n+\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n+            }\n+        }\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n-\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n+                        continuationToken = minioObjectSummary.objectName();\n                     }\n+                } while (minioObjectSummaries.hasNext());\n+            }\n \n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n-                }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..6430df91e7d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -223,7 +228,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 totalCounter += messageCounter;\n             }\n \n-        } catch (Throwable e) {\n+        } catch (Exception e) {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6430df91e7d..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -232,10 +222,6 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n         }\n \n         return answer;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDM4Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650386", "body": "Maybe [try-with-resources](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) could be used here. It would be nice to reduce nesting.", "bodyText": "Maybe try-with-resources could be used here. It would be nice to reduce nesting.", "bodyHTML": "<p dir=\"auto\">Maybe <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\" rel=\"nofollow\">try-with-resources</a> could be used here. It would be nice to reduce nesting.</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:18:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;\n+        String bucketName = getConfiguration().getBucketName();\n+        MinioClient minioClient = getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        InputStream minioObject = null;\n+        Queue<Exchange> exchanges = null;\n+\n+        if (bucketExists(minioClient, bucketName)) {\n+            LOG.trace(\"Bucket {} exists\", bucketName);\n+        } else {\n+            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n+        }\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            try {\n+                minioObject = getObject(bucketName, minioClient, objectName);\n+                if (minioObject != null) {\n+                    exchanges = createExchanges(minioObject, objectName);\n+                }\n+\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                throw e;\n+\n+            } finally {\n+                //must be closed after use to release network resources.\n+                try {\n+                    assert minioObject != null;\n+                    minioObject.close();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -62,102 +70,103 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        MinioClient minioClient = getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        InputStream minioObject = null;\n-        Queue<Exchange> exchanges = null;\n-\n-        if (bucketExists(minioClient, bucketName)) {\n-            LOG.trace(\"Bucket {} exists\", bucketName);\n-        } else {\n-            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n-        }\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n+        if (isNotEmpty(objectName)) {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n-                if (minioObject != null) {\n-                    exchanges = createExchanges(minioObject, objectName);\n-                }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n \n-            } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n-                throw e;\n+        } else {\n \n-            } finally {\n-                //must be closed after use to release network resources.\n-                try {\n-                    assert minioObject != null;\n-                    minioObject.close();\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n-                } catch (IOException e) {\n-                    LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n-                }\n-            }\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n \n-        } else {\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n             }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n \n-        assert CastUtils.cast(exchanges) != null;\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n         return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n-\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n                     }\n-\n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n                 }\n             }\n \n", "next_change": {"commit": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -143,31 +187,40 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n         String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n             if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n                     InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n                     Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-                }\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n             } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n                     // ignore if directory\n                     if (!minioObjectSummary.isDir()) {\n                         InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n                         Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n+                        continuationToken = minioObjectSummary.objectName();\n                     }\n-                }\n+                } while (minioObjectSummaries.hasNext());\n+            }\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..41dbdce96a5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -60,167 +45,117 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    int totalCounter;\n-    private String continuationToken;\n+    private Iterator<Result<Item>> marker;\n     private transient String minioConsumerToString;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        if (getConfiguration().isMoveAfterRead()) {\n-            String destinationBucketName = getConfiguration().getDestinationBucketName();\n-\n-            if (isNotEmpty(destinationBucketName)) {\n-\n-                if (bucketExists(destinationBucketName)) {\n-                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n-                } else {\n-                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n-\n-                    if (getConfiguration().isAutoCreateBucket()) {\n-                        // creates the new bucket because it doesn't exist yet\n-                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n-                        makeBucket(destinationBucketName);\n-                        LOG.trace(\"Destination Bucket created\");\n-                    } else {\n-                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n-                    }\n-                }\n-            } else {\n-                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n-            }\n-        }\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-    }\n-\n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (isNotEmpty(getConfiguration().getRegion())) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        getMinioClient().makeBucket(makeBucketRequest.build());\n-    }\n-\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n+        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n         MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-            return processBatch(CastUtils.cast(exchanges));\n+        String objectName = getConfiguration().getObjectName();\n+        InputStream minioObject;\n+        Queue<Exchange> exchanges = null;\n \n+        if (bucketExists(minioClient, bucketName)) {\n+            LOG.trace(\"Bucket {} exists\", bucketName);\n         } else {\n+            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n+        }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n+            try {\n+                minioObject = getObject(bucketName, minioClient, objectName);\n+                if (minioObject != null) {\n+                    exchanges = createExchanges(minioObject, objectName);\n+                    closeObject(minioObject);\n+                }\n \n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                throw e;\n \n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n             }\n+        } else {\n \n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n+            if (marker == null) {\n+\n+                marker = listObjects(minioClient, bucketName).iterator();\n+                LOG.trace(\"Marker created...\");\n             }\n \n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-                continuationToken = null;\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.startAfter(continuationToken);\n-            }\n+            LOG.trace(\"Getting from marker...\");\n+            exchanges = createExchanges(marker);\n+        }\n \n-            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n+        assert CastUtils.cast(exchanges) != null;\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n \n-            if (listObjects.hasNext()) {\n-                exchanges = createExchanges(listObjects);\n-                if (LOG.isTraceEnabled()) {\n-                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n-                }\n-                return processBatch(CastUtils.cast(exchanges));\n+    private void closeObject(InputStream minioObject) {\n+        try {\n+            assert minioObject != null;\n+            minioObject.close();\n \n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-                return 0;\n-            }\n+        } catch (IOException e) {\n+            LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n         }\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n         answer.add(exchange);\n-        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n-        int messageCounter = 0;\n-        String bucketName = getConfiguration().getBucketName();\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n+\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n+\n         try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                do {\n-                    messageCounter++;\n-                    Item minioObjectSummary = minioObjectSummaries.next().get();\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                    continuationToken = minioObjectSummary.objectName();\n-                } while (minioObjectSummaries.hasNext());\n-            } else {\n-                do {\n-                    messageCounter++;\n-                    Item minioObjectSummary = minioObjectSummaries.next().get();\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+            String bucketName = getConfiguration().getBucketName();\n+            MinioClient minioClient = getMinioClient();\n+            for (int i = 0; i < maxMessagesPerPoll; i++) {\n+                assert marker != null;\n+                if (marker.hasNext()) {\n+                    Item item = marker.next().get();\n+                    String objectName = item.objectName();\n+                    InputStream minioObject;\n+                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n+\n+                    minioObject = getObject(bucketName, minioClient, objectName);\n+\n+                    if (minioObject != null) {\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n                         answer.add(exchange);\n-                        continuationToken = minioObjectSummary.objectName();\n+                    } else {\n+                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n                     }\n-                } while (minioObjectSummaries.hasNext());\n-            }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n-                totalCounter += messageCounter;\n+                } else {\n+                    // no more data so clear marker\n+                    marker = null;\n+                }\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "c03064959bc92443b06333578b1c3a212adb8012", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 41dbdce96a5..937a916576a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -75,86 +77,113 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n             try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n+                InputStream minioObject = getObject(bucketName, minioClient, objectName);\n                 if (minioObject != null) {\n                     exchanges = createExchanges(minioObject, objectName);\n-                    closeObject(minioObject);\n                 }\n \n             } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                LOG.warn(\"Failed to create exchanges in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n                 throw e;\n \n             }\n         } else {\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            try {\n+                LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n-            }\n+                ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                        .bucket(bucketName)\n+                        .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                        .includeVersions(getConfiguration().isIncludeVersions())\n+                        .recursive(getConfiguration().isRecursive())\n+                        .useApiVersion1(getConfiguration().isUseVersion1());\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n-            }\n+                if (getConfiguration().getDelimiter() != null) {\n+                    listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+                }\n \n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+                if (maxMessagesPerPoll > 0) {\n+                    listObjectRequest.maxKeys(maxMessagesPerPoll);\n+                }\n \n-        assert CastUtils.cast(exchanges) != null;\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+                if (getConfiguration().getPrefix() != null) {\n+                    listObjectRequest.prefix(getConfiguration().getPrefix());\n+                }\n \n-    private void closeObject(InputStream minioObject) {\n-        try {\n-            assert minioObject != null;\n-            minioObject.close();\n+                if (getConfiguration().getStartAfter() != null) {\n+                    listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                }\n+\n+                // if there was a marker from previous poll then use that to\n+                // continue from where we left last time\n+                if (continuationToken != null) {\n+                    LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                    listObjectRequest.continuationToken(continuationToken);\n+                }\n \n-        } catch (IOException e) {\n-            LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n+                // TODO: Check for validity of the statement\n+                ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+                if (listObjects.isTruncated()) {\n+                    continuationToken = listObjects.nextContinuationToken();\n+                    LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                } else {\n+                    // no more data so clear marker\n+                    continuationToken = null;\n+                }\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+                }\n+\n+                exchanges = createExchanges(listObjects.contents());\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to create exchanges in bucket {} with object list, Error message {}\", bucketName, e.getMessage());\n+                throw e;\n+            }\n         }\n+\n+        return processBatch(CastUtils.cast(exchanges));\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n \n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            GetObjectArgs.Builder minioObjectRequest = GetObjectArgs.builder().bucket(getConfiguration().getBucketName());\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n+                            .object(minioObjectSummary.objectName())\n+                            .build());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n+                                .object(minioObjectSummary.objectName())\n+                                .build());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n                     }\n-\n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n                 }\n             }\n \n", "next_change": {"commit": "aa7ba42bf24225df0036f6164360b5067781d18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 937a916576a..7536f78ba70 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -158,28 +137,22 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n         }\n-\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n         try {\n-            GetObjectArgs.Builder minioObjectRequest = GetObjectArgs.builder().bucket(getConfiguration().getBucketName());\n             if (getConfiguration().isIncludeFolders()) {\n                 for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n-                            .object(minioObjectSummary.objectName())\n-                            .build());\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                     minioObjects.add(minioObject);\n                     Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                     answer.add(exchange);\n-\n                 }\n             } else {\n                 for (Contents minioObjectSummary : minioObjectSummaries) {\n                     // ignore if directory\n                     if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getMinioClient().getObject(minioObjectRequest\n-                                .object(minioObjectSummary.objectName())\n-                                .build());\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n                         Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,366 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.InputStream;\n-import java.util.*;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (getConfiguration().getDelimiter() != null) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (getConfiguration().getPrefix() != null) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (getConfiguration().getStartAfter() != null) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (continuationToken != null) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n-\n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n-\n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-\n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-            }\n-        } catch (MinioException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n-        }\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n         try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n-\n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n-\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n-\n-            getMinioClient().copyObject(copyObjectRequest.build());\n-\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n         } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n-\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (cause != null) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioConsumerToString == null) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            }\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 41dbdce96a5..937a916576a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -163,13 +192,9 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             throw e;\n \n         } finally {\n-            // must be closed after use to release network resources.\n-            minioObjects.forEach(this::closeObject);\n-        }\n-\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages out of {} objects in this poll, Maximum objects per poll is: {}\",\n-                    minioObjects.size(), ((Collection<?>) objectsList).size(), maxMessagesPerPoll);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n         }\n \n         return answer;\n", "next_change": {"commit": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 937a916576a..0b94c606706 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -200,50 +178,35 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         return answer;\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        try {\n-            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                getObjectRequest.ssec(getConfiguration().getServerSideEncryption());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                getObjectRequest.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                getObjectRequest.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                getObjectRequest.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            return minioClient.getObject(getObjectRequest.build());\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting object: {} in bucket: {}, due: {}\", objectName, bucketName, e.getMessage());\n-            throw e;\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 0b94c606706..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -181,28 +186,28 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             getObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             getObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             getObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             getObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..41dbdce96a5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -228,27 +163,98 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             throw e;\n \n         } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n+            // must be closed after use to release network resources.\n+            minioObjects.forEach(this::closeObject);\n+        }\n+\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages out of {} objects in this poll, Maximum objects per poll is: {}\",\n+                    minioObjects.size(), ((Collection<?>) objectsList).size(), maxMessagesPerPoll);\n         }\n \n         return answer;\n     }\n \n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private List<Bucket> bucketList(MinioClient minioClient) throws Exception {\n+        try {\n+            return minioClient.listBuckets();\n+        } catch (Throwable e) {\n+            LOG.warn(\"Failed to get bucket list, Error message {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private Iterable<Result<Item>> listObjects(MinioClient minioClient, String bucketName) {\n+        try {\n+            return minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Failed to get object list in bucket {}, Error message {}\", bucketName, e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n-\n-        return minioClient.getObject(getObjectRequest.build());\n+        InputStream minioObject = null;\n+        if (getConfiguration().getOffset() != 0) {\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                minioObject = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+            } else {\n+                if (getConfiguration().getLength() != 0) {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getOffset(),\n+                            getConfiguration().getLength());\n+                } else {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getOffset());\n+                }\n+            }\n+        } else {\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                if (getConfiguration().getFileName() != null) {\n+                    minioClient.downloadObject(DownloadObjectArgs.builder()\n+                            .bucket(bucketName)\n+                            .object(objectName)\n+                            .ssec(getConfiguration().getServerSideEncryption())\n+                            .filename(getConfiguration().getFileName())\n+                            .build());\n+                } else {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getServerSideEncryption());\n+                }\n+            } else {\n+                if (getConfiguration().getFileName() != null) {\n+                    minioClient.getObject(bucketName,\n+                            objectName,\n+                            getConfiguration().getFileName());\n+                } else {\n+                    minioObject = minioClient.getObject(bucketName,\n+                            objectName);\n+                }\n+            }\n+        }\n+        return minioObject;\n     }\n \n     @Override\n", "next_change": {"commit": "c03064959bc92443b06333578b1c3a212adb8012", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 41dbdce96a5..937a916576a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -185,76 +210,40 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         }\n     }\n \n-    private List<Bucket> bucketList(MinioClient minioClient) throws Exception {\n-        try {\n-            return minioClient.listBuckets();\n-        } catch (Throwable e) {\n-            LOG.warn(\"Failed to get bucket list, Error message {}\", e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n-    private Iterable<Result<Item>> listObjects(MinioClient minioClient, String bucketName) {\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         try {\n-            return minioClient.listObjects(bucketName,\n-                    getConfiguration().getPrefix(),\n-                    getConfiguration().isRecursive(),\n-                    getConfiguration().isUseVersion1()\n-            );\n+            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        } catch (Throwable e) {\n-            LOG.warn(\"Failed to get object list in bucket {}, Error message {}\", bucketName, e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        InputStream minioObject = null;\n-        if (getConfiguration().getOffset() != 0) {\n             if (getConfiguration().getServerSideEncryption() != null) {\n-                minioObject = minioClient.getObject(bucketName,\n-                        objectName,\n-                        getConfiguration().getOffset(),\n-                        getConfiguration().getLength(),\n-                        getConfiguration().getServerSideEncryption());\n-            } else {\n-                if (getConfiguration().getLength() != 0) {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getOffset(),\n-                            getConfiguration().getLength());\n-                } else {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getOffset());\n-                }\n+                getObjectRequest.ssec(getConfiguration().getServerSideEncryption());\n             }\n-        } else {\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                if (getConfiguration().getFileName() != null) {\n-                    minioClient.downloadObject(DownloadObjectArgs.builder()\n-                            .bucket(bucketName)\n-                            .object(objectName)\n-                            .ssec(getConfiguration().getServerSideEncryption())\n-                            .filename(getConfiguration().getFileName())\n-                            .build());\n-                } else {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getServerSideEncryption());\n-                }\n-            } else {\n-                if (getConfiguration().getFileName() != null) {\n-                    minioClient.getObject(bucketName,\n-                            objectName,\n-                            getConfiguration().getFileName());\n-                } else {\n-                    minioObject = minioClient.getObject(bucketName,\n-                            objectName);\n-                }\n+            if (getConfiguration().getOffset() != 0) {\n+                getObjectRequest.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                getObjectRequest.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                getObjectRequest.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n             }\n+\n+            return minioClient.getObject(getObjectRequest.build());\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting object: {} in bucket: {}, due: {}\", objectName, bucketName, e.getMessage());\n+            throw e;\n         }\n-        return minioObject;\n     }\n \n     @Override\n", "next_change": {"commit": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 937a916576a..0b94c606706 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -200,50 +178,35 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n         return answer;\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n-    }\n-\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        try {\n-            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                getObjectRequest.ssec(getConfiguration().getServerSideEncryption());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                getObjectRequest.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                getObjectRequest.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                getObjectRequest.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            return minioClient.getObject(getObjectRequest.build());\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting object: {} in bucket: {}, due: {}\", objectName, bucketName, e.getMessage());\n-            throw e;\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n     }\n \n     @Override\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 0b94c606706..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -181,28 +186,28 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             getObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             getObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             getObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             getObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -49,116 +60,167 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n \n-    private Iterator<Result<Item>> marker;\n+    int totalCounter;\n+    private String continuationToken;\n     private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n     }\n \n+    @Override\n+    protected void doStart() throws Exception {\n+        super.doStart();\n+\n+        if (getConfiguration().isMoveAfterRead()) {\n+            String destinationBucketName = getConfiguration().getDestinationBucketName();\n+\n+            if (isNotEmpty(destinationBucketName)) {\n+\n+                if (bucketExists(destinationBucketName)) {\n+                    LOG.trace(\"Bucket {} already exists\", destinationBucketName);\n+                } else {\n+                    LOG.trace(\"Destination Bucket {} doesn't exist yet\", destinationBucketName);\n+\n+                    if (getConfiguration().isAutoCreateBucket()) {\n+                        // creates the new bucket because it doesn't exist yet\n+                        LOG.trace(\"Creating Destination bucket {}...\", destinationBucketName);\n+                        makeBucket(destinationBucketName);\n+                        LOG.trace(\"Destination Bucket created\");\n+                    } else {\n+                        throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", destinationBucketName);\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"invalid destinationBucketName found: {}\", destinationBucketName);\n+            }\n+        }\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return getMinioClient().bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (isNotEmpty(getConfiguration().getRegion())) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        getMinioClient().makeBucket(makeBucketRequest.build());\n+    }\n+\n     @Override\n     protected int poll() throws Exception {\n         // must reset for each poll\n         shutdownRunningTask = null;\n         pendingExchanges = 0;\n \n-        assert getConfiguration().getBucketName() != null;\n         String bucketName = getConfiguration().getBucketName();\n-        MinioClient minioClient = getMinioClient();\n         String objectName = getConfiguration().getObjectName();\n-        InputStream minioObject = null;\n-        Queue<Exchange> exchanges = null;\n-\n-        if (bucketExists(minioClient, bucketName)) {\n-            LOG.trace(\"Bucket {} exists\", bucketName);\n-        } else {\n-            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n-        }\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n \n-        if (objectName != null) {\n+        if (isNotEmpty(objectName)) {\n             LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n \n-            try {\n-                minioObject = getObject(bucketName, minioClient, objectName);\n-                if (minioObject != null) {\n-                    exchanges = createExchanges(minioObject, objectName);\n-                }\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+            return processBatch(CastUtils.cast(exchanges));\n \n-            } catch (Throwable e) {\n-                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n-                throw e;\n+        } else {\n \n-            } finally {\n-                //must be closed after use to release network resources.\n-                try {\n-                    assert minioObject != null;\n-                    minioObject.close();\n+            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n \n-                } catch (IOException e) {\n-                    LOG.warn(\"Error closing MinioObject due: {}, Could not release network resources properly\", e.getMessage());\n-                }\n-            }\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n \n-        } else {\n+            if (isNotEmpty(getConfiguration().getDelimiter())) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n \n-            LOG.trace(\"Queueing objects in bucket {}...\", bucketName);\n-            if (marker == null) {\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n \n-                marker = listObjects(minioClient, bucketName).iterator();\n-                LOG.trace(\"Marker created...\");\n+            if (isNotEmpty(getConfiguration().getPrefix())) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n             }\n \n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket {}...\", ((Collection<?>) marker).size(), bucketName);\n+            if (isNotEmpty(getConfiguration().getStartAfter())) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+                continuationToken = null;\n             }\n \n             // if there was a marker from previous poll then use that to\n             // continue from where we left last time\n-            LOG.trace(\"Getting from marker...\");\n-            exchanges = createExchanges(marker);\n-        }\n+            if (isNotEmpty(continuationToken)) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.startAfter(continuationToken);\n+            }\n \n-        assert CastUtils.cast(exchanges) != null;\n-        return processBatch(CastUtils.cast(exchanges));\n+            Iterator<Result<Item>> listObjects = getMinioClient().listObjects(listObjectRequest.build()).iterator();\n+\n+            if (listObjects.hasNext()) {\n+                exchanges = createExchanges(listObjects);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Found {} objects in bucket {}...\", totalCounter, bucketName);\n+                }\n+                return processBatch(CastUtils.cast(exchanges));\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+                return 0;\n+            }\n+        }\n     }\n \n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String key) throws Exception {\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n         Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, key);\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n         answer.add(exchange);\n+        IOHelper.close(objectStream);\n         return answer;\n     }\n \n-    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> objectsList) throws Exception {\n-\n+    protected Queue<Exchange> createExchanges(Iterator<Result<Item>> minioObjectSummaries) throws Exception {\n+        int messageCounter = 0;\n+        String bucketName = getConfiguration().getBucketName();\n         Collection<InputStream> minioObjects = new ArrayList<>();\n         Queue<Exchange> answer = new LinkedList<>();\n-\n         try {\n-            String bucketName = getConfiguration().getBucketName();\n-            MinioClient minioClient = getMinioClient();\n-            for (int i = 0; i < maxMessagesPerPoll; i++) {\n-                assert marker != null;\n-                if (marker.hasNext()) {\n-                    Item item = marker.next().get();\n-                    String objectName = item.objectName();\n-                    InputStream minioObject;\n-                    LOG.trace(\"Getting object name: {} in {}\", objectName, bucketName);\n-\n-                    minioObject = getObject(bucketName, minioClient, objectName);\n-\n-                    if (minioObject != null) {\n+            if (getConfiguration().isIncludeFolders()) {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                    continuationToken = minioObjectSummary.objectName();\n+                } while (minioObjectSummaries.hasNext());\n+            } else {\n+                do {\n+                    messageCounter++;\n+                    Item minioObjectSummary = minioObjectSummaries.next().get();\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n                         minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, item.objectName());\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n                         answer.add(exchange);\n-                    } else {\n-                        LOG.trace(\"no returned objects found, Possible reason: Downloads may have set to fileName location\");\n+                        continuationToken = minioObjectSummary.objectName();\n                     }\n+                } while (minioObjectSummaries.hasNext());\n+            }\n \n-                } else {\n-                    // no more data so clear marker\n-                    marker = null;\n-                }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received {} messages in this poll\", messageCounter);\n+                totalCounter += messageCounter;\n             }\n \n         } catch (Throwable e) {\n", "next_change": {"commit": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..6430df91e7d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -223,7 +228,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 totalCounter += messageCounter;\n             }\n \n-        } catch (Throwable e) {\n+        } catch (Exception e) {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6430df91e7d..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -232,10 +222,6 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n             throw e;\n \n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n         }\n \n         return answer;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDk3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650977", "body": "Typo: retrieve", "bodyText": "Typo: retrieve", "bodyHTML": "<p dir=\"auto\">Typo: retrieve</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:20:17Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import io.minio.GetObjectTagsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.messages.Tags;\n+import jdk.internal.org.jline.utils.Log;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -43,23 +46,27 @@ import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.IOHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n- * Store and retrie objects from Minio Storage Service using Minio SDK.\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Qualified url\")\n+    @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String url; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f75734b972..0abc9a5d2d1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -46,27 +41,23 @@ import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-\n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Bucket name\")\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketName;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0abc9a5d2d1..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -57,7 +60,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String url; // to support component docs\n+    private String bucketNameOrArn; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..fbdf2cc5294 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -60,7 +60,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn; // to support component docs\n+    private String bucketName; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbdf2cc5294..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -51,14 +51,14 @@ import org.slf4j.LoggerFactory;\n /**\n  * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:bucketName\", category = {Category.CLOUD, Category.FILE})\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Qualified url\")\n+    @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n     private String bucketName; // to support component docs\n     @UriParam\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..c28617d57ae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -60,7 +65,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String bucketName; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c28617d57ae..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,282 +16,72 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.BucketExistsArgs;\n-import io.minio.MakeBucketArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectStat;\n-import io.minio.SetBucketPolicyArgs;\n-import io.minio.StatObjectArgs;\n-import io.minio.errors.InvalidBucketNameException;\n-import org.apache.camel.Category;\n-import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.Producer;\n-import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n-import org.apache.camel.support.ScheduledPollEndpoint;\n-import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultEndpoint;\n \n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Minio component which does bla bla.\n+ * <p>\n+ * TODO: Update one line description above what the component does.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n-public class MinioEndpoint extends ScheduledPollEndpoint {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n-\n-    private MinioClient minioClient;\n-\n-    @UriPath(description = \"Bucket name\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:name\",\n+        consumerClass = MinioConsumer.class, label = \"custom\")\n+public class MinioEndpoint extends DefaultEndpoint {\n+    @UriPath\n     @Metadata(required = true)\n-    private String bucketName;\n-    @UriParam\n-    private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n \n-    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n-        super(uri, component);\n-        this.configuration = configuration;\n+    public MinioEndpoint() {\n     }\n \n-    @Override\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n-        configureConsumer(minioConsumer);\n-        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n-        return minioConsumer;\n+    public MinioEndpoint(String uri, MinioComponent component) {\n+        super(uri, component);\n     }\n \n-    @Override\n-    public Producer createProducer() {\n+    public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    @Override\n-    public void doStart() throws Exception {\n-        super.doStart();\n-\n-        minioClient = getConfiguration().getMinioClient() != null\n-                ? getConfiguration().getMinioClient()\n-                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n-\n-        String objectName = getConfiguration().getObjectName();\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n-            return;\n-        }\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n-\n-        if (bucketExists(bucketName)) {\n-            LOG.trace(\"Bucket {} already exists\", bucketName);\n-        } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n-                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n-                makeBucket(bucketName);\n-                LOG.trace(\"Bucket created\");\n-            }\n-        }\n-\n-        if (getConfiguration().getPolicy() != null) {\n-            setBucketPolicy(bucketName);\n-        }\n-    }\n-\n-    @Override\n-    public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n-        super.doStop();\n-    }\n-\n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutocloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinioConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n+    public String getName() {\n+        return name;\n     }\n \n     /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    public void setName(String name) {\n+        this.name = name;\n     }\n \n-    public int getMaxConnections() {\n-        return maxConnections;\n+    public int getOption() {\n+        return option;\n     }\n \n     /**\n-     * Set the maxConnections parameter in the minio client configuration\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n-    }\n-\n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    public void setOption(int option) {\n+        this.option = option;\n     }\n \n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (getConfiguration().getRegion() != null) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        minioClient.makeBucket(makeBucketRequest.build());\n-    }\n-\n-    private void setBucketPolicy(String bucketName) throws Exception {\n-        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-        minioClient.setBucketPolicy(\n-                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n-        LOG.trace(\"Bucket policy updated\");\n-    }\n-\n-    private void getObjectStat(String objectName, Message message) throws Exception {\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n-\n-        // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n-        message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex ee167dbbeab..0edc380c6eb 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -69,19 +76,19 @@ public class MinioEndpoint extends DefaultEndpoint {\n         this.name = name;\n     }\n \n-    public int getOption() {\n-        return option;\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n     }\n \n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n+    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+                this.configuration.getSecretKey());\n+        return minioClient;\n+\n     }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0edc380c6eb..64b18d08cdc 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -84,8 +85,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.configuration = configuration;\n     }\n \n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n                 this.configuration.getSecretKey());\n         return minioClient;\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 64b18d08cdc..823af3025a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,88 +16,244 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n import io.minio.MinioClient;\n-import io.minio.errors.InvalidEndpointException;\n-import io.minio.errors.InvalidPortException;\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n+import io.minio.Result;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * Represents a Minio endpoint.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:url\", consumerClass = MinioConsumer.class, label = \"storage,cloud,file\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n-    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioEndpoint.class);\n \n-    @UriPath\n-    @Metadata(required = true)\n-    private String name;\n-    @UriPath(description = \"Bucket name or ARN\")\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n-    private MinioClient minioClient;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n \n-    public MinioEndpoint() {\n-    }\n-\n-    public MinioEndpoint(final String uri, final MinioComponent component,\n-                         final MinioConfiguration configuration) {\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n         this.configuration = configuration;\n     }\n \n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n     public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        return new MinioConsumer(this, processor);\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = configuration.getMinioClient() != null\n+                ? configuration.getMinioClient()\n+                : MinioClientFactory.getMinioClient(configuration).getMinioClient();\n+\n+        String fileName = getConfiguration().getFileName();\n+\n+        if (fileName != null) {\n+            LOG.trace(\"File name [{}] requested, so skipping bucket check...\", fileName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket [{}] already exists...\", bucketName);\n+\n+        String prefix = getConfiguration().getPrefix();\n+\n+        try {\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+            LOG.trace(\"Bucket [{}] already exists\", bucketName);\n+            return;\n+        } catch (AwsServiceException ase) {\n+            /* 404 means the bucket doesn't exist */\n+            if (ase.awsErrorDetails().errorCode().equalsIgnoreCase(\"404\")) {\n+                throw ase;\n+            }\n+        }\n+\n+        LOG.trace(\"Bucket [{}] doesn't exist yet\", bucketName);\n+\n+        if (getConfiguration().isAutoCreateBucket()) {\n+            // creates the new bucket because it doesn't exist yet\n+            CreateBucketRequest createBucketRequest = CreateBucketRequest.builder().bucket(getConfiguration().getBucketName()).build();\n+\n+            LOG.trace(\"Creating bucket [{}] in region [{}] with request [{}]...\", configuration.getBucketName(), configuration.getRegion(), createBucketRequest);\n+\n+            minioClient.createBucket(createBucketRequest);\n+\n+            LOG.trace(\"Bucket created\");\n+        }\n+\n+        if (configuration.getPolicy() != null) {\n+            LOG.trace(\"Updating bucket [{}] with policy [{}]\", bucketName, configuration.getPolicy());\n+\n+            minioClient.putBucketPolicy(PutBucketPolicyRequest.builder().bucket(bucketName).policy(configuration.getPolicy()).build());\n+\n+            LOG.trace(\"Bucket policy updated\");\n+        }\n     }\n \n-    public boolean isSingleton() {\n-        return true;\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {\n+            if (s3Client != null) {\n+                s3Client.close();\n+            }\n+        }\n+        super.doStop();\n     }\n \n-    public String getName() {\n-        return name;\n+    public Exchange createExchange(ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        return createExchange(getExchangePattern(), s3Object, key);\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n+    public Exchange createExchange(ExchangePattern pattern, ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        LOG.trace(\"Getting object with key [{}] from bucket [{}]...\", key, getConfiguration().getBucketName());\n+\n+        LOG.trace(\"Got object [{}]\", s3Object);\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+\n+        if (configuration.isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(s3Object));\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+        }\n+\n+        message.setHeader(AWS2S3Constants.KEY, key);\n+        message.setHeader(AWS2S3Constants.BUCKET_NAME, getConfiguration().getBucketName());\n+        message.setHeader(AWS2S3Constants.E_TAG, s3Object.response().eTag());\n+        message.setHeader(AWS2S3Constants.LAST_MODIFIED, s3Object.response().lastModified());\n+        message.setHeader(AWS2S3Constants.VERSION_ID, s3Object.response().versionId());\n+        message.setHeader(AWS2S3Constants.CONTENT_TYPE, s3Object.response().contentType());\n+        message.setHeader(AWS2S3Constants.CONTENT_LENGTH, s3Object.response().contentLength());\n+        message.setHeader(AWS2S3Constants.CONTENT_ENCODING, s3Object.response().contentEncoding());\n+        message.setHeader(AWS2S3Constants.CONTENT_DISPOSITION, s3Object.response().contentDisposition());\n+        message.setHeader(AWS2S3Constants.CACHE_CONTROL, s3Object.response().cacheControl());\n+        message.setHeader(AWS2S3Constants.SERVER_SIDE_ENCRYPTION, s3Object.response().serverSideEncryption());\n+        message.setHeader(AWS2S3Constants.EXPIRATION_TIME, s3Object.response().expiration());\n+        message.setHeader(AWS2S3Constants.REPLICATION_STATUS, s3Object.response().replicationStatus());\n+        message.setHeader(AWS2S3Constants.STORAGE_CLASS, s3Object.response().storageClass());\n+\n+        /**\n+         * If includeBody != true, it is safe to close the object here. If\n+         * includeBody == true, the caller is responsible for closing the stream\n+         * and object once the body has been fully consumed. As of 2.17, the\n+         * consumer does not close the stream or object on commit.\n+         */\n+        if (!configuration.isIncludeBody()) {\n+            IOHelper.close(s3Object);\n+        } else {\n+            if (configuration.isAutocloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(s3Object);\n+                    }\n+                });\n+            }\n+        }\n+\n+        return exchange;\n     }\n \n-    public MinioConfiguration getConfiguration() {\n+    public AWS2S3Configuration getConfiguration() {\n         return configuration;\n     }\n \n-    public void setConfiguration(MinioConfiguration configuration) {\n+    public void setConfiguration(AWS2S3Configuration configuration) {\n         this.configuration = configuration;\n     }\n \n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public void setS3Client(S3Client s3Client) {\n+        this.s3Client = s3Client;\n+    }\n+\n+    public S3Client getS3Client() {\n+        return s3Client;\n     }\n \n-    public MinioClient getMinioClient() {\n-        return minioClient;\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n     }\n \n-    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n-                this.configuration.getSecretKey());\n-        return minioClient;\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n \n+    public int getMaxConnections() {\n+        return maxConnections;\n     }\n \n+    /**\n+     * Set the maxConnections parameter in the S3 client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(ResponseInputStream<GetObjectResponse> s3Object) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(s3Object, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c = 0;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 823af3025a0..fbc5e921a19 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -256,4 +243,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n         return textBuilder.toString();\n     }\n+\n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n+        if (getConfiguration().)\n+    }\n }\n", "next_change": {"commit": "152fd8b381686621d3de6a6300323fe89f42720b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbc5e921a19..c827cc9fab1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -254,7 +267,24 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n-        if (getConfiguration().)\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+        try {\n+            if (region != null) {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .region(region)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            } else {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n     }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..1010a4c0cc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -267,24 +234,52 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+    private void makeBucket(String bucketName) throws Exception {\n         try {\n-            if (region != null) {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .region(region)\n-                        .objectLock(isObjectLock)\n-                        .build());\n-            } else {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .objectLock(isObjectLock)\n-                        .build());\n+            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n+            if (configuration.getRegion() != null) {\n+                makeBucketRequest.region(configuration.getRegion());\n             }\n+            minioClient.makeBucket(makeBucketRequest.build());\n \n         } catch (Throwable e) {\n             LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n             throw e;\n         }\n     }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        try {\n+            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+            minioClient.setBucketPolicy(\n+                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n+            LOG.trace(\"Bucket policy updated\");\n+        } catch (Throwable e) {\n+            Log.warn(\"Error updating policy, due {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void getObjectTags(String objectName, String bucketName, Message message) {\n+        try {\n+            ObjectStat stat = minioClient.statObject(\n+                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n+\n+            // set all stat as message headers\n+            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+            message.setHeader(MinioConstants.E_TAG, stat.etag());\n+            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+\n+        } catch (Exception e) {\n+            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+        }\n+    }\n }\n", "next_change": {"commit": "f4aea6f0902b2108a296a183973813785969618b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 1010a4c0cc6..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -279,7 +278,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n \n         } catch (Exception e) {\n-            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n         }\n     }\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -223,62 +223,67 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return textBuilder.toString();\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n \n     private void makeBucket(String bucketName) throws Exception {\n-        try {\n-            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n-            if (configuration.getRegion() != null) {\n-                makeBucketRequest.region(configuration.getRegion());\n-            }\n-            minioClient.makeBucket(makeBucketRequest.build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n-            throw e;\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n         }\n+        minioClient.makeBucket(makeBucketRequest.build());\n     }\n \n     private void setBucketPolicy(String bucketName) throws Exception {\n-        try {\n-            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-            minioClient.setBucketPolicy(\n-                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n-            LOG.trace(\"Bucket policy updated\");\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error updating policy, due {}\", e.getMessage());\n-            throw e;\n-        }\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n     }\n \n-    private void getObjectTags(String objectName, String bucketName, Message message) {\n-        try {\n-            ObjectStat stat = minioClient.statObject(\n-                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n-\n-            // set all stat as message headers\n-            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n-            message.setHeader(MinioConstants.E_TAG, stat.etag());\n-            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n-\n-        } catch (Exception e) {\n-            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n+    private void getObjectTags(String objectName, String bucketName, Message message) throws Exception {\n+\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n         }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+\n+        // set all stat as message headers\n+        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.E_TAG, stat.etag());\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..fa911a0dac1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -274,13 +276,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n         message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n         message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n         message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n         message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n         message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n         message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -43,23 +46,27 @@ import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.IOHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n- * Store and retrie objects from Minio Storage Service using Minio SDK.\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Qualified url\")\n+    @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String url; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -55,24 +53,16 @@ import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n /**\n  * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:bucketName\",\n         category = {Category.CLOUD, Category.FILE})\n-\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Bucket name\")\n-    @Metadata(required = true)\n-    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n \n     public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "committedDate": "2020-09-10 11:33:02 +0200", "message": "Camel-Minio: Lets simplify the client instantiation"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "fceb5aeac41ffc5a6fb64b2ce177628b5d85c621", "committedDate": "2020-12-04 08:32:34 +0100", "message": "CAMEL-15880 - Regen docs and fixed CS"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "committedDate": "2022-02-15 21:51:03 +0100", "message": "Remove unused code"}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449651579", "body": "Looks like that test should fail, because there are no messages being sent.", "bodyText": "Looks like that test should fail, because there are no messages being sent.", "bodyHTML": "<p dir=\"auto\">Looks like that test should fail, because there are no messages being sent.</p>", "author": "DenisIstomin", "createdAt": "2020-07-03T16:22:46Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit4.CamelTestSupport;\n+import org.junit.Test;\n+\n+public class MinioComponentTest extends CamelTestSupport {\n+\n+    @Test\n+    public void testMinio() throws Exception {\n+        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n+        mock.expectedMinimumMessageCount(1);\n+\n+        assertMockEndpointsSatisfied();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc2MDE4NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449760185", "bodyText": "ack, I haven't look into tests yet, I'll work on these asap :)", "author": "Nayananga", "createdAt": "2020-07-04T10:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioClientFactoryTest.java\nsimilarity index 54%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioClientFactoryTest.java\nindex ff31e186930..bf5ab50a206 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioClientFactoryTest.java\n", "chunk": "@@ -16,29 +16,19 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit4.CamelTestSupport;\n-import org.junit.Test;\n+import org.apache.camel.component.minio.client.MinioCamelInternalClient;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.component.minio.client.MinioRemoteClientImpl;\n+import org.junit.jupiter.api.Test;\n \n-public class MinioComponentTest extends CamelTestSupport {\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-    @Test\n-    public void testMinio() throws Exception {\n-        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n-        mock.expectedMinimumMessageCount(1);\n-\n-        assertMockEndpointsSatisfied();\n-    }\n+public class MinioClientFactoryTest {\n \n-    @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n-        return new RouteBuilder() {\n-            public void configure() {\n-                from(\"minio://foo\")\n-                        .to(\"minio://bar\")\n-                        .to(\"mock:result\");\n-            }\n-        };\n+    @Test\n+    public void getStandardMinioClientDefault() {\n+        MinioConfiguration minioConfiguration = new MinioConfiguration();\n+        MinioCamelInternalClient minioClient = MinioClientFactory.getClient(minioConfiguration);\n+        assertTrue(minioClient instanceof MinioRemoteClientImpl);\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioClientFactoryTest.java\nsimilarity index 54%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioClientFactoryTest.java\nindex ff31e186930..bf5ab50a206 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioClientFactoryTest.java\n", "chunk": "@@ -16,29 +16,19 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit4.CamelTestSupport;\n-import org.junit.Test;\n+import org.apache.camel.component.minio.client.MinioCamelInternalClient;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.component.minio.client.MinioRemoteClientImpl;\n+import org.junit.jupiter.api.Test;\n \n-public class MinioComponentTest extends CamelTestSupport {\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-    @Test\n-    public void testMinio() throws Exception {\n-        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n-        mock.expectedMinimumMessageCount(1);\n-\n-        assertMockEndpointsSatisfied();\n-    }\n+public class MinioClientFactoryTest {\n \n-    @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n-        return new RouteBuilder() {\n-            public void configure() {\n-                from(\"minio://foo\")\n-                        .to(\"minio://bar\")\n-                        .to(\"mock:result\");\n-            }\n-        };\n+    @Test\n+    public void getStandardMinioClientDefault() {\n+        MinioConfiguration minioConfiguration = new MinioConfiguration();\n+        MinioCamelInternalClient minioClient = MinioClientFactory.getClient(minioConfiguration);\n+        assertTrue(minioClient instanceof MinioRemoteClientImpl);\n     }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"oid": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "url": "https://github.com/apache/camel/commit/eb8a5eab91055dbefb8eb2a664bc6efc02068922", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-07-07T20:00:00Z", "type": "forcePushed"}, {"oid": "9a61617593bd21370a09598b54c766d167a9484c", "url": "https://github.com/apache/camel/commit/9a61617593bd21370a09598b54c766d167a9484c", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-07-09T14:43:55Z", "type": "forcePushed"}, {"oid": "c03064959bc92443b06333578b1c3a212adb8012", "url": "https://github.com/apache/camel/commit/c03064959bc92443b06333578b1c3a212adb8012", "message": "Updated to Minio 7.1.0", "committedDate": "2020-07-09T23:42:26Z", "type": "forcePushed"}, {"oid": "6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "url": "https://github.com/apache/camel/commit/6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-07-10T18:45:31Z", "type": "forcePushed"}, {"oid": "6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "url": "https://github.com/apache/camel/commit/6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "message": "Include integration Tests", "committedDate": "2020-07-13T22:08:02Z", "type": "forcePushed"}, {"oid": "311972bb833e08423b081d8268f686355cdcc161", "url": "https://github.com/apache/camel/commit/311972bb833e08423b081d8268f686355cdcc161", "message": "Code Reformatted", "committedDate": "2020-07-15T23:25:21Z", "type": "forcePushed"}, {"oid": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "url": "https://github.com/apache/camel/commit/3878b763e4e472b798d59f32e77fe5d52b7d4446", "message": "Ran Integration tests", "committedDate": "2020-07-16T22:20:43Z", "type": "forcePushed"}, {"oid": "aa7ba42bf24225df0036f6164360b5067781d18b", "url": "https://github.com/apache/camel/commit/aa7ba42bf24225df0036f6164360b5067781d18b", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-07-19T04:14:27Z", "type": "forcePushed"}, {"oid": "0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "url": "https://github.com/apache/camel/commit/0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "message": "Added documentation", "committedDate": "2020-07-19T18:43:50Z", "type": "forcePushed"}, {"oid": "e6028a86cd2018454b7d0d65938785171b6d02ab", "url": "https://github.com/apache/camel/commit/e6028a86cd2018454b7d0d65938785171b6d02ab", "message": "Minor changes to the tests", "committedDate": "2020-07-24T15:58:23Z", "type": "forcePushed"}, {"oid": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "url": "https://github.com/apache/camel/commit/ca963a048e1beb422fdf86ed84790523e9fd4b76", "message": "Fixed typo", "committedDate": "2020-07-25T18:22:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyODIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460728216", "body": "labels are missing here, for example `producer`, `consumer`, `common` ..etc", "bodyText": "labels are missing here, for example producer, consumer, common ..etc", "bodyHTML": "<p dir=\"auto\">labels are missing here, for example <code>producer</code>, <code>consumer</code>, <code>common</code> ..etc</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:29:11Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..93afa8e2874 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -29,36 +29,35 @@ import org.apache.camel.spi.UriParams;\n @UriParams\n public class MinioConfiguration implements Cloneable {\n \n-    @UriParam\n+    @UriParam(label = \"common\")\n     private String endpoint;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private Integer proxyPort;\n+    @UriParam(label = \"common\")\n+    private boolean secure;\n+    @UriParam(label = \"common\")\n+    private String region;\n+    @UriParam(label = \"common\")\n+    private OkHttpClient customHttpClient;\n \n     @UriParam(label = \"security\", secret = true)\n     private String accessKey;\n     @UriParam(label = \"security\", secret = true)\n     private String secretKey;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean secure;\n-\n-    @UriParam\n-    private String region;\n-\n-    @UriParam\n-    private OkHttpClient customHttpClient;\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n \n     private String bucketName;\n-    @UriParam(defaultValue = \"true\")\n+    @UriParam(label = \"common\", defaultValue = \"true\")\n     private boolean autoCreateBucket = true;\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n     private boolean objectLock;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n+    private String policy;\n+    @UriParam(label = \"common\")\n     private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private ServerSideEncryption serverSideEncryption;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n     @UriParam(label = \"consumer\")\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\ndeleted file mode 100644\nindex 93afa8e2874..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ /dev/null\n", "chunk": "@@ -1,637 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio;\n-\n-import java.time.ZonedDateTime;\n-\n-import io.minio.MinioClient;\n-import io.minio.ServerSideEncryption;\n-import io.minio.ServerSideEncryptionCustomerKey;\n-import okhttp3.OkHttpClient;\n-import org.apache.camel.RuntimeCamelException;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriParams;\n-\n-@UriParams\n-public class MinioConfiguration implements Cloneable {\n-\n-    @UriParam(label = \"common\")\n-    private String endpoint;\n-    @UriParam(label = \"common\")\n-    private Integer proxyPort;\n-    @UriParam(label = \"common\")\n-    private boolean secure;\n-    @UriParam(label = \"common\")\n-    private String region;\n-    @UriParam(label = \"common\")\n-    private OkHttpClient customHttpClient;\n-\n-    @UriParam(label = \"security\", secret = true)\n-    private String accessKey;\n-    @UriParam(label = \"security\", secret = true)\n-    private String secretKey;\n-    @UriParam(label = \"common\", defaultValue = \"false\")\n-\n-    private String bucketName;\n-    @UriParam(label = \"common\", defaultValue = \"true\")\n-    private boolean autoCreateBucket = true;\n-    @UriParam(label = \"common\", defaultValue = \"false\")\n-    private boolean objectLock;\n-    @UriParam(label = \"common\")\n-    private String policy;\n-    @UriParam(label = \"common\")\n-    private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam(label = \"common\")\n-    private ServerSideEncryption serverSideEncryption;\n-    @UriParam(label = \"common\")\n-    private MinioClient minioClient;\n-\n-    @UriParam(label = \"consumer\")\n-    private String objectName;\n-    @UriParam(label = \"consumer\")\n-    private String delimiter;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean includeUserMetadata;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean includeVersions;\n-    @UriParam(label = \"consumer\")\n-    private String prefix;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean recursive;\n-    @UriParam(label = \"consumer\")\n-    private String startAfter;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean useVersion1;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean includeFolders;\n-    @UriParam(label = \"consumer\")\n-    private long offset;\n-    @UriParam(label = \"consumer\")\n-    private long length;\n-    @UriParam(label = \"consumer\")\n-    private String versionId;\n-    @UriParam(label = \"consumer\")\n-    private String matchETag;\n-    @UriParam(label = \"consumer\")\n-    private String notMatchETag;\n-    @UriParam(label = \"consumer\")\n-    private ZonedDateTime modifiedSince;\n-    @UriParam(label = \"consumer\")\n-    private ZonedDateTime unModifiedSince;\n-    @UriParam(label = \"consumer\")\n-    private String destinationBucketName;\n-    @UriParam(label = \"consumer\")\n-    private String destinationObjectName;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean deleteAfterRead = true;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean moveAfterRead;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean bypassGovernanceMode;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean includeBody = true;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autoCloseBody = true;\n-\n-    @UriParam(label = \"producer\")\n-    private String keyName;\n-    @UriParam(label = \"producer\")\n-    private boolean deleteAfterWrite;\n-    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n-    private long partSize = 25 * 1024 * 1024;\n-    @UriParam(label = \"producer\")\n-    private String storageClass;\n-    @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n-    private MinioOperations operation;\n-    @UriParam(label = \"producer\", defaultValue = \"false\")\n-    private boolean pojoRequest;\n-\n-    public String getEndpoint() {\n-        return endpoint;\n-    }\n-\n-    /**\n-     * Endpoint can be an URL, domain name, IPv4 address or IPv6 address.\n-     */\n-    public void setEndpoint(String endpoint) {\n-        this.endpoint = endpoint;\n-    }\n-\n-    public Integer getProxyPort() {\n-        return proxyPort;\n-    }\n-\n-    /**\n-     * TCP/IP port number. 80 and 443 are used as defaults for HTTP and HTTPS.\n-     */\n-    public void setProxyPort(Integer proxyPort) {\n-        this.proxyPort = proxyPort;\n-    }\n-\n-    public boolean isSecure() {\n-        return secure;\n-    }\n-\n-    /**\n-     * Flag to indicate to use secure connection to minio service or not.\n-     */\n-    public void setSecure(boolean secure) {\n-        this.secure = secure;\n-    }\n-\n-    public String getRegion() {\n-        return region;\n-    }\n-\n-    /**\n-     * The region in which Minio client needs to work. When using this parameter,\n-     * the configuration will expect the lowercase name of the region (for\n-     * example ap-east-1). You'll need to use the name Region.EU_WEST_1.id()\n-     */\n-    public void setRegion(String region) {\n-        this.region = region;\n-    }\n-\n-    public OkHttpClient getCustomHttpClient() {\n-        return customHttpClient;\n-    }\n-\n-    /**\n-     * Set custom HTTP client for authenticated access.\n-     */\n-    public void setCustomHttpClient(OkHttpClient customHttpClient) {\n-        this.customHttpClient = customHttpClient;\n-    }\n-\n-    public String getAccessKey() {\n-        return accessKey;\n-    }\n-\n-    /**\n-     * Amazon AWS Secret Access Key or Minio Access Key.\n-     * If not set camel will connect to service for anonymous access.\n-     */\n-    public void setAccessKey(String accessKey) {\n-        this.accessKey = accessKey;\n-    }\n-\n-    public String getSecretKey() {\n-        return secretKey;\n-    }\n-\n-    /**\n-     * Amazon AWS Access Key Id or Minio Secret Key.\n-     * If not set camel will connect to service for anonymous access.\n-     */\n-    public void setSecretKey(String secretKey) {\n-        this.secretKey = secretKey;\n-    }\n-\n-    public String getBucketName() {\n-        return bucketName;\n-    }\n-\n-    /**\n-     * Name of the bucket. The bucket will be created if it doesn't already\n-     * exists.\n-     */\n-    public void setBucketName(String bucketName) {\n-        this.bucketName = bucketName;\n-    }\n-\n-    public boolean isAutoCreateBucket() {\n-        return autoCreateBucket;\n-    }\n-\n-    /**\n-     * Setting the autocreation of the bucket if bucket name not exist.\n-     */\n-    public void setAutoCreateBucket(boolean autoCreateBucket) {\n-        this.autoCreateBucket = autoCreateBucket;\n-    }\n-\n-    public boolean isObjectLock() {\n-        return objectLock;\n-    }\n-\n-    /**\n-     * Set when creating new bucket.\n-     */\n-    public void setObjectLock(boolean objectLock) {\n-        this.objectLock = objectLock;\n-    }\n-\n-    public String getPolicy() {\n-        return policy;\n-    }\n-\n-    /**\n-     * The policy for this queue to set in the method.\n-     */\n-    public void setPolicy(String policy) {\n-        this.policy = policy;\n-    }\n-\n-    public ServerSideEncryptionCustomerKey getServerSideEncryptionCustomerKey() {\n-        return serverSideEncryptionCustomerKey;\n-    }\n-\n-    /**\n-     * Server-side encryption for source object while copy/move objects.\n-     */\n-    public void setServerSideEncryptionCustomerKey(ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey) {\n-        this.serverSideEncryptionCustomerKey = serverSideEncryptionCustomerKey;\n-    }\n-\n-    public ServerSideEncryption getServerSideEncryption() {\n-        return serverSideEncryption;\n-    }\n-\n-    /**\n-     * Server-side encryption.\n-     */\n-    public void setServerSideEncryption(ServerSideEncryption serverSideEncryption) {\n-        this.serverSideEncryption = serverSideEncryption;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    /**\n-     * Reference to a Minio Client object in the registry.\n-     */\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n-    }\n-\n-    public String getObjectName() {\n-        return objectName;\n-    }\n-\n-    /**\n-     * To get the object from the bucket with the given object name.\n-     */\n-    public void setObjectName(String objectName) {\n-        this.objectName = objectName;\n-    }\n-\n-    public String getDelimiter() {\n-        return delimiter;\n-    }\n-\n-    /**\n-     * The delimiter which is used in the\n-     * ListObjectsRequest to only consume\n-     * objects we are interested in.\n-     */\n-    public void setDelimiter(String delimiter) {\n-        this.delimiter = delimiter;\n-    }\n-\n-    public boolean isIncludeUserMetadata() {\n-        return includeUserMetadata;\n-    }\n-\n-    /**\n-     * The flag which is used in the\n-     * ListObjectsRequest to get objects with user meta data.\n-     */\n-    public void setIncludeUserMetadata(boolean includeUserMetadata) {\n-        this.includeUserMetadata = includeUserMetadata;\n-    }\n-\n-    public boolean isIncludeVersions() {\n-        return includeVersions;\n-    }\n-\n-    /**\n-     * The flag which is used in the\n-     * ListObjectsRequest to get objects with versioning.\n-     */\n-    public void setIncludeVersions(boolean includeVersions) {\n-        this.includeVersions = includeVersions;\n-    }\n-\n-    public boolean isIncludeFolders() {\n-        return includeFolders;\n-    }\n-\n-    /**\n-     * The flag which is used in the\n-     * ListObjectsRequest to set include folders.\n-     */\n-    public void setIncludeFolders(boolean includeFolders) {\n-        this.includeFolders = includeFolders;\n-    }\n-\n-    public String getPrefix() {\n-        return prefix;\n-    }\n-\n-    /**\n-     * Object name starts with prefix.\n-     */\n-    public void setPrefix(String prefix) {\n-        this.prefix = prefix;\n-    }\n-\n-    public boolean isRecursive() {\n-        return recursive;\n-    }\n-\n-    /**\n-     * List recursively than directory structure emulation.\n-     */\n-    public void setRecursive(boolean recursive) {\n-        this.recursive = recursive;\n-    }\n-\n-    public String getStartAfter() {\n-        return startAfter;\n-    }\n-\n-    /**\n-     * list objects in bucket after this object name.\n-     */\n-    public void setStartAfter(String startAfter) {\n-        this.startAfter = startAfter;\n-    }\n-\n-    public boolean isUseVersion1() {\n-        return useVersion1;\n-    }\n-\n-    /**\n-     * when true, version 1 of REST API is used.\n-     */\n-    public void setUseVersion1(boolean useVersion1) {\n-        this.useVersion1 = useVersion1;\n-    }\n-\n-    public long getOffset() {\n-        return offset;\n-    }\n-\n-    /**\n-     * Start byte position of object data.\n-     */\n-    public void setOffset(long offset) {\n-        this.offset = offset;\n-    }\n-\n-    public long getLength() {\n-        return length;\n-    }\n-\n-    /**\n-     * Number of bytes of object data from offset.\n-     */\n-    public void setLength(long length) {\n-        this.length = length;\n-    }\n-\n-    public String getVersionId() {\n-        return versionId;\n-    }\n-\n-    /**\n-     * Set specific version_ID of a object when deleting the object.\n-     */\n-    public void setVersionId(String versionId) {\n-        this.versionId = versionId;\n-    }\n-\n-    public String getMatchETag() {\n-        return matchETag;\n-    }\n-\n-    /**\n-     * Set match ETag parameter for get object(s).\n-     */\n-    public void setMatchETag(String matchETag) {\n-        this.matchETag = matchETag;\n-    }\n-\n-    public String getNotMatchETag() {\n-        return notMatchETag;\n-    }\n-\n-    /**\n-     * Set not match ETag parameter for get object(s).\n-     */\n-    public void setNotMatchETag(String notMatchETag) {\n-        this.notMatchETag = notMatchETag;\n-    }\n-\n-    public ZonedDateTime getModifiedSince() {\n-        return modifiedSince;\n-    }\n-\n-    /**\n-     * Set modified since parameter for get object(s).\n-     */\n-    public void setModifiedSince(ZonedDateTime modifiedSince) {\n-        this.modifiedSince = modifiedSince;\n-    }\n-\n-    public ZonedDateTime getUnModifiedSince() {\n-        return unModifiedSince;\n-    }\n-\n-    /**\n-     * Set un modified since parameter for get object(s).\n-     */\n-    public void setUnModifiedSince(ZonedDateTime unModifiedSince) {\n-        this.unModifiedSince = unModifiedSince;\n-    }\n-\n-    public String getDestinationBucketName() {\n-        return destinationBucketName;\n-    }\n-\n-    /**\n-     * Source bucket name.\n-     */\n-    public void setDestinationBucketName(String destinationBucketName) {\n-        this.destinationBucketName = destinationBucketName;\n-    }\n-\n-    public String getDestinationObjectName() {\n-        return destinationObjectName;\n-    }\n-\n-    /**\n-     * Source object name.\n-     */\n-    public void setDestinationObjectName(String destinationObjectName) {\n-        this.destinationObjectName = destinationObjectName;\n-    }\n-\n-    public boolean isDeleteAfterRead() {\n-        return deleteAfterRead;\n-    }\n-\n-    /**\n-     * Delete objects from Minio after they have been retrieved. The delete is only\n-     * performed if the Exchange is committed. If a rollback occurs, the object\n-     * is not deleted.\n-     * <p/>\n-     * If this option is false, then the same objects will be retrieve over and\n-     * over again on the polls. Therefore you need to use the Idempotent\n-     * Consumer EIP in the route to filter out duplicates. You can filter using\n-     * the {@link MinioConstants#BUCKET_NAME} and {@link MinioConstants#OBJECT_NAME}\n-     * headers, or only the {@link MinioConstants#OBJECT_NAME} header.\n-     */\n-    public void setDeleteAfterRead(boolean deleteAfterRead) {\n-        this.deleteAfterRead = deleteAfterRead;\n-    }\n-\n-    public boolean isMoveAfterRead() {\n-        return moveAfterRead;\n-    }\n-\n-    /**\n-     * Move objects from bucket to a different bucket after they have been retrieved. To accomplish the operation\n-     * the destinationBucket option must be set.\n-     * The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object\n-     * is not moved.\n-     */\n-    public void setMoveAfterRead(boolean moveAfterRead) {\n-        this.moveAfterRead = moveAfterRead;\n-    }\n-\n-    public boolean isBypassGovernanceMode() {\n-        return bypassGovernanceMode;\n-    }\n-\n-    /**\n-     * Set this flag if you want to bypassGovernanceMode when deleting a particular object.\n-     */\n-    public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n-        this.bypassGovernanceMode = bypassGovernanceMode;\n-    }\n-\n-    public boolean isIncludeBody() {\n-        return includeBody;\n-    }\n-\n-    /**\n-     * If it is true, the exchange body will be set to a stream to the contents\n-     * of the file. If false, the headers will be set with the Minio object\n-     * metadata, but the body will be null. This option is strongly related to\n-     * autocloseBody option. In case of setting includeBody to true and\n-     * autocloseBody to false, it will be up to the caller to close the MinioObject\n-     * stream. Setting autocloseBody to true, will close the MinioObject stream\n-     * automatically.\n-     */\n-    public void setIncludeBody(boolean includeBody) {\n-        this.includeBody = includeBody;\n-    }\n-\n-    public boolean isAutoCloseBody() {\n-        return autoCloseBody;\n-    }\n-\n-    /**\n-     * If this option is true and includeBody is true, then the MinioObject.close()\n-     * method will be called on exchange completion. This option is strongly\n-     * related to includeBody option. In case of setting includeBody to true and\n-     * autocloseBody to false, it will be up to the caller to close the MinioObject\n-     * stream. Setting autocloseBody to true, will close the MinioObject stream\n-     * automatically.\n-     */\n-    public void setAutoCloseBody(boolean autoCloseBody) {\n-        this.autoCloseBody = autoCloseBody;\n-    }\n-\n-    public String getKeyName() {\n-        return keyName;\n-    }\n-\n-    /**\n-     * Setting the key name for an element in the bucket through endpoint\n-     * parameter.\n-     */\n-    public void setKeyName(String keyName) {\n-        this.keyName = keyName;\n-    }\n-\n-    public boolean isDeleteAfterWrite() {\n-        return deleteAfterWrite;\n-    }\n-\n-    /**\n-     * Delete file object after the Minio file has been uploaded.\n-     */\n-    public void setDeleteAfterWrite(boolean deleteAfterWrite) {\n-        this.deleteAfterWrite = deleteAfterWrite;\n-    }\n-\n-    public long getPartSize() {\n-        return partSize;\n-    }\n-\n-    /**\n-     * Setup the partSize which is used in multi part upload, the default size\n-     * is 25M.\n-     */\n-    public void setPartSize(long partSize) {\n-        this.partSize = partSize;\n-    }\n-\n-    public String getStorageClass() {\n-        return storageClass;\n-    }\n-\n-    /**\n-     * The storage class to set in the request.\n-     */\n-    public void setStorageClass(String storageClass) {\n-        this.storageClass = storageClass;\n-    }\n-\n-    public MinioOperations getOperation() {\n-        return operation;\n-    }\n-\n-    /**\n-     * The operation to do in case the user don't want to do only an upload.\n-     */\n-    public void setOperation(MinioOperations operation) {\n-        this.operation = operation;\n-    }\n-\n-    public boolean isPojoRequest() {\n-        return pojoRequest;\n-    }\n-\n-    /**\n-     * If we want to use a POJO request as body or not.\n-     */\n-    public void setPojoRequest(boolean pojoRequest) {\n-        this.pojoRequest = pojoRequest;\n-    }\n-\n-    public MinioConfiguration copy() {\n-        try {\n-            return (MinioConfiguration) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw new RuntimeCamelException(e);\n-        }\n-    }\n-}\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nnew file mode 100644\nindex 00000000000..22dc7ae8a48\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam(defaultValue = \"false\")\n+    boolean secure;\n+    private String bucketName;\n+    @UriParam\n+    private String accessKey;\n+    @UriParam\n+    private String secretKey;\n+    @UriParam(label = \"consumer\")\n+    private String fileName;\n+    @UriParam(label = \"consumer\")\n+    private String prefix;\n+    @UriParam(label = \"producer\")\n+    private String region;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean deleteAfterRead = true;\n+    @UriParam(label = \"producer\")\n+    private boolean deleteAfterWrite;\n+    @UriParam(label = \"producer\")\n+    private boolean multiPartUpload;\n+    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n+    private long partSize = 25 * 1024 * 1024;\n+    @UriParam\n+    private String policy;\n+    @UriParam(label = \"producer\")\n+    private String storageClass;\n+    @UriParam(label = \"producer\")\n+    private String serverSideEncryption;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean includeBody = true;\n+    @UriParam\n+    private boolean pathStyleAccess;\n+    @UriParam(label = \"producer\", enums = \"copyObject,deleteBucket,listBuckets\")\n+    private MinioOperations operation;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean autocloseBody = true;\n+\n+    /**\n+     * Some description of this option(isSecure), and what it does\n+     */\n+    public boolean isSecure() {\n+        return secure;\n+    }\n+\n+    public void setSecure(boolean secure) {\n+        this.secure = secure;\n+    }\n+\n+    public String getBucketName() {\n+        return bucketName;\n+    }\n+\n+    public void setBucketName(String bucketName) {\n+        this.bucketName = bucketName;\n+    }\n+\n+    /**\n+     * Some description of this option(getAccessKey), and what it does\n+     */\n+    public String getAccessKey() {\n+        return accessKey;\n+    }\n+\n+    public void setAccessKey(String accessKey) {\n+        this.accessKey = accessKey;\n+    }\n+\n+    /**\n+     * Some description of this option(getSecretKey), and what it does\n+     */\n+    public String getSecretKey() {\n+        return secretKey;\n+    }\n+\n+    public void setSecretKey(String secretKey) {\n+        this.secretKey = secretKey;\n+    }\n+\n+    /**\n+     * Some description of this option(getFileName), and what it does\n+     */\n+    public String getFileName() {\n+        return fileName;\n+    }\n+\n+    public void setFileName(String fileName) {\n+        this.fileName = fileName;\n+    }\n+\n+    /**\n+     * Some description of this option(getPrefix), and what it does\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    public void setPrefix(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    /**\n+     * Some description of this option(getRegion), and what it does\n+     */\n+    public String getRegion() {\n+        return region;\n+    }\n+\n+    public void setRegion(String region) {\n+        this.region = region;\n+    }\n+\n+    /**\n+     * Some description of this option(isDeleteAfterRead), and what it does\n+     */\n+    public boolean isDeleteAfterRead() {\n+        return deleteAfterRead;\n+    }\n+\n+    public void setDeleteAfterRead(boolean deleteAfterRead) {\n+        this.deleteAfterRead = deleteAfterRead;\n+    }\n+\n+    /**\n+     * Some description of this option(isDeleteAfterWrite), and what it does\n+     */\n+    public boolean isDeleteAfterWrite() {\n+        return deleteAfterWrite;\n+    }\n+\n+    public void setDeleteAfterWrite(boolean deleteAfterWrite) {\n+        this.deleteAfterWrite = deleteAfterWrite;\n+    }\n+\n+    /**\n+     * Some description of this option(isMultiPartUpload), and what it does\n+     */\n+    public boolean isMultiPartUpload() {\n+        return multiPartUpload;\n+    }\n+\n+    public void setMultiPartUpload(boolean multiPartUpload) {\n+        this.multiPartUpload = multiPartUpload;\n+    }\n+\n+    /**\n+     * Some description of this option(getPartSize), and what it does\n+     */\n+    public long getPartSize() {\n+        return partSize;\n+    }\n+\n+    public void setPartSize(long partSize) {\n+        this.partSize = partSize;\n+    }\n+\n+    /**\n+     * Some description of this option(getPolicy), and what it does\n+     */\n+    public String getPolicy() {\n+        return policy;\n+    }\n+\n+    public void setPolicy(String policy) {\n+        this.policy = policy;\n+    }\n+\n+    /**\n+     * Some description of this option(getStorageClass), and what it does\n+     */\n+    public String getStorageClass() {\n+        return storageClass;\n+    }\n+\n+    public void setStorageClass(String storageClass) {\n+        this.storageClass = storageClass;\n+    }\n+\n+    /**\n+     * Some description of this option(getServerSideEncryption), and what it does\n+     */\n+    public String getServerSideEncryption() {\n+        return serverSideEncryption;\n+    }\n+\n+    public void setServerSideEncryption(String serverSideEncryption) {\n+        this.serverSideEncryption = serverSideEncryption;\n+    }\n+\n+    /**\n+     * Some description of this option(isIncludeBody), and what it does\n+     */\n+    public boolean isIncludeBody() {\n+        return includeBody;\n+    }\n+\n+    public void setIncludeBody(boolean includeBody) {\n+        this.includeBody = includeBody;\n+    }\n+\n+    /**\n+     * Some description of this option(isPathStyleAccess), and what it does\n+     */\n+    public boolean isPathStyleAccess() {\n+        return pathStyleAccess;\n+    }\n+\n+    public void setPathStyleAccess(boolean pathStyleAccess) {\n+        this.pathStyleAccess = pathStyleAccess;\n+    }\n+\n+    /**\n+     * Some description of this option(getOperation), and what it does\n+     */\n+    public MinioOperations getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(MinioOperations operation) {\n+        this.operation = operation;\n+    }\n+\n+    /**\n+     * Some description of this option(isAutocloseBody), and what it does\n+     */\n+    public boolean isAutocloseBody() {\n+        return autocloseBody;\n+    }\n+\n+    public void setAutocloseBody(boolean autocloseBody) {\n+        this.autocloseBody = autocloseBody;\n+    }\n+}\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22dc7ae8a48..365aa2009a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -48,208 +65,287 @@ public class MinioConfiguration implements Cloneable {\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\")\n-    private String serverSideEncryption;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean includeBody = true;\n+    private ServerSideEncryption serverSideEncryption;\n+    @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteBucket,listBuckets,getObject,getObjectRange\")\n+    private MinioOperations operation;\n     @UriParam\n     private boolean pathStyleAccess;\n-    @UriParam(label = \"producer\", enums = \"copyObject,deleteBucket,listBuckets\")\n-    private MinioOperations operation;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autocloseBody = true;\n-\n-    /**\n-     * Some description of this option(isSecure), and what it does\n-     */\n-    public boolean isSecure() {\n-        return secure;\n-    }\n-\n-    public void setSecure(boolean secure) {\n-        this.secure = secure;\n-    }\n \n     public String getBucketName() {\n         return bucketName;\n     }\n \n+    /**\n+     * Name of the bucket. The bucket will be created if it doesn't already\n+     * exists.\n+     */\n     public void setBucketName(String bucketName) {\n         this.bucketName = bucketName;\n     }\n \n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     /**\n-     * Some description of this option(getAccessKey), and what it does\n+     * Reference to a Minio Client object in the registry.\n      */\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n     public String getAccessKey() {\n         return accessKey;\n     }\n \n+    /**\n+     * Amazon AWS Secret Access Key or Minio Access Key\n+     */\n     public void setAccessKey(String accessKey) {\n         this.accessKey = accessKey;\n     }\n \n-    /**\n-     * Some description of this option(getSecretKey), and what it does\n-     */\n     public String getSecretKey() {\n         return secretKey;\n     }\n \n+    /**\n+     * Amazon AWS Access Key Id or Minio Secret Key\n+     */\n     public void setSecretKey(String secretKey) {\n         this.secretKey = secretKey;\n     }\n \n+    public boolean isUseAWSIAMCredentials() {\n+        return useAWSIAMCredentials;\n+    }\n+\n     /**\n-     * Some description of this option(getFileName), and what it does\n+     * Set this flag true if you use AWS IAM Credentials to create MinIO client object\n      */\n-    public String getFileName() {\n-        return fileName;\n+    public void setUseAWSIAMCredentials(boolean useAWSIAMCredentials) {\n+        this.useAWSIAMCredentials = useAWSIAMCredentials;\n     }\n \n-    public void setFileName(String fileName) {\n-        this.fileName = fileName;\n+    public String getRegion() {\n+        return region;\n     }\n \n     /**\n-     * Some description of this option(getPrefix), and what it does\n+     * The region in which Minio client needs to work. When using this parameter,\n+     * the configuration will expect the lowercase name of the region (for\n+     * example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()\n      */\n+    public void setRegion(String region) {\n+        this.region = region;\n+    }\n+\n+    public String getObjectName() {\n+        return objectName;\n+    }\n+\n+    /**\n+     * To get the object from the bucket with the given object name\n+     */\n+    public void setObjectName(String objectName) {\n+        this.objectName = objectName;\n+    }\n+\n     public String getPrefix() {\n         return prefix;\n     }\n \n+    /**\n+     * Object name starts with prefix.\n+     */\n     public void setPrefix(String prefix) {\n         this.prefix = prefix;\n     }\n \n+    public boolean isRecursive() {\n+        return recursive;\n+    }\n+\n     /**\n-     * Some description of this option(getRegion), and what it does\n+     * List recursively than directory structure emulation.\n      */\n-    public String getRegion() {\n-        return region;\n+    public void setRecursive(boolean recursive) {\n+        this.recursive = recursive;\n     }\n \n-    public void setRegion(String region) {\n-        this.region = region;\n+    public boolean isUseVersion1() {\n+        return useVersion1;\n+    }\n+\n+    /**\n+     * when true, version 1 of REST API is used.\n+     */\n+    public void setUseVersion1(boolean useVersion1) {\n+        this.useVersion1 = useVersion1;\n+    }\n+\n+    public long getOffset() {\n+        return offset;\n     }\n \n     /**\n-     * Some description of this option(isDeleteAfterRead), and what it does\n+     * Start byte position of object data.\n      */\n+    public void setOffset(long offset) {\n+        this.offset = offset;\n+    }\n+\n+    /**\n+     *  Number of bytes of object data from offset.\n+     */\n+    public long getLength() {\n+        return length;\n+    }\n+\n+    public void setLength(long length) {\n+        this.length = length;\n+    }\n+\n     public boolean isDeleteAfterRead() {\n         return deleteAfterRead;\n     }\n \n+    /**\n+     * Delete objects from Minio after they have been retrieved. The delete is only\n+     * performed if the Exchange is committed. If a rollback occurs, the object\n+     * is not deleted.\n+     * <p/>\n+     * If this option is false, then the same objects will be retrieve over and\n+     * over again on the polls. Therefore you need to use the Idempotent\n+     * Consumer EIP in the route to filter out duplicates. You can filter using\n+     * the {@link MinioConstants#BUCKET_NAME} and {@link MinioConstants#KEY}\n+     * headers, or only the {@link MinioConstants#KEY} header.\n+     */\n     public void setDeleteAfterRead(boolean deleteAfterRead) {\n         this.deleteAfterRead = deleteAfterRead;\n     }\n \n+    public boolean isIncludeBody() {\n+        return includeBody;\n+    }\n+\n     /**\n-     * Some description of this option(isDeleteAfterWrite), and what it does\n+     * If it is true, the exchange body will be set to a stream to the contents\n+     * of the file. If false, the headers will be set with the Minio object\n+     * metadata, but the body will be null. This option is strongly related to\n+     * autocloseBody option. In case of setting includeBody to true and\n+     * autocloseBody to false, it will be up to the caller to close the MinioObject\n+     * stream. Setting autocloseBody to true, will close the MinioObject stream\n+     * automatically.\n      */\n+    public void setIncludeBody(boolean includeBody) {\n+        this.includeBody = includeBody;\n+    }\n+\n+    public boolean isAutocloseBody() {\n+        return autocloseBody;\n+    }\n+\n+    /**\n+     * If this option is true and includeBody is true, then the MinioObject.close()\n+     * method will be called on exchange completion. This option is strongly\n+     * related to includeBody option. In case of setting includeBody to true and\n+     * autocloseBody to false, it will be up to the caller to close the MinioObject\n+     * stream. Setting autocloseBody to true, will close the MinioObject stream\n+     * automatically.\n+     */\n+    public void setAutocloseBody(boolean autocloseBody) {\n+        this.autocloseBody = autocloseBody;\n+    }\n+\n     public boolean isDeleteAfterWrite() {\n         return deleteAfterWrite;\n     }\n \n+    /**\n+     * Delete file object after the Minio file has been uploaded\n+     */\n     public void setDeleteAfterWrite(boolean deleteAfterWrite) {\n         this.deleteAfterWrite = deleteAfterWrite;\n     }\n \n-    /**\n-     * Some description of this option(isMultiPartUpload), and what it does\n-     */\n     public boolean isMultiPartUpload() {\n         return multiPartUpload;\n     }\n \n+    /**\n+     * If it is true, camel will upload the file with multi part format, the\n+     * part size is decided by the option of `partSize`\n+     */\n     public void setMultiPartUpload(boolean multiPartUpload) {\n         this.multiPartUpload = multiPartUpload;\n     }\n \n-    /**\n-     * Some description of this option(getPartSize), and what it does\n-     */\n     public long getPartSize() {\n         return partSize;\n     }\n \n+    /**\n+     * Setup the partSize which is used in multi part upload, the default size\n+     * is 25M.\n+     */\n     public void setPartSize(long partSize) {\n         this.partSize = partSize;\n     }\n \n-    /**\n-     * Some description of this option(getPolicy), and what it does\n-     */\n     public String getPolicy() {\n         return policy;\n     }\n \n+    /**\n+     * The policy for this queue to set in the method.\n+     */\n     public void setPolicy(String policy) {\n         this.policy = policy;\n     }\n \n-    /**\n-     * Some description of this option(getStorageClass), and what it does\n-     */\n     public String getStorageClass() {\n         return storageClass;\n     }\n \n+    /**\n+     * The storage class to set in the request.\n+     */\n     public void setStorageClass(String storageClass) {\n         this.storageClass = storageClass;\n     }\n \n-    /**\n-     * Some description of this option(getServerSideEncryption), and what it does\n-     */\n-    public String getServerSideEncryption() {\n+    public ServerSideEncryption getServerSideEncryption() {\n         return serverSideEncryption;\n     }\n \n-    public void setServerSideEncryption(String serverSideEncryption) {\n-        this.serverSideEncryption = serverSideEncryption;\n-    }\n-\n     /**\n-     * Some description of this option(isIncludeBody), and what it does\n+     *  (Optional) Server-side encryption.\n      */\n-    public boolean isIncludeBody() {\n-        return includeBody;\n-    }\n-\n-    public void setIncludeBody(boolean includeBody) {\n-        this.includeBody = includeBody;\n-    }\n-\n-    /**\n-     * Some description of this option(isPathStyleAccess), and what it does\n-     */\n-    public boolean isPathStyleAccess() {\n-        return pathStyleAccess;\n-    }\n-\n-    public void setPathStyleAccess(boolean pathStyleAccess) {\n-        this.pathStyleAccess = pathStyleAccess;\n+    public void setServerSideEncryption(ServerSideEncryption serverSideEncryption) {\n+        this.serverSideEncryption = serverSideEncryption;\n     }\n \n-    /**\n-     * Some description of this option(getOperation), and what it does\n-     */\n     public MinioOperations getOperation() {\n         return operation;\n     }\n \n+    /**\n+     * The operation to do in case the user don't want to do only an upload\n+     */\n     public void setOperation(MinioOperations operation) {\n         this.operation = operation;\n     }\n \n+    public boolean isPathStyleAccess() {\n+        return pathStyleAccess;\n+    }\n+\n     /**\n-     * Some description of this option(isAutocloseBody), and what it does\n+     * Some description of this option(isPathStyleAccess), and what it does\n      */\n-    public boolean isAutocloseBody() {\n-        return autocloseBody;\n+    public void setPathStyleAccess(boolean pathStyleAccess) {\n+        this.pathStyleAccess = pathStyleAccess;\n     }\n \n-    public void setAutocloseBody(boolean autocloseBody) {\n-        this.autocloseBody = autocloseBody;\n-    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 365aa2009a0..5a0640c8e6f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -347,5 +506,4 @@ public class MinioConfiguration implements Cloneable {\n     public void setPathStyleAccess(boolean pathStyleAccess) {\n         this.pathStyleAccess = pathStyleAccess;\n     }\n-\n }\n", "next_change": {"commit": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 5a0640c8e6f..c3065908c39 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -506,4 +527,37 @@ public class MinioConfiguration implements Cloneable {\n     public void setPathStyleAccess(boolean pathStyleAccess) {\n         this.pathStyleAccess = pathStyleAccess;\n     }\n+\n+    public boolean isPojoRequest() {\n+        return pojoRequest;\n+    }\n+\n+    /**\n+     * If we want to use a POJO request as body or not\n+     */\n+    public void setPojoRequest(boolean pojoRequest) {\n+        this.pojoRequest = pojoRequest;\n+    }\n+\n+    public String getVersionId() {\n+        return versionId;\n+    }\n+\n+    /**\n+     * Set specific version_ID of a object when deleting the object\n+     */\n+    public void setVersionId(String versionId) {\n+        this.versionId = versionId;\n+    }\n+\n+    public boolean isBypassGovernanceMode() {\n+        return bypassGovernanceMode;\n+    }\n+\n+    /**\n+     * Set this flag if you want to bypassGovernanceMode when deleting a particular object\n+     */\n+    public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n+        this.bypassGovernanceMode = bypassGovernanceMode;\n+    }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex c3065908c39..b866c41376f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -560,4 +629,12 @@ public class MinioConfiguration implements Cloneable {\n     public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n         this.bypassGovernanceMode = bypassGovernanceMode;\n     }\n+\n+    public MinioConfiguration copy() {\n+        try {\n+            return (MinioConfiguration)super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new RuntimeCamelException(e);\n+        }\n+    }\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex b866c41376f..18ac4042a9a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -632,7 +633,7 @@ public class MinioConfiguration implements Cloneable {\n \n     public MinioConfiguration copy() {\n         try {\n-            return (MinioConfiguration)super.clone();\n+            return (MinioConfiguration) super.clone();\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeCamelException(e);\n         }\n", "next_change": {"commit": "585e4deebddd6999431c35a3b5a8f3ce72f1f974", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 18ac4042a9a..e3e6b94a989 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -603,34 +621,12 @@ public class MinioConfiguration implements Cloneable {\n     }\n \n     /**\n-     * If we want to use a POJO request as body or not\n+     * If we want to use a POJO request as body or not.\n      */\n     public void setPojoRequest(boolean pojoRequest) {\n         this.pojoRequest = pojoRequest;\n     }\n \n-    public String getVersionId() {\n-        return versionId;\n-    }\n-\n-    /**\n-     * Set specific version_ID of a object when deleting the object\n-     */\n-    public void setVersionId(String versionId) {\n-        this.versionId = versionId;\n-    }\n-\n-    public boolean isBypassGovernanceMode() {\n-        return bypassGovernanceMode;\n-    }\n-\n-    /**\n-     * Set this flag if you want to bypassGovernanceMode when deleting a particular object\n-     */\n-    public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n-        this.bypassGovernanceMode = bypassGovernanceMode;\n-    }\n-\n     public MinioConfiguration copy() {\n         try {\n             return (MinioConfiguration) super.clone();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..ee18fe1d920 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -29,36 +29,35 @@ import org.apache.camel.spi.UriParams;\n @UriParams\n public class MinioConfiguration implements Cloneable {\n \n-    @UriParam\n+    @UriParam(label = \"common\")\n     private String endpoint;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private Integer proxyPort;\n+    @UriParam(label = \"common\")\n+    private boolean secure;\n+    @UriParam(label = \"common\")\n+    private String region;\n+    @UriParam(label = \"common\")\n+    private OkHttpClient customHttpClient;\n \n     @UriParam(label = \"security\", secret = true)\n     private String accessKey;\n     @UriParam(label = \"security\", secret = true)\n     private String secretKey;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean secure;\n-\n-    @UriParam\n-    private String region;\n-\n-    @UriParam\n-    private OkHttpClient customHttpClient;\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n \n     private String bucketName;\n-    @UriParam(defaultValue = \"true\")\n+    @UriParam(label = \"common\", defaultValue = \"true\")\n     private boolean autoCreateBucket = true;\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n     private boolean objectLock;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n+    private String policy;\n+    @UriParam(label = \"common\")\n     private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private ServerSideEncryption serverSideEncryption;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n     @UriParam(label = \"consumer\")\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex ee18fe1d920..4e37e980bcd 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -60,6 +64,10 @@ public class MinioConfiguration implements Cloneable {\n     @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n     @UriParam(label = \"consumer\")\n     private String objectName;\n     @UriParam(label = \"consumer\")\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "0addeb0da4c77837ade865e237aefde4cee4b50e", "committedDate": "2020-11-27 09:07:24 +0000", "message": "CAMEL-15836: Add autowired metadata to camel-minio minioClient option"}, {"oid": "6c8ae5862ec0fc88d1fa4056258c73da26e99c7c", "committedDate": "2022-12-05 13:06:13 +0100", "message": "[doc] Fix MinIO bucket and object destination (#8834)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyOTQyOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460729429", "body": "Please avoid wildcard import", "bodyText": "Please avoid wildcard import", "bodyHTML": "<p dir=\"auto\">Please avoid wildcard import</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:31:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,8 +16,15 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n \n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n", "next_change": {"commit": "5ce02877a27e4c44242760f1bd7af412bd220664", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..b88ab25b4db 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -26,12 +26,15 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Queue;\n \n+import io.minio.BucketExistsArgs;\n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n import io.minio.GetObjectArgs;\n import io.minio.ListObjectsArgs;\n+import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n import io.minio.messages.Contents;\n import io.minio.messages.ListBucketResultV2;\n", "next_change": {"commit": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex b88ab25b4db..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -34,10 +34,10 @@ import io.minio.ListObjectsArgs;\n import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n+import io.minio.Result;\n import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n+import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..8f7c624c95b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,28 +16,18 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Queue;\n-\n-import io.minio.BucketExistsArgs;\n+import java.util.*;\n+\n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n import io.minio.GetObjectArgs;\n import io.minio.ListObjectsArgs;\n-import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n-import io.minio.Result;\n-import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Item;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 8f7c624c95b..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,364 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.InputStream;\n-import java.util.*;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (getConfiguration().getDelimiter() != null) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (getConfiguration().getPrefix() != null) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (getConfiguration().getStartAfter() != null) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (continuationToken != null) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n-\n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n-\n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-\n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n-\n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-            }\n-        } catch (MinioException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n-        }\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n         try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n-\n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n-\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n-\n-            getMinioClient().copyObject(copyObjectRequest.build());\n-\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n         } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n-\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (cause != null) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioConsumerToString == null) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            }\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..8f7c624c95b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -45,14 +35,11 @@ import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.util.CastUtils;\n import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-import static org.apache.camel.util.ObjectHelper.cast;\n-\n /**\n  * A Consumer of messages from the Minio Storage Service.\n  */\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 8f7c624c95b..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -40,6 +47,9 @@ import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isEmpty;\n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * A Consumer of messages from the Minio Storage Service.\n  */\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,18 +16,28 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n-\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import io.minio.BucketExistsArgs;\n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n import io.minio.GetObjectArgs;\n import io.minio.ListObjectsArgs;\n+import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n+import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n", "next_change": {"commit": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..df0a7d9d105 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -35,7 +35,6 @@ import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n import io.minio.RemoveObjectArgs;\n import io.minio.Result;\n-import io.minio.errors.InvalidBucketNameException;\n import io.minio.errors.MinioException;\n import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex df0a7d9d105..e98b295b961 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -39,9 +39,11 @@ import io.minio.errors.MinioException;\n import io.minio.messages.Item;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.CastUtils;\n import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.URISupport;\n", "next_change": {"commit": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex e98b295b961..b3cc1c85157 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -42,6 +42,7 @@ import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.EmptyAsyncCallback;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.CastUtils;\n", "next_change": {"commit": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex b3cc1c85157..f82d5fd3385 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -48,6 +49,7 @@ import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.CastUtils;\n import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.URISupport;\n+import org.apache.commons.compress.utils.IOUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731257", "body": "Should we handle this exception as well?", "bodyText": "Should we handle this exception as well?", "bodyHTML": "<p dir=\"auto\">Should we handle this exception as well?</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:34:15Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODI0Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088247", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().removeObject(removeObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2OTIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464269216", "bodyText": "What I mean here, does it make sense to handle it through  getExceptionHandler().handleException", "author": "omarsmak", "createdAt": "2020-08-03T08:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxNDAyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464614021", "bodyText": "Hi, @omarsmak I was mimicking this line. should I keep this or change it to maybe LOG.warn?", "author": "Nayananga", "createdAt": "2020-08-03T19:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4NjIxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464886215", "bodyText": "@Nayananga my question is about catching Exception e, do you need your consumer to ignore all exceptions (as the case now) or you need your consumer to throw  and halt camel process in case minio client throw any exceptions other than MinioException? My gut feeling, you may just need to remove catch (Exception e) block and only handle MinioException as you are currently doing, by that camel will halt its process in any unexpected process.", "author": "omarsmak", "createdAt": "2020-08-04T08:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNTU3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466215578", "bodyText": "Hi @omarsmak, thank you for your suggestion. I did some changes :)", "author": "Nayananga", "createdAt": "2020-08-06T07:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,88 +254,62 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n+        if (isEmpty(destinationBucketName)) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n-\n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n+        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..8f7c624c95b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -254,62 +260,86 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n+        } catch (MinioException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+    private void copyObject(String srcBucketName, String srcObjectName) {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n+        if (destinationBucketName == null) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n+        try {\n+            // set destination object name as source object name, if not specified\n+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                    ? getConfiguration().getDestinationObjectName()\n+                    : srcObjectName;\n \n \n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n+            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n \n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+            }\n+            if (getConfiguration().getOffset() != 0) {\n+                copySourceBuilder.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                copySourceBuilder.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                copySourceBuilder.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+            }\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .source(copySourceBuilder.build())\n+                    .bucket(getConfiguration().getDestinationBucketName())\n+                    .object(destinationObjectName);\n \n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n+            }\n+\n+            getMinioClient().copyObject(copyObjectRequest.build());\n \n-        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n+        } catch (Exception e) {\n+            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n+        }\n \n-        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 8f7c624c95b..0ad908b0861 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,86 +267,79 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (getConfiguration().getVersionId() != null) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n         if (destinationBucketName == null) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n-\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() > 0) {\n+            copySourceBuilder.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() > 0) {\n+            copySourceBuilder.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            copySourceBuilder.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n \n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n+        if (getConfiguration().getServerSideEncryption() != null) {\n+            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n         }\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 0ad908b0861..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -335,7 +338,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 .bucket(getConfiguration().getDestinationBucketName())\n                 .object(destinationObjectName);\n \n-        if (getConfiguration().getServerSideEncryption() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n             copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,88 +307,62 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n+        if (isEmpty(destinationBucketName)) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n \n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n+        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -340,27 +348,30 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 ? getConfiguration().getDestinationObjectName()\n                 : srcObjectName;\n \n-\n         LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n                 srcBucketName, srcObjectName, destinationBucketName);\n \n         CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                copySourceBuilder::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, copySourceBuilder::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, copySourceBuilder::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, copySourceBuilder::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, copySourceBuilder::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag,\n+                copySourceBuilder::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                copySourceBuilder::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                copySourceBuilder::unmodifiedSince);\n \n         CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n                 .source(copySourceBuilder.build())\n                 .bucket(getConfiguration().getDestinationBucketName())\n                 .object(destinationObjectName);\n \n-        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryption, copyObjectRequest::sse);\n \n         getMinioClient().copyObject(copyObjectRequest.build());\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731754", "body": "Same here, should handle this exception as well?", "bodyText": "Same here, should handle this exception as well?", "bodyHTML": "<p dir=\"auto\">Same here, should handle this exception as well?</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:35:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");\n+        }\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) {\n+        String destinationBucketName = getConfiguration().getDestinationBucketName();\n+        if (destinationBucketName == null) {\n+            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n+        }\n+\n+        try {\n+            // set destination object name as source object name, if not specified\n+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                    ? getConfiguration().getDestinationObjectName()\n+                    : srcObjectName;\n+\n+\n+            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+            }\n+            if (getConfiguration().getOffset() != 0) {\n+                copySourceBuilder.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                copySourceBuilder.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                copySourceBuilder.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+            }\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .source(copySourceBuilder.build())\n+                    .bucket(getConfiguration().getDestinationBucketName())\n+                    .object(destinationObjectName);\n+\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n+            }\n+\n+            getMinioClient().copyObject(copyObjectRequest.build());\n+\n+        } catch (Exception e) {\n+            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODM1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088357", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().copyObject(copyObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDUyMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464620523", "bodyText": "I'll remove this error handle since this is redundant", "author": "Nayananga", "createdAt": "2020-08-03T19:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,88 +254,62 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n+        if (isEmpty(destinationBucketName)) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n-\n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n+        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..8f7c624c95b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -254,62 +260,86 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n+        } catch (MinioException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+    private void copyObject(String srcBucketName, String srcObjectName) {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n+        if (destinationBucketName == null) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n+        try {\n+            // set destination object name as source object name, if not specified\n+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                    ? getConfiguration().getDestinationObjectName()\n+                    : srcObjectName;\n \n \n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n+            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n \n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+            }\n+            if (getConfiguration().getOffset() != 0) {\n+                copySourceBuilder.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                copySourceBuilder.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                copySourceBuilder.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+            }\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .source(copySourceBuilder.build())\n+                    .bucket(getConfiguration().getDestinationBucketName())\n+                    .object(destinationObjectName);\n \n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n+            }\n+\n+            getMinioClient().copyObject(copyObjectRequest.build());\n \n-        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n+        } catch (Exception e) {\n+            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n+        }\n \n-        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 8f7c624c95b..0ad908b0861 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,86 +267,79 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (getConfiguration().getVersionId() != null) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n         if (destinationBucketName == null) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n-\n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() > 0) {\n+            copySourceBuilder.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() > 0) {\n+            copySourceBuilder.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            copySourceBuilder.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n \n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n+        if (getConfiguration().getServerSideEncryption() != null) {\n+            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n         }\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 0ad908b0861..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -335,7 +338,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 .bucket(getConfiguration().getDestinationBucketName())\n                 .object(destinationObjectName);\n \n-        if (getConfiguration().getServerSideEncryption() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n             copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -260,88 +307,62 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 }\n \n                 LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-\n-                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                        .bucket(srcBucketName)\n-                        .object(srcObjectName)\n-                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-                if (getConfiguration().getVersionId() != null) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                if (getConfiguration().isBypassGovernanceMode()) {\n-                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n-                }\n-                getMinioClient().removeObject(removeObjectRequest.build());\n-\n+                removeObject(srcBucketName, srcObjectName);\n                 LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n             }\n-        } catch (MinioException e) {\n+        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n             getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n                     exchange, e);\n-        } catch (Exception e) {\n-            LOG.trace(\"Error process commit...\");\n         }\n     }\n \n-    private void copyObject(String srcBucketName, String srcObjectName) {\n+    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n+        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                .bucket(srcBucketName)\n+                .object(srcObjectName)\n+                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n+            removeObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+\n+        getMinioClient().removeObject(removeObjectRequest.build());\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n         String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (destinationBucketName == null) {\n+        if (isEmpty(destinationBucketName)) {\n             throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n         }\n \n-        try {\n-            // set destination object name as source object name, if not specified\n-            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n-                    ? getConfiguration().getDestinationObjectName()\n-                    : srcObjectName;\n-\n+        // set destination object name as source object name, if not specified\n+        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n+                ? getConfiguration().getDestinationObjectName()\n+                : srcObjectName;\n \n-            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-            }\n-            if (getConfiguration().getOffset() != 0) {\n-                copySourceBuilder.offset(getConfiguration().getOffset());\n-            }\n-            if (getConfiguration().getLength() != 0) {\n-                copySourceBuilder.length(getConfiguration().getLength());\n-            }\n-            if (getConfiguration().getVersionId() != null) {\n-                copySourceBuilder.versionId(getConfiguration().getVersionId());\n-            }\n-            if (getConfiguration().getMatchETag() != null) {\n-                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-            }\n-            if (getConfiguration().getNotMatchETag() != null) {\n-                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-            }\n-            if (getConfiguration().getModifiedSince() != null) {\n-                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-            }\n-            if (getConfiguration().getUnModifiedSince() != null) {\n-                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-            }\n+        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                srcBucketName, srcObjectName, destinationBucketName);\n \n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .source(copySourceBuilder.build())\n-                    .bucket(getConfiguration().getDestinationBucketName())\n-                    .object(destinationObjectName);\n+        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-            if (getConfiguration().getServerSideEncryption() != null) {\n-                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-            }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n \n-            getMinioClient().copyObject(copyObjectRequest.build());\n+        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                .source(copySourceBuilder.build())\n+                .bucket(getConfiguration().getDestinationBucketName())\n+                .object(destinationObjectName);\n \n-        } catch (Exception e) {\n-            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",\n-                    srcBucketName, srcObjectName, destinationBucketName);\n-        }\n+        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n \n+        getMinioClient().copyObject(copyObjectRequest.build());\n     }\n \n     /**\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -340,27 +348,30 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n                 ? getConfiguration().getDestinationObjectName()\n                 : srcObjectName;\n \n-\n         LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n                 srcBucketName, srcObjectName, destinationBucketName);\n \n         CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), copySourceBuilder::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), copySourceBuilder::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), copySourceBuilder::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), copySourceBuilder::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), copySourceBuilder::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), copySourceBuilder::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), copySourceBuilder::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), copySourceBuilder::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                copySourceBuilder::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, copySourceBuilder::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, copySourceBuilder::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, copySourceBuilder::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, copySourceBuilder::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag,\n+                copySourceBuilder::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                copySourceBuilder::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                copySourceBuilder::unmodifiedSince);\n \n         CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n                 .source(copySourceBuilder.build())\n                 .bucket(getConfiguration().getDestinationBucketName())\n                 .object(destinationObjectName);\n \n-        MinioChecks.checkServerSideEncryptionConfig(getConfiguration(), copyObjectRequest::sse);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryption, copyObjectRequest::sse);\n \n         getMinioClient().copyObject(copyObjectRequest.build());\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MDMyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460740321", "body": "I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to `> 0` instead. Same for the other checks", "bodyText": "I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to > 0 instead. Same for the other checks", "bodyHTML": "<p dir=\"auto\">I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to <code>&gt; 0</code> instead. Same for the other checks</p>", "author": "omarsmak", "createdAt": "2020-07-27T08:49:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,30 +186,14 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..8f7c624c95b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -186,14 +176,30 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 8f7c624c95b..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,28 +186,28 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             getObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             getObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             getObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             getObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,30 +239,14 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -239,14 +242,17 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                getObjectRequest::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, getObjectRequest::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, getObjectRequest::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, getObjectRequest::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, getObjectRequest::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag, getObjectRequest::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                getObjectRequest::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex bfa3be1d631..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -258,20 +246,41 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": {"commit": "43a6574cbd699733dd174f60dcc5a87c68068e21", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 562d499a574..49647d77814 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -282,7 +285,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             }\n \n             // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+            exchange.getExchangeExtension().addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n                     processCommit(exchange);\n                 }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0Nzk0OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460747948", "body": "Perhaps we can use `isNotEmpty` from `org.apache.camel.util.ObjectHelper` to check for nulls or emptyness", "bodyText": "Perhaps we can use isNotEmpty from org.apache.camel.util.ObjectHelper to check for nulls or emptyness", "bodyHTML": "<p dir=\"auto\">Perhaps we can use <code>isNotEmpty</code> from <code>org.apache.camel.util.ObjectHelper</code> to check for nulls or emptyness</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:01:43Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,30 +186,14 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 686af10f67f..8f7c624c95b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -186,14 +176,30 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 8f7c624c95b..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,28 +186,28 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             getObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             getObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             getObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             getObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 26e08745c67..1e3c6597553 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,367 +16,60 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.errors.MinioException;\n-import io.minio.messages.Contents;\n-import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n-import org.apache.camel.ExtendedExchange;\n import org.apache.camel.Processor;\n-import org.apache.camel.spi.Synchronization;\n-import org.apache.camel.support.ScheduledBatchPollingConsumer;\n-import org.apache.camel.util.CastUtils;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultConsumer;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+public class MinioConsumer extends DefaultConsumer {\n+    private final MinioEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n \n-/**\n- * A Consumer of messages from the Minio Storage Service.\n- */\n-public class MinioConsumer extends ScheduledBatchPollingConsumer {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n-\n-    private String continuationToken;\n-    private transient String minioConsumerToString;\n+    private ExecutorService executorService;\n \n     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n         super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected int poll() throws Exception {\n-        // must reset for each poll\n-        shutdownRunningTask = null;\n-        pendingExchanges = 0;\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        String objectName = getConfiguration().getObjectName();\n-        MinioClient minioClient = getMinioClient();\n-        Queue<Exchange> exchanges;\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n-\n-            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n-            exchanges = createExchanges(minioObject, objectName);\n-\n-        } else {\n-\n-            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n-\n-            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n-                    .includeVersions(getConfiguration().isIncludeVersions())\n-                    .recursive(getConfiguration().isRecursive())\n-                    .useApiVersion1(getConfiguration().isUseVersion1());\n-\n-            if (isNotEmpty(getConfiguration().getDelimiter())) {\n-                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n-            }\n-\n-            if (maxMessagesPerPoll > 0) {\n-                listObjectRequest.maxKeys(maxMessagesPerPoll);\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getPrefix())) {\n-                listObjectRequest.prefix(getConfiguration().getPrefix());\n-            }\n-\n-            if (isNotEmpty(getConfiguration().getStartAfter())) {\n-                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n-            }\n-\n-            // if there was a marker from previous poll then use that to\n-            // continue from where we left last time\n-            if (isNotEmpty(continuationToken)) {\n-                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n-                listObjectRequest.continuationToken(continuationToken);\n-            }\n-\n-            // TODO: Check for validity of the statement\n-            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n-\n-            if (listObjects.isTruncated()) {\n-                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n-                continuationToken = listObjects.nextContinuationToken();\n-\n-            } else {\n-                // no more data so clear marker\n-                continuationToken = null;\n-            }\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n-            }\n+    protected void doStart() throws Exception {\n+        super.doStart();\n \n-            exchanges = createExchanges(listObjects.contents());\n-        }\n-        return processBatch(CastUtils.cast(exchanges));\n-    }\n-\n-    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n-        Queue<Exchange> answer = new LinkedList<>();\n-        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n-        answer.add(exchange);\n-        IOHelper.close(objectStream);\n-        return answer;\n-    }\n-\n-    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n-        if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n-        }\n-        String bucketName = getConfiguration().getBucketName();\n-        Collection<InputStream> minioObjects = new ArrayList<>();\n-        Queue<Exchange> answer = new LinkedList<>();\n-        try {\n-            if (getConfiguration().isIncludeFolders()) {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                    minioObjects.add(minioObject);\n-                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                    answer.add(exchange);\n-                }\n-            } else {\n-                for (Contents minioObjectSummary : minioObjectSummaries) {\n-                    // ignore if directory\n-                    if (!minioObjectSummary.isDir()) {\n-                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n-                        minioObjects.add(minioObject);\n-                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n-                        answer.add(exchange);\n-                    }\n-                }\n-            }\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n-            throw e;\n-\n-        } finally {\n-            // ensure all previous gathered minio objects are closed\n-            // if there was an exception creating the exchanges in this batch\n-            minioObjects.forEach(IOHelper::close);\n-        }\n-\n-        return answer;\n-    }\n-\n-    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n-        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        // start a single threaded pool to monitor events\n+        executorService = endpoint.createExecutor();\n \n-        return minioClient.getObject(getObjectRequest.build());\n+        // submit task to the thread pool\n+        executorService.submit(() -> {\n+            // subscribe to an event\n+            eventBusHelper.subscribe(this::onEventListener);\n+        });\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n-        int total = exchanges.size();\n+    protected void doStop() throws Exception {\n+        super.doStop();\n \n-        for (int index = 0; index < total && isBatchAllowed(); index++) {\n-            // only loop if we are started (allowed to run)\n-            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n-            // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n-\n-            // update pending number of exchanges\n-            pendingExchanges = total - index - 1;\n-\n-            // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n-                public void onComplete(Exchange exchange) {\n-                    processCommit(exchange);\n-                }\n-\n-                public void onFailure(Exchange exchange) {\n-                    processRollback(exchange);\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return \"MinioConsumerOnCompletion\";\n-                }\n-            });\n-\n-            LOG.trace(\"Processing exchange ...\");\n-            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n-        }\n-\n-        return total;\n+        // shutdown the thread pool gracefully\n+        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n     }\n \n-    /**\n-     * Strategy to delete the message after being processed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processCommit(Exchange exchange) {\n-        try {\n-            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+    private void onEventListener(final Object event) {\n+        final Exchange exchange = endpoint.createExchange();\n \n-            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n-                if (getConfiguration().isMoveAfterRead()) {\n-                    copyObject(srcBucketName, srcObjectName);\n-                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n-                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n-                }\n+        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n \n-                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n-                removeObject(srcBucketName, srcObjectName);\n-                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+        try {\n+            // send message to next processor in the route\n+            getProcessor().process(exchange);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            if (exchange.getException() != null) {\n+                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n-        } catch (MinioException | NoSuchAlgorithmException | InvalidKeyException | IOException e) {\n-            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n-                    exchange, e);\n-        }\n-    }\n-\n-    private void removeObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n-                .bucket(srcBucketName)\n-                .object(srcObjectName)\n-                .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n-\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            removeObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-\n-        getMinioClient().removeObject(removeObjectRequest.build());\n-    }\n-\n-    private void copyObject(String srcBucketName, String srcObjectName) throws MinioException, IOException, InvalidKeyException, NoSuchAlgorithmException {\n-        String destinationBucketName = getConfiguration().getDestinationBucketName();\n-        if (isEmpty(destinationBucketName)) {\n-            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n-        }\n-\n-        // set destination object name as source object name, if not specified\n-        String destinationObjectName = (isNotEmpty(getConfiguration().getDestinationObjectName()))\n-                ? getConfiguration().getDestinationObjectName()\n-                : srcObjectName;\n-\n-\n-        LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n-                srcBucketName, srcObjectName, destinationBucketName);\n-\n-        CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            copySourceBuilder.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            copySourceBuilder.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            copySourceBuilder.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                .source(copySourceBuilder.build())\n-                .bucket(getConfiguration().getDestinationBucketName())\n-                .object(destinationObjectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryption())) {\n-            copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n-        }\n-\n-        getMinioClient().copyObject(copyObjectRequest.build());\n-    }\n-\n-    /**\n-     * Strategy when processing the exchange failed.\n-     *\n-     * @param exchange the exchange\n-     */\n-    protected void processRollback(Exchange exchange) {\n-        Exception cause = exchange.getException();\n-        if (isNotEmpty(cause)) {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n-        } else {\n-            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n-        }\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    protected MinioClient getMinioClient() {\n-        return getEndpoint().getMinioClient();\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioConsumerToString)) {\n-            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n-        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 1e3c6597553..6cd523bc736 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,57 +16,33 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.concurrent.ExecutorService;\n+import java.util.Date;\n \n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-public class MinioConsumer extends DefaultConsumer {\n+/**\n+ * The Minio consumer.\n+ */\n+public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n     private final MinioEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n \n-    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n         super(endpoint, processor);\n         this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n     }\n \n     @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n+    protected int poll() throws Exception {\n+        org.apache.camel.Exchange exchange = endpoint.createExchange();\n \n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n+        // create a message body\n+        Date now = new Date();\n+        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n \n         try {\n             // send message to next processor in the route\n             getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n+            return 1; // number of messages polled\n         } finally {\n+            // log exception if an exception occurred and was not handled\n             if (exchange.getException() != null) {\n                 getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n             }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 6cd523bc736..78c7b72a228 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -16,36 +16,271 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Date;\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * The Minio consumer.\n+ * A Consumer of messages from the Minio Storage Service.\n  */\n-public class MinioConsumer extends org.apache.camel.support.ScheduledPollConsumer {\n-    private final MinioEndpoint endpoint;\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n \n-    public MinioConsumer(MinioEndpoint endpoint, org.apache.camel.Processor processor) {\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n         super(endpoint, processor);\n-        this.endpoint = endpoint;\n     }\n \n     @Override\n     protected int poll() throws Exception {\n-        org.apache.camel.Exchange exchange = endpoint.createExchange();\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (marker == null) {\n+                marker = results.iterator();\n+            }\n+            exchanges = pollMarker(bucketName, minioClient);\n+\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", ((Collection<?>) results).size(), bucketName);\n+            }\n+\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    private Queue<Object> pollMarker(String bucketName, MinioClient minioClient) throws Exception {\n+        LOG.trace(\"Resuming from marker: {}\", marker);\n+        Queue<Object> bucketQueue = null;\n+        while (marker.hasNext()) {\n+            Item item = marker.next().get();\n+            LOG.trace(\"Getting object name: [{}] in [{}]\", item.objectName(), bucketName);\n+            try {\n+                InputStream resumeStream = minioClient.getObject(bucketName,\n+                        item.objectName(),\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                bucketQueue.add(createExchanges(resumeStream, item.objectName()));\n+\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, item.objectName(), e);\n+            }\n+        }\n+        // no more data so clear marker\n+        marker = null;\n+        return bucketQueue;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream stream, String key) {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(minioObject, key);\n+        answer.add(exchange);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<MinioObject> minioObjectSummaries) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+\n+        Collection<ResponseInputStream<GetObjectResponse>> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            for (MinioObject minioObjectSummary : minioObjectSummaries) {\n+                ResponseInputStream<GetObjectResponse> minioObject = getAmazonMinioClient()\n+                        .getObject(GetObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(minioObjectSummary.key()).build(), ResponseTransformer.toInputStream());\n+\n+                if (includeMinioObject(minioObject)) {\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.key());\n+                    answer.add(exchange);\n+                }\n+            }\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage(), e);\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+            throw e;\n+        }\n+\n+        return answer;\n+    }\n \n-        // create a message body\n-        Date now = new Date();\n-        exchange.getIn().setBody(\"Hello World! The time is \" + now);\n+    /**\n+     * Decide whether to include the MinioObjects in the results\n+     *\n+     * @param minioObject\n+     * @return true to include, false to exclude\n+     */\n+    protected boolean includeMinioObject(ResponseInputStream<GetObjectResponse> minioObject) {\n \n+        if (getConfiguration().isIncludeFolders()) {\n+            return true;\n+        } else {\n+            //Config says to ignore folders/directories\n+            return !\"application/x-directory\".equalsIgnoreCase(minioObject.response().contentType());\n+        }\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange [{}]...\", exchange);\n+            getAsyncProcessor().process(exchange, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    LOG.trace(\"Processing exchange [{}] done.\", exchange);\n+                }\n+            });\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n         try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-            return 1; // number of messages polled\n-        } finally {\n-            // log exception if an exception occurred and was not handled\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n+            if (getConfiguration().isMoveAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Moving object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n+\n+                getMinioClient().copyObject(CopyObjectRequest.builder().destinationKey(key).destinationBucket(getConfiguration().getDestinationBucket()).copySource(bucketName + \"/\" + key).build());\n+\n+                LOG.trace(\"Moved object from bucket {} with key {} to bucket {}...\", bucketName, key, getConfiguration().getDestinationBucket());\n             }\n+            if (getConfiguration().isDeleteAfterRead()) {\n+                String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+                String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+\n+                LOG.trace(\"Deleting object from bucket {} with key {}...\", bucketName, key);\n+\n+                getMinioClient().deleteObject(DeleteObjectRequest.builder().bucket(getConfiguration().getBucketName()).key(key).build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with key {}...\", bucketName, key);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\", exchange, e);\n+        }\n+    }\n+\n+    /**\n+     * Strategy when processing the exchange failed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processRollback(Exchange exchange) {\n+        Exception cause = exchange.getException();\n+        if (cause != null) {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange, cause);\n+        } else {\n+            LOG.warn(\"Exchange failed, so rolling back message status: {}\", exchange);\n+        }\n+    }\n+\n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n+\n+    protected MinioClient getMinioClient() {\n+        return getEndpoint().getMinioClient();\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (minioConsumerToString == null) {\n+            minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n+        return minioConsumerToString;\n     }\n }\n", "next_change": {"commit": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..26e08745c67 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -278,7 +374,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n \n     @Override\n     public String toString() {\n-        if (minioConsumerToString == null) {\n+        if (isEmpty(minioConsumerToString)) {\n             minioConsumerToString = \"MinioConsumer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n         }\n         return minioConsumerToString;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..37896ce9cd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -176,30 +239,14 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            getObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            getObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            getObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 37896ce9cd8..bfa3be1d631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -239,14 +242,17 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n         GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), getObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), getObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), getObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), getObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), getObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), getObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), getObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), getObjectRequest::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                getObjectRequest::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, getObjectRequest::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, getObjectRequest::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, getObjectRequest::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, getObjectRequest::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag, getObjectRequest::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                getObjectRequest::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                getObjectRequest::unmodifiedSince);\n \n         return minioClient.getObject(getObjectRequest.build());\n     }\n", "next_change": {"commit": "7de327d91eb6b238a4c937a31962932e9178c9dc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex bfa3be1d631..562d499a574 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -258,20 +246,41 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n     }\n \n     @Override\n-    public int processBatch(Queue<Object> exchanges) {\n+    public int processBatch(Queue<Object> exchanges) throws Exception {\n         int total = exchanges.size();\n \n         for (int index = 0; index < total && isBatchAllowed(); index++) {\n             // only loop if we are started (allowed to run)\n             final Exchange exchange = cast(Exchange.class, exchanges.poll());\n             // add current index and total as properties\n-            exchange.setProperty(Exchange.BATCH_INDEX, index);\n-            exchange.setProperty(Exchange.BATCH_SIZE, total);\n-            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, index);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, total);\n+            exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, index == total - 1);\n \n             // update pending number of exchanges\n             pendingExchanges = total - index - 1;\n \n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+            if (getConfiguration().isIncludeBody()) {\n+                InputStream minioObject;\n+                try {\n+                    minioObject = getObject(srcBucketName, getMinioClient(), srcObjectName);\n+                    exchange.getIn().setBody(IOUtils.toByteArray(minioObject));\n+                    if (getConfiguration().isAutoCloseBody()) {\n+                        exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                            @Override\n+                            public void onDone(Exchange exchange) {\n+                                IOHelper.close(minioObject);\n+                            }\n+                        });\n+                    }\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+                    throw e;\n+                }\n+            }\n+\n             // add on completion to handle after work when the exchange is done\n             exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n", "next_change": {"commit": "43a6574cbd699733dd174f60dcc5a87c68068e21", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 562d499a574..49647d77814 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n", "chunk": "@@ -282,7 +285,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {\n             }\n \n             // add on completion to handle after work when the exchange is done\n-            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+            exchange.getExchangeExtension().addOnCompletion(new Synchronization() {\n                 public void onComplete(Exchange exchange) {\n                     processCommit(exchange);\n                 }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "e2d8627878e99045c7fbb34605d927d24bd07ee5", "committedDate": "2021-03-10 09:40:47 +0100", "message": "CAMEL-16319: camel-core - Optimize consumer default done callback to reduce object allocations."}, {"oid": "e37cffe2d94ceb0828b5696fd1e1548de2bca8a3", "committedDate": "2021-03-12 09:08:55 +0100", "message": "CAMEL-16326: camel-core - Optimize usage of exchanage properties for state in routing engine."}, {"oid": "655d7f2f5ad05c8346ae2ddc50f9257fb93314c7", "committedDate": "2021-03-19 14:31:14 +0100", "message": "Avoid catching Throwable (#5246)"}, {"oid": "3305678a8ad055efa4afe5a16fc7cd12b6853b63", "committedDate": "2021-03-29 14:02:36 +0200", "message": "CAMEL-16423 - Camel-Minio converts any body consumed to String"}, {"oid": "7de327d91eb6b238a4c937a31962932e9178c9dc", "committedDate": "2022-06-01 06:38:33 +0200", "message": "CAMEL-17100: minio consumer is slow at starting. Change the minio object loading at beginning to exchange by exchange (#7691)"}, {"oid": "62fd4017653de963446a67b34e6784858987bc8d", "committedDate": "2022-06-08 06:24:32 +0200", "message": "fix(minio): fix polling working half the time because of continuationToken which restart previous polling (#7720)"}, {"oid": "43a6574cbd699733dd174f60dcc5a87c68068e21", "committedDate": "2023-02-14 13:53:30 +0100", "message": "CAMEL-15105: rework handling addOnCompletions on Exchanges in several components"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MDQxMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460750413", "body": "I don't see any reason to null the client here, isn't? ", "bodyText": "I don't see any reason to null the client here, isn't?", "bodyHTML": "<p dir=\"auto\">I don't see any reason to null the client here, isn't?</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:06:05Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -118,18 +122,13 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             }\n         }\n \n-        if (getConfiguration().getPolicy() != null) {\n+        if (isNotEmpty(getConfiguration().getPolicy())) {\n             setBucketPolicy(bucketName);\n         }\n     }\n \n     @Override\n     public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n         super.doStop();\n     }\n \n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f75734b972..9ad67ad3573 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -122,13 +118,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             }\n         }\n \n-        if (isNotEmpty(getConfiguration().getPolicy())) {\n+        if (getConfiguration().getPolicy() != null) {\n             setBucketPolicy(bucketName);\n         }\n     }\n \n     @Override\n     public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n         super.doStop();\n     }\n \n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..54e7662498d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -118,18 +123,13 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             }\n         }\n \n-        if (getConfiguration().getPolicy() != null) {\n+        if (isNotEmpty(getConfiguration().getPolicy())) {\n             setBucketPolicy(bucketName);\n         }\n     }\n \n     @Override\n     public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n         super.doStop();\n     }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 54e7662498d..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,279 +16,72 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.BucketExistsArgs;\n-import io.minio.MakeBucketArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectStat;\n-import io.minio.SetBucketPolicyArgs;\n-import io.minio.StatObjectArgs;\n-import io.minio.errors.InvalidBucketNameException;\n-import org.apache.camel.Category;\n-import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.Producer;\n-import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n-import org.apache.camel.support.ScheduledPollEndpoint;\n-import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+import org.apache.camel.support.DefaultEndpoint;\n \n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Minio component which does bla bla.\n+ * <p>\n+ * TODO: Update one line description above what the component does.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n-public class MinioEndpoint extends ScheduledPollEndpoint {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n-\n-    private MinioClient minioClient;\n-\n-    @UriPath(description = \"Bucket name\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:name\",\n+        consumerClass = MinioConsumer.class, label = \"custom\")\n+public class MinioEndpoint extends DefaultEndpoint {\n+    @UriPath\n     @Metadata(required = true)\n-    private String bucketName;\n-    @UriParam\n-    private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n \n-    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n-        super(uri, component);\n-        this.configuration = configuration;\n+    public MinioEndpoint() {\n     }\n \n-    @Override\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n-        configureConsumer(minioConsumer);\n-        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n-        return minioConsumer;\n+    public MinioEndpoint(String uri, MinioComponent component) {\n+        super(uri, component);\n     }\n \n-    @Override\n-    public Producer createProducer() {\n+    public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    @Override\n-    public void doStart() throws Exception {\n-        super.doStart();\n-\n-        minioClient = isNotEmpty(getConfiguration().getMinioClient())\n-                ? getConfiguration().getMinioClient()\n-                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n-\n-        String objectName = getConfiguration().getObjectName();\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n-            return;\n-        }\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n-\n-        if (bucketExists(bucketName)) {\n-            LOG.trace(\"Bucket {} already exists\", bucketName);\n-        } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n-                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n-                makeBucket(bucketName);\n-                LOG.trace(\"Bucket created\");\n-            }\n-        }\n-\n-        if (isNotEmpty(getConfiguration().getPolicy())) {\n-            setBucketPolicy(bucketName);\n-        }\n-    }\n-\n-    @Override\n-    public void doStop() throws Exception {\n-        super.doStop();\n-    }\n-\n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutoCloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinioConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n+    public String getName() {\n+        return name;\n     }\n \n     /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    public void setName(String name) {\n+        this.name = name;\n     }\n \n-    public int getMaxConnections() {\n-        return maxConnections;\n+    public int getOption() {\n+        return option;\n     }\n \n     /**\n-     * Set the maxConnections parameter in the minio client configuration\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n+    public void setOption(int option) {\n+        this.option = option;\n     }\n \n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-    }\n-\n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (isNotEmpty(getConfiguration().getRegion())) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        minioClient.makeBucket(makeBucketRequest.build());\n-    }\n-\n-    private void setBucketPolicy(String bucketName) throws Exception {\n-        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-        minioClient.setBucketPolicy(\n-                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n-        LOG.trace(\"Bucket policy updated\");\n-    }\n-\n-    private void getObjectStat(String objectName, Message message) throws Exception {\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n-\n-        // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n-        message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex ee167dbbeab..0edc380c6eb 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -69,19 +76,19 @@ public class MinioEndpoint extends DefaultEndpoint {\n         this.name = name;\n     }\n \n-    public int getOption() {\n-        return option;\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n     }\n \n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n+    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+                this.configuration.getSecretKey());\n+        return minioClient;\n+\n     }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0edc380c6eb..64b18d08cdc 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -84,8 +85,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.configuration = configuration;\n     }\n \n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n                 this.configuration.getSecretKey());\n         return minioClient;\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 64b18d08cdc..823af3025a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,88 +16,244 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n import io.minio.MinioClient;\n-import io.minio.errors.InvalidEndpointException;\n-import io.minio.errors.InvalidPortException;\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n+import io.minio.Result;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * Represents a Minio endpoint.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:url\", consumerClass = MinioConsumer.class, label = \"storage,cloud,file\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n-    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioEndpoint.class);\n \n-    @UriPath\n-    @Metadata(required = true)\n-    private String name;\n-    @UriPath(description = \"Bucket name or ARN\")\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n-    private MinioClient minioClient;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n \n-    public MinioEndpoint() {\n-    }\n-\n-    public MinioEndpoint(final String uri, final MinioComponent component,\n-                         final MinioConfiguration configuration) {\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n         this.configuration = configuration;\n     }\n \n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n     public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        return new MinioConsumer(this, processor);\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = configuration.getMinioClient() != null\n+                ? configuration.getMinioClient()\n+                : MinioClientFactory.getMinioClient(configuration).getMinioClient();\n+\n+        String fileName = getConfiguration().getFileName();\n+\n+        if (fileName != null) {\n+            LOG.trace(\"File name [{}] requested, so skipping bucket check...\", fileName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket [{}] already exists...\", bucketName);\n+\n+        String prefix = getConfiguration().getPrefix();\n+\n+        try {\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+            LOG.trace(\"Bucket [{}] already exists\", bucketName);\n+            return;\n+        } catch (AwsServiceException ase) {\n+            /* 404 means the bucket doesn't exist */\n+            if (ase.awsErrorDetails().errorCode().equalsIgnoreCase(\"404\")) {\n+                throw ase;\n+            }\n+        }\n+\n+        LOG.trace(\"Bucket [{}] doesn't exist yet\", bucketName);\n+\n+        if (getConfiguration().isAutoCreateBucket()) {\n+            // creates the new bucket because it doesn't exist yet\n+            CreateBucketRequest createBucketRequest = CreateBucketRequest.builder().bucket(getConfiguration().getBucketName()).build();\n+\n+            LOG.trace(\"Creating bucket [{}] in region [{}] with request [{}]...\", configuration.getBucketName(), configuration.getRegion(), createBucketRequest);\n+\n+            minioClient.createBucket(createBucketRequest);\n+\n+            LOG.trace(\"Bucket created\");\n+        }\n+\n+        if (configuration.getPolicy() != null) {\n+            LOG.trace(\"Updating bucket [{}] with policy [{}]\", bucketName, configuration.getPolicy());\n+\n+            minioClient.putBucketPolicy(PutBucketPolicyRequest.builder().bucket(bucketName).policy(configuration.getPolicy()).build());\n+\n+            LOG.trace(\"Bucket policy updated\");\n+        }\n     }\n \n-    public boolean isSingleton() {\n-        return true;\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {\n+            if (s3Client != null) {\n+                s3Client.close();\n+            }\n+        }\n+        super.doStop();\n     }\n \n-    public String getName() {\n-        return name;\n+    public Exchange createExchange(ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        return createExchange(getExchangePattern(), s3Object, key);\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n+    public Exchange createExchange(ExchangePattern pattern, ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        LOG.trace(\"Getting object with key [{}] from bucket [{}]...\", key, getConfiguration().getBucketName());\n+\n+        LOG.trace(\"Got object [{}]\", s3Object);\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+\n+        if (configuration.isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(s3Object));\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+        }\n+\n+        message.setHeader(AWS2S3Constants.KEY, key);\n+        message.setHeader(AWS2S3Constants.BUCKET_NAME, getConfiguration().getBucketName());\n+        message.setHeader(AWS2S3Constants.E_TAG, s3Object.response().eTag());\n+        message.setHeader(AWS2S3Constants.LAST_MODIFIED, s3Object.response().lastModified());\n+        message.setHeader(AWS2S3Constants.VERSION_ID, s3Object.response().versionId());\n+        message.setHeader(AWS2S3Constants.CONTENT_TYPE, s3Object.response().contentType());\n+        message.setHeader(AWS2S3Constants.CONTENT_LENGTH, s3Object.response().contentLength());\n+        message.setHeader(AWS2S3Constants.CONTENT_ENCODING, s3Object.response().contentEncoding());\n+        message.setHeader(AWS2S3Constants.CONTENT_DISPOSITION, s3Object.response().contentDisposition());\n+        message.setHeader(AWS2S3Constants.CACHE_CONTROL, s3Object.response().cacheControl());\n+        message.setHeader(AWS2S3Constants.SERVER_SIDE_ENCRYPTION, s3Object.response().serverSideEncryption());\n+        message.setHeader(AWS2S3Constants.EXPIRATION_TIME, s3Object.response().expiration());\n+        message.setHeader(AWS2S3Constants.REPLICATION_STATUS, s3Object.response().replicationStatus());\n+        message.setHeader(AWS2S3Constants.STORAGE_CLASS, s3Object.response().storageClass());\n+\n+        /**\n+         * If includeBody != true, it is safe to close the object here. If\n+         * includeBody == true, the caller is responsible for closing the stream\n+         * and object once the body has been fully consumed. As of 2.17, the\n+         * consumer does not close the stream or object on commit.\n+         */\n+        if (!configuration.isIncludeBody()) {\n+            IOHelper.close(s3Object);\n+        } else {\n+            if (configuration.isAutocloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(s3Object);\n+                    }\n+                });\n+            }\n+        }\n+\n+        return exchange;\n     }\n \n-    public MinioConfiguration getConfiguration() {\n+    public AWS2S3Configuration getConfiguration() {\n         return configuration;\n     }\n \n-    public void setConfiguration(MinioConfiguration configuration) {\n+    public void setConfiguration(AWS2S3Configuration configuration) {\n         this.configuration = configuration;\n     }\n \n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public void setS3Client(S3Client s3Client) {\n+        this.s3Client = s3Client;\n+    }\n+\n+    public S3Client getS3Client() {\n+        return s3Client;\n     }\n \n-    public MinioClient getMinioClient() {\n-        return minioClient;\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n     }\n \n-    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n-                this.configuration.getSecretKey());\n-        return minioClient;\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n \n+    public int getMaxConnections() {\n+        return maxConnections;\n     }\n \n+    /**\n+     * Set the maxConnections parameter in the S3 client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(ResponseInputStream<GetObjectResponse> s3Object) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(s3Object, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c = 0;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 823af3025a0..fbc5e921a19 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -256,4 +243,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n         return textBuilder.toString();\n     }\n+\n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n+        if (getConfiguration().)\n+    }\n }\n", "next_change": {"commit": "152fd8b381686621d3de6a6300323fe89f42720b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbc5e921a19..c827cc9fab1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -254,7 +267,24 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n-        if (getConfiguration().)\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+        try {\n+            if (region != null) {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .region(region)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            } else {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n     }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..1010a4c0cc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -267,24 +234,52 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+    private void makeBucket(String bucketName) throws Exception {\n         try {\n-            if (region != null) {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .region(region)\n-                        .objectLock(isObjectLock)\n-                        .build());\n-            } else {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .objectLock(isObjectLock)\n-                        .build());\n+            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n+            if (configuration.getRegion() != null) {\n+                makeBucketRequest.region(configuration.getRegion());\n             }\n+            minioClient.makeBucket(makeBucketRequest.build());\n \n         } catch (Throwable e) {\n             LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n             throw e;\n         }\n     }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        try {\n+            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+            minioClient.setBucketPolicy(\n+                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n+            LOG.trace(\"Bucket policy updated\");\n+        } catch (Throwable e) {\n+            Log.warn(\"Error updating policy, due {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void getObjectTags(String objectName, String bucketName, Message message) {\n+        try {\n+            ObjectStat stat = minioClient.statObject(\n+                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n+\n+            // set all stat as message headers\n+            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+            message.setHeader(MinioConstants.E_TAG, stat.etag());\n+            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+\n+        } catch (Exception e) {\n+            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+        }\n+    }\n }\n", "next_change": {"commit": "f4aea6f0902b2108a296a183973813785969618b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 1010a4c0cc6..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -279,7 +278,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n \n         } catch (Exception e) {\n-            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n         }\n     }\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -223,62 +223,67 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return textBuilder.toString();\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n \n     private void makeBucket(String bucketName) throws Exception {\n-        try {\n-            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n-            if (configuration.getRegion() != null) {\n-                makeBucketRequest.region(configuration.getRegion());\n-            }\n-            minioClient.makeBucket(makeBucketRequest.build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n-            throw e;\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n         }\n+        minioClient.makeBucket(makeBucketRequest.build());\n     }\n \n     private void setBucketPolicy(String bucketName) throws Exception {\n-        try {\n-            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-            minioClient.setBucketPolicy(\n-                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n-            LOG.trace(\"Bucket policy updated\");\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error updating policy, due {}\", e.getMessage());\n-            throw e;\n-        }\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n     }\n \n-    private void getObjectTags(String objectName, String bucketName, Message message) {\n-        try {\n-            ObjectStat stat = minioClient.statObject(\n-                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n-\n-            // set all stat as message headers\n-            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n-            message.setHeader(MinioConstants.E_TAG, stat.etag());\n-            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n-\n-        } catch (Exception e) {\n-            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n+    private void getObjectTags(String objectName, String bucketName, Message message) throws Exception {\n+\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n         }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+\n+        // set all stat as message headers\n+        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.E_TAG, stat.etag());\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..fa911a0dac1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -274,13 +276,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n         message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n         message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n         message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n         message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n         message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n         message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -109,27 +113,25 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         if (bucketExists(bucketName)) {\n             LOG.trace(\"Bucket {} already exists\", bucketName);\n         } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n+            if (getConfiguration().isAutoCreateBucket()) {\n                 LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n                 makeBucket(bucketName);\n                 LOG.trace(\"Bucket created\");\n+            } else {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+\n             }\n         }\n \n-        if (getConfiguration().getPolicy() != null) {\n+        if (isNotEmpty(getConfiguration().getPolicy())) {\n+            LOG.trace(\"Updating bucket {} with policy {}\", bucketName, configuration.getPolicy());\n             setBucketPolicy(bucketName);\n+            LOG.trace(\"Bucket policy updated\");\n         }\n     }\n \n     @Override\n     public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n         super.doStop();\n     }\n \n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..8e77b779c57 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -139,8 +130,10 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return createExchange(getExchangePattern(), minioObject, objectName);\n     }\n \n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n+    public Exchange createExchange(\n+            ExchangePattern pattern,\n+            InputStream minioObject, String objectName)\n+            throws Exception {\n         LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n \n         Exchange exchange = super.createExchange(pattern);\n", "next_change": {"commit": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 8e77b779c57..5a3a10be9d1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -130,10 +128,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return createExchange(getExchangePattern(), minioObject, objectName);\n     }\n \n-    public Exchange createExchange(\n-            ExchangePattern pattern,\n-            InputStream minioObject, String objectName)\n-            throws Exception {\n+    public Exchange createExchange(ExchangePattern pattern, InputStream minioObject, String objectName) throws Exception {\n         LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n \n         Exchange exchange = super.createExchange(pattern);\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 5a3a10be9d1..bb67186fdc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -124,37 +118,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         super.doStop();\n     }\n \n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern, InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            message.setBody(readInputStream(minioObject));\n-            if (getConfiguration().isAutoCloseBody()) {\n-                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                    @Override\n-                    public void onDone(Exchange exchange) {\n-                        IOHelper.close(minioObject);\n-                    }\n-                });\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n     public MinioConfiguration getConfiguration() {\n         return configuration;\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "committedDate": "2020-09-10 11:33:02 +0200", "message": "Camel-Minio: Lets simplify the client instantiation"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "fceb5aeac41ffc5a6fb64b2ce177628b5d85c621", "committedDate": "2020-12-04 08:32:34 +0100", "message": "CAMEL-15880 - Regen docs and fixed CS"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "committedDate": "2022-02-15 21:51:03 +0100", "message": "Remove unused code"}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MTMxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460751316", "body": "please don't print the stack trace here, instead handle the exception.", "bodyText": "please don't print the stack trace here, instead handle the exception.", "bodyHTML": "<p dir=\"auto\">please don't print the stack trace here, instead handle the exception.</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:07:49Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -161,7 +160,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n             } catch (IOException e) {\n                 // TODO Auto-generated catch block\n-                e.printStackTrace();\n+                LOG.warn(\"Error setting message body\");\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f75734b972..9ad67ad3573 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -160,7 +161,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n             } catch (IOException e) {\n                 // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n+                e.printStackTrace();\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..c28617d57ae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -161,7 +164,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n             } catch (IOException e) {\n                 // TODO Auto-generated catch block\n-                e.printStackTrace();\n+                LOG.warn(\"Error setting message body\");\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c28617d57ae..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,282 +16,72 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.BucketExistsArgs;\n-import io.minio.MakeBucketArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectStat;\n-import io.minio.SetBucketPolicyArgs;\n-import io.minio.StatObjectArgs;\n-import io.minio.errors.InvalidBucketNameException;\n-import org.apache.camel.Category;\n-import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.Producer;\n-import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n-import org.apache.camel.support.ScheduledPollEndpoint;\n-import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultEndpoint;\n \n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Minio component which does bla bla.\n+ * <p>\n+ * TODO: Update one line description above what the component does.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n-public class MinioEndpoint extends ScheduledPollEndpoint {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n-\n-    private MinioClient minioClient;\n-\n-    @UriPath(description = \"Bucket name\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:name\",\n+        consumerClass = MinioConsumer.class, label = \"custom\")\n+public class MinioEndpoint extends DefaultEndpoint {\n+    @UriPath\n     @Metadata(required = true)\n-    private String bucketName;\n-    @UriParam\n-    private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n \n-    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n-        super(uri, component);\n-        this.configuration = configuration;\n+    public MinioEndpoint() {\n     }\n \n-    @Override\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n-        configureConsumer(minioConsumer);\n-        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n-        return minioConsumer;\n+    public MinioEndpoint(String uri, MinioComponent component) {\n+        super(uri, component);\n     }\n \n-    @Override\n-    public Producer createProducer() {\n+    public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    @Override\n-    public void doStart() throws Exception {\n-        super.doStart();\n-\n-        minioClient = getConfiguration().getMinioClient() != null\n-                ? getConfiguration().getMinioClient()\n-                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n-\n-        String objectName = getConfiguration().getObjectName();\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n-            return;\n-        }\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n-\n-        if (bucketExists(bucketName)) {\n-            LOG.trace(\"Bucket {} already exists\", bucketName);\n-        } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n-                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n-                makeBucket(bucketName);\n-                LOG.trace(\"Bucket created\");\n-            }\n-        }\n-\n-        if (getConfiguration().getPolicy() != null) {\n-            setBucketPolicy(bucketName);\n-        }\n-    }\n-\n-    @Override\n-    public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n-        super.doStop();\n-    }\n-\n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutocloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinioConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n+    public String getName() {\n+        return name;\n     }\n \n     /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    public void setName(String name) {\n+        this.name = name;\n     }\n \n-    public int getMaxConnections() {\n-        return maxConnections;\n+    public int getOption() {\n+        return option;\n     }\n \n     /**\n-     * Set the maxConnections parameter in the minio client configuration\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n-    }\n-\n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    public void setOption(int option) {\n+        this.option = option;\n     }\n \n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (getConfiguration().getRegion() != null) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        minioClient.makeBucket(makeBucketRequest.build());\n-    }\n-\n-    private void setBucketPolicy(String bucketName) throws Exception {\n-        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-        minioClient.setBucketPolicy(\n-                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n-        LOG.trace(\"Bucket policy updated\");\n-    }\n-\n-    private void getObjectStat(String objectName, Message message) throws Exception {\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n-\n-        // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n-        message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex ee167dbbeab..0edc380c6eb 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -69,19 +76,19 @@ public class MinioEndpoint extends DefaultEndpoint {\n         this.name = name;\n     }\n \n-    public int getOption() {\n-        return option;\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n     }\n \n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n+    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+                this.configuration.getSecretKey());\n+        return minioClient;\n+\n     }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0edc380c6eb..64b18d08cdc 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -84,8 +85,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.configuration = configuration;\n     }\n \n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n                 this.configuration.getSecretKey());\n         return minioClient;\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 64b18d08cdc..823af3025a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,88 +16,244 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n import io.minio.MinioClient;\n-import io.minio.errors.InvalidEndpointException;\n-import io.minio.errors.InvalidPortException;\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n+import io.minio.Result;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * Represents a Minio endpoint.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:url\", consumerClass = MinioConsumer.class, label = \"storage,cloud,file\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n-    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioEndpoint.class);\n \n-    @UriPath\n-    @Metadata(required = true)\n-    private String name;\n-    @UriPath(description = \"Bucket name or ARN\")\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n-    private MinioClient minioClient;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n \n-    public MinioEndpoint() {\n-    }\n-\n-    public MinioEndpoint(final String uri, final MinioComponent component,\n-                         final MinioConfiguration configuration) {\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n         this.configuration = configuration;\n     }\n \n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n     public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        return new MinioConsumer(this, processor);\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = configuration.getMinioClient() != null\n+                ? configuration.getMinioClient()\n+                : MinioClientFactory.getMinioClient(configuration).getMinioClient();\n+\n+        String fileName = getConfiguration().getFileName();\n+\n+        if (fileName != null) {\n+            LOG.trace(\"File name [{}] requested, so skipping bucket check...\", fileName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket [{}] already exists...\", bucketName);\n+\n+        String prefix = getConfiguration().getPrefix();\n+\n+        try {\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+            LOG.trace(\"Bucket [{}] already exists\", bucketName);\n+            return;\n+        } catch (AwsServiceException ase) {\n+            /* 404 means the bucket doesn't exist */\n+            if (ase.awsErrorDetails().errorCode().equalsIgnoreCase(\"404\")) {\n+                throw ase;\n+            }\n+        }\n+\n+        LOG.trace(\"Bucket [{}] doesn't exist yet\", bucketName);\n+\n+        if (getConfiguration().isAutoCreateBucket()) {\n+            // creates the new bucket because it doesn't exist yet\n+            CreateBucketRequest createBucketRequest = CreateBucketRequest.builder().bucket(getConfiguration().getBucketName()).build();\n+\n+            LOG.trace(\"Creating bucket [{}] in region [{}] with request [{}]...\", configuration.getBucketName(), configuration.getRegion(), createBucketRequest);\n+\n+            minioClient.createBucket(createBucketRequest);\n+\n+            LOG.trace(\"Bucket created\");\n+        }\n+\n+        if (configuration.getPolicy() != null) {\n+            LOG.trace(\"Updating bucket [{}] with policy [{}]\", bucketName, configuration.getPolicy());\n+\n+            minioClient.putBucketPolicy(PutBucketPolicyRequest.builder().bucket(bucketName).policy(configuration.getPolicy()).build());\n+\n+            LOG.trace(\"Bucket policy updated\");\n+        }\n     }\n \n-    public boolean isSingleton() {\n-        return true;\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {\n+            if (s3Client != null) {\n+                s3Client.close();\n+            }\n+        }\n+        super.doStop();\n     }\n \n-    public String getName() {\n-        return name;\n+    public Exchange createExchange(ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        return createExchange(getExchangePattern(), s3Object, key);\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n+    public Exchange createExchange(ExchangePattern pattern, ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        LOG.trace(\"Getting object with key [{}] from bucket [{}]...\", key, getConfiguration().getBucketName());\n+\n+        LOG.trace(\"Got object [{}]\", s3Object);\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+\n+        if (configuration.isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(s3Object));\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+        }\n+\n+        message.setHeader(AWS2S3Constants.KEY, key);\n+        message.setHeader(AWS2S3Constants.BUCKET_NAME, getConfiguration().getBucketName());\n+        message.setHeader(AWS2S3Constants.E_TAG, s3Object.response().eTag());\n+        message.setHeader(AWS2S3Constants.LAST_MODIFIED, s3Object.response().lastModified());\n+        message.setHeader(AWS2S3Constants.VERSION_ID, s3Object.response().versionId());\n+        message.setHeader(AWS2S3Constants.CONTENT_TYPE, s3Object.response().contentType());\n+        message.setHeader(AWS2S3Constants.CONTENT_LENGTH, s3Object.response().contentLength());\n+        message.setHeader(AWS2S3Constants.CONTENT_ENCODING, s3Object.response().contentEncoding());\n+        message.setHeader(AWS2S3Constants.CONTENT_DISPOSITION, s3Object.response().contentDisposition());\n+        message.setHeader(AWS2S3Constants.CACHE_CONTROL, s3Object.response().cacheControl());\n+        message.setHeader(AWS2S3Constants.SERVER_SIDE_ENCRYPTION, s3Object.response().serverSideEncryption());\n+        message.setHeader(AWS2S3Constants.EXPIRATION_TIME, s3Object.response().expiration());\n+        message.setHeader(AWS2S3Constants.REPLICATION_STATUS, s3Object.response().replicationStatus());\n+        message.setHeader(AWS2S3Constants.STORAGE_CLASS, s3Object.response().storageClass());\n+\n+        /**\n+         * If includeBody != true, it is safe to close the object here. If\n+         * includeBody == true, the caller is responsible for closing the stream\n+         * and object once the body has been fully consumed. As of 2.17, the\n+         * consumer does not close the stream or object on commit.\n+         */\n+        if (!configuration.isIncludeBody()) {\n+            IOHelper.close(s3Object);\n+        } else {\n+            if (configuration.isAutocloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(s3Object);\n+                    }\n+                });\n+            }\n+        }\n+\n+        return exchange;\n     }\n \n-    public MinioConfiguration getConfiguration() {\n+    public AWS2S3Configuration getConfiguration() {\n         return configuration;\n     }\n \n-    public void setConfiguration(MinioConfiguration configuration) {\n+    public void setConfiguration(AWS2S3Configuration configuration) {\n         this.configuration = configuration;\n     }\n \n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public void setS3Client(S3Client s3Client) {\n+        this.s3Client = s3Client;\n+    }\n+\n+    public S3Client getS3Client() {\n+        return s3Client;\n     }\n \n-    public MinioClient getMinioClient() {\n-        return minioClient;\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n     }\n \n-    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n-                this.configuration.getSecretKey());\n-        return minioClient;\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n \n+    public int getMaxConnections() {\n+        return maxConnections;\n     }\n \n+    /**\n+     * Set the maxConnections parameter in the S3 client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(ResponseInputStream<GetObjectResponse> s3Object) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(s3Object, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c = 0;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 823af3025a0..fbc5e921a19 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -256,4 +243,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n         return textBuilder.toString();\n     }\n+\n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n+        if (getConfiguration().)\n+    }\n }\n", "next_change": {"commit": "152fd8b381686621d3de6a6300323fe89f42720b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbc5e921a19..c827cc9fab1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -254,7 +267,24 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n-        if (getConfiguration().)\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+        try {\n+            if (region != null) {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .region(region)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            } else {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n     }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..1010a4c0cc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -267,24 +234,52 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+    private void makeBucket(String bucketName) throws Exception {\n         try {\n-            if (region != null) {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .region(region)\n-                        .objectLock(isObjectLock)\n-                        .build());\n-            } else {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .objectLock(isObjectLock)\n-                        .build());\n+            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n+            if (configuration.getRegion() != null) {\n+                makeBucketRequest.region(configuration.getRegion());\n             }\n+            minioClient.makeBucket(makeBucketRequest.build());\n \n         } catch (Throwable e) {\n             LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n             throw e;\n         }\n     }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        try {\n+            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+            minioClient.setBucketPolicy(\n+                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n+            LOG.trace(\"Bucket policy updated\");\n+        } catch (Throwable e) {\n+            Log.warn(\"Error updating policy, due {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void getObjectTags(String objectName, String bucketName, Message message) {\n+        try {\n+            ObjectStat stat = minioClient.statObject(\n+                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n+\n+            // set all stat as message headers\n+            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+            message.setHeader(MinioConstants.E_TAG, stat.etag());\n+            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+\n+        } catch (Exception e) {\n+            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+        }\n+    }\n }\n", "next_change": {"commit": "f4aea6f0902b2108a296a183973813785969618b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 1010a4c0cc6..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -279,7 +278,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n \n         } catch (Exception e) {\n-            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n         }\n     }\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -223,62 +223,67 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return textBuilder.toString();\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n \n     private void makeBucket(String bucketName) throws Exception {\n-        try {\n-            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n-            if (configuration.getRegion() != null) {\n-                makeBucketRequest.region(configuration.getRegion());\n-            }\n-            minioClient.makeBucket(makeBucketRequest.build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n-            throw e;\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n         }\n+        minioClient.makeBucket(makeBucketRequest.build());\n     }\n \n     private void setBucketPolicy(String bucketName) throws Exception {\n-        try {\n-            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-            minioClient.setBucketPolicy(\n-                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n-            LOG.trace(\"Bucket policy updated\");\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error updating policy, due {}\", e.getMessage());\n-            throw e;\n-        }\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n     }\n \n-    private void getObjectTags(String objectName, String bucketName, Message message) {\n-        try {\n-            ObjectStat stat = minioClient.statObject(\n-                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n-\n-            // set all stat as message headers\n-            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n-            message.setHeader(MinioConstants.E_TAG, stat.etag());\n-            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n-\n-        } catch (Exception e) {\n-            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n+    private void getObjectTags(String objectName, String bucketName, Message message) throws Exception {\n+\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n         }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+\n+        // set all stat as message headers\n+        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.E_TAG, stat.etag());\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..fa911a0dac1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -274,13 +276,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n         message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n         message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n         message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n         message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n         message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n         message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -161,7 +163,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n             } catch (IOException e) {\n                 // TODO Auto-generated catch block\n-                e.printStackTrace();\n+                LOG.warn(\"Error setting message body\");\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -150,20 +140,14 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         getObjectStat(objectName, message);\n \n         if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutoCloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n+            message.setBody(readInputStream(minioObject));\n+            if (getConfiguration().isAutoCloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(minioObject);\n+                    }\n+                });\n             }\n         } else {\n             message.setBody(null);\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c03dbc18109..bb67186fdc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -125,38 +118,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         super.doStop();\n     }\n \n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            message.setBody(readInputStream(minioObject));\n-            if (getConfiguration().isAutoCloseBody()) {\n-                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                    @Override\n-                    public void onDone(Exchange exchange) {\n-                        IOHelper.close(minioObject);\n-                    }\n-                });\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n     public MinioConfiguration getConfiguration() {\n         return configuration;\n     }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "committedDate": "2020-09-10 11:33:02 +0200", "message": "Camel-Minio: Lets simplify the client instantiation"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "fceb5aeac41ffc5a6fb64b2ce177628b5d85c621", "committedDate": "2020-12-04 08:32:34 +0100", "message": "CAMEL-15880 - Regen docs and fixed CS"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "committedDate": "2022-02-15 21:51:03 +0100", "message": "Remove unused code"}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NDgyNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460754824", "body": "`versionId` is not used here", "bodyText": "versionId is not used here", "bodyHTML": "<p dir=\"auto\"><code>versionId</code> is not used here</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:14:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -227,25 +234,23 @@ public class MinioProducer extends DefaultProducer {\n             ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n \n             Message message = getMessageForResponse(exchange);\n-            if (copyObjectResult.versionId() != null) {\n+            if (isNotEmpty(copyObjectResult.versionId())) {\n                 message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n             }\n         }\n     }\n \n     private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-        final String sourceKey = determineObjectName(exchange);\n-        final String versionId = determineVersionId(exchange);\n         if (getConfiguration().isPojoRequest()) {\n             RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (payload != null) {\n+            if (isNotEmpty(payload)) {\n                 minioClient.removeObject(payload.build());\n                 Message message = getMessageForResponse(exchange);\n                 message.setBody(true);\n             }\n         } else {\n-\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n             minioClient.removeObject(RemoveObjectArgs.builder()\n                     .bucket(bucketName)\n                     .object(sourceKey).build());\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 6be64b509d8..9649c1df3e3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,473 +16,22 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectWriteResponse;\n-import io.minio.PutObjectArgs;\n-import io.minio.RemoveBucketArgs;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.RemoveObjectsArgs;\n-import io.minio.Result;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n-import org.apache.camel.InvalidPayloadException;\n-import org.apache.camel.Message;\n-import org.apache.camel.WrappedFile;\n import org.apache.camel.support.DefaultProducer;\n-import org.apache.camel.util.FileUtil;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-\n-/**\n- * A Producer which sends messages to the Minio Simple Storage\n- */\n public class MinioProducer extends DefaultProducer {\n-\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private MinioEndpoint endpoint;\n \n-    private transient String minioProducerToString;\n-\n-    public MinioProducer(final Endpoint endpoint) {\n+    public MinioProducer(MinioEndpoint endpoint) {\n         super(endpoint);\n+        this.endpoint = endpoint;\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n-    @Override\n-    public void process(final Exchange exchange) throws Exception {\n-        MinioOperations operation = determineOperation(exchange);\n-        MinioClient minioClient = getEndpoint().getMinioClient();\n-        if (isEmpty(operation)) {\n-            putObject(minioClient, exchange);\n-        } else {\n-            switch (operation) {\n-                case copyObject:\n-                    copyObject(minioClient, exchange);\n-                    break;\n-                case deleteObject:\n-                    deleteObject(minioClient, exchange);\n-                    break;\n-                case deleteObjects:\n-                    deleteObjects(minioClient, exchange);\n-                    break;\n-                case listBuckets:\n-                    listBuckets(minioClient, exchange);\n-                    break;\n-                case deleteBucket:\n-                    deleteBucket(minioClient, exchange);\n-                    break;\n-                case listObjects:\n-                    listObjects(minioClient, exchange);\n-                    break;\n-                case getObject:\n-                    getObject(minioClient, exchange);\n-                    break;\n-                case getPartialObject:\n-                    getPartialObject(minioClient, exchange);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported operation\");\n-            }\n-        }\n-    }\n-\n-    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-                if (isNotEmpty(putObjectResult.versionId())) {\n-                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-                }\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String objectName = determineObjectName(exchange);\n-            Map<String, String> objectMetadata = determineMetadata(exchange);\n-            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n-\n-            File filePayload = null;\n-            InputStream inputStream;\n-            ByteArrayOutputStream baos;\n-            Object object = exchange.getIn().getMandatoryBody();\n-\n-            // Need to check if the message body is WrappedFile\n-            if (object instanceof WrappedFile) {\n-                object = ((WrappedFile<?>) object).getFile();\n-            }\n-            if (object instanceof File) {\n-                filePayload = (File) object;\n-                inputStream = new FileInputStream(filePayload);\n-            } else {\n-                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n-                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n-                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n-                        baos = determineLengthInputStream(inputStream);\n-                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n-                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n-                    } else {\n-                        if (isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n-                        }\n-                    }\n-                }\n-            }\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(bucketName)\n-                    .object(objectName)\n-                    .userMetadata(objectMetadata);\n-\n-            if (!extraHeaders.isEmpty()) {\n-                putObjectRequest.extraHeaders(extraHeaders);\n-            }\n-\n-            LOG.trace(\"Put object from exchange...\");\n-\n-            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n-\n-            LOG.trace(\"Received result...\");\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-            if (isNotEmpty(putObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-            }\n-\n-            IOHelper.close(inputStream);\n-\n-            if (getConfiguration().isDeleteAfterWrite() && isNotEmpty(filePayload)) {\n-                FileUtil.deleteFile(filePayload);\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n-        Map<String, String> extraHeaders = new HashMap<>();\n-        String storageClass = determineStorageClass(exchange);\n-        if (isNotEmpty(storageClass)) {\n-            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n-        }\n-\n-        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n-        if (isNotEmpty(cannedAcl)) {\n-            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n-        }\n-\n-        return extraHeaders;\n-    }\n-\n-    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(result);\n-            }\n-        } else {\n-\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n-            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n-\n-            if (isEmpty(destinationBucketName)) {\n-                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n-            }\n-            if (isEmpty(destinationKey)) {\n-                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n-            }\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(destinationBucketName)\n-                    .object(destinationKey)\n-                    .source(copySourceBuilder.build());\n-\n-            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            if (isNotEmpty(copyObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n-            }\n-        }\n-    }\n-\n-    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            minioClient.removeObject(RemoveObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey).build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(true);\n-        }\n-    }\n-\n-    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n-        }\n-    }\n-\n-    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n-        List<Bucket> bucketsList = minioClient.listBuckets();\n-        Message message = getMessageForResponse(exchange);\n-        //returns iterator of bucketList\n-        message.setBody(bucketsList.iterator());\n-    }\n-\n-    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeBucket(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(\"ok\");\n-            }\n-        } else {\n-\n-            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(\"ok\");\n-        }\n+    public void process(Exchange exchange) throws Exception {\n+        System.out.println(exchange.getIn().getBody());\n     }\n \n-    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n-            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n-\n-            if (isEmpty(offset) || isEmpty(length)) {\n-                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n-            }\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .offset(Long.parseLong(offset))\n-                    .length(Long.parseLong(length))\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(objectList);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-\n-            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(objectList);\n-        }\n-    }\n-\n-    private MinioOperations determineOperation(Exchange exchange) {\n-        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n-        if (isEmpty(operation)) {\n-            operation = getConfiguration().getOperation();\n-        }\n-        return operation;\n-    }\n-\n-    private Map<String, String> determineMetadata(final Exchange exchange) {\n-        Map<String, String> objectMetadata = new HashMap<>();\n-\n-        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (isNotEmpty(contentLength)) {\n-            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n-        }\n-\n-        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (isNotEmpty(contentType)) {\n-            objectMetadata.put(\"Content-Type\", contentType);\n-        }\n-\n-        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (isNotEmpty(cacheControl)) {\n-            objectMetadata.put(\"Cache-Control\", cacheControl);\n-        }\n-\n-        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (isNotEmpty(contentDisposition)) {\n-            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n-        }\n-\n-        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (isNotEmpty(contentEncoding)) {\n-            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n-        }\n-\n-        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (isNotEmpty(contentMD5)) {\n-            objectMetadata.put(\"Content-Md5\", contentMD5);\n-        }\n-\n-        return objectMetadata;\n-    }\n-\n-    /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n-     *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n-     * @throws IllegalArgumentException if the header could not be determined.\n-     */\n-    private String determineBucketName(final Exchange exchange) {\n-        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-\n-        if (isEmpty(bucketName)) {\n-            if (isNotEmpty(getConfiguration().getBucketName())) {\n-                bucketName = getConfiguration().getBucketName();\n-                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-            } else {\n-                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-            }\n-        }\n-        return bucketName;\n-    }\n-\n-    private String determineObjectName(final Exchange exchange) {\n-        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (isEmpty(objectName)) {\n-            objectName = getConfiguration().getKeyName();\n-        }\n-        if (isEmpty(objectName)) {\n-            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n-        }\n-        return objectName;\n-    }\n-\n-    private String determineStorageClass(final Exchange exchange) {\n-        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (isEmpty(storageClass)) {\n-            storageClass = getConfiguration().getStorageClass();\n-        }\n-\n-        return storageClass;\n-    }\n-\n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n-        }\n-        return out;\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioProducerToString)) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 9649c1df3e3..7a4306e2cf3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,21 +16,21 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n import org.apache.camel.support.DefaultProducer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+/**\n+ * The Minio producer.\n+ */\n public class MinioProducer extends DefaultProducer {\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioProducer.class);\n     private MinioEndpoint endpoint;\n \n-    public MinioProducer(MinioEndpoint endpoint) {\n+    public MinioProducer(final MinioEndpoint endpoint) {\n         super(endpoint);\n         this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n+    public void process(org.apache.camel.Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "c6a9b5ac3b4d5a128c045495008174d905492576", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 7a4306e2cf3..2ab2c6e4a95 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -30,7 +33,7 @@ public class MinioProducer extends DefaultProducer {\n         this.endpoint = endpoint;\n     }\n \n-    public void process(org.apache.camel.Exchange exchange) throws Exception {\n+    public void process(Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 2ab2c6e4a95..bef3a9c6607 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -37,4 +37,7 @@ public class MinioProducer extends DefaultProducer {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n }\n", "next_change": {"commit": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex bef3a9c6607..a14c218b4a8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,28 +16,551 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n+import org.apache.camel.*;\n import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n /**\n- * The Minio producer.\n+ * A Producer which sends messages to the Minio Simple Storage\n  */\n public class MinioProducer extends DefaultProducer {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n-    private MinioEndpoint endpoint;\n \n-    public MinioProducer(final MinioEndpoint endpoint) {\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n         super(endpoint);\n-        this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n-        System.out.println(exchange.getIn().getBody());\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        if (ObjectHelper.isEmpty(operation)) {\n+            if (getConfiguration().isMultiPartUpload()) {\n+                processMultiPart(exchange);\n+            } else {\n+                processSingleOp(exchange);\n+            }\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObject:\n+                    getObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObjectRange:\n+                    getObjectRange(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void processMultiPart(final Exchange exchange) throws Exception {\n+        File filePayload = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+        } else {\n+            throw new IllegalArgumentException(\"aws2-s3: MultiPart upload requires a File input.\");\n+        }\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+        if (objectMetadata.containsKey(\"Content-Length\")) {\n+            if (objectMetadata.get(\"Content-Length\").equalsIgnoreCase(\"0\")) {\n+                objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+            }\n+        } else {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+        }\n+\n+        final String keyName = determineKey(exchange);\n+        CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            createMultipartUploadRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            createMultipartUploadRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            createMultipartUploadRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            createMultipartUploadRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                createMultipartUploadRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                createMultipartUploadRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                createMultipartUploadRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", createMultipartUploadRequest, exchange);\n+\n+        CreateMultipartUploadResponse initResponse = getEndpoint().getMinioClient().createMultipartUpload(createMultipartUploadRequest.build());\n+        final long contentLength = Long.valueOf(objectMetadata.get(\"Content-Length\"));\n+        List<CompletedPart> completedParts = new ArrayList<CompletedPart>();\n+        long partSize = getConfiguration().getPartSize();\n+        CompleteMultipartUploadResponse uploadResult = null;\n+\n+        long filePosition = 0;\n+\n+        try {\n+            for (int part = 1; filePosition < contentLength; part++) {\n+                partSize = Math.min(partSize, contentLength - filePosition);\n+\n+                UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId())\n+                        .partNumber(part).build();\n+\n+                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n+                String etag = getEndpoint().getMinioClient().uploadPart(uploadRequest, RequestBody.fromFile(filePayload)).eTag();\n+                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();\n+                completedParts.add(partUpload);\n+                filePosition += partSize;\n+            }\n+            CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();\n+            CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload)\n+                    .bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();\n+\n+            uploadResult = getEndpoint().getMinioClient().completeMultipartUpload(compRequest);\n+\n+        } catch (Exception e) {\n+            getEndpoint().getMinioClient()\n+                    .abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());\n+            throw e;\n+        }\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, uploadResult.eTag());\n+        if (uploadResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, uploadResult.versionId());\n+        }\n+\n+        if (getConfiguration().isDeleteAfterWrite()) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    public void processSingleOp(final Exchange exchange) throws Exception {\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+\n+        File filePayload = null;\n+        InputStream is = null;\n+        ByteArrayOutputStream baos = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+            is = new FileInputStream(filePayload);\n+        } else {\n+            is = exchange.getIn().getMandatoryBody(InputStream.class);\n+            if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                    LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                    baos = determineLengthInputStream(is);\n+                    objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                    is = new ByteArrayInputStream(baos.toByteArray());\n+                } else {\n+                    if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                    }\n+                }\n+            }\n+        }\n+\n+        final String bucketName = determineBucketName(exchange);\n+        final String key = determineKey(exchange);\n+        putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            putObjectRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            putObjectRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            putObjectRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+            }\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Put object [{}] from exchange [{}]...\", putObjectRequest, exchange);\n+\n+        PutObjectResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build(), RequestBody.fromBytes(SdkBytes.fromInputStream(is).asByteArray()));\n+\n+        LOG.trace(\"Received result [{}]\", putObjectResult);\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, putObjectResult.eTag());\n+        if (putObjectResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+        }\n+\n+        IOHelper.close(is);\n+\n+        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_KEY, String.class);\n+        final String bucketNameDestination = exchange.getIn().getHeader(MinioConstants.BUCKET_DESTINATION_NAME, String.class);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof CopyObjectRequest) {\n+                CopyObjectResponse result;\n+                result = minioClient.copyObject((CopyObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+            if (ObjectHelper.isEmpty(bucketNameDestination)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+            CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder();\n+            copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).copySource(bucketName + \"/\" + sourceKey);\n+\n+            if (getConfiguration().isUseAwsKMS()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                    copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+                }\n+            }\n+\n+            if (getConfiguration().isUseCustomerKey()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                    copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                    copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                    copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+                }\n+            }\n+\n+            CopyObjectResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteObjectRequest) {\n+                minioClient.deleteObject((DeleteObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            DeleteObjectRequest.Builder deleteObjectRequest = DeleteObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            minioClient.deleteObject(deleteObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) {\n+        ListBucketsResponse bucketsList = minioClient.listBuckets();\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setBody(bucketsList.buckets());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteBucketRequest) {\n+                DeleteBucketResponse resp = minioClient.deleteBucket((DeleteBucketRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(resp);\n+            }\n+        } else {\n+\n+            DeleteBucketRequest.Builder deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName);\n+            DeleteBucketResponse resp = minioClient.deleteBucket(deleteBucketRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(resp);\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineKey(exchange);\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void getObjectRange(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String rangeStart = exchange.getIn().getHeader(MinioConstants.RANGE_START, String.class);\n+        final String rangeEnd = exchange.getIn().getHeader(MinioConstants.RANGE_END, String.class);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+\n+            if (ObjectHelper.isEmpty(rangeStart) || ObjectHelper.isEmpty(rangeEnd)) {\n+                throw new IllegalArgumentException(\"A Range start and range end header must be configured to perform a range get operation.\");\n+            }\n+\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey)\n+                    .range(\"bytes=\" + Long.parseLong(rangeStart) + \"-\" + Long.parseLong(rangeEnd));\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof ListObjectsRequest) {\n+                ListObjectsResponse objectList = minioClient.listObjects((ListObjectsRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList.contents());\n+            }\n+        } else {\n+\n+            ListObjectsResponse objectList = minioClient.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList.contents());\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.Minio_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<String, String>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"AWS S3 Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineKey(final Exchange exchange) {\n+        String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+        if (ObjectHelper.isEmpty(key)) {\n+            key = getConfiguration().getKeyName();\n+        }\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Key header missing.\");\n+        }\n+        return key;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream is) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];\n+        int count;\n+        while ((count = is.read(bytes)) > 0) {\n+            out.write(bytes, 0, count);\n+        }\n+        return out;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (minioProducerToString == null) {\n+            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+        }\n+        return minioProducerToString;\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex a14c218b4a8..d5c3579376d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -563,4 +470,8 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex d5c3579376d..44ea0653d78 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -470,8 +473,4 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 44ea0653d78..79c80ab4cae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -472,5 +491,4 @@ public class MinioProducer extends DefaultProducer {\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -227,25 +234,23 @@ public class MinioProducer extends DefaultProducer {\n             ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n \n             Message message = getMessageForResponse(exchange);\n-            if (copyObjectResult.versionId() != null) {\n+            if (isNotEmpty(copyObjectResult.versionId())) {\n                 message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n             }\n         }\n     }\n \n     private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-        final String sourceKey = determineObjectName(exchange);\n-        final String versionId = determineVersionId(exchange);\n         if (getConfiguration().isPojoRequest()) {\n             RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (payload != null) {\n+            if (isNotEmpty(payload)) {\n                 minioClient.removeObject(payload.build());\n                 Message message = getMessageForResponse(exchange);\n                 message.setBody(true);\n             }\n         } else {\n-\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n             minioClient.removeObject(RemoveObjectArgs.builder()\n                     .bucket(bucketName)\n                     .object(sourceKey).build());\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "25628a8919c403b25ce89dd485fe59278b7effd7", "committedDate": "2021-08-30 10:56:11 +0200", "message": "(chores) fix resource leaks in camel-grape and camel-minio (#6005)"}, {"oid": "99e08d0237368053b32935bfdb3106b67e7222d4", "committedDate": "2021-09-30 12:32:06 +0200", "message": "CAMEL-17021: camel-minio - Determine content-length in a smarter way (#6184)"}, {"oid": "b04bc67e4c63ab845669f77cc13a9dee5f54fdbf", "committedDate": "2022-10-05 06:26:38 -0500", "message": "CAMEL-18583: [camel-minio] deleteObjects operation does not delete multiple objects (#8483)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NjczMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460756730", "body": "`isNotEmpty` as I mentioned earlier would make more sense here", "bodyText": "isNotEmpty as I mentioned earlier would make more sense here", "bodyHTML": "<p dir=\"auto\"><code>isNotEmpty</code> as I mentioned earlier would make more sense here</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:17:20Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -381,32 +385,32 @@ public class MinioProducer extends DefaultProducer {\n         Map<String, String> objectMetadata = new HashMap<>();\n \n         Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (contentLength != null) {\n+        if (isNotEmpty(contentLength)) {\n             objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n         }\n \n         String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (contentType != null) {\n+        if (isNotEmpty(contentType)) {\n             objectMetadata.put(\"Content-Type\", contentType);\n         }\n \n         String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (cacheControl != null) {\n+        if (isNotEmpty(cacheControl)) {\n             objectMetadata.put(\"Cache-Control\", cacheControl);\n         }\n \n         String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (contentDisposition != null) {\n+        if (isNotEmpty(contentDisposition)) {\n             objectMetadata.put(\"Content-Disposition\", contentDisposition);\n         }\n \n         String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (contentEncoding != null) {\n+        if (isNotEmpty(contentEncoding)) {\n             objectMetadata.put(\"Content-Encoding\", contentEncoding);\n         }\n \n         String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (contentMD5 != null) {\n+        if (isNotEmpty(contentMD5)) {\n             objectMetadata.put(\"Content-Md5\", contentMD5);\n         }\n \n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 6be64b509d8..8137de609b5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -385,32 +378,32 @@ public class MinioProducer extends DefaultProducer {\n         Map<String, String> objectMetadata = new HashMap<>();\n \n         Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (isNotEmpty(contentLength)) {\n+        if (contentLength != null) {\n             objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n         }\n \n         String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (isNotEmpty(contentType)) {\n+        if (contentType != null) {\n             objectMetadata.put(\"Content-Type\", contentType);\n         }\n \n         String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (isNotEmpty(cacheControl)) {\n+        if (cacheControl != null) {\n             objectMetadata.put(\"Cache-Control\", cacheControl);\n         }\n \n         String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (isNotEmpty(contentDisposition)) {\n+        if (contentDisposition != null) {\n             objectMetadata.put(\"Content-Disposition\", contentDisposition);\n         }\n \n         String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (isNotEmpty(contentEncoding)) {\n+        if (contentEncoding != null) {\n             objectMetadata.put(\"Content-Encoding\", contentEncoding);\n         }\n \n         String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (isNotEmpty(contentMD5)) {\n+        if (contentMD5 != null) {\n             objectMetadata.put(\"Content-Md5\", contentMD5);\n         }\n \n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8137de609b5..630540ebace 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -378,32 +386,32 @@ public class MinioProducer extends DefaultProducer {\n         Map<String, String> objectMetadata = new HashMap<>();\n \n         Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (contentLength != null) {\n+        if (isNotEmpty(contentLength)) {\n             objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n         }\n \n         String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (contentType != null) {\n+        if (isNotEmpty(contentType)) {\n             objectMetadata.put(\"Content-Type\", contentType);\n         }\n \n         String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (cacheControl != null) {\n+        if (isNotEmpty(cacheControl)) {\n             objectMetadata.put(\"Cache-Control\", cacheControl);\n         }\n \n         String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (contentDisposition != null) {\n+        if (isNotEmpty(contentDisposition)) {\n             objectMetadata.put(\"Content-Disposition\", contentDisposition);\n         }\n \n         String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (contentEncoding != null) {\n+        if (isNotEmpty(contentEncoding)) {\n             objectMetadata.put(\"Content-Encoding\", contentEncoding);\n         }\n \n         String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (contentMD5 != null) {\n+        if (isNotEmpty(contentMD5)) {\n             objectMetadata.put(\"Content-Md5\", contentMD5);\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 630540ebace..9649c1df3e3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,474 +16,22 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectWriteResponse;\n-import io.minio.PutObjectArgs;\n-import io.minio.RemoveBucketArgs;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.RemoveObjectsArgs;\n-import io.minio.Result;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n-import org.apache.camel.InvalidPayloadException;\n-import org.apache.camel.Message;\n-import org.apache.camel.WrappedFile;\n import org.apache.camel.support.DefaultProducer;\n-import org.apache.camel.util.FileUtil;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-\n-/**\n- * A Producer which sends messages to the Minio Simple Storage\n- */\n public class MinioProducer extends DefaultProducer {\n-\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private MinioEndpoint endpoint;\n \n-    private transient String minioProducerToString;\n-\n-    public MinioProducer(final Endpoint endpoint) {\n+    public MinioProducer(MinioEndpoint endpoint) {\n         super(endpoint);\n+        this.endpoint = endpoint;\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n-    @Override\n-    public void process(final Exchange exchange) throws Exception {\n-        MinioOperations operation = determineOperation(exchange);\n-        MinioClient minioClient = getEndpoint().getMinioClient();\n-        if (isEmpty(operation)) {\n-            putObject(minioClient, exchange);\n-        } else {\n-            switch (operation) {\n-                case copyObject:\n-                    copyObject(minioClient, exchange);\n-                    break;\n-                case deleteObject:\n-                    deleteObject(minioClient, exchange);\n-                    break;\n-                case deleteObjects:\n-                    deleteObjects(minioClient, exchange);\n-                    break;\n-                case listBuckets:\n-                    listBuckets(minioClient, exchange);\n-                    break;\n-                case deleteBucket:\n-                    deleteBucket(minioClient, exchange);\n-                    break;\n-                case listObjects:\n-                    listObjects(minioClient, exchange);\n-                    break;\n-                case getObject:\n-                    getObject(minioClient, exchange);\n-                    break;\n-                case getPartialObject:\n-                    getPartialObject(minioClient, exchange);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported operation\");\n-            }\n-        }\n-    }\n-\n-    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-                if (isNotEmpty(putObjectResult.versionId())) {\n-                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-                }\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String objectName = determineObjectName(exchange);\n-            Map<String, String> objectMetadata = determineMetadata(exchange);\n-            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n-\n-            File filePayload = null;\n-            InputStream inputStream;\n-            ByteArrayOutputStream baos;\n-            Object object = exchange.getIn().getMandatoryBody();\n-\n-            // Need to check if the message body is WrappedFile\n-            if (object instanceof WrappedFile) {\n-                object = ((WrappedFile<?>) object).getFile();\n-            }\n-            if (object instanceof File) {\n-                filePayload = (File) object;\n-                inputStream = new FileInputStream(filePayload);\n-            } else {\n-                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n-                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n-                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n-                        baos = determineLengthInputStream(inputStream);\n-                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n-                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n-                    } else {\n-                        if (isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n-                        }\n-                    }\n-                }\n-            }\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(bucketName)\n-                    .object(objectName)\n-                    .userMetadata(objectMetadata);\n-\n-            if (!extraHeaders.isEmpty()) {\n-                putObjectRequest.extraHeaders(extraHeaders);\n-            }\n-\n-            LOG.trace(\"Put object from exchange...\");\n-\n-            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n-\n-            LOG.trace(\"Received result...\");\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-            if (isNotEmpty(putObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-            }\n-\n-            IOHelper.close(inputStream);\n-\n-            if (getConfiguration().isDeleteAfterWrite() && isNotEmpty(filePayload)) {\n-                FileUtil.deleteFile(filePayload);\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n-        Map<String, String> extraHeaders = new HashMap<>();\n-        String storageClass = determineStorageClass(exchange);\n-        if (isNotEmpty(storageClass)) {\n-            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n-        }\n-\n-        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n-        if (isNotEmpty(cannedAcl)) {\n-            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n-        }\n-\n-        return extraHeaders;\n-    }\n-\n-    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(result);\n-            }\n-        } else {\n-\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n-            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n-\n-            if (isEmpty(destinationBucketName)) {\n-                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n-            }\n-            if (isEmpty(destinationKey)) {\n-                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n-            }\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(destinationBucketName)\n-                    .object(destinationKey)\n-                    .source(copySourceBuilder.build());\n-\n-            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            if (isNotEmpty(copyObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n-            }\n-        }\n-    }\n-\n-    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            minioClient.removeObject(RemoveObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey).build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(true);\n-        }\n-    }\n-\n-    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n-        }\n-    }\n-\n-    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n-        List<Bucket> bucketsList = minioClient.listBuckets();\n-        Message message = getMessageForResponse(exchange);\n-        //returns iterator of bucketList\n-        message.setBody(bucketsList.iterator());\n-    }\n-\n-    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeBucket(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(\"ok\");\n-            }\n-        } else {\n-\n-            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(\"ok\");\n-        }\n+    public void process(Exchange exchange) throws Exception {\n+        System.out.println(exchange.getIn().getBody());\n     }\n \n-    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n-            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n-\n-            if (isEmpty(offset) || isEmpty(length)) {\n-                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n-            }\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .offset(Long.parseLong(offset))\n-                    .length(Long.parseLong(length))\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(objectList);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-\n-            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(objectList);\n-        }\n-    }\n-\n-    private MinioOperations determineOperation(Exchange exchange) {\n-        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n-        if (isEmpty(operation)) {\n-            operation = getConfiguration().getOperation();\n-        }\n-        return operation;\n-    }\n-\n-    private Map<String, String> determineMetadata(final Exchange exchange) {\n-        Map<String, String> objectMetadata = new HashMap<>();\n-\n-        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (isNotEmpty(contentLength)) {\n-            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n-        }\n-\n-        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (isNotEmpty(contentType)) {\n-            objectMetadata.put(\"Content-Type\", contentType);\n-        }\n-\n-        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (isNotEmpty(cacheControl)) {\n-            objectMetadata.put(\"Cache-Control\", cacheControl);\n-        }\n-\n-        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (isNotEmpty(contentDisposition)) {\n-            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n-        }\n-\n-        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (isNotEmpty(contentEncoding)) {\n-            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n-        }\n-\n-        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (isNotEmpty(contentMD5)) {\n-            objectMetadata.put(\"Content-Md5\", contentMD5);\n-        }\n-\n-        return objectMetadata;\n-    }\n-\n-    /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n-     *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n-     * @throws IllegalArgumentException if the header could not be determined.\n-     */\n-    private String determineBucketName(final Exchange exchange) {\n-        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-\n-        if (isEmpty(bucketName)) {\n-            if (isNotEmpty(getConfiguration().getBucketName())) {\n-                bucketName = getConfiguration().getBucketName();\n-                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-            } else {\n-                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-            }\n-        }\n-        return bucketName;\n-    }\n-\n-    private String determineObjectName(final Exchange exchange) {\n-        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (isEmpty(objectName)) {\n-            objectName = getConfiguration().getKeyName();\n-        }\n-        if (isEmpty(objectName)) {\n-            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n-        }\n-        return objectName;\n-    }\n-\n-    private String determineStorageClass(final Exchange exchange) {\n-        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (isEmpty(storageClass)) {\n-            storageClass = getConfiguration().getStorageClass();\n-        }\n-\n-        return storageClass;\n-    }\n-\n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n-        }\n-        return out;\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioProducerToString)) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 9649c1df3e3..7a4306e2cf3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,21 +16,21 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n import org.apache.camel.support.DefaultProducer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+/**\n+ * The Minio producer.\n+ */\n public class MinioProducer extends DefaultProducer {\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioProducer.class);\n     private MinioEndpoint endpoint;\n \n-    public MinioProducer(MinioEndpoint endpoint) {\n+    public MinioProducer(final MinioEndpoint endpoint) {\n         super(endpoint);\n         this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n+    public void process(org.apache.camel.Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "c6a9b5ac3b4d5a128c045495008174d905492576", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 7a4306e2cf3..2ab2c6e4a95 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -30,7 +33,7 @@ public class MinioProducer extends DefaultProducer {\n         this.endpoint = endpoint;\n     }\n \n-    public void process(org.apache.camel.Exchange exchange) throws Exception {\n+    public void process(Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 2ab2c6e4a95..bef3a9c6607 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -37,4 +37,7 @@ public class MinioProducer extends DefaultProducer {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n }\n", "next_change": {"commit": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex bef3a9c6607..a14c218b4a8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,28 +16,551 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n+import org.apache.camel.*;\n import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n /**\n- * The Minio producer.\n+ * A Producer which sends messages to the Minio Simple Storage\n  */\n public class MinioProducer extends DefaultProducer {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n-    private MinioEndpoint endpoint;\n \n-    public MinioProducer(final MinioEndpoint endpoint) {\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n         super(endpoint);\n-        this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n-        System.out.println(exchange.getIn().getBody());\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        if (ObjectHelper.isEmpty(operation)) {\n+            if (getConfiguration().isMultiPartUpload()) {\n+                processMultiPart(exchange);\n+            } else {\n+                processSingleOp(exchange);\n+            }\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObject:\n+                    getObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObjectRange:\n+                    getObjectRange(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void processMultiPart(final Exchange exchange) throws Exception {\n+        File filePayload = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+        } else {\n+            throw new IllegalArgumentException(\"aws2-s3: MultiPart upload requires a File input.\");\n+        }\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+        if (objectMetadata.containsKey(\"Content-Length\")) {\n+            if (objectMetadata.get(\"Content-Length\").equalsIgnoreCase(\"0\")) {\n+                objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+            }\n+        } else {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+        }\n+\n+        final String keyName = determineKey(exchange);\n+        CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            createMultipartUploadRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            createMultipartUploadRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            createMultipartUploadRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            createMultipartUploadRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                createMultipartUploadRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                createMultipartUploadRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                createMultipartUploadRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", createMultipartUploadRequest, exchange);\n+\n+        CreateMultipartUploadResponse initResponse = getEndpoint().getMinioClient().createMultipartUpload(createMultipartUploadRequest.build());\n+        final long contentLength = Long.valueOf(objectMetadata.get(\"Content-Length\"));\n+        List<CompletedPart> completedParts = new ArrayList<CompletedPart>();\n+        long partSize = getConfiguration().getPartSize();\n+        CompleteMultipartUploadResponse uploadResult = null;\n+\n+        long filePosition = 0;\n+\n+        try {\n+            for (int part = 1; filePosition < contentLength; part++) {\n+                partSize = Math.min(partSize, contentLength - filePosition);\n+\n+                UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId())\n+                        .partNumber(part).build();\n+\n+                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n+                String etag = getEndpoint().getMinioClient().uploadPart(uploadRequest, RequestBody.fromFile(filePayload)).eTag();\n+                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();\n+                completedParts.add(partUpload);\n+                filePosition += partSize;\n+            }\n+            CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();\n+            CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload)\n+                    .bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();\n+\n+            uploadResult = getEndpoint().getMinioClient().completeMultipartUpload(compRequest);\n+\n+        } catch (Exception e) {\n+            getEndpoint().getMinioClient()\n+                    .abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());\n+            throw e;\n+        }\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, uploadResult.eTag());\n+        if (uploadResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, uploadResult.versionId());\n+        }\n+\n+        if (getConfiguration().isDeleteAfterWrite()) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    public void processSingleOp(final Exchange exchange) throws Exception {\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+\n+        File filePayload = null;\n+        InputStream is = null;\n+        ByteArrayOutputStream baos = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+            is = new FileInputStream(filePayload);\n+        } else {\n+            is = exchange.getIn().getMandatoryBody(InputStream.class);\n+            if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                    LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                    baos = determineLengthInputStream(is);\n+                    objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                    is = new ByteArrayInputStream(baos.toByteArray());\n+                } else {\n+                    if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                    }\n+                }\n+            }\n+        }\n+\n+        final String bucketName = determineBucketName(exchange);\n+        final String key = determineKey(exchange);\n+        putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            putObjectRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            putObjectRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            putObjectRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+            }\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Put object [{}] from exchange [{}]...\", putObjectRequest, exchange);\n+\n+        PutObjectResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build(), RequestBody.fromBytes(SdkBytes.fromInputStream(is).asByteArray()));\n+\n+        LOG.trace(\"Received result [{}]\", putObjectResult);\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, putObjectResult.eTag());\n+        if (putObjectResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+        }\n+\n+        IOHelper.close(is);\n+\n+        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_KEY, String.class);\n+        final String bucketNameDestination = exchange.getIn().getHeader(MinioConstants.BUCKET_DESTINATION_NAME, String.class);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof CopyObjectRequest) {\n+                CopyObjectResponse result;\n+                result = minioClient.copyObject((CopyObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+            if (ObjectHelper.isEmpty(bucketNameDestination)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+            CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder();\n+            copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).copySource(bucketName + \"/\" + sourceKey);\n+\n+            if (getConfiguration().isUseAwsKMS()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                    copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+                }\n+            }\n+\n+            if (getConfiguration().isUseCustomerKey()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                    copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                    copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                    copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+                }\n+            }\n+\n+            CopyObjectResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteObjectRequest) {\n+                minioClient.deleteObject((DeleteObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            DeleteObjectRequest.Builder deleteObjectRequest = DeleteObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            minioClient.deleteObject(deleteObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) {\n+        ListBucketsResponse bucketsList = minioClient.listBuckets();\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setBody(bucketsList.buckets());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteBucketRequest) {\n+                DeleteBucketResponse resp = minioClient.deleteBucket((DeleteBucketRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(resp);\n+            }\n+        } else {\n+\n+            DeleteBucketRequest.Builder deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName);\n+            DeleteBucketResponse resp = minioClient.deleteBucket(deleteBucketRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(resp);\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineKey(exchange);\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void getObjectRange(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String rangeStart = exchange.getIn().getHeader(MinioConstants.RANGE_START, String.class);\n+        final String rangeEnd = exchange.getIn().getHeader(MinioConstants.RANGE_END, String.class);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+\n+            if (ObjectHelper.isEmpty(rangeStart) || ObjectHelper.isEmpty(rangeEnd)) {\n+                throw new IllegalArgumentException(\"A Range start and range end header must be configured to perform a range get operation.\");\n+            }\n+\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey)\n+                    .range(\"bytes=\" + Long.parseLong(rangeStart) + \"-\" + Long.parseLong(rangeEnd));\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof ListObjectsRequest) {\n+                ListObjectsResponse objectList = minioClient.listObjects((ListObjectsRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList.contents());\n+            }\n+        } else {\n+\n+            ListObjectsResponse objectList = minioClient.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList.contents());\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.Minio_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<String, String>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"AWS S3 Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineKey(final Exchange exchange) {\n+        String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+        if (ObjectHelper.isEmpty(key)) {\n+            key = getConfiguration().getKeyName();\n+        }\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Key header missing.\");\n+        }\n+        return key;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream is) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];\n+        int count;\n+        while ((count = is.read(bytes)) > 0) {\n+            out.write(bytes, 0, count);\n+        }\n+        return out;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (minioProducerToString == null) {\n+            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+        }\n+        return minioProducerToString;\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex a14c218b4a8..d5c3579376d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -563,4 +470,8 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex d5c3579376d..44ea0653d78 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -470,8 +473,4 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 44ea0653d78..79c80ab4cae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -472,5 +491,4 @@ public class MinioProducer extends DefaultProducer {\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -381,32 +385,32 @@ public class MinioProducer extends DefaultProducer {\n         Map<String, String> objectMetadata = new HashMap<>();\n \n         Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (contentLength != null) {\n+        if (isNotEmpty(contentLength)) {\n             objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n         }\n \n         String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (contentType != null) {\n+        if (isNotEmpty(contentType)) {\n             objectMetadata.put(\"Content-Type\", contentType);\n         }\n \n         String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (cacheControl != null) {\n+        if (isNotEmpty(cacheControl)) {\n             objectMetadata.put(\"Cache-Control\", cacheControl);\n         }\n \n         String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (contentDisposition != null) {\n+        if (isNotEmpty(contentDisposition)) {\n             objectMetadata.put(\"Content-Disposition\", contentDisposition);\n         }\n \n         String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (contentEncoding != null) {\n+        if (isNotEmpty(contentEncoding)) {\n             objectMetadata.put(\"Content-Encoding\", contentEncoding);\n         }\n \n         String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (contentMD5 != null) {\n+        if (isNotEmpty(contentMD5)) {\n             objectMetadata.put(\"Content-Md5\", contentMD5);\n         }\n \n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 1e19e06c13b..5ed607a5381 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -418,11 +422,11 @@ public class MinioProducer extends DefaultProducer {\n     }\n \n     /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n+     * Reads the bucket name from the header of the given exchange. If not provided, it's read from the endpoint\n+     * configuration.\n      *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n+     * @param  exchange                 The exchange to read the header from.\n+     * @return                          The bucket name.\n      * @throws IllegalArgumentException if the header could not be determined.\n      */\n     private String determineBucketName(final Exchange exchange) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "25628a8919c403b25ce89dd485fe59278b7effd7", "committedDate": "2021-08-30 10:56:11 +0200", "message": "(chores) fix resource leaks in camel-grape and camel-minio (#6005)"}, {"oid": "99e08d0237368053b32935bfdb3106b67e7222d4", "committedDate": "2021-09-30 12:32:06 +0200", "message": "CAMEL-17021: camel-minio - Determine content-length in a smarter way (#6184)"}, {"oid": "b04bc67e4c63ab845669f77cc13a9dee5f54fdbf", "committedDate": "2022-10-05 06:26:38 -0500", "message": "CAMEL-18583: [camel-minio] deleteObjects operation does not delete multiple objects (#8483)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1Nzg3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460757877", "body": "this check here is not needed. `ObjectHelper.isEmpty(bucketName)` will check if string is empty or null", "bodyText": "this check here is not needed. ObjectHelper.isEmpty(bucketName) will check if string is empty or null", "bodyHTML": "<p dir=\"auto\">this check here is not needed. <code>ObjectHelper.isEmpty(bucketName)</code> will check if string is empty or null</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:19:21Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -424,24 +428,23 @@ public class MinioProducer extends DefaultProducer {\n     private String determineBucketName(final Exchange exchange) {\n         String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n \n-        if (ObjectHelper.isEmpty(bucketName)) {\n-            bucketName = getConfiguration().getBucketName();\n-            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-        }\n-\n-        if (bucketName == null) {\n-            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        if (isEmpty(bucketName)) {\n+            if (isNotEmpty(getConfiguration().getBucketName())) {\n+                bucketName = getConfiguration().getBucketName();\n+                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+            } else {\n+                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+            }\n         }\n-\n         return bucketName;\n     }\n \n     private String determineObjectName(final Exchange exchange) {\n         String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (ObjectHelper.isEmpty(objectName)) {\n+        if (isEmpty(objectName)) {\n             objectName = getConfiguration().getKeyName();\n         }\n-        if (objectName == null) {\n+        if (isEmpty(objectName)) {\n             throw new IllegalArgumentException(\"Minio Key header is missing.\");\n         }\n         return objectName;\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 6be64b509d8..8137de609b5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -428,23 +421,24 @@ public class MinioProducer extends DefaultProducer {\n     private String determineBucketName(final Exchange exchange) {\n         String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n \n-        if (isEmpty(bucketName)) {\n-            if (isNotEmpty(getConfiguration().getBucketName())) {\n-                bucketName = getConfiguration().getBucketName();\n-                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-            } else {\n-                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-            }\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n         }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        }\n+\n         return bucketName;\n     }\n \n     private String determineObjectName(final Exchange exchange) {\n         String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (isEmpty(objectName)) {\n+        if (ObjectHelper.isEmpty(objectName)) {\n             objectName = getConfiguration().getKeyName();\n         }\n-        if (isEmpty(objectName)) {\n+        if (objectName == null) {\n             throw new IllegalArgumentException(\"Minio Key header is missing.\");\n         }\n         return objectName;\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8137de609b5..630540ebace 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -421,24 +429,23 @@ public class MinioProducer extends DefaultProducer {\n     private String determineBucketName(final Exchange exchange) {\n         String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n \n-        if (ObjectHelper.isEmpty(bucketName)) {\n-            bucketName = getConfiguration().getBucketName();\n-            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-        }\n-\n-        if (bucketName == null) {\n-            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        if (isEmpty(bucketName)) {\n+            if (isNotEmpty(getConfiguration().getBucketName())) {\n+                bucketName = getConfiguration().getBucketName();\n+                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+            } else {\n+                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+            }\n         }\n-\n         return bucketName;\n     }\n \n     private String determineObjectName(final Exchange exchange) {\n         String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (ObjectHelper.isEmpty(objectName)) {\n+        if (isEmpty(objectName)) {\n             objectName = getConfiguration().getKeyName();\n         }\n-        if (objectName == null) {\n+        if (isEmpty(objectName)) {\n             throw new IllegalArgumentException(\"Minio Key header is missing.\");\n         }\n         return objectName;\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 630540ebace..9649c1df3e3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,474 +16,22 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectWriteResponse;\n-import io.minio.PutObjectArgs;\n-import io.minio.RemoveBucketArgs;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.RemoveObjectsArgs;\n-import io.minio.Result;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n-import org.apache.camel.InvalidPayloadException;\n-import org.apache.camel.Message;\n-import org.apache.camel.WrappedFile;\n import org.apache.camel.support.DefaultProducer;\n-import org.apache.camel.util.FileUtil;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-\n-/**\n- * A Producer which sends messages to the Minio Simple Storage\n- */\n public class MinioProducer extends DefaultProducer {\n-\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private MinioEndpoint endpoint;\n \n-    private transient String minioProducerToString;\n-\n-    public MinioProducer(final Endpoint endpoint) {\n+    public MinioProducer(MinioEndpoint endpoint) {\n         super(endpoint);\n+        this.endpoint = endpoint;\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n-    @Override\n-    public void process(final Exchange exchange) throws Exception {\n-        MinioOperations operation = determineOperation(exchange);\n-        MinioClient minioClient = getEndpoint().getMinioClient();\n-        if (isEmpty(operation)) {\n-            putObject(minioClient, exchange);\n-        } else {\n-            switch (operation) {\n-                case copyObject:\n-                    copyObject(minioClient, exchange);\n-                    break;\n-                case deleteObject:\n-                    deleteObject(minioClient, exchange);\n-                    break;\n-                case deleteObjects:\n-                    deleteObjects(minioClient, exchange);\n-                    break;\n-                case listBuckets:\n-                    listBuckets(minioClient, exchange);\n-                    break;\n-                case deleteBucket:\n-                    deleteBucket(minioClient, exchange);\n-                    break;\n-                case listObjects:\n-                    listObjects(minioClient, exchange);\n-                    break;\n-                case getObject:\n-                    getObject(minioClient, exchange);\n-                    break;\n-                case getPartialObject:\n-                    getPartialObject(minioClient, exchange);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported operation\");\n-            }\n-        }\n-    }\n-\n-    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-                if (isNotEmpty(putObjectResult.versionId())) {\n-                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-                }\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String objectName = determineObjectName(exchange);\n-            Map<String, String> objectMetadata = determineMetadata(exchange);\n-            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n-\n-            File filePayload = null;\n-            InputStream inputStream;\n-            ByteArrayOutputStream baos;\n-            Object object = exchange.getIn().getMandatoryBody();\n-\n-            // Need to check if the message body is WrappedFile\n-            if (object instanceof WrappedFile) {\n-                object = ((WrappedFile<?>) object).getFile();\n-            }\n-            if (object instanceof File) {\n-                filePayload = (File) object;\n-                inputStream = new FileInputStream(filePayload);\n-            } else {\n-                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n-                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n-                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n-                        baos = determineLengthInputStream(inputStream);\n-                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n-                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n-                    } else {\n-                        if (isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n-                        }\n-                    }\n-                }\n-            }\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(bucketName)\n-                    .object(objectName)\n-                    .userMetadata(objectMetadata);\n-\n-            if (!extraHeaders.isEmpty()) {\n-                putObjectRequest.extraHeaders(extraHeaders);\n-            }\n-\n-            LOG.trace(\"Put object from exchange...\");\n-\n-            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n-\n-            LOG.trace(\"Received result...\");\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-            if (isNotEmpty(putObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-            }\n-\n-            IOHelper.close(inputStream);\n-\n-            if (getConfiguration().isDeleteAfterWrite() && isNotEmpty(filePayload)) {\n-                FileUtil.deleteFile(filePayload);\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n-        Map<String, String> extraHeaders = new HashMap<>();\n-        String storageClass = determineStorageClass(exchange);\n-        if (isNotEmpty(storageClass)) {\n-            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n-        }\n-\n-        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n-        if (isNotEmpty(cannedAcl)) {\n-            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n-        }\n-\n-        return extraHeaders;\n-    }\n-\n-    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(result);\n-            }\n-        } else {\n-\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n-            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n-\n-            if (isEmpty(destinationBucketName)) {\n-                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n-            }\n-            if (isEmpty(destinationKey)) {\n-                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n-            }\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(destinationBucketName)\n-                    .object(destinationKey)\n-                    .source(copySourceBuilder.build());\n-\n-            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            if (isNotEmpty(copyObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n-            }\n-        }\n-    }\n-\n-    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            minioClient.removeObject(RemoveObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey).build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(true);\n-        }\n-    }\n-\n-    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n-        }\n-    }\n-\n-    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n-        List<Bucket> bucketsList = minioClient.listBuckets();\n-        Message message = getMessageForResponse(exchange);\n-        //returns iterator of bucketList\n-        message.setBody(bucketsList.iterator());\n-    }\n-\n-    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeBucket(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(\"ok\");\n-            }\n-        } else {\n-\n-            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(\"ok\");\n-        }\n+    public void process(Exchange exchange) throws Exception {\n+        System.out.println(exchange.getIn().getBody());\n     }\n \n-    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n-            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n-\n-            if (isEmpty(offset) || isEmpty(length)) {\n-                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n-            }\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .offset(Long.parseLong(offset))\n-                    .length(Long.parseLong(length))\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(objectList);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-\n-            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(objectList);\n-        }\n-    }\n-\n-    private MinioOperations determineOperation(Exchange exchange) {\n-        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n-        if (isEmpty(operation)) {\n-            operation = getConfiguration().getOperation();\n-        }\n-        return operation;\n-    }\n-\n-    private Map<String, String> determineMetadata(final Exchange exchange) {\n-        Map<String, String> objectMetadata = new HashMap<>();\n-\n-        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (isNotEmpty(contentLength)) {\n-            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n-        }\n-\n-        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (isNotEmpty(contentType)) {\n-            objectMetadata.put(\"Content-Type\", contentType);\n-        }\n-\n-        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (isNotEmpty(cacheControl)) {\n-            objectMetadata.put(\"Cache-Control\", cacheControl);\n-        }\n-\n-        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (isNotEmpty(contentDisposition)) {\n-            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n-        }\n-\n-        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (isNotEmpty(contentEncoding)) {\n-            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n-        }\n-\n-        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (isNotEmpty(contentMD5)) {\n-            objectMetadata.put(\"Content-Md5\", contentMD5);\n-        }\n-\n-        return objectMetadata;\n-    }\n-\n-    /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n-     *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n-     * @throws IllegalArgumentException if the header could not be determined.\n-     */\n-    private String determineBucketName(final Exchange exchange) {\n-        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-\n-        if (isEmpty(bucketName)) {\n-            if (isNotEmpty(getConfiguration().getBucketName())) {\n-                bucketName = getConfiguration().getBucketName();\n-                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-            } else {\n-                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-            }\n-        }\n-        return bucketName;\n-    }\n-\n-    private String determineObjectName(final Exchange exchange) {\n-        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (isEmpty(objectName)) {\n-            objectName = getConfiguration().getKeyName();\n-        }\n-        if (isEmpty(objectName)) {\n-            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n-        }\n-        return objectName;\n-    }\n-\n-    private String determineStorageClass(final Exchange exchange) {\n-        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (isEmpty(storageClass)) {\n-            storageClass = getConfiguration().getStorageClass();\n-        }\n-\n-        return storageClass;\n-    }\n-\n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n-        }\n-        return out;\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioProducerToString)) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 9649c1df3e3..7a4306e2cf3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,21 +16,21 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n import org.apache.camel.support.DefaultProducer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+/**\n+ * The Minio producer.\n+ */\n public class MinioProducer extends DefaultProducer {\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioProducer.class);\n     private MinioEndpoint endpoint;\n \n-    public MinioProducer(MinioEndpoint endpoint) {\n+    public MinioProducer(final MinioEndpoint endpoint) {\n         super(endpoint);\n         this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n+    public void process(org.apache.camel.Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "c6a9b5ac3b4d5a128c045495008174d905492576", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 7a4306e2cf3..2ab2c6e4a95 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -30,7 +33,7 @@ public class MinioProducer extends DefaultProducer {\n         this.endpoint = endpoint;\n     }\n \n-    public void process(org.apache.camel.Exchange exchange) throws Exception {\n+    public void process(Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 2ab2c6e4a95..bef3a9c6607 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -37,4 +37,7 @@ public class MinioProducer extends DefaultProducer {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n }\n", "next_change": {"commit": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex bef3a9c6607..a14c218b4a8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,28 +16,551 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n+import org.apache.camel.*;\n import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n /**\n- * The Minio producer.\n+ * A Producer which sends messages to the Minio Simple Storage\n  */\n public class MinioProducer extends DefaultProducer {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n-    private MinioEndpoint endpoint;\n \n-    public MinioProducer(final MinioEndpoint endpoint) {\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n         super(endpoint);\n-        this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n-        System.out.println(exchange.getIn().getBody());\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        if (ObjectHelper.isEmpty(operation)) {\n+            if (getConfiguration().isMultiPartUpload()) {\n+                processMultiPart(exchange);\n+            } else {\n+                processSingleOp(exchange);\n+            }\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObject:\n+                    getObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObjectRange:\n+                    getObjectRange(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void processMultiPart(final Exchange exchange) throws Exception {\n+        File filePayload = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+        } else {\n+            throw new IllegalArgumentException(\"aws2-s3: MultiPart upload requires a File input.\");\n+        }\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+        if (objectMetadata.containsKey(\"Content-Length\")) {\n+            if (objectMetadata.get(\"Content-Length\").equalsIgnoreCase(\"0\")) {\n+                objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+            }\n+        } else {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+        }\n+\n+        final String keyName = determineKey(exchange);\n+        CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            createMultipartUploadRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            createMultipartUploadRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            createMultipartUploadRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            createMultipartUploadRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                createMultipartUploadRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                createMultipartUploadRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                createMultipartUploadRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", createMultipartUploadRequest, exchange);\n+\n+        CreateMultipartUploadResponse initResponse = getEndpoint().getMinioClient().createMultipartUpload(createMultipartUploadRequest.build());\n+        final long contentLength = Long.valueOf(objectMetadata.get(\"Content-Length\"));\n+        List<CompletedPart> completedParts = new ArrayList<CompletedPart>();\n+        long partSize = getConfiguration().getPartSize();\n+        CompleteMultipartUploadResponse uploadResult = null;\n+\n+        long filePosition = 0;\n+\n+        try {\n+            for (int part = 1; filePosition < contentLength; part++) {\n+                partSize = Math.min(partSize, contentLength - filePosition);\n+\n+                UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId())\n+                        .partNumber(part).build();\n+\n+                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n+                String etag = getEndpoint().getMinioClient().uploadPart(uploadRequest, RequestBody.fromFile(filePayload)).eTag();\n+                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();\n+                completedParts.add(partUpload);\n+                filePosition += partSize;\n+            }\n+            CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();\n+            CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload)\n+                    .bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();\n+\n+            uploadResult = getEndpoint().getMinioClient().completeMultipartUpload(compRequest);\n+\n+        } catch (Exception e) {\n+            getEndpoint().getMinioClient()\n+                    .abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());\n+            throw e;\n+        }\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, uploadResult.eTag());\n+        if (uploadResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, uploadResult.versionId());\n+        }\n+\n+        if (getConfiguration().isDeleteAfterWrite()) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    public void processSingleOp(final Exchange exchange) throws Exception {\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+\n+        File filePayload = null;\n+        InputStream is = null;\n+        ByteArrayOutputStream baos = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+            is = new FileInputStream(filePayload);\n+        } else {\n+            is = exchange.getIn().getMandatoryBody(InputStream.class);\n+            if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                    LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                    baos = determineLengthInputStream(is);\n+                    objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                    is = new ByteArrayInputStream(baos.toByteArray());\n+                } else {\n+                    if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                    }\n+                }\n+            }\n+        }\n+\n+        final String bucketName = determineBucketName(exchange);\n+        final String key = determineKey(exchange);\n+        putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            putObjectRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            putObjectRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            putObjectRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+            }\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Put object [{}] from exchange [{}]...\", putObjectRequest, exchange);\n+\n+        PutObjectResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build(), RequestBody.fromBytes(SdkBytes.fromInputStream(is).asByteArray()));\n+\n+        LOG.trace(\"Received result [{}]\", putObjectResult);\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, putObjectResult.eTag());\n+        if (putObjectResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+        }\n+\n+        IOHelper.close(is);\n+\n+        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_KEY, String.class);\n+        final String bucketNameDestination = exchange.getIn().getHeader(MinioConstants.BUCKET_DESTINATION_NAME, String.class);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof CopyObjectRequest) {\n+                CopyObjectResponse result;\n+                result = minioClient.copyObject((CopyObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+            if (ObjectHelper.isEmpty(bucketNameDestination)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+            CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder();\n+            copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).copySource(bucketName + \"/\" + sourceKey);\n+\n+            if (getConfiguration().isUseAwsKMS()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                    copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+                }\n+            }\n+\n+            if (getConfiguration().isUseCustomerKey()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                    copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                    copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                    copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+                }\n+            }\n+\n+            CopyObjectResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteObjectRequest) {\n+                minioClient.deleteObject((DeleteObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            DeleteObjectRequest.Builder deleteObjectRequest = DeleteObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            minioClient.deleteObject(deleteObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) {\n+        ListBucketsResponse bucketsList = minioClient.listBuckets();\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setBody(bucketsList.buckets());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteBucketRequest) {\n+                DeleteBucketResponse resp = minioClient.deleteBucket((DeleteBucketRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(resp);\n+            }\n+        } else {\n+\n+            DeleteBucketRequest.Builder deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName);\n+            DeleteBucketResponse resp = minioClient.deleteBucket(deleteBucketRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(resp);\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineKey(exchange);\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void getObjectRange(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String rangeStart = exchange.getIn().getHeader(MinioConstants.RANGE_START, String.class);\n+        final String rangeEnd = exchange.getIn().getHeader(MinioConstants.RANGE_END, String.class);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+\n+            if (ObjectHelper.isEmpty(rangeStart) || ObjectHelper.isEmpty(rangeEnd)) {\n+                throw new IllegalArgumentException(\"A Range start and range end header must be configured to perform a range get operation.\");\n+            }\n+\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey)\n+                    .range(\"bytes=\" + Long.parseLong(rangeStart) + \"-\" + Long.parseLong(rangeEnd));\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof ListObjectsRequest) {\n+                ListObjectsResponse objectList = minioClient.listObjects((ListObjectsRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList.contents());\n+            }\n+        } else {\n+\n+            ListObjectsResponse objectList = minioClient.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList.contents());\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.Minio_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<String, String>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"AWS S3 Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineKey(final Exchange exchange) {\n+        String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+        if (ObjectHelper.isEmpty(key)) {\n+            key = getConfiguration().getKeyName();\n+        }\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Key header missing.\");\n+        }\n+        return key;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream is) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];\n+        int count;\n+        while ((count = is.read(bytes)) > 0) {\n+            out.write(bytes, 0, count);\n+        }\n+        return out;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (minioProducerToString == null) {\n+            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+        }\n+        return minioProducerToString;\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex a14c218b4a8..d5c3579376d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -563,4 +470,8 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex d5c3579376d..44ea0653d78 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -470,8 +473,4 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 44ea0653d78..79c80ab4cae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -472,5 +491,4 @@ public class MinioProducer extends DefaultProducer {\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8137de609b5..630540ebace 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -446,7 +453,7 @@ public class MinioProducer extends DefaultProducer {\n \n     private String determineStorageClass(final Exchange exchange) {\n         String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (storageClass == null) {\n+        if (isEmpty(storageClass)) {\n             storageClass = getConfiguration().getStorageClass();\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 630540ebace..9649c1df3e3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,474 +16,22 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectWriteResponse;\n-import io.minio.PutObjectArgs;\n-import io.minio.RemoveBucketArgs;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.RemoveObjectsArgs;\n-import io.minio.Result;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n-import org.apache.camel.InvalidPayloadException;\n-import org.apache.camel.Message;\n-import org.apache.camel.WrappedFile;\n import org.apache.camel.support.DefaultProducer;\n-import org.apache.camel.util.FileUtil;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-\n-/**\n- * A Producer which sends messages to the Minio Simple Storage\n- */\n public class MinioProducer extends DefaultProducer {\n-\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private MinioEndpoint endpoint;\n \n-    private transient String minioProducerToString;\n-\n-    public MinioProducer(final Endpoint endpoint) {\n+    public MinioProducer(MinioEndpoint endpoint) {\n         super(endpoint);\n+        this.endpoint = endpoint;\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n-    @Override\n-    public void process(final Exchange exchange) throws Exception {\n-        MinioOperations operation = determineOperation(exchange);\n-        MinioClient minioClient = getEndpoint().getMinioClient();\n-        if (isEmpty(operation)) {\n-            putObject(minioClient, exchange);\n-        } else {\n-            switch (operation) {\n-                case copyObject:\n-                    copyObject(minioClient, exchange);\n-                    break;\n-                case deleteObject:\n-                    deleteObject(minioClient, exchange);\n-                    break;\n-                case deleteObjects:\n-                    deleteObjects(minioClient, exchange);\n-                    break;\n-                case listBuckets:\n-                    listBuckets(minioClient, exchange);\n-                    break;\n-                case deleteBucket:\n-                    deleteBucket(minioClient, exchange);\n-                    break;\n-                case listObjects:\n-                    listObjects(minioClient, exchange);\n-                    break;\n-                case getObject:\n-                    getObject(minioClient, exchange);\n-                    break;\n-                case getPartialObject:\n-                    getPartialObject(minioClient, exchange);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported operation\");\n-            }\n-        }\n-    }\n-\n-    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-                if (isNotEmpty(putObjectResult.versionId())) {\n-                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-                }\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String objectName = determineObjectName(exchange);\n-            Map<String, String> objectMetadata = determineMetadata(exchange);\n-            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n-\n-            File filePayload = null;\n-            InputStream inputStream;\n-            ByteArrayOutputStream baos;\n-            Object object = exchange.getIn().getMandatoryBody();\n-\n-            // Need to check if the message body is WrappedFile\n-            if (object instanceof WrappedFile) {\n-                object = ((WrappedFile<?>) object).getFile();\n-            }\n-            if (object instanceof File) {\n-                filePayload = (File) object;\n-                inputStream = new FileInputStream(filePayload);\n-            } else {\n-                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n-                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n-                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n-                        baos = determineLengthInputStream(inputStream);\n-                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n-                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n-                    } else {\n-                        if (isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n-                        }\n-                    }\n-                }\n-            }\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(bucketName)\n-                    .object(objectName)\n-                    .userMetadata(objectMetadata);\n-\n-            if (!extraHeaders.isEmpty()) {\n-                putObjectRequest.extraHeaders(extraHeaders);\n-            }\n-\n-            LOG.trace(\"Put object from exchange...\");\n-\n-            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n-\n-            LOG.trace(\"Received result...\");\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-            if (isNotEmpty(putObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-            }\n-\n-            IOHelper.close(inputStream);\n-\n-            if (getConfiguration().isDeleteAfterWrite() && isNotEmpty(filePayload)) {\n-                FileUtil.deleteFile(filePayload);\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n-        Map<String, String> extraHeaders = new HashMap<>();\n-        String storageClass = determineStorageClass(exchange);\n-        if (isNotEmpty(storageClass)) {\n-            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n-        }\n-\n-        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n-        if (isNotEmpty(cannedAcl)) {\n-            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n-        }\n-\n-        return extraHeaders;\n-    }\n-\n-    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(result);\n-            }\n-        } else {\n-\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n-            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n-\n-            if (isEmpty(destinationBucketName)) {\n-                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n-            }\n-            if (isEmpty(destinationKey)) {\n-                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n-            }\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(destinationBucketName)\n-                    .object(destinationKey)\n-                    .source(copySourceBuilder.build());\n-\n-            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            if (isNotEmpty(copyObjectResult.versionId())) {\n-                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n-            }\n-        }\n-    }\n-\n-    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            minioClient.removeObject(RemoveObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey).build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(true);\n-        }\n-    }\n-\n-    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n-        }\n-    }\n-\n-    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n-        List<Bucket> bucketsList = minioClient.listBuckets();\n-        Message message = getMessageForResponse(exchange);\n-        //returns iterator of bucketList\n-        message.setBody(bucketsList.iterator());\n-    }\n-\n-    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                minioClient.removeBucket(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(\"ok\");\n-            }\n-        } else {\n-\n-            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(\"ok\");\n-        }\n+    public void process(Exchange exchange) throws Exception {\n+        System.out.println(exchange.getIn().getBody());\n     }\n \n-    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n-            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n-\n-            if (isEmpty(offset) || isEmpty(length)) {\n-                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n-            }\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .offset(Long.parseLong(offset))\n-                    .length(Long.parseLong(length))\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n-            if (isNotEmpty(payload)) {\n-                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(objectList);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-\n-            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(objectList);\n-        }\n-    }\n-\n-    private MinioOperations determineOperation(Exchange exchange) {\n-        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n-        if (isEmpty(operation)) {\n-            operation = getConfiguration().getOperation();\n-        }\n-        return operation;\n-    }\n-\n-    private Map<String, String> determineMetadata(final Exchange exchange) {\n-        Map<String, String> objectMetadata = new HashMap<>();\n-\n-        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (isNotEmpty(contentLength)) {\n-            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n-        }\n-\n-        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (isNotEmpty(contentType)) {\n-            objectMetadata.put(\"Content-Type\", contentType);\n-        }\n-\n-        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (isNotEmpty(cacheControl)) {\n-            objectMetadata.put(\"Cache-Control\", cacheControl);\n-        }\n-\n-        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (isNotEmpty(contentDisposition)) {\n-            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n-        }\n-\n-        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (isNotEmpty(contentEncoding)) {\n-            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n-        }\n-\n-        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (isNotEmpty(contentMD5)) {\n-            objectMetadata.put(\"Content-Md5\", contentMD5);\n-        }\n-\n-        return objectMetadata;\n-    }\n-\n-    /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n-     *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n-     * @throws IllegalArgumentException if the header could not be determined.\n-     */\n-    private String determineBucketName(final Exchange exchange) {\n-        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-\n-        if (isEmpty(bucketName)) {\n-            if (isNotEmpty(getConfiguration().getBucketName())) {\n-                bucketName = getConfiguration().getBucketName();\n-                LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-            } else {\n-                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-            }\n-        }\n-        return bucketName;\n-    }\n-\n-    private String determineObjectName(final Exchange exchange) {\n-        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (isEmpty(objectName)) {\n-            objectName = getConfiguration().getKeyName();\n-        }\n-        if (isEmpty(objectName)) {\n-            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n-        }\n-        return objectName;\n-    }\n-\n-    private String determineStorageClass(final Exchange exchange) {\n-        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (isEmpty(storageClass)) {\n-            storageClass = getConfiguration().getStorageClass();\n-        }\n-\n-        return storageClass;\n-    }\n-\n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n-        }\n-        return out;\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioProducerToString)) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 9649c1df3e3..7a4306e2cf3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,21 +16,21 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n import org.apache.camel.support.DefaultProducer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+/**\n+ * The Minio producer.\n+ */\n public class MinioProducer extends DefaultProducer {\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioProducer.class);\n     private MinioEndpoint endpoint;\n \n-    public MinioProducer(MinioEndpoint endpoint) {\n+    public MinioProducer(final MinioEndpoint endpoint) {\n         super(endpoint);\n         this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n+    public void process(org.apache.camel.Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "c6a9b5ac3b4d5a128c045495008174d905492576", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 7a4306e2cf3..2ab2c6e4a95 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -30,7 +33,7 @@ public class MinioProducer extends DefaultProducer {\n         this.endpoint = endpoint;\n     }\n \n-    public void process(org.apache.camel.Exchange exchange) throws Exception {\n+    public void process(Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 2ab2c6e4a95..bef3a9c6607 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -37,4 +37,7 @@ public class MinioProducer extends DefaultProducer {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n }\n", "next_change": {"commit": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex bef3a9c6607..a14c218b4a8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,28 +16,551 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n+import org.apache.camel.*;\n import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n /**\n- * The Minio producer.\n+ * A Producer which sends messages to the Minio Simple Storage\n  */\n public class MinioProducer extends DefaultProducer {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n-    private MinioEndpoint endpoint;\n \n-    public MinioProducer(final MinioEndpoint endpoint) {\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n         super(endpoint);\n-        this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n-        System.out.println(exchange.getIn().getBody());\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        if (ObjectHelper.isEmpty(operation)) {\n+            if (getConfiguration().isMultiPartUpload()) {\n+                processMultiPart(exchange);\n+            } else {\n+                processSingleOp(exchange);\n+            }\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObject:\n+                    getObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObjectRange:\n+                    getObjectRange(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void processMultiPart(final Exchange exchange) throws Exception {\n+        File filePayload = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+        } else {\n+            throw new IllegalArgumentException(\"aws2-s3: MultiPart upload requires a File input.\");\n+        }\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+        if (objectMetadata.containsKey(\"Content-Length\")) {\n+            if (objectMetadata.get(\"Content-Length\").equalsIgnoreCase(\"0\")) {\n+                objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+            }\n+        } else {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+        }\n+\n+        final String keyName = determineKey(exchange);\n+        CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            createMultipartUploadRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            createMultipartUploadRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            createMultipartUploadRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            createMultipartUploadRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                createMultipartUploadRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                createMultipartUploadRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                createMultipartUploadRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", createMultipartUploadRequest, exchange);\n+\n+        CreateMultipartUploadResponse initResponse = getEndpoint().getMinioClient().createMultipartUpload(createMultipartUploadRequest.build());\n+        final long contentLength = Long.valueOf(objectMetadata.get(\"Content-Length\"));\n+        List<CompletedPart> completedParts = new ArrayList<CompletedPart>();\n+        long partSize = getConfiguration().getPartSize();\n+        CompleteMultipartUploadResponse uploadResult = null;\n+\n+        long filePosition = 0;\n+\n+        try {\n+            for (int part = 1; filePosition < contentLength; part++) {\n+                partSize = Math.min(partSize, contentLength - filePosition);\n+\n+                UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId())\n+                        .partNumber(part).build();\n+\n+                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n+                String etag = getEndpoint().getMinioClient().uploadPart(uploadRequest, RequestBody.fromFile(filePayload)).eTag();\n+                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();\n+                completedParts.add(partUpload);\n+                filePosition += partSize;\n+            }\n+            CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();\n+            CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload)\n+                    .bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();\n+\n+            uploadResult = getEndpoint().getMinioClient().completeMultipartUpload(compRequest);\n+\n+        } catch (Exception e) {\n+            getEndpoint().getMinioClient()\n+                    .abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());\n+            throw e;\n+        }\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, uploadResult.eTag());\n+        if (uploadResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, uploadResult.versionId());\n+        }\n+\n+        if (getConfiguration().isDeleteAfterWrite()) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    public void processSingleOp(final Exchange exchange) throws Exception {\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+\n+        File filePayload = null;\n+        InputStream is = null;\n+        ByteArrayOutputStream baos = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+            is = new FileInputStream(filePayload);\n+        } else {\n+            is = exchange.getIn().getMandatoryBody(InputStream.class);\n+            if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                    LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                    baos = determineLengthInputStream(is);\n+                    objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                    is = new ByteArrayInputStream(baos.toByteArray());\n+                } else {\n+                    if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                    }\n+                }\n+            }\n+        }\n+\n+        final String bucketName = determineBucketName(exchange);\n+        final String key = determineKey(exchange);\n+        putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            putObjectRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            putObjectRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            putObjectRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+            }\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Put object [{}] from exchange [{}]...\", putObjectRequest, exchange);\n+\n+        PutObjectResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build(), RequestBody.fromBytes(SdkBytes.fromInputStream(is).asByteArray()));\n+\n+        LOG.trace(\"Received result [{}]\", putObjectResult);\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, putObjectResult.eTag());\n+        if (putObjectResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+        }\n+\n+        IOHelper.close(is);\n+\n+        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_KEY, String.class);\n+        final String bucketNameDestination = exchange.getIn().getHeader(MinioConstants.BUCKET_DESTINATION_NAME, String.class);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof CopyObjectRequest) {\n+                CopyObjectResponse result;\n+                result = minioClient.copyObject((CopyObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+            if (ObjectHelper.isEmpty(bucketNameDestination)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+            CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder();\n+            copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).copySource(bucketName + \"/\" + sourceKey);\n+\n+            if (getConfiguration().isUseAwsKMS()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                    copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+                }\n+            }\n+\n+            if (getConfiguration().isUseCustomerKey()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                    copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                    copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                    copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+                }\n+            }\n+\n+            CopyObjectResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteObjectRequest) {\n+                minioClient.deleteObject((DeleteObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            DeleteObjectRequest.Builder deleteObjectRequest = DeleteObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            minioClient.deleteObject(deleteObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) {\n+        ListBucketsResponse bucketsList = minioClient.listBuckets();\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setBody(bucketsList.buckets());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteBucketRequest) {\n+                DeleteBucketResponse resp = minioClient.deleteBucket((DeleteBucketRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(resp);\n+            }\n+        } else {\n+\n+            DeleteBucketRequest.Builder deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName);\n+            DeleteBucketResponse resp = minioClient.deleteBucket(deleteBucketRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(resp);\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineKey(exchange);\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void getObjectRange(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String rangeStart = exchange.getIn().getHeader(MinioConstants.RANGE_START, String.class);\n+        final String rangeEnd = exchange.getIn().getHeader(MinioConstants.RANGE_END, String.class);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+\n+            if (ObjectHelper.isEmpty(rangeStart) || ObjectHelper.isEmpty(rangeEnd)) {\n+                throw new IllegalArgumentException(\"A Range start and range end header must be configured to perform a range get operation.\");\n+            }\n+\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey)\n+                    .range(\"bytes=\" + Long.parseLong(rangeStart) + \"-\" + Long.parseLong(rangeEnd));\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof ListObjectsRequest) {\n+                ListObjectsResponse objectList = minioClient.listObjects((ListObjectsRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList.contents());\n+            }\n+        } else {\n+\n+            ListObjectsResponse objectList = minioClient.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList.contents());\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.Minio_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<String, String>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"AWS S3 Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineKey(final Exchange exchange) {\n+        String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+        if (ObjectHelper.isEmpty(key)) {\n+            key = getConfiguration().getKeyName();\n+        }\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Key header missing.\");\n+        }\n+        return key;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream is) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];\n+        int count;\n+        while ((count = is.read(bytes)) > 0) {\n+            out.write(bytes, 0, count);\n+        }\n+        return out;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (minioProducerToString == null) {\n+            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+        }\n+        return minioProducerToString;\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex a14c218b4a8..d5c3579376d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -563,4 +470,8 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex d5c3579376d..44ea0653d78 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -470,8 +473,4 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 44ea0653d78..79c80ab4cae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -472,5 +491,4 @@ public class MinioProducer extends DefaultProducer {\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 6be64b509d8..8137de609b5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -452,7 +446,7 @@ public class MinioProducer extends DefaultProducer {\n \n     private String determineStorageClass(final Exchange exchange) {\n         String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (isEmpty(storageClass)) {\n+        if (storageClass == null) {\n             storageClass = getConfiguration().getStorageClass();\n         }\n \n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8137de609b5..8486993bdd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -455,7 +460,7 @@ public class MinioProducer extends DefaultProducer {\n \n     private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[1024];\n+        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n         int count;\n         while ((count = inputStream.read(bytes)) > 0) {\n             out.write(bytes, 0, count);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8486993bdd8..9649c1df3e3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,472 +16,22 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectWriteResponse;\n-import io.minio.PutObjectArgs;\n-import io.minio.RemoveBucketArgs;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.RemoveObjectsArgs;\n-import io.minio.Result;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n-import org.apache.camel.InvalidPayloadException;\n-import org.apache.camel.Message;\n-import org.apache.camel.WrappedFile;\n import org.apache.camel.support.DefaultProducer;\n-import org.apache.camel.util.FileUtil;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-/**\n- * A Producer which sends messages to the Minio Simple Storage\n- */\n public class MinioProducer extends DefaultProducer {\n-\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private MinioEndpoint endpoint;\n \n-    private transient String minioProducerToString;\n-\n-    public MinioProducer(final Endpoint endpoint) {\n+    public MinioProducer(MinioEndpoint endpoint) {\n         super(endpoint);\n+        this.endpoint = endpoint;\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n-    @Override\n-    public void process(final Exchange exchange) throws Exception {\n-        MinioOperations operation = determineOperation(exchange);\n-        MinioClient minioClient = getEndpoint().getMinioClient();\n-        if (ObjectHelper.isEmpty(operation)) {\n-            putObject(minioClient, exchange);\n-        } else {\n-            switch (operation) {\n-                case copyObject:\n-                    copyObject(minioClient, exchange);\n-                    break;\n-                case deleteObject:\n-                    deleteObject(minioClient, exchange);\n-                    break;\n-                case deleteObjects:\n-                    deleteObjects(minioClient, exchange);\n-                    break;\n-                case listBuckets:\n-                    listBuckets(minioClient, exchange);\n-                    break;\n-                case deleteBucket:\n-                    deleteBucket(minioClient, exchange);\n-                    break;\n-                case listObjects:\n-                    listObjects(minioClient, exchange);\n-                    break;\n-                case getObject:\n-                    getObject(minioClient, exchange);\n-                    break;\n-                case getPartialObject:\n-                    getPartialObject(minioClient, exchange);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported operation\");\n-            }\n-        }\n-    }\n-\n-    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n-            if (payload != null) {\n-                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-                if (putObjectResult.versionId() != null) {\n-                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-                }\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String objectName = determineObjectName(exchange);\n-            Map<String, String> objectMetadata = determineMetadata(exchange);\n-            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n-\n-            File filePayload = null;\n-            InputStream inputStream;\n-            ByteArrayOutputStream baos;\n-            Object object = exchange.getIn().getMandatoryBody();\n-\n-            // Need to check if the message body is WrappedFile\n-            if (object instanceof WrappedFile) {\n-                object = ((WrappedFile<?>) object).getFile();\n-            }\n-            if (object instanceof File) {\n-                filePayload = (File) object;\n-                inputStream = new FileInputStream(filePayload);\n-            } else {\n-                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n-                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n-                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n-                        baos = determineLengthInputStream(inputStream);\n-                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n-                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n-                    } else {\n-                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n-                        }\n-                    }\n-                }\n-            }\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(bucketName)\n-                    .object(objectName)\n-                    .userMetadata(objectMetadata);\n-\n-            if (!extraHeaders.isEmpty()) {\n-                putObjectRequest.extraHeaders(extraHeaders);\n-            }\n-\n-            LOG.trace(\"Put object from exchange...\");\n-\n-            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n-\n-            LOG.trace(\"Received result...\");\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-            if (putObjectResult.versionId() != null) {\n-                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-            }\n-\n-            IOHelper.close(inputStream);\n-\n-            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n-                FileUtil.deleteFile(filePayload);\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n-        Map<String, String> extraHeaders = new HashMap<>();\n-        String storageClass = determineStorageClass(exchange);\n-        if (storageClass != null) {\n-            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n-        }\n-\n-        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n-        if (cannedAcl != null) {\n-            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n-        }\n-\n-        return extraHeaders;\n-    }\n-\n-    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n-            if (payload != null) {\n-                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(result);\n-            }\n-        } else {\n-\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n-            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n-\n-            if (ObjectHelper.isEmpty(destinationBucketName)) {\n-                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n-            }\n-            if (ObjectHelper.isEmpty(destinationKey)) {\n-                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n-            }\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(destinationBucketName)\n-                    .object(destinationKey)\n-                    .source(copySourceBuilder.build());\n-\n-            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            if (copyObjectResult.versionId() != null) {\n-                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n-            }\n-        }\n-    }\n-\n-    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (payload != null) {\n-                minioClient.removeObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            minioClient.removeObject(RemoveObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey).build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(true);\n-        }\n-    }\n-\n-    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n-            if (payload != null) {\n-                minioClient.removeObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n-        }\n-    }\n-\n-    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n-        List<Bucket> bucketsList = minioClient.listBuckets();\n-        Message message = getMessageForResponse(exchange);\n-        //returns iterator of bucketList\n-        message.setBody(bucketsList.iterator());\n-    }\n-\n-    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n-            if (payload != null) {\n-                minioClient.removeBucket(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(\"ok\");\n-            }\n-        } else {\n-\n-            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(\"ok\");\n-        }\n-    }\n-\n-    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (payload != null) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (payload != null) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n-            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n-\n-            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n-                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n-            }\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .offset(Long.parseLong(offset))\n-                    .length(Long.parseLong(length))\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n-            if (payload != null) {\n-                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(objectList);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-\n-            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(objectList);\n-        }\n-    }\n-\n-    private MinioOperations determineOperation(Exchange exchange) {\n-        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n-        if (operation == null) {\n-            operation = getConfiguration().getOperation();\n-        }\n-        return operation;\n+    public void process(Exchange exchange) throws Exception {\n+        System.out.println(exchange.getIn().getBody());\n     }\n \n-    private Map<String, String> determineMetadata(final Exchange exchange) {\n-        Map<String, String> objectMetadata = new HashMap<>();\n-\n-        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (contentLength != null) {\n-            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n-        }\n-\n-        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (contentType != null) {\n-            objectMetadata.put(\"Content-Type\", contentType);\n-        }\n-\n-        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (cacheControl != null) {\n-            objectMetadata.put(\"Cache-Control\", cacheControl);\n-        }\n-\n-        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (contentDisposition != null) {\n-            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n-        }\n-\n-        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (contentEncoding != null) {\n-            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n-        }\n-\n-        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (contentMD5 != null) {\n-            objectMetadata.put(\"Content-Md5\", contentMD5);\n-        }\n-\n-        return objectMetadata;\n-    }\n-\n-    /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n-     *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n-     * @throws IllegalArgumentException if the header could not be determined.\n-     */\n-    private String determineBucketName(final Exchange exchange) {\n-        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-\n-        if (ObjectHelper.isEmpty(bucketName)) {\n-            bucketName = getConfiguration().getBucketName();\n-            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-        }\n-\n-        if (bucketName == null) {\n-            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-        }\n-\n-        return bucketName;\n-    }\n-\n-    private String determineObjectName(final Exchange exchange) {\n-        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (ObjectHelper.isEmpty(objectName)) {\n-            objectName = getConfiguration().getKeyName();\n-        }\n-        if (objectName == null) {\n-            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n-        }\n-        return objectName;\n-    }\n-\n-    private String determineStorageClass(final Exchange exchange) {\n-        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (storageClass == null) {\n-            storageClass = getConfiguration().getStorageClass();\n-        }\n-\n-        return storageClass;\n-    }\n-\n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n-        }\n-        return out;\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioProducerToString == null) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 9649c1df3e3..7a4306e2cf3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,21 +16,21 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n import org.apache.camel.support.DefaultProducer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+/**\n+ * The Minio producer.\n+ */\n public class MinioProducer extends DefaultProducer {\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioProducer.class);\n     private MinioEndpoint endpoint;\n \n-    public MinioProducer(MinioEndpoint endpoint) {\n+    public MinioProducer(final MinioEndpoint endpoint) {\n         super(endpoint);\n         this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n+    public void process(org.apache.camel.Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "c6a9b5ac3b4d5a128c045495008174d905492576", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 7a4306e2cf3..2ab2c6e4a95 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -30,7 +33,7 @@ public class MinioProducer extends DefaultProducer {\n         this.endpoint = endpoint;\n     }\n \n-    public void process(org.apache.camel.Exchange exchange) throws Exception {\n+    public void process(Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 2ab2c6e4a95..bef3a9c6607 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -37,4 +37,7 @@ public class MinioProducer extends DefaultProducer {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n }\n", "next_change": {"commit": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex bef3a9c6607..a14c218b4a8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,28 +16,551 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n+import org.apache.camel.*;\n import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n /**\n- * The Minio producer.\n+ * A Producer which sends messages to the Minio Simple Storage\n  */\n public class MinioProducer extends DefaultProducer {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n-    private MinioEndpoint endpoint;\n \n-    public MinioProducer(final MinioEndpoint endpoint) {\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n         super(endpoint);\n-        this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n-        System.out.println(exchange.getIn().getBody());\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        if (ObjectHelper.isEmpty(operation)) {\n+            if (getConfiguration().isMultiPartUpload()) {\n+                processMultiPart(exchange);\n+            } else {\n+                processSingleOp(exchange);\n+            }\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObject:\n+                    getObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObjectRange:\n+                    getObjectRange(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void processMultiPart(final Exchange exchange) throws Exception {\n+        File filePayload = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+        } else {\n+            throw new IllegalArgumentException(\"aws2-s3: MultiPart upload requires a File input.\");\n+        }\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+        if (objectMetadata.containsKey(\"Content-Length\")) {\n+            if (objectMetadata.get(\"Content-Length\").equalsIgnoreCase(\"0\")) {\n+                objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+            }\n+        } else {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+        }\n+\n+        final String keyName = determineKey(exchange);\n+        CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            createMultipartUploadRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            createMultipartUploadRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            createMultipartUploadRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            createMultipartUploadRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                createMultipartUploadRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                createMultipartUploadRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                createMultipartUploadRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", createMultipartUploadRequest, exchange);\n+\n+        CreateMultipartUploadResponse initResponse = getEndpoint().getMinioClient().createMultipartUpload(createMultipartUploadRequest.build());\n+        final long contentLength = Long.valueOf(objectMetadata.get(\"Content-Length\"));\n+        List<CompletedPart> completedParts = new ArrayList<CompletedPart>();\n+        long partSize = getConfiguration().getPartSize();\n+        CompleteMultipartUploadResponse uploadResult = null;\n+\n+        long filePosition = 0;\n+\n+        try {\n+            for (int part = 1; filePosition < contentLength; part++) {\n+                partSize = Math.min(partSize, contentLength - filePosition);\n+\n+                UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId())\n+                        .partNumber(part).build();\n+\n+                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n+                String etag = getEndpoint().getMinioClient().uploadPart(uploadRequest, RequestBody.fromFile(filePayload)).eTag();\n+                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();\n+                completedParts.add(partUpload);\n+                filePosition += partSize;\n+            }\n+            CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();\n+            CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload)\n+                    .bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();\n+\n+            uploadResult = getEndpoint().getMinioClient().completeMultipartUpload(compRequest);\n+\n+        } catch (Exception e) {\n+            getEndpoint().getMinioClient()\n+                    .abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());\n+            throw e;\n+        }\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, uploadResult.eTag());\n+        if (uploadResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, uploadResult.versionId());\n+        }\n+\n+        if (getConfiguration().isDeleteAfterWrite()) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    public void processSingleOp(final Exchange exchange) throws Exception {\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+\n+        File filePayload = null;\n+        InputStream is = null;\n+        ByteArrayOutputStream baos = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+            is = new FileInputStream(filePayload);\n+        } else {\n+            is = exchange.getIn().getMandatoryBody(InputStream.class);\n+            if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                    LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                    baos = determineLengthInputStream(is);\n+                    objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                    is = new ByteArrayInputStream(baos.toByteArray());\n+                } else {\n+                    if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                    }\n+                }\n+            }\n+        }\n+\n+        final String bucketName = determineBucketName(exchange);\n+        final String key = determineKey(exchange);\n+        putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            putObjectRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            putObjectRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            putObjectRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+            }\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Put object [{}] from exchange [{}]...\", putObjectRequest, exchange);\n+\n+        PutObjectResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build(), RequestBody.fromBytes(SdkBytes.fromInputStream(is).asByteArray()));\n+\n+        LOG.trace(\"Received result [{}]\", putObjectResult);\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, putObjectResult.eTag());\n+        if (putObjectResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+        }\n+\n+        IOHelper.close(is);\n+\n+        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_KEY, String.class);\n+        final String bucketNameDestination = exchange.getIn().getHeader(MinioConstants.BUCKET_DESTINATION_NAME, String.class);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof CopyObjectRequest) {\n+                CopyObjectResponse result;\n+                result = minioClient.copyObject((CopyObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+            if (ObjectHelper.isEmpty(bucketNameDestination)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+            CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder();\n+            copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).copySource(bucketName + \"/\" + sourceKey);\n+\n+            if (getConfiguration().isUseAwsKMS()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                    copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+                }\n+            }\n+\n+            if (getConfiguration().isUseCustomerKey()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                    copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                    copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                    copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+                }\n+            }\n+\n+            CopyObjectResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteObjectRequest) {\n+                minioClient.deleteObject((DeleteObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            DeleteObjectRequest.Builder deleteObjectRequest = DeleteObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            minioClient.deleteObject(deleteObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) {\n+        ListBucketsResponse bucketsList = minioClient.listBuckets();\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setBody(bucketsList.buckets());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteBucketRequest) {\n+                DeleteBucketResponse resp = minioClient.deleteBucket((DeleteBucketRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(resp);\n+            }\n+        } else {\n+\n+            DeleteBucketRequest.Builder deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName);\n+            DeleteBucketResponse resp = minioClient.deleteBucket(deleteBucketRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(resp);\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineKey(exchange);\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void getObjectRange(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String rangeStart = exchange.getIn().getHeader(MinioConstants.RANGE_START, String.class);\n+        final String rangeEnd = exchange.getIn().getHeader(MinioConstants.RANGE_END, String.class);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+\n+            if (ObjectHelper.isEmpty(rangeStart) || ObjectHelper.isEmpty(rangeEnd)) {\n+                throw new IllegalArgumentException(\"A Range start and range end header must be configured to perform a range get operation.\");\n+            }\n+\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey)\n+                    .range(\"bytes=\" + Long.parseLong(rangeStart) + \"-\" + Long.parseLong(rangeEnd));\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof ListObjectsRequest) {\n+                ListObjectsResponse objectList = minioClient.listObjects((ListObjectsRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList.contents());\n+            }\n+        } else {\n+\n+            ListObjectsResponse objectList = minioClient.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList.contents());\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.Minio_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<String, String>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"AWS S3 Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineKey(final Exchange exchange) {\n+        String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+        if (ObjectHelper.isEmpty(key)) {\n+            key = getConfiguration().getKeyName();\n+        }\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Key header missing.\");\n+        }\n+        return key;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream is) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];\n+        int count;\n+        while ((count = is.read(bytes)) > 0) {\n+            out.write(bytes, 0, count);\n+        }\n+        return out;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (minioProducerToString == null) {\n+            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+        }\n+        return minioProducerToString;\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex a14c218b4a8..d5c3579376d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -563,4 +470,8 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex d5c3579376d..44ea0653d78 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -470,8 +473,4 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 44ea0653d78..79c80ab4cae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -472,5 +491,4 @@ public class MinioProducer extends DefaultProducer {\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -424,24 +428,23 @@ public class MinioProducer extends DefaultProducer {\n     private String determineBucketName(final Exchange exchange) {\n         String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n \n-        if (ObjectHelper.isEmpty(bucketName)) {\n-            bucketName = getConfiguration().getBucketName();\n-            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-        }\n-\n-        if (bucketName == null) {\n-            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        if (isEmpty(bucketName)) {\n+            if (isNotEmpty(getConfiguration().getBucketName())) {\n+                bucketName = getConfiguration().getBucketName();\n+                LOG.trace(\"Minio Bucket name header is missing, using default one {}\", bucketName);\n+            } else {\n+                throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+            }\n         }\n-\n         return bucketName;\n     }\n \n     private String determineObjectName(final Exchange exchange) {\n         String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (ObjectHelper.isEmpty(objectName)) {\n+        if (isEmpty(objectName)) {\n             objectName = getConfiguration().getKeyName();\n         }\n-        if (objectName == null) {\n+        if (isEmpty(objectName)) {\n             throw new IllegalArgumentException(\"Minio Key header is missing.\");\n         }\n         return objectName;\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "25628a8919c403b25ce89dd485fe59278b7effd7", "committedDate": "2021-08-30 10:56:11 +0200", "message": "(chores) fix resource leaks in camel-grape and camel-minio (#6005)"}, {"oid": "99e08d0237368053b32935bfdb3106b67e7222d4", "committedDate": "2021-09-30 12:32:06 +0200", "message": "CAMEL-17021: camel-minio - Determine content-length in a smarter way (#6184)"}, {"oid": "b04bc67e4c63ab845669f77cc13a9dee5f54fdbf", "committedDate": "2022-10-05 06:26:38 -0500", "message": "CAMEL-18583: [camel-minio] deleteObjects operation does not delete multiple objects (#8483)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460759163", "body": "why is it `1024` bits here? Can you please move this into constant and with some comment why you opted for `1024`bits?", "bodyText": "why is it 1024 bits here? Can you please move this into constant and with some comment why you opted for 1024bits?", "bodyHTML": "<p dir=\"auto\">why is it <code>1024</code> bits here? Can you please move this into constant and with some comment why you opted for <code>1024</code>bits?</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:21:29Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineObjectName(final Exchange exchange) {\n+        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+        if (ObjectHelper.isEmpty(objectName)) {\n+            objectName = getConfiguration().getKeyName();\n+        }\n+        if (objectName == null) {\n+            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n+        }\n+        return objectName;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private String determineVersionId(final Exchange exchange) {\n+        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n+        if (versionId == null) {\n+            versionId = getConfiguration().getVersionId();\n+        }\n+\n+        return versionId;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113257", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113295", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -449,25 +452,16 @@ public class MinioProducer extends DefaultProducer {\n \n     private String determineStorageClass(final Exchange exchange) {\n         String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (storageClass == null) {\n+        if (isEmpty(storageClass)) {\n             storageClass = getConfiguration().getStorageClass();\n         }\n \n         return storageClass;\n     }\n \n-    private String determineVersionId(final Exchange exchange) {\n-        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n-        if (versionId == null) {\n-            versionId = getConfiguration().getVersionId();\n-        }\n-\n-        return versionId;\n-    }\n-\n     private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[1024];\n+        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n         int count;\n         while ((count = inputStream.read(bytes)) > 0) {\n             out.write(bytes, 0, count);\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 6be64b509d8..8137de609b5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -461,7 +455,7 @@ public class MinioProducer extends DefaultProducer {\n \n     private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n+        byte[] bytes = new byte[1024];\n         int count;\n         while ((count = inputStream.read(bytes)) > 0) {\n             out.write(bytes, 0, count);\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8137de609b5..8486993bdd8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -455,7 +460,7 @@ public class MinioProducer extends DefaultProducer {\n \n     private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[1024];\n+        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n         int count;\n         while ((count = inputStream.read(bytes)) > 0) {\n             out.write(bytes, 0, count);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 8486993bdd8..9649c1df3e3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,472 +16,22 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.ListObjectsArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectWriteResponse;\n-import io.minio.PutObjectArgs;\n-import io.minio.RemoveBucketArgs;\n-import io.minio.RemoveObjectArgs;\n-import io.minio.RemoveObjectsArgs;\n-import io.minio.Result;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n-import org.apache.camel.InvalidPayloadException;\n-import org.apache.camel.Message;\n-import org.apache.camel.WrappedFile;\n import org.apache.camel.support.DefaultProducer;\n-import org.apache.camel.util.FileUtil;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-/**\n- * A Producer which sends messages to the Minio Simple Storage\n- */\n public class MinioProducer extends DefaultProducer {\n-\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private MinioEndpoint endpoint;\n \n-    private transient String minioProducerToString;\n-\n-    public MinioProducer(final Endpoint endpoint) {\n+    public MinioProducer(MinioEndpoint endpoint) {\n         super(endpoint);\n+        this.endpoint = endpoint;\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n-    @Override\n-    public void process(final Exchange exchange) throws Exception {\n-        MinioOperations operation = determineOperation(exchange);\n-        MinioClient minioClient = getEndpoint().getMinioClient();\n-        if (ObjectHelper.isEmpty(operation)) {\n-            putObject(minioClient, exchange);\n-        } else {\n-            switch (operation) {\n-                case copyObject:\n-                    copyObject(minioClient, exchange);\n-                    break;\n-                case deleteObject:\n-                    deleteObject(minioClient, exchange);\n-                    break;\n-                case deleteObjects:\n-                    deleteObjects(minioClient, exchange);\n-                    break;\n-                case listBuckets:\n-                    listBuckets(minioClient, exchange);\n-                    break;\n-                case deleteBucket:\n-                    deleteBucket(minioClient, exchange);\n-                    break;\n-                case listObjects:\n-                    listObjects(minioClient, exchange);\n-                    break;\n-                case getObject:\n-                    getObject(minioClient, exchange);\n-                    break;\n-                case getPartialObject:\n-                    getPartialObject(minioClient, exchange);\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"Unsupported operation\");\n-            }\n-        }\n-    }\n-\n-    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n-            if (payload != null) {\n-                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-                if (putObjectResult.versionId() != null) {\n-                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-                }\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String objectName = determineObjectName(exchange);\n-            Map<String, String> objectMetadata = determineMetadata(exchange);\n-            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n-\n-            File filePayload = null;\n-            InputStream inputStream;\n-            ByteArrayOutputStream baos;\n-            Object object = exchange.getIn().getMandatoryBody();\n-\n-            // Need to check if the message body is WrappedFile\n-            if (object instanceof WrappedFile) {\n-                object = ((WrappedFile<?>) object).getFile();\n-            }\n-            if (object instanceof File) {\n-                filePayload = (File) object;\n-                inputStream = new FileInputStream(filePayload);\n-            } else {\n-                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n-                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n-                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n-                        baos = determineLengthInputStream(inputStream);\n-                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n-                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n-                    } else {\n-                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n-                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n-                        }\n-                    }\n-                }\n-            }\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(bucketName)\n-                    .object(objectName)\n-                    .userMetadata(objectMetadata);\n-\n-            if (!extraHeaders.isEmpty()) {\n-                putObjectRequest.extraHeaders(extraHeaders);\n-            }\n-\n-            LOG.trace(\"Put object from exchange...\");\n-\n-            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n-\n-            LOG.trace(\"Received result...\");\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n-            if (putObjectResult.versionId() != null) {\n-                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n-            }\n-\n-            IOHelper.close(inputStream);\n-\n-            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n-                FileUtil.deleteFile(filePayload);\n-            }\n-        }\n-    }\n-\n-    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n-        Map<String, String> extraHeaders = new HashMap<>();\n-        String storageClass = determineStorageClass(exchange);\n-        if (storageClass != null) {\n-            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n-        }\n-\n-        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n-        if (cannedAcl != null) {\n-            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n-        }\n-\n-        return extraHeaders;\n-    }\n-\n-    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n-            if (payload != null) {\n-                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(result);\n-            }\n-        } else {\n-\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n-            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n-\n-            if (ObjectHelper.isEmpty(destinationBucketName)) {\n-                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n-            }\n-            if (ObjectHelper.isEmpty(destinationKey)) {\n-                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n-            }\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(destinationBucketName)\n-                    .object(destinationKey)\n-                    .source(copySourceBuilder.build());\n-\n-            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            if (copyObjectResult.versionId() != null) {\n-                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n-            }\n-        }\n-    }\n-\n-    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n-            if (payload != null) {\n-                minioClient.removeObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            minioClient.removeObject(RemoveObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey).build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(true);\n-        }\n-    }\n-\n-    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n-            if (payload != null) {\n-                minioClient.removeObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(true);\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n-        }\n-    }\n-\n-    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n-        List<Bucket> bucketsList = minioClient.listBuckets();\n-        Message message = getMessageForResponse(exchange);\n-        //returns iterator of bucketList\n-        message.setBody(bucketsList.iterator());\n-    }\n-\n-    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n-        final String bucketName = determineBucketName(exchange);\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n-            if (payload != null) {\n-                minioClient.removeBucket(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(\"ok\");\n-            }\n-        } else {\n-\n-            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(\"ok\");\n-        }\n-    }\n-\n-    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (payload != null) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n-            if (payload != null) {\n-                InputStream respond = minioClient.getObject(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(respond);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-            final String sourceKey = determineObjectName(exchange);\n-            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n-            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n-\n-            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n-                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n-            }\n-\n-            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n-                    .bucket(bucketName)\n-                    .object(sourceKey)\n-                    .offset(Long.parseLong(offset))\n-                    .length(Long.parseLong(length))\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(respond);\n-        }\n-    }\n-\n-    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n-\n-        if (getConfiguration().isPojoRequest()) {\n-            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n-            if (payload != null) {\n-                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n-                Message message = getMessageForResponse(exchange);\n-                message.setBody(objectList);\n-            }\n-        } else {\n-            final String bucketName = determineBucketName(exchange);\n-\n-            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n-                    .bucket(bucketName)\n-                    .build());\n-\n-            Message message = getMessageForResponse(exchange);\n-            message.setBody(objectList);\n-        }\n-    }\n-\n-    private MinioOperations determineOperation(Exchange exchange) {\n-        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n-        if (operation == null) {\n-            operation = getConfiguration().getOperation();\n-        }\n-        return operation;\n+    public void process(Exchange exchange) throws Exception {\n+        System.out.println(exchange.getIn().getBody());\n     }\n \n-    private Map<String, String> determineMetadata(final Exchange exchange) {\n-        Map<String, String> objectMetadata = new HashMap<>();\n-\n-        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n-        if (contentLength != null) {\n-            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n-        }\n-\n-        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n-        if (contentType != null) {\n-            objectMetadata.put(\"Content-Type\", contentType);\n-        }\n-\n-        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n-        if (cacheControl != null) {\n-            objectMetadata.put(\"Cache-Control\", cacheControl);\n-        }\n-\n-        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n-        if (contentDisposition != null) {\n-            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n-        }\n-\n-        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n-        if (contentEncoding != null) {\n-            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n-        }\n-\n-        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n-        if (contentMD5 != null) {\n-            objectMetadata.put(\"Content-Md5\", contentMD5);\n-        }\n-\n-        return objectMetadata;\n-    }\n-\n-    /**\n-     * Reads the bucket name from the header of the given exchange. If not\n-     * provided, it's read from the endpoint configuration.\n-     *\n-     * @param exchange The exchange to read the header from.\n-     * @return The bucket name.\n-     * @throws IllegalArgumentException if the header could not be determined.\n-     */\n-    private String determineBucketName(final Exchange exchange) {\n-        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n-\n-        if (ObjectHelper.isEmpty(bucketName)) {\n-            bucketName = getConfiguration().getBucketName();\n-            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n-        }\n-\n-        if (bucketName == null) {\n-            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n-        }\n-\n-        return bucketName;\n-    }\n-\n-    private String determineObjectName(final Exchange exchange) {\n-        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n-        if (ObjectHelper.isEmpty(objectName)) {\n-            objectName = getConfiguration().getKeyName();\n-        }\n-        if (objectName == null) {\n-            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n-        }\n-        return objectName;\n-    }\n-\n-    private String determineStorageClass(final Exchange exchange) {\n-        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (storageClass == null) {\n-            storageClass = getConfiguration().getStorageClass();\n-        }\n-\n-        return storageClass;\n-    }\n-\n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n-        }\n-        return out;\n-    }\n-\n-    protected MinioConfiguration getConfiguration() {\n-        return getEndpoint().getConfiguration();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        if (minioProducerToString == null) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n-    @Override\n-    public MinioEndpoint getEndpoint() {\n-        return (MinioEndpoint) super.getEndpoint();\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 9649c1df3e3..7a4306e2cf3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,21 +16,21 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n import org.apache.camel.support.DefaultProducer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+/**\n+ * The Minio producer.\n+ */\n public class MinioProducer extends DefaultProducer {\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioProducer.class);\n     private MinioEndpoint endpoint;\n \n-    public MinioProducer(MinioEndpoint endpoint) {\n+    public MinioProducer(final MinioEndpoint endpoint) {\n         super(endpoint);\n         this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n+    public void process(org.apache.camel.Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "c6a9b5ac3b4d5a128c045495008174d905492576", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 7a4306e2cf3..2ab2c6e4a95 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -30,7 +33,7 @@ public class MinioProducer extends DefaultProducer {\n         this.endpoint = endpoint;\n     }\n \n-    public void process(org.apache.camel.Exchange exchange) throws Exception {\n+    public void process(Exchange exchange) throws Exception {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 2ab2c6e4a95..bef3a9c6607 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -37,4 +37,7 @@ public class MinioProducer extends DefaultProducer {\n         System.out.println(exchange.getIn().getBody());\n     }\n \n+    protected MinioConfiguration getConfiguration() {\n+        return getEndpoint().getConfiguration();\n+    }\n }\n", "next_change": {"commit": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex bef3a9c6607..a14c218b4a8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -16,28 +16,551 @@\n  */\n package org.apache.camel.component.minio;\n \n-import org.apache.camel.Exchange;\n+import org.apache.camel.*;\n import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n /**\n- * The Minio producer.\n+ * A Producer which sends messages to the Minio Simple Storage\n  */\n public class MinioProducer extends DefaultProducer {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n-    private MinioEndpoint endpoint;\n \n-    public MinioProducer(final MinioEndpoint endpoint) {\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n         super(endpoint);\n-        this.endpoint = endpoint;\n     }\n \n-    public void process(Exchange exchange) throws Exception {\n-        System.out.println(exchange.getIn().getBody());\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        if (ObjectHelper.isEmpty(operation)) {\n+            if (getConfiguration().isMultiPartUpload()) {\n+                processMultiPart(exchange);\n+            } else {\n+                processSingleOp(exchange);\n+            }\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObject:\n+                    getObject(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                case getObjectRange:\n+                    getObjectRange(getEndpoint().getMinioClient(), exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void processMultiPart(final Exchange exchange) throws Exception {\n+        File filePayload = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+        } else {\n+            throw new IllegalArgumentException(\"aws2-s3: MultiPart upload requires a File input.\");\n+        }\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+        if (objectMetadata.containsKey(\"Content-Length\")) {\n+            if (objectMetadata.get(\"Content-Length\").equalsIgnoreCase(\"0\")) {\n+                objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+            }\n+        } else {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(filePayload.length()));\n+        }\n+\n+        final String keyName = determineKey(exchange);\n+        CreateMultipartUploadRequest.Builder createMultipartUploadRequest = CreateMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            createMultipartUploadRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            createMultipartUploadRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            createMultipartUploadRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            createMultipartUploadRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                createMultipartUploadRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                createMultipartUploadRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                createMultipartUploadRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Initiating multipart upload [{}] from exchange [{}]...\", createMultipartUploadRequest, exchange);\n+\n+        CreateMultipartUploadResponse initResponse = getEndpoint().getMinioClient().createMultipartUpload(createMultipartUploadRequest.build());\n+        final long contentLength = Long.valueOf(objectMetadata.get(\"Content-Length\"));\n+        List<CompletedPart> completedParts = new ArrayList<CompletedPart>();\n+        long partSize = getConfiguration().getPartSize();\n+        CompleteMultipartUploadResponse uploadResult = null;\n+\n+        long filePosition = 0;\n+\n+        try {\n+            for (int part = 1; filePosition < contentLength; part++) {\n+                partSize = Math.min(partSize, contentLength - filePosition);\n+\n+                UploadPartRequest uploadRequest = UploadPartRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId())\n+                        .partNumber(part).build();\n+\n+                LOG.trace(\"Uploading part [{}] for {}\", part, keyName);\n+                String etag = getEndpoint().getMinioClient().uploadPart(uploadRequest, RequestBody.fromFile(filePayload)).eTag();\n+                CompletedPart partUpload = CompletedPart.builder().partNumber(part).eTag(etag).build();\n+                completedParts.add(partUpload);\n+                filePosition += partSize;\n+            }\n+            CompletedMultipartUpload completeMultipartUpload = CompletedMultipartUpload.builder().parts(completedParts).build();\n+            CompleteMultipartUploadRequest compRequest = CompleteMultipartUploadRequest.builder().multipartUpload(completeMultipartUpload)\n+                    .bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build();\n+\n+            uploadResult = getEndpoint().getMinioClient().completeMultipartUpload(compRequest);\n+\n+        } catch (Exception e) {\n+            getEndpoint().getMinioClient()\n+                    .abortMultipartUpload(AbortMultipartUploadRequest.builder().bucket(getConfiguration().getBucketName()).key(keyName).uploadId(initResponse.uploadId()).build());\n+            throw e;\n+        }\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, uploadResult.eTag());\n+        if (uploadResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, uploadResult.versionId());\n+        }\n+\n+        if (getConfiguration().isDeleteAfterWrite()) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    public void processSingleOp(final Exchange exchange) throws Exception {\n+\n+        Map<String, String> objectMetadata = determineMetadata(exchange);\n+\n+        File filePayload = null;\n+        InputStream is = null;\n+        ByteArrayOutputStream baos = null;\n+        Object obj = exchange.getIn().getMandatoryBody();\n+        PutObjectRequest.Builder putObjectRequest = PutObjectRequest.builder();\n+        // Need to check if the message body is WrappedFile\n+        if (obj instanceof WrappedFile) {\n+            obj = ((WrappedFile<?>) obj).getFile();\n+        }\n+        if (obj instanceof File) {\n+            filePayload = (File) obj;\n+            is = new FileInputStream(filePayload);\n+        } else {\n+            is = exchange.getIn().getMandatoryBody(InputStream.class);\n+            if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                    LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                    baos = determineLengthInputStream(is);\n+                    objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                    is = new ByteArrayInputStream(baos.toByteArray());\n+                } else {\n+                    if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                    }\n+                }\n+            }\n+        }\n+\n+        final String bucketName = determineBucketName(exchange);\n+        final String key = determineKey(exchange);\n+        putObjectRequest.bucket(bucketName).key(key).metadata(objectMetadata);\n+\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            putObjectRequest.storageClass(storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            ObjectCannedACL objectAcl = ObjectCannedACL.valueOf(cannedAcl);\n+            putObjectRequest.acl(objectAcl);\n+        }\n+\n+        BucketCannedACL acl = exchange.getIn().getHeader(MinioConstants.ACL, BucketCannedACL.class);\n+        if (acl != null) {\n+            // note: if cannedacl and acl are both specified the last one will\n+            // be used. refer to\n+            // PutObjectRequest#setAccessControlList for more details\n+            putObjectRequest.acl(acl.toString());\n+        }\n+\n+        if (getConfiguration().isUseAwsKMS()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                putObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+            }\n+        }\n+\n+        if (getConfiguration().isUseCustomerKey()) {\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                putObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                putObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+            }\n+            if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                putObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+            }\n+        }\n+\n+        LOG.trace(\"Put object [{}] from exchange [{}]...\", putObjectRequest, exchange);\n+\n+        PutObjectResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build(), RequestBody.fromBytes(SdkBytes.fromInputStream(is).asByteArray()));\n+\n+        LOG.trace(\"Received result [{}]\", putObjectResult);\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setHeader(MinioConstants.E_TAG, putObjectResult.eTag());\n+        if (putObjectResult.versionId() != null) {\n+            message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+        }\n+\n+        IOHelper.close(is);\n+\n+        if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+            FileUtil.deleteFile(filePayload);\n+        }\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_KEY, String.class);\n+        final String bucketNameDestination = exchange.getIn().getHeader(MinioConstants.BUCKET_DESTINATION_NAME, String.class);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof CopyObjectRequest) {\n+                CopyObjectResponse result;\n+                result = minioClient.copyObject((CopyObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+            if (ObjectHelper.isEmpty(bucketNameDestination)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+            CopyObjectRequest.Builder copyObjectRequest = CopyObjectRequest.builder();\n+            copyObjectRequest = CopyObjectRequest.builder().destinationBucket(bucketNameDestination).destinationKey(destinationKey).copySource(bucketName + \"/\" + sourceKey);\n+\n+            if (getConfiguration().isUseAwsKMS()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getAwsKMSKeyId())) {\n+                    copyObjectRequest.ssekmsKeyId(getConfiguration().getAwsKMSKeyId());\n+                }\n+            }\n+\n+            if (getConfiguration().isUseCustomerKey()) {\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyId())) {\n+                    copyObjectRequest.sseCustomerKey(getConfiguration().getCustomerKeyId());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerKeyMD5())) {\n+                    copyObjectRequest.sseCustomerKeyMD5(getConfiguration().getCustomerKeyMD5());\n+                }\n+                if (ObjectHelper.isNotEmpty(getConfiguration().getCustomerAlgorithm())) {\n+                    copyObjectRequest.sseCustomerAlgorithm(getConfiguration().getCustomerAlgorithm());\n+                }\n+            }\n+\n+            CopyObjectResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteObjectRequest) {\n+                minioClient.deleteObject((DeleteObjectRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            DeleteObjectRequest.Builder deleteObjectRequest = DeleteObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            minioClient.deleteObject(deleteObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) {\n+        ListBucketsResponse bucketsList = minioClient.listBuckets();\n+\n+        Message message = getMessageForResponse(exchange);\n+        message.setBody(bucketsList.buckets());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof DeleteBucketRequest) {\n+                DeleteBucketResponse resp = minioClient.deleteBucket((DeleteBucketRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(resp);\n+            }\n+        } else {\n+\n+            DeleteBucketRequest.Builder deleteBucketRequest = DeleteBucketRequest.builder().bucket(bucketName);\n+            DeleteBucketResponse resp = minioClient.deleteBucket(deleteBucketRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(resp);\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineKey(exchange);\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey);\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void getObjectRange(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineKey(exchange);\n+        final String rangeStart = exchange.getIn().getHeader(MinioConstants.RANGE_START, String.class);\n+        final String rangeEnd = exchange.getIn().getHeader(MinioConstants.RANGE_END, String.class);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof GetObjectRequest) {\n+                ResponseInputStream<GetObjectResponse> res = minioClient.getObject((GetObjectRequest) payload, ResponseTransformer.toInputStream());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(res);\n+            }\n+        } else {\n+\n+            if (ObjectHelper.isEmpty(rangeStart) || ObjectHelper.isEmpty(rangeEnd)) {\n+                throw new IllegalArgumentException(\"A Range start and range end header must be configured to perform a range get operation.\");\n+            }\n+\n+            GetObjectRequest.Builder req = GetObjectRequest.builder().bucket(bucketName).key(sourceKey)\n+                    .range(\"bytes=\" + Long.parseLong(rangeStart) + \"-\" + Long.parseLong(rangeEnd));\n+            ResponseInputStream<GetObjectResponse> res = minioClient.getObject(req.build(), ResponseTransformer.toInputStream());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(res);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            Object payload = exchange.getIn().getMandatoryBody();\n+            if (payload instanceof ListObjectsRequest) {\n+                ListObjectsResponse objectList = minioClient.listObjects((ListObjectsRequest) payload);\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList.contents());\n+            }\n+        } else {\n+\n+            ListObjectsResponse objectList = minioClient.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList.contents());\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.Minio_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<String, String>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"AWS S3 Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineKey(final Exchange exchange) {\n+        String key = exchange.getIn().getHeader(MinioConstants.KEY, String.class);\n+        if (ObjectHelper.isEmpty(key)) {\n+            key = getConfiguration().getKeyName();\n+        }\n+        if (key == null) {\n+            throw new IllegalArgumentException(\"AWS S3 Key header missing.\");\n+        }\n+        return key;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream is) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];\n+        int count;\n+        while ((count = is.read(bytes)) > 0) {\n+            out.write(bytes, 0, count);\n+        }\n+        return out;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n+\n+    @Override\n+    public String toString() {\n+        if (minioProducerToString == null) {\n+            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n+        }\n+        return minioProducerToString;\n+    }\n+\n+    @Override\n+    public MinioEndpoint getEndpoint() {\n+        return (MinioEndpoint) super.getEndpoint();\n+    }\n+\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex a14c218b4a8..d5c3579376d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -563,4 +470,8 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex d5c3579376d..44ea0653d78 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -470,8 +473,4 @@ public class MinioProducer extends DefaultProducer {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n \n-    public static Message getMessageForResponse(final Exchange exchange) {\n-        return exchange.getMessage();\n-    }\n-\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 44ea0653d78..79c80ab4cae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -472,5 +491,4 @@ public class MinioProducer extends DefaultProducer {\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..1e19e06c13b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -449,25 +452,16 @@ public class MinioProducer extends DefaultProducer {\n \n     private String determineStorageClass(final Exchange exchange) {\n         String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n-        if (storageClass == null) {\n+        if (isEmpty(storageClass)) {\n             storageClass = getConfiguration().getStorageClass();\n         }\n \n         return storageClass;\n     }\n \n-    private String determineVersionId(final Exchange exchange) {\n-        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n-        if (versionId == null) {\n-            versionId = getConfiguration().getVersionId();\n-        }\n-\n-        return versionId;\n-    }\n-\n     private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[1024];\n+        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n         int count;\n         while ((count = inputStream.read(bytes)) > 0) {\n             out.write(bytes, 0, count);\n", "next_change": {"commit": "99e08d0237368053b32935bfdb3106b67e7222d4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 1e19e06c13b..b2d11ac703a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n", "chunk": "@@ -459,28 +481,32 @@ public class MinioProducer extends DefaultProducer {\n         return storageClass;\n     }\n \n-    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        byte[] bytes = new byte[MinioConstants.BYTE_ARRAY_LENGTH];\n-        int count;\n-        while ((count = inputStream.read(bytes)) > 0) {\n-            out.write(bytes, 0, count);\n+    private long determineLengthInputStream(InputStream is) throws IOException {\n+        if (!is.markSupported()) {\n+            return -1;\n         }\n-        return out;\n+        if (is instanceof ByteArrayInputStream) {\n+            return is.available();\n+        }\n+        long size = 0;\n+        try {\n+            is.mark(MinioConstants.BYTE_ARRAY_LENGTH);\n+            int i = is.available();\n+            while (i > 0) {\n+                long skip = is.skip(i);\n+                size += skip;\n+                i = is.available();\n+            }\n+        } finally {\n+            is.reset();\n+        }\n+        return size;\n     }\n \n     protected MinioConfiguration getConfiguration() {\n         return getEndpoint().getConfiguration();\n     }\n \n-    @Override\n-    public String toString() {\n-        if (isEmpty(minioProducerToString)) {\n-            minioProducerToString = \"MinioProducer[\" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + \"]\";\n-        }\n-        return minioProducerToString;\n-    }\n-\n     @Override\n     public MinioEndpoint getEndpoint() {\n         return (MinioEndpoint) super.getEndpoint();\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "25628a8919c403b25ce89dd485fe59278b7effd7", "committedDate": "2021-08-30 10:56:11 +0200", "message": "(chores) fix resource leaks in camel-grape and camel-minio (#6005)"}, {"oid": "99e08d0237368053b32935bfdb3106b67e7222d4", "committedDate": "2021-09-30 12:32:06 +0200", "message": "CAMEL-17021: camel-minio - Determine content-length in a smarter way (#6184)"}, {"oid": "b04bc67e4c63ab845669f77cc13a9dee5f54fdbf", "committedDate": "2022-10-05 06:26:38 -0500", "message": "CAMEL-18583: [camel-minio] deleteObjects operation does not delete multiple objects (#8483)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NTMwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460765307", "body": "This class name is weird for the client impl. If this the remote client from the factory, something like `MinioRemoteClientImpl` would make more sense", "bodyText": "This class name is weird for the client impl. If this the remote client from the factory, something like MinioRemoteClientImpl would make more sense", "bodyHTML": "<p dir=\"auto\">This class name is weird for the client impl. If this the remote client from the factory, something like <code>MinioRemoteClientImpl</code> would make more sense</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:32:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nsimilarity index 78%\nrename from components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nindex 6cb96368b45..387b4409420 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\n", "chunk": "@@ -21,18 +21,20 @@ import org.apache.camel.component.minio.MinioConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * Creates MinIO client object according to the\n  * given endpoint, port, access key, secret key, region and secure option.\n  */\n-public class GetMinioClient implements MinioCamelInternalClient {\n-    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+public class MinioRemoteClientImpl implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioRemoteClientImpl.class);\n     private final MinioConfiguration configuration;\n \n     /**\n      * Constructor that uses the config file.\n      */\n-    public GetMinioClient(MinioConfiguration configuration) {\n+    public MinioRemoteClientImpl(MinioConfiguration configuration) {\n         LOG.trace(\"Creating an Minio client.\");\n         this.configuration = configuration;\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nsimilarity index 78%\nrename from components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nindex 6cb96368b45..387b4409420 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\n", "chunk": "@@ -21,18 +21,20 @@ import org.apache.camel.component.minio.MinioConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * Creates MinIO client object according to the\n  * given endpoint, port, access key, secret key, region and secure option.\n  */\n-public class GetMinioClient implements MinioCamelInternalClient {\n-    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+public class MinioRemoteClientImpl implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioRemoteClientImpl.class);\n     private final MinioConfiguration configuration;\n \n     /**\n      * Constructor that uses the config file.\n      */\n-    public GetMinioClient(MinioConfiguration configuration) {\n+    public MinioRemoteClientImpl(MinioConfiguration configuration) {\n         LOG.trace(\"Creating an Minio client.\");\n         this.configuration = configuration;\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766063", "body": "I wonder accessKeys, same as region are not required?", "bodyText": "I wonder accessKeys, same as region are not required?", "bodyHTML": "<p dir=\"auto\">I wonder accessKeys, same as region are not required?</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:33:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+    private final MinioConfiguration configuration;\n+\n+    /**\n+     * Constructor that uses the config file.\n+     */\n+    public GetMinioClient(MinioConfiguration configuration) {\n+        LOG.trace(\"Creating an Minio client.\");\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Getting the minio client.\n+     *\n+     * @return Minio Client.\n+     */\n+    @Override\n+    public MinioClient getMinioClient() {\n+        if (configuration.getEndpoint() != null) {\n+            MinioClient.Builder minioClientRequest = MinioClient.builder();\n+\n+            if (configuration.getProxyPort() != null) {\n+                minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n+            } else {\n+                minioClientRequest.endpoint(configuration.getEndpoint());\n+            }\n+            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMDMyMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464100320", "bodyText": "Hi @omarsmak sorry, I didn't get this question?", "author": "Nayananga", "createdAt": "2020-08-02T17:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MDYwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464270607", "bodyText": "What I mean here, are the accessKey, secretKey and region are required in order to initiate the client? What happens if one of these is null or not set?", "author": "omarsmak", "createdAt": "2020-08-03T08:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMzg2NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464623864", "bodyText": "@omarsmak, As per Java Client API Reference you can create MinioClient with or without accessKey, secretKey (namely anonymous access) or region.", "author": "Nayananga", "createdAt": "2020-08-03T19:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNjIwNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466216204", "bodyText": "@omarsmak is it okay to mark this as resolved?", "author": "Nayananga", "createdAt": "2020-08-06T07:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nsimilarity index 78%\nrename from components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nindex 6cb96368b45..387b4409420 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\n", "chunk": "@@ -44,21 +46,21 @@ public class GetMinioClient implements MinioCamelInternalClient {\n      */\n     @Override\n     public MinioClient getMinioClient() {\n-        if (configuration.getEndpoint() != null) {\n+        if (isNotEmpty(configuration.getEndpoint())) {\n             MinioClient.Builder minioClientRequest = MinioClient.builder();\n \n-            if (configuration.getProxyPort() != null) {\n+            if (isNotEmpty(configuration.getProxyPort())) {\n                 minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n             } else {\n                 minioClientRequest.endpoint(configuration.getEndpoint());\n             }\n-            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {\n+            if (isNotEmpty(configuration.getAccessKey()) && isNotEmpty(configuration.getSecretKey())) {\n                 minioClientRequest.credentials(configuration.getAccessKey(), configuration.getSecretKey());\n             }\n-            if (configuration.getRegion() != null) {\n+            if (isNotEmpty(configuration.getRegion())) {\n                 minioClientRequest.region(configuration.getRegion());\n             }\n-            if (configuration.getCustomHttpClient() != null) {\n+            if (isNotEmpty(configuration.getCustomHttpClient())) {\n                 minioClientRequest.httpClient(configuration.getCustomHttpClient());\n             }\n             return minioClientRequest.build();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nsimilarity index 78%\nrename from components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nindex 6cb96368b45..387b4409420 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\n", "chunk": "@@ -44,21 +46,21 @@ public class GetMinioClient implements MinioCamelInternalClient {\n      */\n     @Override\n     public MinioClient getMinioClient() {\n-        if (configuration.getEndpoint() != null) {\n+        if (isNotEmpty(configuration.getEndpoint())) {\n             MinioClient.Builder minioClientRequest = MinioClient.builder();\n \n-            if (configuration.getProxyPort() != null) {\n+            if (isNotEmpty(configuration.getProxyPort())) {\n                 minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n             } else {\n                 minioClientRequest.endpoint(configuration.getEndpoint());\n             }\n-            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {\n+            if (isNotEmpty(configuration.getAccessKey()) && isNotEmpty(configuration.getSecretKey())) {\n                 minioClientRequest.credentials(configuration.getAccessKey(), configuration.getSecretKey());\n             }\n-            if (configuration.getRegion() != null) {\n+            if (isNotEmpty(configuration.getRegion())) {\n                 minioClientRequest.region(configuration.getRegion());\n             }\n-            if (configuration.getCustomHttpClient() != null) {\n+            if (isNotEmpty(configuration.getCustomHttpClient())) {\n                 minioClientRequest.httpClient(configuration.getCustomHttpClient());\n             }\n             return minioClientRequest.build();\n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjU1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766557", "body": "Please add more cases for region, secretKey .. etc", "bodyText": "Please add more cases for region, secretKey .. etc", "bodyHTML": "<p dir=\"auto\">Please add more cases for region, secretKey .. etc</p>", "author": "omarsmak", "createdAt": "2020-07-27T09:34:22Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinioComponentConfigurationTest extends CamelTestSupport {\n+\n+    @Test\n+    public void createEndpointWithMinimalConfiguration() throws Exception {\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex a30b0f5a702..056b1403c9c 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -28,6 +28,10 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n+        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n+        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n+        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n }\n", "next_change": {"commit": "5ce02877a27e4c44242760f1bd7af412bd220664", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex 056b1403c9c..b2d0324eac0 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -34,4 +38,19 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n+\n+    @Test\n+    public void createEndpointWithCredentialsAndClientExistInRegistry() throws Exception {\n+        final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n+\n+        MinioClient client = MinioClient.builder()\n+                .endpoint(properties.getProperty(\"endpoint\"))\n+                .build();\n+        context.getRegistry().bind(\"minioClient\", client);\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint)component.createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n+\n+        assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n+        assertSame(client, endpoint.getConfiguration().getMinioClient());\n+    }\n }\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex b2d0324eac0..a30b0f5a702 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -32,25 +28,6 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n-        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n-        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n-        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n-        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n-\n-    @Test\n-    public void createEndpointWithCredentialsAndClientExistInRegistry() throws Exception {\n-        final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n-\n-        MinioClient client = MinioClient.builder()\n-                .endpoint(properties.getProperty(\"endpoint\"))\n-                .build();\n-        context.getRegistry().bind(\"minioClient\", client);\n-        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n-        MinioEndpoint endpoint = (MinioEndpoint)component.createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n-\n-        assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n-        assertSame(client, endpoint.getConfiguration().getMinioClient());\n-    }\n }\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex a30b0f5a702..056b1403c9c 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -28,6 +28,10 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n+        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n+        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n+        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n }\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\ndeleted file mode 100644\nindex 056b1403c9c..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,37 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio;\n-\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-public class MinioComponentConfigurationTest extends CamelTestSupport {\n-\n-    @Test\n-    public void createEndpointWithMinimalConfiguration() throws Exception {\n-        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n-        MinioEndpoint endpoint = (MinioEndpoint) component\n-                .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n-        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n-        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n-        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n-        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n-        assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nnew file mode 100644\nindex 00000000000..cbbd3682e72\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinioComponentConfigurationTest extends CamelTestSupport {\n+\n+    @Test\n+    public void createEndpointWithMinimalConfiguration() throws Exception {\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint)component\n+            .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n+    }\n+}\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex cbbd3682e72..a30b0f5a702 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -26,8 +26,8 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n     @Test\n     public void createEndpointWithMinimalConfiguration() throws Exception {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n-        MinioEndpoint endpoint = (MinioEndpoint)component\n-            .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n }\n", "next_change": {"commit": "170ea27658ce31d585e0df8cddc599d6e2e63d74", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex a30b0f5a702..056b1403c9c 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -28,6 +28,10 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n+        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n+        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n+        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex a30b0f5a702..18ddc54c8d4 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -28,6 +33,25 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n+        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n+        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n+        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n+\n+    @Test\n+    public void createEndpointWithCredentialsAndClientExistInRegistry() throws Exception {\n+        final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n+\n+        MinioClient client = MinioClient.builder()\n+                .endpoint(properties.getProperty(\"endpoint\"))\n+                .build();\n+        context.getRegistry().bind(\"minioClient\", client);\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint)component.createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n+\n+        assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n+        assertSame(client, endpoint.getConfiguration().getMinioClient());\n+    }\n }\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex 18ddc54c8d4..caf6af39d3e 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -49,7 +50,8 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n                 .build();\n         context.getRegistry().bind(\"minioClient\", client);\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n-        MinioEndpoint endpoint = (MinioEndpoint)component.createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1\");\n \n         assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n         assertSame(client, endpoint.getConfiguration().getMinioClient());\n", "next_change": {"commit": "96eb5704825443ea891a04d108771bbcab2890d0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex caf6af39d3e..5ba72edd593 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n", "chunk": "@@ -56,4 +56,22 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n         assertSame(client, endpoint.getConfiguration().getMinioClient());\n     }\n+\n+    @Test\n+    void createEndpoinWthAutowiredDisabledAndClientExistInRegistry() throws Exception {\n+        final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n+\n+        context.setAutowiredEnabled(false);\n+        MinioClient client = MinioClient.builder()\n+                .endpoint(properties.getProperty(\"endpoint\"))\n+                .build();\n+        context.getRegistry().bind(\"minioClient\", client);\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\n+                        \"minio://MyBucket?accessKey=RAW(XXX)&secretKey=RAW(XXX)&region=eu-west-1&endpoint=https://play.min.io\");\n+        context.setAutowiredEnabled(true);\n+        assertEquals(\"MyBucket\", endpoint.getConfiguration().getBucketName());\n+        assertNull(endpoint.getConfiguration().getMinioClient());\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "2fd065371821831d6884c5d9449302931e2dc217", "committedDate": "2020-08-21 19:19:27 +0200", "message": "CAMEL-15444: fix incorrect assertion order (#4116)"}, {"oid": "c40364a59815239e63d959faa982cb5212a217a3", "committedDate": "2020-08-27 08:03:20 +0200", "message": "Added testcontainer integration test for Minio (#4101)"}, {"oid": "96eb5704825443ea891a04d108771bbcab2890d0", "committedDate": "2021-01-14 20:12:21 +0100", "message": "CAMEL-16037 Minio: if autowiredEnabled is set to false on camelContext, minioClient is still autowired (#4886)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3NTgzMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460775832", "body": "These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:\r\n```\r\nprivate void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer<String> fn) {\r\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\r\n            fn.accept(configuration.getMatchETag());\r\n        }\r\n    }\r\n```  \r\nAnd then somewhere in the code:\r\n```\r\ncheckMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);\r\n```", "bodyText": "These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:\nprivate void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer<String> fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n\nAnd then somewhere in the code:\ncheckMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);", "bodyHTML": "<p dir=\"auto\">These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer&lt;String&gt; fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n\"><pre><code>private void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer&lt;String&gt; fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n</code></pre></div>\n<p dir=\"auto\">And then somewhere in the code:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"checkMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);\n\"><pre><code>checkMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);\n</code></pre></div>", "author": "omarsmak", "createdAt": "2020-07-27T09:50:46Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char) c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        minioClient.makeBucket(makeBucketRequest.build());\n+    }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n+    }\n+\n+    private void getObjectStat(String objectName, Message message) throws Exception {\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -248,30 +247,14 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), statObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), statObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), statObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), statObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), statObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), statObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), statObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), statObjectRequest::unmodifiedSince);\n \n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f75734b972..9ad67ad3573 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -247,14 +248,30 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), statObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), statObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), statObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), statObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), statObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), statObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), statObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), statObjectRequest::unmodifiedSince);\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n \n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..54e7662498d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -248,28 +248,28 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n             statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n         }\n-        if (getConfiguration().getOffset() != 0) {\n+        if (getConfiguration().getOffset() > 0) {\n             statObjectRequest.offset(getConfiguration().getOffset());\n         }\n-        if (getConfiguration().getLength() != 0) {\n+        if (getConfiguration().getLength() > 0) {\n             statObjectRequest.length(getConfiguration().getLength());\n         }\n-        if (getConfiguration().getVersionId() != null) {\n+        if (isNotEmpty(getConfiguration().getVersionId())) {\n             statObjectRequest.versionId(getConfiguration().getVersionId());\n         }\n-        if (getConfiguration().getMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getMatchETag())) {\n             statObjectRequest.matchETag(getConfiguration().getMatchETag());\n         }\n-        if (getConfiguration().getNotMatchETag() != null) {\n+        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n             statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n         }\n-        if (getConfiguration().getModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n             statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n         }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n+        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n             statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n         }\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 54e7662498d..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,279 +16,72 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.BucketExistsArgs;\n-import io.minio.MakeBucketArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectStat;\n-import io.minio.SetBucketPolicyArgs;\n-import io.minio.StatObjectArgs;\n-import io.minio.errors.InvalidBucketNameException;\n-import org.apache.camel.Category;\n-import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.Producer;\n-import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n-import org.apache.camel.support.ScheduledPollEndpoint;\n-import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+import org.apache.camel.support.DefaultEndpoint;\n \n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Minio component which does bla bla.\n+ * <p>\n+ * TODO: Update one line description above what the component does.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n-public class MinioEndpoint extends ScheduledPollEndpoint {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n-\n-    private MinioClient minioClient;\n-\n-    @UriPath(description = \"Bucket name\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:name\",\n+        consumerClass = MinioConsumer.class, label = \"custom\")\n+public class MinioEndpoint extends DefaultEndpoint {\n+    @UriPath\n     @Metadata(required = true)\n-    private String bucketName;\n-    @UriParam\n-    private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n \n-    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n-        super(uri, component);\n-        this.configuration = configuration;\n+    public MinioEndpoint() {\n     }\n \n-    @Override\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n-        configureConsumer(minioConsumer);\n-        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n-        return minioConsumer;\n+    public MinioEndpoint(String uri, MinioComponent component) {\n+        super(uri, component);\n     }\n \n-    @Override\n-    public Producer createProducer() {\n+    public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    @Override\n-    public void doStart() throws Exception {\n-        super.doStart();\n-\n-        minioClient = isNotEmpty(getConfiguration().getMinioClient())\n-                ? getConfiguration().getMinioClient()\n-                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n-\n-        String objectName = getConfiguration().getObjectName();\n-\n-        if (isNotEmpty(objectName)) {\n-            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n-            return;\n-        }\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n-\n-        if (bucketExists(bucketName)) {\n-            LOG.trace(\"Bucket {} already exists\", bucketName);\n-        } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n-                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n-                makeBucket(bucketName);\n-                LOG.trace(\"Bucket created\");\n-            }\n-        }\n-\n-        if (isNotEmpty(getConfiguration().getPolicy())) {\n-            setBucketPolicy(bucketName);\n-        }\n-    }\n-\n-    @Override\n-    public void doStop() throws Exception {\n-        super.doStop();\n-    }\n-\n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutoCloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinioConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n+    public String getName() {\n+        return name;\n     }\n \n     /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    public void setName(String name) {\n+        this.name = name;\n     }\n \n-    public int getMaxConnections() {\n-        return maxConnections;\n+    public int getOption() {\n+        return option;\n     }\n \n     /**\n-     * Set the maxConnections parameter in the minio client configuration\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n+    public void setOption(int option) {\n+        this.option = option;\n     }\n \n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-    }\n-\n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (isNotEmpty(getConfiguration().getRegion())) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        minioClient.makeBucket(makeBucketRequest.build());\n-    }\n-\n-    private void setBucketPolicy(String bucketName) throws Exception {\n-        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-        minioClient.setBucketPolicy(\n-                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n-        LOG.trace(\"Bucket policy updated\");\n-    }\n-\n-    private void getObjectStat(String objectName, Message message) throws Exception {\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (isNotEmpty(getConfiguration().getServerSideEncryptionCustomerKey())) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (isNotEmpty(getConfiguration().getVersionId())) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (isNotEmpty(getConfiguration().getMatchETag())) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getNotMatchETag())) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (isNotEmpty(getConfiguration().getModifiedSince())) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (isNotEmpty(getConfiguration().getUnModifiedSince())) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n-\n-        // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n-        message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex ee167dbbeab..0edc380c6eb 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -69,19 +76,19 @@ public class MinioEndpoint extends DefaultEndpoint {\n         this.name = name;\n     }\n \n-    public int getOption() {\n-        return option;\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n     }\n \n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n+    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+                this.configuration.getSecretKey());\n+        return minioClient;\n+\n     }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0edc380c6eb..64b18d08cdc 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -84,8 +85,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.configuration = configuration;\n     }\n \n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n                 this.configuration.getSecretKey());\n         return minioClient;\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 64b18d08cdc..823af3025a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,88 +16,244 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n import io.minio.MinioClient;\n-import io.minio.errors.InvalidEndpointException;\n-import io.minio.errors.InvalidPortException;\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n+import io.minio.Result;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * Represents a Minio endpoint.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:url\", consumerClass = MinioConsumer.class, label = \"storage,cloud,file\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n-    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioEndpoint.class);\n \n-    @UriPath\n-    @Metadata(required = true)\n-    private String name;\n-    @UriPath(description = \"Bucket name or ARN\")\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n-    private MinioClient minioClient;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n \n-    public MinioEndpoint() {\n-    }\n-\n-    public MinioEndpoint(final String uri, final MinioComponent component,\n-                         final MinioConfiguration configuration) {\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n         this.configuration = configuration;\n     }\n \n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n     public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        return new MinioConsumer(this, processor);\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = configuration.getMinioClient() != null\n+                ? configuration.getMinioClient()\n+                : MinioClientFactory.getMinioClient(configuration).getMinioClient();\n+\n+        String fileName = getConfiguration().getFileName();\n+\n+        if (fileName != null) {\n+            LOG.trace(\"File name [{}] requested, so skipping bucket check...\", fileName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket [{}] already exists...\", bucketName);\n+\n+        String prefix = getConfiguration().getPrefix();\n+\n+        try {\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+            LOG.trace(\"Bucket [{}] already exists\", bucketName);\n+            return;\n+        } catch (AwsServiceException ase) {\n+            /* 404 means the bucket doesn't exist */\n+            if (ase.awsErrorDetails().errorCode().equalsIgnoreCase(\"404\")) {\n+                throw ase;\n+            }\n+        }\n+\n+        LOG.trace(\"Bucket [{}] doesn't exist yet\", bucketName);\n+\n+        if (getConfiguration().isAutoCreateBucket()) {\n+            // creates the new bucket because it doesn't exist yet\n+            CreateBucketRequest createBucketRequest = CreateBucketRequest.builder().bucket(getConfiguration().getBucketName()).build();\n+\n+            LOG.trace(\"Creating bucket [{}] in region [{}] with request [{}]...\", configuration.getBucketName(), configuration.getRegion(), createBucketRequest);\n+\n+            minioClient.createBucket(createBucketRequest);\n+\n+            LOG.trace(\"Bucket created\");\n+        }\n+\n+        if (configuration.getPolicy() != null) {\n+            LOG.trace(\"Updating bucket [{}] with policy [{}]\", bucketName, configuration.getPolicy());\n+\n+            minioClient.putBucketPolicy(PutBucketPolicyRequest.builder().bucket(bucketName).policy(configuration.getPolicy()).build());\n+\n+            LOG.trace(\"Bucket policy updated\");\n+        }\n     }\n \n-    public boolean isSingleton() {\n-        return true;\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {\n+            if (s3Client != null) {\n+                s3Client.close();\n+            }\n+        }\n+        super.doStop();\n     }\n \n-    public String getName() {\n-        return name;\n+    public Exchange createExchange(ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        return createExchange(getExchangePattern(), s3Object, key);\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n+    public Exchange createExchange(ExchangePattern pattern, ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        LOG.trace(\"Getting object with key [{}] from bucket [{}]...\", key, getConfiguration().getBucketName());\n+\n+        LOG.trace(\"Got object [{}]\", s3Object);\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+\n+        if (configuration.isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(s3Object));\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+        }\n+\n+        message.setHeader(AWS2S3Constants.KEY, key);\n+        message.setHeader(AWS2S3Constants.BUCKET_NAME, getConfiguration().getBucketName());\n+        message.setHeader(AWS2S3Constants.E_TAG, s3Object.response().eTag());\n+        message.setHeader(AWS2S3Constants.LAST_MODIFIED, s3Object.response().lastModified());\n+        message.setHeader(AWS2S3Constants.VERSION_ID, s3Object.response().versionId());\n+        message.setHeader(AWS2S3Constants.CONTENT_TYPE, s3Object.response().contentType());\n+        message.setHeader(AWS2S3Constants.CONTENT_LENGTH, s3Object.response().contentLength());\n+        message.setHeader(AWS2S3Constants.CONTENT_ENCODING, s3Object.response().contentEncoding());\n+        message.setHeader(AWS2S3Constants.CONTENT_DISPOSITION, s3Object.response().contentDisposition());\n+        message.setHeader(AWS2S3Constants.CACHE_CONTROL, s3Object.response().cacheControl());\n+        message.setHeader(AWS2S3Constants.SERVER_SIDE_ENCRYPTION, s3Object.response().serverSideEncryption());\n+        message.setHeader(AWS2S3Constants.EXPIRATION_TIME, s3Object.response().expiration());\n+        message.setHeader(AWS2S3Constants.REPLICATION_STATUS, s3Object.response().replicationStatus());\n+        message.setHeader(AWS2S3Constants.STORAGE_CLASS, s3Object.response().storageClass());\n+\n+        /**\n+         * If includeBody != true, it is safe to close the object here. If\n+         * includeBody == true, the caller is responsible for closing the stream\n+         * and object once the body has been fully consumed. As of 2.17, the\n+         * consumer does not close the stream or object on commit.\n+         */\n+        if (!configuration.isIncludeBody()) {\n+            IOHelper.close(s3Object);\n+        } else {\n+            if (configuration.isAutocloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(s3Object);\n+                    }\n+                });\n+            }\n+        }\n+\n+        return exchange;\n     }\n \n-    public MinioConfiguration getConfiguration() {\n+    public AWS2S3Configuration getConfiguration() {\n         return configuration;\n     }\n \n-    public void setConfiguration(MinioConfiguration configuration) {\n+    public void setConfiguration(AWS2S3Configuration configuration) {\n         this.configuration = configuration;\n     }\n \n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public void setS3Client(S3Client s3Client) {\n+        this.s3Client = s3Client;\n+    }\n+\n+    public S3Client getS3Client() {\n+        return s3Client;\n     }\n \n-    public MinioClient getMinioClient() {\n-        return minioClient;\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n     }\n \n-    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n-                this.configuration.getSecretKey());\n-        return minioClient;\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n \n+    public int getMaxConnections() {\n+        return maxConnections;\n     }\n \n+    /**\n+     * Set the maxConnections parameter in the S3 client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(ResponseInputStream<GetObjectResponse> s3Object) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(s3Object, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c = 0;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 823af3025a0..fbc5e921a19 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -256,4 +243,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n         return textBuilder.toString();\n     }\n+\n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n+        if (getConfiguration().)\n+    }\n }\n", "next_change": {"commit": "152fd8b381686621d3de6a6300323fe89f42720b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbc5e921a19..c827cc9fab1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -254,7 +267,24 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n-        if (getConfiguration().)\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+        try {\n+            if (region != null) {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .region(region)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            } else {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n     }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..1010a4c0cc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -267,24 +234,52 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+    private void makeBucket(String bucketName) throws Exception {\n         try {\n-            if (region != null) {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .region(region)\n-                        .objectLock(isObjectLock)\n-                        .build());\n-            } else {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .objectLock(isObjectLock)\n-                        .build());\n+            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n+            if (configuration.getRegion() != null) {\n+                makeBucketRequest.region(configuration.getRegion());\n             }\n+            minioClient.makeBucket(makeBucketRequest.build());\n \n         } catch (Throwable e) {\n             LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n             throw e;\n         }\n     }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        try {\n+            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+            minioClient.setBucketPolicy(\n+                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n+            LOG.trace(\"Bucket policy updated\");\n+        } catch (Throwable e) {\n+            Log.warn(\"Error updating policy, due {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void getObjectTags(String objectName, String bucketName, Message message) {\n+        try {\n+            ObjectStat stat = minioClient.statObject(\n+                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n+\n+            // set all stat as message headers\n+            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+            message.setHeader(MinioConstants.E_TAG, stat.etag());\n+            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+\n+        } catch (Exception e) {\n+            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+        }\n+    }\n }\n", "next_change": {"commit": "f4aea6f0902b2108a296a183973813785969618b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 1010a4c0cc6..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -279,7 +278,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n \n         } catch (Exception e) {\n-            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n         }\n     }\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -223,62 +223,67 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return textBuilder.toString();\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n \n     private void makeBucket(String bucketName) throws Exception {\n-        try {\n-            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n-            if (configuration.getRegion() != null) {\n-                makeBucketRequest.region(configuration.getRegion());\n-            }\n-            minioClient.makeBucket(makeBucketRequest.build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n-            throw e;\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n         }\n+        minioClient.makeBucket(makeBucketRequest.build());\n     }\n \n     private void setBucketPolicy(String bucketName) throws Exception {\n-        try {\n-            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-            minioClient.setBucketPolicy(\n-                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n-            LOG.trace(\"Bucket policy updated\");\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error updating policy, due {}\", e.getMessage());\n-            throw e;\n-        }\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n     }\n \n-    private void getObjectTags(String objectName, String bucketName, Message message) {\n-        try {\n-            ObjectStat stat = minioClient.statObject(\n-                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n-\n-            // set all stat as message headers\n-            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n-            message.setHeader(MinioConstants.E_TAG, stat.etag());\n-            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n-\n-        } catch (Exception e) {\n-            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n+    private void getObjectTags(String objectName, String bucketName, Message message) throws Exception {\n+\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n         }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+\n+        // set all stat as message headers\n+        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.E_TAG, stat.etag());\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..fa911a0dac1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -274,13 +276,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n         message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n         message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n         message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n         message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n         message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n         message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -248,30 +250,14 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() != 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() != 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n+        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), statObjectRequest::ssec);\n+        MinioChecks.checkOffsetConfig(getConfiguration(), statObjectRequest::offset);\n+        MinioChecks.checkLengthConfig(getConfiguration(), statObjectRequest::length);\n+        MinioChecks.checkVersionIdConfig(getConfiguration(), statObjectRequest::versionId);\n+        MinioChecks.checkMatchETagConfig(getConfiguration(), statObjectRequest::matchETag);\n+        MinioChecks.checkNotMatchETagConfig(getConfiguration(), statObjectRequest::notMatchETag);\n+        MinioChecks.checkModifiedSinceConfig(getConfiguration(), statObjectRequest::modifiedSince);\n+        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), statObjectRequest::unmodifiedSince);\n \n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n", "next_change": {"commit": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..0f4f069f776 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -250,14 +212,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         String bucketName = getConfiguration().getBucketName();\n         StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n \n-        MinioChecks.checkServerSideEncryptionCustomerKeyConfig(getConfiguration(), statObjectRequest::ssec);\n-        MinioChecks.checkOffsetConfig(getConfiguration(), statObjectRequest::offset);\n-        MinioChecks.checkLengthConfig(getConfiguration(), statObjectRequest::length);\n-        MinioChecks.checkVersionIdConfig(getConfiguration(), statObjectRequest::versionId);\n-        MinioChecks.checkMatchETagConfig(getConfiguration(), statObjectRequest::matchETag);\n-        MinioChecks.checkNotMatchETagConfig(getConfiguration(), statObjectRequest::notMatchETag);\n-        MinioChecks.checkModifiedSinceConfig(getConfiguration(), statObjectRequest::modifiedSince);\n-        MinioChecks.checkUnModifiedSinceConfig(getConfiguration(), statObjectRequest::unmodifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getServerSideEncryptionCustomerKey,\n+                statObjectRequest::ssec);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getOffset, statObjectRequest::offset);\n+        MinioChecks.checkLengthAndSetConfig(getConfiguration()::getLength, statObjectRequest::length);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getVersionId, statObjectRequest::versionId);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getMatchETag, statObjectRequest::matchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getNotMatchETag,\n+                statObjectRequest::notMatchETag);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getModifiedSince,\n+                statObjectRequest::modifiedSince);\n+        MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n+                statObjectRequest::unmodifiedSince);\n \n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n", "next_change": {"commit": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f4f069f776..41ff62fc6f1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -225,22 +245,22 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         MinioChecks.checkIfConfigIsNotEmptyAndSetAndConfig(getConfiguration()::getUnModifiedSince,\n                 statObjectRequest::unmodifiedSince);\n \n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+        StatObjectResponse stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.object());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucket());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.headers().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.headers().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.size());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.headers().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.headers().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.headers().get(\"cache-control\"));\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.headers().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.headers().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.headers().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.headers().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "committedDate": "2020-09-10 11:33:02 +0200", "message": "Camel-Minio: Lets simplify the client instantiation"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "fceb5aeac41ffc5a6fb64b2ce177628b5d85c621", "committedDate": "2020-12-04 08:32:34 +0100", "message": "CAMEL-15880 - Regen docs and fixed CS"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "committedDate": "2022-02-15 21:51:03 +0100", "message": "Remove unused code"}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463681735", "body": "Not sure about this, might lead to `NullPointerException`s", "bodyText": "Not sure about this, might lead to NullPointerExceptions", "bodyHTML": "<p dir=\"auto\">Not sure about this, might lead to <code>NullPointerException</code>s</p>", "author": "zregvart", "createdAt": "2020-07-31T15:34:12Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NDMzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463684336", "bodyText": "No, this is fine, we are using similar approach for component with Extension for validation like this https://github.com/apache/camel/blob/master/components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Component.java#L35", "author": "oscerd", "createdAt": "2020-07-31T15:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..c116f0641d2 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -17,76 +17,17 @@\n package org.apache.camel.component.minio;\n \n import java.util.Map;\n-import java.util.Set;\n \n-import io.minio.MinioClient;\n-import org.apache.camel.CamelContext;\n-import org.apache.camel.spi.Metadata;\n+import org.apache.camel.Endpoint;\n import org.apache.camel.spi.annotations.Component;\n import org.apache.camel.support.DefaultComponent;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-/**\n- * Represents the component that manages {@link MinioEndpoint}.\n- */\n @Component(\"minio\")\n public class MinioComponent extends DefaultComponent {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n-\n-    @Metadata\n-    private MinioConfiguration configuration = new MinioConfiguration();\n-\n-    public MinioComponent() {\n-        this(null);\n-    }\n-\n-    public MinioComponent(CamelContext context) {\n-        super(context);\n-        registerExtension(new MinioComponentVerifierExtension());\n-\n-    }\n-\n-    @Override\n-    protected MinioEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        if (remaining == null || remaining.trim().length() == 0) {\n-            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n-        }\n-\n-        final MinioConfiguration configuration = this.configuration != null ? this.configuration.copy() : new MinioConfiguration();\n-        configuration.setBucketName(remaining);\n-        MinioEndpoint endpoint = new MinioEndpoint(uri, this, configuration);\n+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n+        Endpoint endpoint = new MinioEndpoint(uri, this);\n         setProperties(endpoint, parameters);\n-        checkAndSetRegistryClient(configuration, endpoint);\n-\n         return endpoint;\n     }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    /**\n-     * The component configuration\n-     */\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n-            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n-            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() == 1) {\n-                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n-                configuration.setMinioClient(clients.stream().findFirst().get());\n-            } else {\n-                LOG.debug(\"No MinioClient instance in the registry\");\n-            }\n-        } else {\n-            LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n-        }\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex c116f0641d2..ebc4de1010b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -16,18 +16,54 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Map;\n-\n-import org.apache.camel.Endpoint;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.annotations.Component;\n import org.apache.camel.support.DefaultComponent;\n \n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n @Component(\"minio\")\n public class MinioComponent extends DefaultComponent {\n \n-    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        Endpoint endpoint = new MinioEndpoint(uri, this);\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        super();\n+    }\n+\n+    public MinioComponent(CamelContext context) {\n+        super(context);\n+    }\n+\n+    @Override\n+    protected MinioEndpoint createEndpoint(String uri, String remaining, java.util.Map<String, Object> parameters)\n+            throws Exception {\n+        setProperties(configuration, parameters);\n+        if (remaining == null || remaining.trim().length() == 0) {\n+            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n+        }\n+        if (remaining.startsWith(\"arn:\")) {\n+            remaining = remaining.substring(remaining.lastIndexOf(\":\") + 1, remaining.length());\n+        }\n+        configuration.setBucketName(remaining);\n+\n+        final MinioEndpoint endpoint = new MinioEndpoint(uri, remaining, this, configuration);\n         setProperties(endpoint, parameters);\n         return endpoint;\n     }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    /**\n+     * The component configuration\n+     */\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex ebc4de1010b..02f3fe3cfc0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -66,4 +82,19 @@ public class MinioComponent extends DefaultComponent {\n         this.configuration = configuration;\n     }\n \n+    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n+            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n+            if (clients.size() == 1) {\n+                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n+                configuration.setMinioClient(clients.stream().findFirst().get());\n+            } else {\n+                LOG.debug(\"No MinioClient instance in the registry\");\n+            }\n+        } else {\n+            LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 02f3fe3cfc0..92fbfdd2631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -96,5 +88,4 @@ public class MinioComponent extends DefaultComponent {\n             LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n         }\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": null, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "96eb5704825443ea891a04d108771bbcab2890d0", "committedDate": "2021-01-14 20:12:21 +0100", "message": "CAMEL-16037 Minio: if autowiredEnabled is set to false on camelContext, minioClient is still autowired (#4886)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692222", "body": "I would suggest to reformat it like this:\r\n```\r\n    @Override\r\n    protected Result verifyParameters(Map<String, Object> parameters) {\r\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\r\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\r\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\r\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\r\n\r\n        // Validate using the catalog\r\n        super.verifyParametersAgainstCatalog(builder, parameters);\r\n\r\n        return builder.build();\r\n    }\r\n```", "bodyText": "I would suggest to reformat it like this:\n    @Override\n    protected Result verifyParameters(Map<String, Object> parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }", "bodyHTML": "<p dir=\"auto\">I would suggest to reformat it like this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    @Override\n    protected Result verifyParameters(Map&lt;String, Object&gt; parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(&quot;accessKey&quot;, parameters))\n                                             .error(ResultErrorHelper.requiresOption(&quot;secretKey&quot;, parameters))\n                                             .error(ResultErrorHelper.requiresOption(&quot;region&quot;, parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }\n\"><pre><code>    @Override\n    protected Result verifyParameters(Map&lt;String, Object&gt; parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }\n</code></pre></div>", "author": "DenisIstomin", "createdAt": "2020-07-31T15:53:27Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+\n+import io.minio.MinioClient;\n+import io.minio.errors.MinioException;\n+import org.apache.camel.component.extension.verifier.DefaultComponentVerifierExtension;\n+import org.apache.camel.component.extension.verifier.ResultBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n+\n+public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n+\n+    public MinioComponentVerifierExtension() {\n+        this(\"minio\");\n+    }\n+\n+    public MinioComponentVerifierExtension(String scheme) {\n+        super(scheme);\n+    }\n+\n+    // *********************************\n+    // Parameters validation\n+    // *********************************\n+\n+    @Override", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5Mjg0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692845", "bodyText": "And the same below", "author": "DenisIstomin", "createdAt": "2020-07-31T15:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nindex f4bf952a507..cc97d5ecf25 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n", "chunk": "@@ -42,8 +45,10 @@ public class MinioComponentVerifierExtension extends DefaultComponentVerifierExt\n     @Override\n     protected Result verifyParameters(Map<String, Object> parameters) {\n \n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters)).error(ResultErrorHelper.requiresOption(\"region\", parameters));\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n+                .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n \n         // Validate using the catalog\n \n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nindex cc97d5ecf25..f4bf952a507 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n", "chunk": "@@ -45,10 +42,8 @@ public class MinioComponentVerifierExtension extends DefaultComponentVerifierExt\n     @Override\n     protected Result verifyParameters(Map<String, Object> parameters) {\n \n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n-                .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters)).error(ResultErrorHelper.requiresOption(\"region\", parameters));\n \n         // Validate using the catalog\n \n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nindex f4bf952a507..471299615e1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n", "chunk": "@@ -42,8 +42,10 @@ public class MinioComponentVerifierExtension extends DefaultComponentVerifierExt\n     @Override\n     protected Result verifyParameters(Map<String, Object> parameters) {\n \n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters)).error(ResultErrorHelper.requiresOption(\"region\", parameters));\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n+                .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n \n         // Validate using the catalog\n \n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\ndeleted file mode 100644\nindex 471299615e1..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ /dev/null\n", "chunk": "@@ -1,102 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio;\n-\n-import java.util.Map;\n-\n-import io.minio.MinioClient;\n-import io.minio.errors.MinioException;\n-import org.apache.camel.component.extension.verifier.DefaultComponentVerifierExtension;\n-import org.apache.camel.component.extension.verifier.ResultBuilder;\n-import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n-import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n-\n-public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n-\n-    public MinioComponentVerifierExtension() {\n-        this(\"minio\");\n-    }\n-\n-    public MinioComponentVerifierExtension(String scheme) {\n-        super(scheme);\n-    }\n-\n-    // *********************************\n-    // Parameters validation\n-    // *********************************\n-\n-    @Override\n-    protected Result verifyParameters(Map<String, Object> parameters) {\n-\n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n-                .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n-\n-        // Validate using the catalog\n-\n-        super.verifyParametersAgainstCatalog(builder, parameters);\n-\n-        return builder.build();\n-    }\n-\n-    // *********************************\n-    // Connectivity validation\n-    // *********************************\n-\n-    @Override\n-    protected Result verifyConnectivity(Map<String, Object> parameters) {\n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY);\n-        try {\n-            MinioConfiguration configuration = setProperties(new MinioConfiguration(), parameters);\n-            MinioClient.Builder clientBuilderRequest = MinioClient.builder();\n-\n-            if (configuration.getEndpoint() == null) {\n-                ResultErrorBuilder errorBuilder = ResultErrorBuilder.withCodeAndDescription(VerificationError.StandardCode.ILLEGAL_PARAMETER, \"The service endpoint has not defined\");\n-                return builder.error(errorBuilder.build()).build();\n-            }\n-\n-            if (configuration.getProxyPort() != null) {\n-                clientBuilderRequest.endpoint(\n-                        configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n-            } else {\n-                clientBuilderRequest.endpoint(configuration.getEndpoint());\n-            }\n-\n-            if (configuration.getRegion() != null) {\n-                clientBuilderRequest.region(configuration.getRegion());\n-            }\n-\n-            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {\n-                clientBuilderRequest.credentials(configuration.getAccessKey(), configuration.getSecretKey());\n-            }\n-\n-            MinioClient client = clientBuilderRequest.build();\n-            client.listBuckets();\n-        } catch (MinioException e) {\n-            ResultErrorBuilder errorBuilder = ResultErrorBuilder.withCodeAndDescription(VerificationError.StandardCode.AUTHENTICATION, e.getMessage())\n-                    .detail(\"minio_exception_message\", e.getMessage())\n-                    .detail(VerificationError.ExceptionAttribute.EXCEPTION_CLASS, e.getClass().getName())\n-                    .detail(VerificationError.ExceptionAttribute.EXCEPTION_INSTANCE, e);\n-\n-            builder.error(errorBuilder.build());\n-        } catch (Exception e) {\n-            builder.error(ResultErrorBuilder.withException(e).build());\n-        }\n-        return builder.build();\n-    }\n-}\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nnew file mode 100644\nindex 00000000000..a4d27d5a80a\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n", "chunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+\n+import io.minio.MinioClient;\n+import io.minio.errors.MinioException;\n+import org.apache.camel.component.extension.verifier.DefaultComponentVerifierExtension;\n+import org.apache.camel.component.extension.verifier.ResultBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n+\n+public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n+\n+    public MinioComponentVerifierExtension() {\n+        this(\"minio\");\n+    }\n+\n+    public MinioComponentVerifierExtension(String scheme) {\n+        super(scheme);\n+    }\n+\n+    // *********************************\n+    // Parameters validation\n+    // *********************************\n+\n+    @Override\n+    protected Result verifyParameters(Map<String, Object> parameters) {\n+\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters)).error(ResultErrorHelper.requiresOption(\"region\", parameters));\n+\n+        // Validate using the catalog\n+\n+        super.verifyParametersAgainstCatalog(builder, parameters);\n+\n+        return builder.build();\n+    }\n+\n+    // *********************************\n+    // Connectivity validation\n+    // *********************************\n+\n+    @Override\n+    protected Result verifyConnectivity(Map<String, Object> parameters) {\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY);\n+        try {\n+            MinioConfiguration configuration = setProperties(new MinioConfiguration(), parameters);\n+            MinioClient.Builder clientBuilderRequest = MinioClient.builder();\n+\n+            if (configuration.getEndpoint() == null) {\n+                ResultErrorBuilder errorBuilder = ResultErrorBuilder.withCodeAndDescription(VerificationError.StandardCode.ILLEGAL_PARAMETER, \"The service is not supported in this region\");\n+                return builder.error(errorBuilder.build()).build();\n+            }\n+\n+            if (configuration.getProxyPort() != null) {\n+                clientBuilderRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n+            } else {\n+                clientBuilderRequest.endpoint(configuration.getEndpoint());\n+            }\n+\n+            if (configuration.getEndpoint() != null) {\n+                clientBuilderRequest.region(configuration.getRegion());\n+            }\n+\n+            if (configuration.getRegion() != null) {\n+                clientBuilderRequest.region(configuration.getRegion());\n+            }\n+\n+            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {\n+                clientBuilderRequest.credentials(configuration.getAccessKey(), configuration.getSecretKey());\n+            }\n+\n+            MinioClient client = clientBuilderRequest.build();\n+            client.listBuckets();\n+        } catch (MinioException e) {\n+            ResultErrorBuilder errorBuilder = ResultErrorBuilder.withCodeAndDescription(VerificationError.StandardCode.AUTHENTICATION, e.getMessage())\n+                    .detail(\"minio_exception_message\", e.getMessage()).detail(VerificationError.ExceptionAttribute.EXCEPTION_CLASS, e.getClass().getName())\n+                    .detail(VerificationError.ExceptionAttribute.EXCEPTION_INSTANCE, e);\n+\n+            builder.error(errorBuilder.build());\n+        } catch (Exception e) {\n+            builder.error(ResultErrorBuilder.withException(e).build());\n+        }\n+        return builder.build();\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nindex f4bf952a507..cc97d5ecf25 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n", "chunk": "@@ -42,8 +45,10 @@ public class MinioComponentVerifierExtension extends DefaultComponentVerifierExt\n     @Override\n     protected Result verifyParameters(Map<String, Object> parameters) {\n \n-        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n-                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters)).error(ResultErrorHelper.requiresOption(\"region\", parameters));\n+        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n+                .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n+                .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n \n         // Validate using the catalog\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NDMwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463694308", "body": "This is TODO comment?", "bodyText": "This is TODO comment?", "bodyHTML": "<p dir=\"auto\">This is TODO comment?</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T15:57:10Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -62,7 +66,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String bucketName; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f75734b972..9ad67ad3573 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -66,7 +62,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String bucketName;\n+    private String bucketName; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..c28617d57ae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -62,7 +65,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String bucketName; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c28617d57ae..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,282 +16,72 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.BucketExistsArgs;\n-import io.minio.MakeBucketArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectStat;\n-import io.minio.SetBucketPolicyArgs;\n-import io.minio.StatObjectArgs;\n-import io.minio.errors.InvalidBucketNameException;\n-import org.apache.camel.Category;\n-import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.Producer;\n-import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n-import org.apache.camel.support.ScheduledPollEndpoint;\n-import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultEndpoint;\n \n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Minio component which does bla bla.\n+ * <p>\n+ * TODO: Update one line description above what the component does.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n-public class MinioEndpoint extends ScheduledPollEndpoint {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n-\n-    private MinioClient minioClient;\n-\n-    @UriPath(description = \"Bucket name\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:name\",\n+        consumerClass = MinioConsumer.class, label = \"custom\")\n+public class MinioEndpoint extends DefaultEndpoint {\n+    @UriPath\n     @Metadata(required = true)\n-    private String bucketName;\n-    @UriParam\n-    private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n \n-    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n-        super(uri, component);\n-        this.configuration = configuration;\n+    public MinioEndpoint() {\n     }\n \n-    @Override\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n-        configureConsumer(minioConsumer);\n-        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n-        return minioConsumer;\n+    public MinioEndpoint(String uri, MinioComponent component) {\n+        super(uri, component);\n     }\n \n-    @Override\n-    public Producer createProducer() {\n+    public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    @Override\n-    public void doStart() throws Exception {\n-        super.doStart();\n-\n-        minioClient = getConfiguration().getMinioClient() != null\n-                ? getConfiguration().getMinioClient()\n-                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n-\n-        String objectName = getConfiguration().getObjectName();\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n-            return;\n-        }\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n-\n-        if (bucketExists(bucketName)) {\n-            LOG.trace(\"Bucket {} already exists\", bucketName);\n-        } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n-                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n-                makeBucket(bucketName);\n-                LOG.trace(\"Bucket created\");\n-            }\n-        }\n-\n-        if (getConfiguration().getPolicy() != null) {\n-            setBucketPolicy(bucketName);\n-        }\n-    }\n-\n-    @Override\n-    public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n-        super.doStop();\n-    }\n-\n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutocloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinioConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n+    public String getName() {\n+        return name;\n     }\n \n     /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    public void setName(String name) {\n+        this.name = name;\n     }\n \n-    public int getMaxConnections() {\n-        return maxConnections;\n+    public int getOption() {\n+        return option;\n     }\n \n     /**\n-     * Set the maxConnections parameter in the minio client configuration\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n-    }\n-\n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    public void setOption(int option) {\n+        this.option = option;\n     }\n \n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (getConfiguration().getRegion() != null) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        minioClient.makeBucket(makeBucketRequest.build());\n-    }\n-\n-    private void setBucketPolicy(String bucketName) throws Exception {\n-        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-        minioClient.setBucketPolicy(\n-                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n-        LOG.trace(\"Bucket policy updated\");\n-    }\n-\n-    private void getObjectStat(String objectName, Message message) throws Exception {\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n-\n-        // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n-        message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex ee167dbbeab..0edc380c6eb 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -69,19 +76,19 @@ public class MinioEndpoint extends DefaultEndpoint {\n         this.name = name;\n     }\n \n-    public int getOption() {\n-        return option;\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n     }\n \n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n+    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+                this.configuration.getSecretKey());\n+        return minioClient;\n+\n     }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0edc380c6eb..64b18d08cdc 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -84,8 +85,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.configuration = configuration;\n     }\n \n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n                 this.configuration.getSecretKey());\n         return minioClient;\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 64b18d08cdc..823af3025a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,88 +16,244 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n import io.minio.MinioClient;\n-import io.minio.errors.InvalidEndpointException;\n-import io.minio.errors.InvalidPortException;\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n+import io.minio.Result;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * Represents a Minio endpoint.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:url\", consumerClass = MinioConsumer.class, label = \"storage,cloud,file\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n-    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioEndpoint.class);\n \n-    @UriPath\n-    @Metadata(required = true)\n-    private String name;\n-    @UriPath(description = \"Bucket name or ARN\")\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n-    private MinioClient minioClient;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n \n-    public MinioEndpoint() {\n-    }\n-\n-    public MinioEndpoint(final String uri, final MinioComponent component,\n-                         final MinioConfiguration configuration) {\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n         this.configuration = configuration;\n     }\n \n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n     public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        return new MinioConsumer(this, processor);\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = configuration.getMinioClient() != null\n+                ? configuration.getMinioClient()\n+                : MinioClientFactory.getMinioClient(configuration).getMinioClient();\n+\n+        String fileName = getConfiguration().getFileName();\n+\n+        if (fileName != null) {\n+            LOG.trace(\"File name [{}] requested, so skipping bucket check...\", fileName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket [{}] already exists...\", bucketName);\n+\n+        String prefix = getConfiguration().getPrefix();\n+\n+        try {\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+            LOG.trace(\"Bucket [{}] already exists\", bucketName);\n+            return;\n+        } catch (AwsServiceException ase) {\n+            /* 404 means the bucket doesn't exist */\n+            if (ase.awsErrorDetails().errorCode().equalsIgnoreCase(\"404\")) {\n+                throw ase;\n+            }\n+        }\n+\n+        LOG.trace(\"Bucket [{}] doesn't exist yet\", bucketName);\n+\n+        if (getConfiguration().isAutoCreateBucket()) {\n+            // creates the new bucket because it doesn't exist yet\n+            CreateBucketRequest createBucketRequest = CreateBucketRequest.builder().bucket(getConfiguration().getBucketName()).build();\n+\n+            LOG.trace(\"Creating bucket [{}] in region [{}] with request [{}]...\", configuration.getBucketName(), configuration.getRegion(), createBucketRequest);\n+\n+            minioClient.createBucket(createBucketRequest);\n+\n+            LOG.trace(\"Bucket created\");\n+        }\n+\n+        if (configuration.getPolicy() != null) {\n+            LOG.trace(\"Updating bucket [{}] with policy [{}]\", bucketName, configuration.getPolicy());\n+\n+            minioClient.putBucketPolicy(PutBucketPolicyRequest.builder().bucket(bucketName).policy(configuration.getPolicy()).build());\n+\n+            LOG.trace(\"Bucket policy updated\");\n+        }\n     }\n \n-    public boolean isSingleton() {\n-        return true;\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {\n+            if (s3Client != null) {\n+                s3Client.close();\n+            }\n+        }\n+        super.doStop();\n     }\n \n-    public String getName() {\n-        return name;\n+    public Exchange createExchange(ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        return createExchange(getExchangePattern(), s3Object, key);\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n+    public Exchange createExchange(ExchangePattern pattern, ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        LOG.trace(\"Getting object with key [{}] from bucket [{}]...\", key, getConfiguration().getBucketName());\n+\n+        LOG.trace(\"Got object [{}]\", s3Object);\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+\n+        if (configuration.isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(s3Object));\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+        }\n+\n+        message.setHeader(AWS2S3Constants.KEY, key);\n+        message.setHeader(AWS2S3Constants.BUCKET_NAME, getConfiguration().getBucketName());\n+        message.setHeader(AWS2S3Constants.E_TAG, s3Object.response().eTag());\n+        message.setHeader(AWS2S3Constants.LAST_MODIFIED, s3Object.response().lastModified());\n+        message.setHeader(AWS2S3Constants.VERSION_ID, s3Object.response().versionId());\n+        message.setHeader(AWS2S3Constants.CONTENT_TYPE, s3Object.response().contentType());\n+        message.setHeader(AWS2S3Constants.CONTENT_LENGTH, s3Object.response().contentLength());\n+        message.setHeader(AWS2S3Constants.CONTENT_ENCODING, s3Object.response().contentEncoding());\n+        message.setHeader(AWS2S3Constants.CONTENT_DISPOSITION, s3Object.response().contentDisposition());\n+        message.setHeader(AWS2S3Constants.CACHE_CONTROL, s3Object.response().cacheControl());\n+        message.setHeader(AWS2S3Constants.SERVER_SIDE_ENCRYPTION, s3Object.response().serverSideEncryption());\n+        message.setHeader(AWS2S3Constants.EXPIRATION_TIME, s3Object.response().expiration());\n+        message.setHeader(AWS2S3Constants.REPLICATION_STATUS, s3Object.response().replicationStatus());\n+        message.setHeader(AWS2S3Constants.STORAGE_CLASS, s3Object.response().storageClass());\n+\n+        /**\n+         * If includeBody != true, it is safe to close the object here. If\n+         * includeBody == true, the caller is responsible for closing the stream\n+         * and object once the body has been fully consumed. As of 2.17, the\n+         * consumer does not close the stream or object on commit.\n+         */\n+        if (!configuration.isIncludeBody()) {\n+            IOHelper.close(s3Object);\n+        } else {\n+            if (configuration.isAutocloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(s3Object);\n+                    }\n+                });\n+            }\n+        }\n+\n+        return exchange;\n     }\n \n-    public MinioConfiguration getConfiguration() {\n+    public AWS2S3Configuration getConfiguration() {\n         return configuration;\n     }\n \n-    public void setConfiguration(MinioConfiguration configuration) {\n+    public void setConfiguration(AWS2S3Configuration configuration) {\n         this.configuration = configuration;\n     }\n \n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public void setS3Client(S3Client s3Client) {\n+        this.s3Client = s3Client;\n+    }\n+\n+    public S3Client getS3Client() {\n+        return s3Client;\n     }\n \n-    public MinioClient getMinioClient() {\n-        return minioClient;\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n     }\n \n-    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n-                this.configuration.getSecretKey());\n-        return minioClient;\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n \n+    public int getMaxConnections() {\n+        return maxConnections;\n     }\n \n+    /**\n+     * Set the maxConnections parameter in the S3 client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(ResponseInputStream<GetObjectResponse> s3Object) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(s3Object, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c = 0;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 823af3025a0..fbc5e921a19 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -256,4 +243,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n         return textBuilder.toString();\n     }\n+\n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n+        if (getConfiguration().)\n+    }\n }\n", "next_change": {"commit": "152fd8b381686621d3de6a6300323fe89f42720b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbc5e921a19..c827cc9fab1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -254,7 +267,24 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n-        if (getConfiguration().)\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+        try {\n+            if (region != null) {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .region(region)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            } else {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n     }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..1010a4c0cc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -267,24 +234,52 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+    private void makeBucket(String bucketName) throws Exception {\n         try {\n-            if (region != null) {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .region(region)\n-                        .objectLock(isObjectLock)\n-                        .build());\n-            } else {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .objectLock(isObjectLock)\n-                        .build());\n+            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n+            if (configuration.getRegion() != null) {\n+                makeBucketRequest.region(configuration.getRegion());\n             }\n+            minioClient.makeBucket(makeBucketRequest.build());\n \n         } catch (Throwable e) {\n             LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n             throw e;\n         }\n     }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        try {\n+            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+            minioClient.setBucketPolicy(\n+                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n+            LOG.trace(\"Bucket policy updated\");\n+        } catch (Throwable e) {\n+            Log.warn(\"Error updating policy, due {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void getObjectTags(String objectName, String bucketName, Message message) {\n+        try {\n+            ObjectStat stat = minioClient.statObject(\n+                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n+\n+            // set all stat as message headers\n+            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+            message.setHeader(MinioConstants.E_TAG, stat.etag());\n+            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+\n+        } catch (Exception e) {\n+            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+        }\n+    }\n }\n", "next_change": {"commit": "f4aea6f0902b2108a296a183973813785969618b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 1010a4c0cc6..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -279,7 +278,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n \n         } catch (Exception e) {\n-            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n         }\n     }\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -223,62 +223,67 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return textBuilder.toString();\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n \n     private void makeBucket(String bucketName) throws Exception {\n-        try {\n-            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n-            if (configuration.getRegion() != null) {\n-                makeBucketRequest.region(configuration.getRegion());\n-            }\n-            minioClient.makeBucket(makeBucketRequest.build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n-            throw e;\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n         }\n+        minioClient.makeBucket(makeBucketRequest.build());\n     }\n \n     private void setBucketPolicy(String bucketName) throws Exception {\n-        try {\n-            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-            minioClient.setBucketPolicy(\n-                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n-            LOG.trace(\"Bucket policy updated\");\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error updating policy, due {}\", e.getMessage());\n-            throw e;\n-        }\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n     }\n \n-    private void getObjectTags(String objectName, String bucketName, Message message) {\n-        try {\n-            ObjectStat stat = minioClient.statObject(\n-                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n-\n-            // set all stat as message headers\n-            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n-            message.setHeader(MinioConstants.E_TAG, stat.etag());\n-            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n-\n-        } catch (Exception e) {\n-            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n+    private void getObjectTags(String objectName, String bucketName, Message message) throws Exception {\n+\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n         }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+\n+        // set all stat as message headers\n+        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.E_TAG, stat.etag());\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..fa911a0dac1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -274,13 +276,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n         message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n         message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n         message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n         message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n         message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n         message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -62,7 +66,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     @UriPath(description = \"Bucket name\")\n     @Metadata(required = true)\n-    private String bucketName; // to support component docs\n+    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n     @UriParam(label = \"consumer\", defaultValue = \"10\")\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -55,24 +53,16 @@ import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n /**\n  * Store and retrieve objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:bucketName\",\n         category = {Category.CLOUD, Category.FILE})\n-\n public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n \n     private MinioClient minioClient;\n \n-    @UriPath(description = \"Bucket name\")\n-    @Metadata(required = true)\n-    private String bucketName;\n     @UriParam\n     private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n \n     public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "committedDate": "2020-09-10 11:33:02 +0200", "message": "Camel-Minio: Lets simplify the client instantiation"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "fceb5aeac41ffc5a6fb64b2ce177628b5d85c621", "committedDate": "2020-12-04 08:32:34 +0100", "message": "CAMEL-15880 - Regen docs and fixed CS"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "committedDate": "2022-02-15 21:51:03 +0100", "message": "Remove unused code"}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NTYwOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463695609", "body": "Looks like it could be simplified:\r\n```\r\nReader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));\r\n```", "bodyText": "Looks like it could be simplified:\nReader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));", "bodyHTML": "<p dir=\"auto\">Looks like it could be simplified:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));\n\"><pre><code>Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));\n</code></pre></div>", "author": "DenisIstomin", "createdAt": "2020-07-31T15:59:40Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -215,7 +214,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n                 textBuilder.append((char) c);\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0f75734b972..9ad67ad3573 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -214,7 +215,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n                 textBuilder.append((char) c);\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..c28617d57ae 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -215,7 +218,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n                 textBuilder.append((char) c);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c28617d57ae..ee167dbbeab 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,282 +16,72 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n \n-import io.minio.BucketExistsArgs;\n-import io.minio.MakeBucketArgs;\n-import io.minio.MinioClient;\n-import io.minio.ObjectStat;\n-import io.minio.SetBucketPolicyArgs;\n-import io.minio.StatObjectArgs;\n-import io.minio.errors.InvalidBucketNameException;\n-import org.apache.camel.Category;\n-import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.Message;\n import org.apache.camel.Processor;\n import org.apache.camel.Producer;\n-import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n-import org.apache.camel.support.ScheduledPollEndpoint;\n-import org.apache.camel.support.SynchronizationAdapter;\n-import org.apache.camel.util.IOHelper;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.camel.support.DefaultEndpoint;\n \n /**\n- * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ * Minio component which does bla bla.\n+ * <p>\n+ * TODO: Update one line description above what the component does.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n-        category = {Category.CLOUD, Category.FILE})\n-\n-public class MinioEndpoint extends ScheduledPollEndpoint {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n-\n-    private MinioClient minioClient;\n-\n-    @UriPath(description = \"Bucket name\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:name\",\n+        consumerClass = MinioConsumer.class, label = \"custom\")\n+public class MinioEndpoint extends DefaultEndpoint {\n+    @UriPath\n     @Metadata(required = true)\n-    private String bucketName;\n-    @UriParam\n-    private MinioConfiguration configuration;\n-    @UriParam(label = \"consumer\", defaultValue = \"10\")\n-    private int maxMessagesPerPoll = 10;\n-    @UriParam(label = \"consumer\", defaultValue = \"60\")\n-    private int maxConnections = 50 + maxMessagesPerPoll;\n+    private String name;\n+    @UriParam(defaultValue = \"10\")\n+    private int option = 10;\n \n-    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n-        super(uri, component);\n-        this.configuration = configuration;\n+    public MinioEndpoint() {\n     }\n \n-    @Override\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n-        configureConsumer(minioConsumer);\n-        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n-        return minioConsumer;\n+    public MinioEndpoint(String uri, MinioComponent component) {\n+        super(uri, component);\n     }\n \n-    @Override\n-    public Producer createProducer() {\n+    public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    @Override\n-    public void doStart() throws Exception {\n-        super.doStart();\n-\n-        minioClient = getConfiguration().getMinioClient() != null\n-                ? getConfiguration().getMinioClient()\n-                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n-\n-        String objectName = getConfiguration().getObjectName();\n-\n-        if (objectName != null) {\n-            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n-            return;\n-        }\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n-\n-        if (bucketExists(bucketName)) {\n-            LOG.trace(\"Bucket {} already exists\", bucketName);\n-        } else {\n-            if (!getConfiguration().isAutoCreateBucket()) {\n-                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n-            } else {\n-                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n-                makeBucket(bucketName);\n-                LOG.trace(\"Bucket created\");\n-            }\n-        }\n-\n-        if (getConfiguration().getPolicy() != null) {\n-            setBucketPolicy(bucketName);\n-        }\n-    }\n-\n-    @Override\n-    public void doStop() throws Exception {\n-        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n-            if (minioClient != null) {\n-                minioClient = null;\n-            }\n-        }\n-        super.doStop();\n-    }\n-\n-    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n-        return createExchange(getExchangePattern(), minioObject, objectName);\n-    }\n-\n-    public Exchange createExchange(ExchangePattern pattern,\n-                                   InputStream minioObject, String objectName) throws Exception {\n-        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n-\n-        Exchange exchange = super.createExchange(pattern);\n-        Message message = exchange.getIn();\n-        LOG.trace(\"Got object!\");\n-\n-        getObjectStat(objectName, message);\n-\n-        if (getConfiguration().isIncludeBody()) {\n-            try {\n-                message.setBody(readInputStream(minioObject));\n-                if (getConfiguration().isAutocloseBody()) {\n-                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n-                        @Override\n-                        public void onDone(Exchange exchange) {\n-                            IOHelper.close(minioObject);\n-                        }\n-                    });\n-                }\n-\n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                LOG.warn(\"Error setting message body\");\n-            }\n-        } else {\n-            message.setBody(null);\n-            IOHelper.close(minioObject);\n-        }\n-\n-        return exchange;\n-    }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        Consumer consumer = new MinioConsumer(this, processor);\n+        configureConsumer(consumer);\n+        return consumer;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n+    public String getName() {\n+        return name;\n     }\n \n     /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    public void setName(String name) {\n+        this.name = name;\n     }\n \n-    public int getMaxConnections() {\n-        return maxConnections;\n+    public int getOption() {\n+        return option;\n     }\n \n     /**\n-     * Set the maxConnections parameter in the minio client configuration\n+     * Some description of this option, and what it does\n      */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n-    }\n-\n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n-    private boolean bucketExists(String bucketName) throws Exception {\n-        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    public void setOption(int option) {\n+        this.option = option;\n     }\n \n-    private void makeBucket(String bucketName) throws Exception {\n-        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n-        if (getConfiguration().getRegion() != null) {\n-            makeBucketRequest.region(getConfiguration().getRegion());\n-        }\n-        minioClient.makeBucket(makeBucketRequest.build());\n-    }\n-\n-    private void setBucketPolicy(String bucketName) throws Exception {\n-        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-        minioClient.setBucketPolicy(\n-                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n-        LOG.trace(\"Bucket policy updated\");\n-    }\n-\n-    private void getObjectStat(String objectName, Message message) throws Exception {\n-\n-        String bucketName = getConfiguration().getBucketName();\n-        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n-\n-        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n-            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n-        }\n-        if (getConfiguration().getOffset() > 0) {\n-            statObjectRequest.offset(getConfiguration().getOffset());\n-        }\n-        if (getConfiguration().getLength() > 0) {\n-            statObjectRequest.length(getConfiguration().getLength());\n-        }\n-        if (getConfiguration().getVersionId() != null) {\n-            statObjectRequest.versionId(getConfiguration().getVersionId());\n-        }\n-        if (getConfiguration().getMatchETag() != null) {\n-            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n-        }\n-        if (getConfiguration().getNotMatchETag() != null) {\n-            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n-        }\n-        if (getConfiguration().getModifiedSince() != null) {\n-            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n-        }\n-        if (getConfiguration().getUnModifiedSince() != null) {\n-            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n-        }\n-\n-        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n-\n-        // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n-        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n-        message.setHeader(MinioConstants.E_TAG, stat.etag());\n-        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n-        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n-        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n-        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+    public ExecutorService createExecutor() {\n+        // TODO: Delete me when you implementy your custom component\n+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n     }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex ee167dbbeab..0edc380c6eb 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -69,19 +76,19 @@ public class MinioEndpoint extends DefaultEndpoint {\n         this.name = name;\n     }\n \n-    public int getOption() {\n-        return option;\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n     }\n \n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinioConsumer\");\n+    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+                this.configuration.getSecretKey());\n+        return minioClient;\n+\n     }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 0edc380c6eb..64b18d08cdc 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -84,8 +85,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.configuration = configuration;\n     }\n \n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io:9000\", this.configuration.getAccessKey(),\n+        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n                 this.configuration.getSecretKey());\n         return minioClient;\n \n", "next_change": {"commit": "843335696c2da037e026ad7cc0318cf36494b183", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 64b18d08cdc..823af3025a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -16,88 +16,244 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n import io.minio.MinioClient;\n-import io.minio.errors.InvalidEndpointException;\n-import io.minio.errors.InvalidPortException;\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n+import io.minio.Result;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.UriEndpoint;\n import org.apache.camel.spi.UriParam;\n import org.apache.camel.spi.UriPath;\n import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * Represents a Minio endpoint.\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.\n  */\n-@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio\", syntax = \"minio:url\", consumerClass = MinioConsumer.class, label = \"storage,cloud,file\")\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio:url\", category = {Category.CLOUD, Category.FILE})\n public class MinioEndpoint extends ScheduledPollEndpoint {\n-    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(MinioEndpoint.class);\n \n-    @UriPath\n-    @Metadata(required = true)\n-    private String name;\n-    @UriPath(description = \"Bucket name or ARN\")\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Qualified url\")\n     @Metadata(required = true)\n-    private String bucketNameOrArn;\n+    private String url; // to support component docs\n     @UriParam\n     private MinioConfiguration configuration;\n-    private MinioClient minioClient;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n \n-    public MinioEndpoint() {\n-    }\n-\n-    public MinioEndpoint(final String uri, final MinioComponent component,\n-                         final MinioConfiguration configuration) {\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n         super(uri, component);\n         this.configuration = configuration;\n     }\n \n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n     public Producer createProducer() throws Exception {\n         return new MinioProducer(this);\n     }\n \n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        return new MinioConsumer(this, processor);\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = configuration.getMinioClient() != null\n+                ? configuration.getMinioClient()\n+                : MinioClientFactory.getMinioClient(configuration).getMinioClient();\n+\n+        String fileName = getConfiguration().getFileName();\n+\n+        if (fileName != null) {\n+            LOG.trace(\"File name [{}] requested, so skipping bucket check...\", fileName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket [{}] already exists...\", bucketName);\n+\n+        String prefix = getConfiguration().getPrefix();\n+\n+        try {\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,\n+                    getConfiguration().getPrefix(),\n+                    getConfiguration().isRecursive(),\n+                    getConfiguration().isUseVersion1()\n+            );\n+            LOG.trace(\"Bucket [{}] already exists\", bucketName);\n+            return;\n+        } catch (AwsServiceException ase) {\n+            /* 404 means the bucket doesn't exist */\n+            if (ase.awsErrorDetails().errorCode().equalsIgnoreCase(\"404\")) {\n+                throw ase;\n+            }\n+        }\n+\n+        LOG.trace(\"Bucket [{}] doesn't exist yet\", bucketName);\n+\n+        if (getConfiguration().isAutoCreateBucket()) {\n+            // creates the new bucket because it doesn't exist yet\n+            CreateBucketRequest createBucketRequest = CreateBucketRequest.builder().bucket(getConfiguration().getBucketName()).build();\n+\n+            LOG.trace(\"Creating bucket [{}] in region [{}] with request [{}]...\", configuration.getBucketName(), configuration.getRegion(), createBucketRequest);\n+\n+            minioClient.createBucket(createBucketRequest);\n+\n+            LOG.trace(\"Bucket created\");\n+        }\n+\n+        if (configuration.getPolicy() != null) {\n+            LOG.trace(\"Updating bucket [{}] with policy [{}]\", bucketName, configuration.getPolicy());\n+\n+            minioClient.putBucketPolicy(PutBucketPolicyRequest.builder().bucket(bucketName).policy(configuration.getPolicy()).build());\n+\n+            LOG.trace(\"Bucket policy updated\");\n+        }\n     }\n \n-    public boolean isSingleton() {\n-        return true;\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {\n+            if (s3Client != null) {\n+                s3Client.close();\n+            }\n+        }\n+        super.doStop();\n     }\n \n-    public String getName() {\n-        return name;\n+    public Exchange createExchange(ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        return createExchange(getExchangePattern(), s3Object, key);\n     }\n \n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n+    public Exchange createExchange(ExchangePattern pattern, ResponseInputStream<GetObjectResponse> s3Object, String key) {\n+        LOG.trace(\"Getting object with key [{}] from bucket [{}]...\", key, getConfiguration().getBucketName());\n+\n+        LOG.trace(\"Got object [{}]\", s3Object);\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+\n+        if (configuration.isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(s3Object));\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+        }\n+\n+        message.setHeader(AWS2S3Constants.KEY, key);\n+        message.setHeader(AWS2S3Constants.BUCKET_NAME, getConfiguration().getBucketName());\n+        message.setHeader(AWS2S3Constants.E_TAG, s3Object.response().eTag());\n+        message.setHeader(AWS2S3Constants.LAST_MODIFIED, s3Object.response().lastModified());\n+        message.setHeader(AWS2S3Constants.VERSION_ID, s3Object.response().versionId());\n+        message.setHeader(AWS2S3Constants.CONTENT_TYPE, s3Object.response().contentType());\n+        message.setHeader(AWS2S3Constants.CONTENT_LENGTH, s3Object.response().contentLength());\n+        message.setHeader(AWS2S3Constants.CONTENT_ENCODING, s3Object.response().contentEncoding());\n+        message.setHeader(AWS2S3Constants.CONTENT_DISPOSITION, s3Object.response().contentDisposition());\n+        message.setHeader(AWS2S3Constants.CACHE_CONTROL, s3Object.response().cacheControl());\n+        message.setHeader(AWS2S3Constants.SERVER_SIDE_ENCRYPTION, s3Object.response().serverSideEncryption());\n+        message.setHeader(AWS2S3Constants.EXPIRATION_TIME, s3Object.response().expiration());\n+        message.setHeader(AWS2S3Constants.REPLICATION_STATUS, s3Object.response().replicationStatus());\n+        message.setHeader(AWS2S3Constants.STORAGE_CLASS, s3Object.response().storageClass());\n+\n+        /**\n+         * If includeBody != true, it is safe to close the object here. If\n+         * includeBody == true, the caller is responsible for closing the stream\n+         * and object once the body has been fully consumed. As of 2.17, the\n+         * consumer does not close the stream or object on commit.\n+         */\n+        if (!configuration.isIncludeBody()) {\n+            IOHelper.close(s3Object);\n+        } else {\n+            if (configuration.isAutocloseBody()) {\n+                exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                    @Override\n+                    public void onDone(Exchange exchange) {\n+                        IOHelper.close(s3Object);\n+                    }\n+                });\n+            }\n+        }\n+\n+        return exchange;\n     }\n \n-    public MinioConfiguration getConfiguration() {\n+    public AWS2S3Configuration getConfiguration() {\n         return configuration;\n     }\n \n-    public void setConfiguration(MinioConfiguration configuration) {\n+    public void setConfiguration(AWS2S3Configuration configuration) {\n         this.configuration = configuration;\n     }\n \n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n+    public void setS3Client(S3Client s3Client) {\n+        this.s3Client = s3Client;\n+    }\n+\n+    public S3Client getS3Client() {\n+        return s3Client;\n     }\n \n-    public MinioClient getMinioClient() {\n-        return minioClient;\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n     }\n \n-    private MinioClient createClient() throws InvalidPortException, InvalidEndpointException {\n-        final MinioClient minioClient = new MinioClient(\"https://play.minio.io/minio\", this.configuration.getAccessKey(),\n-                this.configuration.getSecretKey());\n-        return minioClient;\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n \n+    public int getMaxConnections() {\n+        return maxConnections;\n     }\n \n+    /**\n+     * Set the maxConnections parameter in the S3 client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(ResponseInputStream<GetObjectResponse> s3Object) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(s3Object, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c = 0;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 823af3025a0..fbc5e921a19 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -256,4 +243,18 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n         return textBuilder.toString();\n     }\n+\n+    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n+        try {\n+            return minioClient.bucketExists(bucketName);\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n+        if (getConfiguration().)\n+    }\n }\n", "next_change": {"commit": "152fd8b381686621d3de6a6300323fe89f42720b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex fbc5e921a19..c827cc9fab1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -254,7 +267,24 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) {\n-        if (getConfiguration().)\n+    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+        try {\n+            if (region != null) {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .region(region)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            } else {\n+                minioClient.makeBucket(MakeBucketArgs.builder()\n+                        .bucket(bucketName)\n+                        .objectLock(isObjectLock)\n+                        .build());\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n+            throw e;\n+        }\n     }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..1010a4c0cc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -267,24 +234,52 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private void makeBucket(String bucketName, String region, boolean isObjectLock) throws Exception {\n+    private void makeBucket(String bucketName) throws Exception {\n         try {\n-            if (region != null) {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .region(region)\n-                        .objectLock(isObjectLock)\n-                        .build());\n-            } else {\n-                minioClient.makeBucket(MakeBucketArgs.builder()\n-                        .bucket(bucketName)\n-                        .objectLock(isObjectLock)\n-                        .build());\n+            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n+            if (configuration.getRegion() != null) {\n+                makeBucketRequest.region(configuration.getRegion());\n             }\n+            minioClient.makeBucket(makeBucketRequest.build());\n \n         } catch (Throwable e) {\n             LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n             throw e;\n         }\n     }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        try {\n+            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+            minioClient.setBucketPolicy(\n+                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n+            LOG.trace(\"Bucket policy updated\");\n+        } catch (Throwable e) {\n+            Log.warn(\"Error updating policy, due {}\", e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    private void getObjectTags(String objectName, String bucketName, Message message) {\n+        try {\n+            ObjectStat stat = minioClient.statObject(\n+                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n+\n+            // set all stat as message headers\n+            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+            message.setHeader(MinioConstants.E_TAG, stat.etag());\n+            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n+\n+        } catch (Exception e) {\n+            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+        }\n+    }\n }\n", "next_change": {"commit": "f4aea6f0902b2108a296a183973813785969618b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 1010a4c0cc6..88e9c117e23 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -279,7 +278,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n             message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n \n         } catch (Exception e) {\n-            Log.warn(\"Error getting message headers, due {}\", e.getMessage());\n+            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n         }\n     }\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 88e9c117e23..b3a1b207800 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -223,62 +223,67 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         return textBuilder.toString();\n     }\n \n-    private boolean bucketExists(MinioClient minioClient, String bucketName) throws Exception {\n-        try {\n-            return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error checking bucket, due: {}\", e.getMessage());\n-            throw e;\n-        }\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n \n     private void makeBucket(String bucketName) throws Exception {\n-        try {\n-            MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(configuration.isObjectLock());\n-            if (configuration.getRegion() != null) {\n-                makeBucketRequest.region(configuration.getRegion());\n-            }\n-            minioClient.makeBucket(makeBucketRequest.build());\n-\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error making bucket, due: {}\", e.getMessage());\n-            throw e;\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n         }\n+        minioClient.makeBucket(makeBucketRequest.build());\n     }\n \n     private void setBucketPolicy(String bucketName) throws Exception {\n-        try {\n-            LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n-            minioClient.setBucketPolicy(\n-                    SetBucketPolicyArgs.builder().bucket(bucketName).config(configuration.getPolicy()).build());\n-            LOG.trace(\"Bucket policy updated\");\n-        } catch (Throwable e) {\n-            LOG.warn(\"Error updating policy, due {}\", e.getMessage());\n-            throw e;\n-        }\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n     }\n \n-    private void getObjectTags(String objectName, String bucketName, Message message) {\n-        try {\n-            ObjectStat stat = minioClient.statObject(\n-                    StatObjectArgs.builder().bucket(bucketName).object(objectName).build());\n-\n-            // set all stat as message headers\n-            message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-            message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n-            message.setHeader(MinioConstants.E_TAG, stat.etag());\n-            message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n-            message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n-            message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n-            message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n-            message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n-            message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n-            message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n-            message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n-\n-        } catch (Exception e) {\n-            LOG.warn(\"Error getting message headers, due {}\", e.getMessage());\n+    private void getObjectTags(String objectName, String bucketName, Message message) throws Exception {\n+\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            statObjectRequest.offset(getConfiguration().getOffset());\n         }\n+        if (getConfiguration().getLength() != 0) {\n+            statObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            statObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            statObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            statObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            statObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            statObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n+\n+        // set all stat as message headers\n+        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n+        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.E_TAG, stat.etag());\n+        message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n+        message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n+        message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n+        message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n+        message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n+        message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n+        message.setHeader(MinioConstants.STORAGE_CLASS, stat.httpHeaders().get(\"x-amz-storage-class\"));\n     }\n }\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex b3a1b207800..fa911a0dac1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -274,13 +276,16 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         ObjectStat stat = minioClient.statObject(statObjectRequest.build());\n \n         // set all stat as message headers\n-        message.setHeader(MinioConstants.OBJECT_NAME, objectName);\n-        message.setHeader(MinioConstants.BUCKET_NAME, bucketName);\n+        message.setHeader(MinioConstants.OBJECT_NAME, stat.name());\n+        message.setHeader(MinioConstants.BUCKET_NAME, stat.bucketName());\n         message.setHeader(MinioConstants.E_TAG, stat.etag());\n         message.setHeader(MinioConstants.LAST_MODIFIED, stat.httpHeaders().get(\"last-modified\"));\n         message.setHeader(MinioConstants.VERSION_ID, stat.httpHeaders().get(\"x-amz-version-id\"));\n         message.setHeader(MinioConstants.CONTENT_TYPE, stat.contentType());\n         message.setHeader(MinioConstants.CONTENT_LENGTH, stat.length());\n+        message.setHeader(MinioConstants.CONTENT_ENCODING, stat.httpHeaders().get(\"content-encoding\"));\n+        message.setHeader(MinioConstants.CONTENT_DISPOSITION, stat.httpHeaders().get(\"content-disposition\"));\n+        message.setHeader(MinioConstants.CACHE_CONTROL, stat.httpHeaders().get(\"cache-control\"));\n         message.setHeader(MinioConstants.SERVER_SIDE_ENCRYPTION, stat.httpHeaders().get(\"x-amz-server-side-encryption\"));\n         message.setHeader(MinioConstants.EXPIRATION_TIME, stat.httpHeaders().get(\"x-amz-expiration\"));\n         message.setHeader(MinioConstants.REPLICATION_STATUS, stat.httpHeaders().get(\"x-amz-replication-status\"));\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..e61a78595e8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -215,7 +217,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n \n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n                 textBuilder.append((char) c);\n", "next_change": {"commit": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex e61a78595e8..c03dbc18109 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -189,32 +173,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.minioClient = minioClient;\n     }\n \n-    public int getMaxMessagesPerPoll() {\n-        return maxMessagesPerPoll;\n-    }\n-\n-    /**\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * <p/>\n-     * Gets the maximum number of messages as a limit to poll at each polling.\n-     * The default value is 10. Use 0 or a negative number to set it as\n-     * unlimited.\n-     */\n-    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n-        this.maxMessagesPerPoll = maxMessagesPerPoll;\n-    }\n-\n-    public int getMaxConnections() {\n-        return maxConnections;\n-    }\n-\n-    /**\n-     * Set the maxConnections parameter in the minio client configuration\n-     */\n-    public void setMaxConnections(int maxConnections) {\n-        this.maxConnections = maxConnections;\n-    }\n-\n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n", "next_change": {"commit": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c03dbc18109..5a3a10be9d1 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -173,6 +171,32 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         this.minioClient = minioClient;\n     }\n \n+    MinioClient createMinioClient() {\n+        if (isNotEmpty(configuration.getEndpoint())) {\n+            MinioClient.Builder minioClientRequest = MinioClient.builder();\n+\n+            if (isNotEmpty(configuration.getProxyPort())) {\n+                minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(),\n+                        configuration.isSecure());\n+            } else {\n+                minioClientRequest.endpoint(configuration.getEndpoint());\n+            }\n+            if (isNotEmpty(configuration.getAccessKey()) && isNotEmpty(configuration.getSecretKey())) {\n+                minioClientRequest.credentials(configuration.getAccessKey(), configuration.getSecretKey());\n+            }\n+            if (isNotEmpty(configuration.getRegion())) {\n+                minioClientRequest.region(configuration.getRegion());\n+            }\n+            if (isNotEmpty(configuration.getCustomHttpClient())) {\n+                minioClientRequest.httpClient(configuration.getCustomHttpClient());\n+            }\n+            return minioClientRequest.build();\n+\n+        } else {\n+            throw new IllegalArgumentException(\"Endpoint must be specified\");\n+        }\n+    }\n+\n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n", "next_change": {"commit": "22c7af563c067fc34c141da3de1338d7e37c3525", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 5a3a10be9d1..bb67186fdc6 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -197,7 +160,7 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    private String readInputStream(InputStream minioObject) throws IOException {\n+    String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n             int c;\n", "next_change": {"commit": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex bb67186fdc6..3c01e8b922a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n", "chunk": "@@ -160,17 +153,6 @@ public class MinioEndpoint extends ScheduledPollEndpoint {\n         }\n     }\n \n-    String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-\n     private boolean bucketExists(String bucketName) throws Exception {\n         return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n     }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "3f79d182373ca079c32d722aa6e3aeb00f79e736", "committedDate": "2020-08-18 14:27:38 +0200", "message": "Remove redundant checks in camel-minio"}, {"oid": "fcef39d2233506badff9139dff0c6614bb5f9c1e", "committedDate": "2020-09-10 11:33:02 +0200", "message": "Camel-Minio: Lets simplify the client instantiation"}, {"oid": "2fd3c843d453ad8417a3b4d5e03d8a0d3330f4e0", "committedDate": "2020-12-04 08:30:29 +0100", "message": "CAMEL-15880 - Camel-Minio: Upgrade to Minio 8.x"}, {"oid": "fceb5aeac41ffc5a6fb64b2ce177628b5d85c621", "committedDate": "2020-12-04 08:32:34 +0100", "message": "CAMEL-15880 - Regen docs and fixed CS"}, {"oid": "22c7af563c067fc34c141da3de1338d7e37c3525", "committedDate": "2021-02-25 07:20:17 +0100", "message": "CAMEL-16222: camel-core - ExchangeFactory SPI to allow to use exchange pooling (#5122)"}, {"oid": "f47423f5d5e4bd77a07d346bfcae3b12a1c4a9bc", "committedDate": "2022-02-15 21:51:03 +0100", "message": "Remove unused code"}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5OTg5Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463699896", "body": "Please avoid `star import` usage.", "bodyText": "Please avoid star import usage.", "bodyHTML": "<p dir=\"auto\">Please avoid <code>star import</code> usage.</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T16:08:36Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.Message;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex d449212a70a..3191fd6c874 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,7 +28,10 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 3191fd6c874..d449212a70a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,10 +28,7 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n+import static org.junit.jupiter.api.Assertions.*;\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex d449212a70a..3191fd6c874 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,7 +28,10 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\ndeleted file mode 100644\nindex 3191fd6c874..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,115 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio.integration;\n-\n-import org.apache.camel.EndpointInject;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ExchangePattern;\n-import org.apache.camel.Message;\n-import org.apache.camel.ProducerTemplate;\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.minio.MinioConstants;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioComponentIntegrationTest extends CamelTestSupport {\n-\n-    @EndpointInject(\"direct:start\")\n-    private ProducerTemplate template;\n-\n-    @EndpointInject(\"mock:result\")\n-    private MockEndpoint result;\n-\n-    @Test\n-    public void sendInOnly() throws Exception {\n-        result.expectedMessageCount(2);\n-\n-        Exchange exchange1 = template.send(\"direct:start\", ExchangePattern.InOnly, exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"CamelUnitTest\");\n-            exchange.getIn().setBody(\"This is my bucket content.\");\n-        });\n-\n-        Exchange exchange2 = template.send(\"direct:start\", ExchangePattern.InOnly, exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"CamelUnitTest\");\n-            exchange.getIn().setBody(\"This is my bucket content.\");\n-        });\n-\n-        assertMockEndpointsSatisfied();\n-\n-        assertResultExchange(result.getExchanges().get(0));\n-        assertResultExchange(result.getExchanges().get(1));\n-\n-        assertResponseMessage(exchange1.getIn());\n-        assertResponseMessage(exchange2.getIn());\n-    }\n-\n-    @Test\n-    public void sendInOut() throws Exception {\n-        result.expectedMessageCount(1);\n-\n-        Exchange exchange = template.send(\"direct:start\", ExchangePattern.InOut, exchange1 -> {\n-            exchange1.getIn().setHeader(MinioConstants.OBJECT_NAME, \"CamelUnitTest\");\n-            exchange1.getIn().setBody(\"This is my bucket content.\");\n-        });\n-\n-        assertMockEndpointsSatisfied();\n-\n-        assertResultExchange(result.getExchanges().get(0));\n-\n-        assertResponseMessage(exchange.getMessage());\n-    }\n-\n-    private void assertResultExchange(Exchange resultExchange) {\n-        assertEquals(\"This is my bucket content.\", resultExchange.getIn().getBody(String.class));\n-        assertTrue(resultExchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class).startsWith(\"CamelUnitTest\"));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.BUCKET_NAME));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.VERSION_ID)); // not enabled on this bucket\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.LAST_MODIFIED));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_TYPE));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_MD5));\n-        assertNull(resultExchange.getIn().getHeader(MinioConstants.CACHE_CONTROL));\n-    }\n-\n-    private void assertResponseMessage(Message message) {\n-        assertNull(message.getHeader(MinioConstants.VERSION_ID));\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() {\n-        return new RouteBuilder() {\n-            @Override\n-            public void configure() {\n-                String minioEndpointUri =\n-                        \"minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=RAW(zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG)&region=us-west-1&autoCreateBucket=false&endpoint=https://play.min.io\";\n-\n-                from(\"direct:start\").to(minioEndpointUri).to(\"mock:result\");\n-\n-            }\n-        };\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nnew file mode 100644\nindex 00000000000..0569d7cac47\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.Message;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioComponentIntegrationTest extends CamelTestSupport {\n+\n+    @EndpointInject(\"direct:start\")\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendInOnly() throws Exception {\n+        result.expectedMessageCount(2);\n+\n+        Exchange exchange1 = template.send(\"direct:start\", ExchangePattern.InOnly, exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"CamelUnitTest1\");\n+            exchange.getIn().setBody(\"This is my bucket content.\");\n+        });\n+\n+        Exchange exchange2 = template.send(\"direct:start\", ExchangePattern.InOnly, exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"CamelUnitTest2\");\n+            exchange.getIn().setBody(\"This is my bucket content.\");\n+        });\n+\n+        assertMockEndpointsSatisfied();\n+\n+        assertResultExchange(result.getExchanges().get(0));\n+        assertResultExchange(result.getExchanges().get(1));\n+\n+        assertResponseMessage(exchange1.getIn());\n+        assertResponseMessage(exchange2.getIn());\n+    }\n+\n+    @Test\n+    public void sendInOut() throws Exception {\n+        result.expectedMessageCount(1);\n+\n+        Exchange exchange = template.send(\"direct:start\", ExchangePattern.InOut, exchange1 -> {\n+            exchange1.getIn().setHeader(MinioConstants.OBJECT_NAME, \"CamelUnitTest\");\n+            exchange1.getIn().setBody(\"This is my bucket content.\");\n+        });\n+\n+        assertMockEndpointsSatisfied();\n+\n+        assertResultExchange(result.getExchanges().get(0));\n+\n+        assertResponseMessage(exchange.getMessage());\n+    }\n+\n+    private void assertResultExchange(Exchange resultExchange) {\n+        assertEquals(\"This is my bucket content.\", resultExchange.getIn().getBody(String.class));\n+        assertEquals(\"mycamelbucket\", resultExchange.getIn().getHeader(MinioConstants.BUCKET_NAME));\n+        assertTrue(resultExchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class).startsWith(\"CamelUnitTest\"));\n+        assertNull(resultExchange.getIn().getHeader(MinioConstants.VERSION_ID)); // not\n+        // enabled\n+        // on\n+        // this\n+        // bucket\n+        assertNotNull(resultExchange.getIn().getHeader(MinioConstants.LAST_MODIFIED));\n+        assertEquals(\"application/octet-stream\", resultExchange.getIn().getHeader(MinioConstants.CONTENT_TYPE));\n+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING));\n+        assertEquals(26L, resultExchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH));\n+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION));\n+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_MD5));\n+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CACHE_CONTROL));\n+    }\n+\n+    private void assertResponseMessage(Message message) {\n+        assertNull(message.getHeader(MinioConstants.VERSION_ID));\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() throws Exception {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpointUri = \"minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&region=us-west-1&autoCreateBucket=false\";\n+\n+                from(\"direct:start\").to(minioEndpointUri);\n+\n+                from(minioEndpointUri).to(\"mock:result\");\n+            }\n+        };\n+    }\n+}\n", "next_change": {"commit": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 0569d7cac47..6617f6ac74a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -101,15 +97,15 @@ public class MinioComponentIntegrationTest extends CamelTestSupport {\n     }\n \n     @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n+    protected RouteBuilder createRouteBuilder() {\n         return new RouteBuilder() {\n             @Override\n             public void configure() {\n-                String minioEndpointUri = \"minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&region=us-west-1&autoCreateBucket=false\";\n+                String minioEndpointUri =\n+                        \"minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=RAW(zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG)&region=us-west-1&autoCreateBucket=true&endpoint=https://play.min.io\";\n \n-                from(\"direct:start\").to(minioEndpointUri);\n+                from(\"direct:start\").to(minioEndpointUri).to(\"mock:result\");\n \n-                from(minioEndpointUri).to(\"mock:result\");\n             }\n         };\n     }\n", "next_change": {"commit": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 6617f6ac74a..d449212a70a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -102,7 +102,7 @@ public class MinioComponentIntegrationTest extends CamelTestSupport {\n             @Override\n             public void configure() {\n                 String minioEndpointUri =\n-                        \"minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=RAW(zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG)&region=us-west-1&autoCreateBucket=true&endpoint=https://play.min.io\";\n+                        \"minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=RAW(zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG)&region=us-west-1&autoCreateBucket=false&endpoint=https://play.min.io\";\n \n                 from(\"direct:start\").to(minioEndpointUri).to(\"mock:result\");\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex d449212a70a..3191fd6c874 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,7 +28,10 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n", "next_change": {"commit": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 3191fd6c874..4ae951b2e15 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -29,6 +29,7 @@ import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex 4ae951b2e15..86ddc683415 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n", "chunk": "@@ -28,12 +28,11 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-\n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n \n", "next_change": {"commit": "c40364a59815239e63d959faa982cb5212a217a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/localTests/MinioComponentIntegrationTest.java\nsimilarity index 86%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/localTests/MinioComponentIntegrationTest.java\nindex 86ddc683415..88da95ca254 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/localTests/MinioComponentIntegrationTest.java\n", "chunk": "@@ -33,8 +31,7 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioComponentIntegrationTest extends CamelTestSupport {\n+class MinioComponentIntegrationTest extends MinioTestContainerSupport {\n \n     @EndpointInject(\"direct:start\")\n     private ProducerTemplate template;\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "committedDate": "2020-08-10 20:52:18 +0200", "message": "Resolved a TODO (#4082)"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "c40364a59815239e63d959faa982cb5212a217a3", "committedDate": "2020-08-27 08:03:20 +0200", "message": "Added testcontainer integration test for Minio (#4101)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700750", "body": "It would be nice to extract all credentials into `.properties` file", "bodyText": "It would be nice to extract all credentials into .properties file", "bodyHTML": "<p dir=\"auto\">It would be nice to extract all credentials into <code>.properties</code> file</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:19Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMjAxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464112015", "bodyText": "Hi @DenisIstomin, How can I do that?", "author": "Nayananga", "createdAt": "2020-08-02T19:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MjE5NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464272194", "bodyText": "An example here", "author": "omarsmak", "createdAt": "2020-08-03T08:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzNzgyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466837828", "bodyText": "@omarsmak, @DenisIstomin I have put minio_key.properties file in test/resources file along with the log4j2.properties file,\nendpoint=https://play.min.io\naccessKey=Q3AM3UQ867SPQQA43P2F\nsecretKey=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\nregion=us-west-1\n\nbut then it throws this error java.lang.Exception: Make sure to supply minio endpoint and credentials as throws in this line. Any suggestions?", "author": "Nayananga", "createdAt": "2020-08-07T06:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MDE4Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466840183", "bodyText": "Hi this problem solved", "author": "Nayananga", "createdAt": "2020-08-07T06:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..4884ebd3455 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -29,12 +31,13 @@ import org.junit.jupiter.api.Test;\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n \n     @BindToRegistry(\"minioClient\")\n     MinioClient client = MinioClient.builder()\n-            .endpoint(\"https://play.min.io\")\n-            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-            .region(\"us-west-1\")\n+            .endpoint(properties.getProperty(\"endpoint\"))\n+            .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n+            .region(properties.getProperty(\"region\"))\n             .build();\n \n     @EndpointInject\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 4884ebd3455..3f653b6a10a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -31,13 +29,12 @@ import org.junit.jupiter.api.Test;\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioConsumerIntegrationTest extends CamelTestSupport {\n-    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n \n     @BindToRegistry(\"minioClient\")\n     MinioClient client = MinioClient.builder()\n-            .endpoint(properties.getProperty(\"endpoint\"))\n-            .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n-            .region(properties.getProperty(\"region\"))\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n             .build();\n \n     @EndpointInject\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\ndeleted file mode 100644\nindex 3f653b6a10a..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,83 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio.integration;\n-\n-import io.minio.MinioClient;\n-import org.apache.camel.BindToRegistry;\n-import org.apache.camel.EndpointInject;\n-import org.apache.camel.ProducerTemplate;\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.minio.MinioConstants;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioConsumerIntegrationTest extends CamelTestSupport {\n-\n-    @BindToRegistry(\"minioClient\")\n-    MinioClient client = MinioClient.builder()\n-            .endpoint(\"https://play.min.io\")\n-            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-            .region(\"us-west-1\")\n-            .build();\n-\n-    @EndpointInject\n-    private ProducerTemplate template;\n-\n-    @EndpointInject(\"mock:result\")\n-    private MockEndpoint result;\n-\n-    @Test\n-    public void sendIn() throws Exception {\n-        result.expectedMessageCount(3);\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n-            exchange.getIn().setBody(\"Test1\");\n-        });\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n-            exchange.getIn().setBody(\"Test2\");\n-        });\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n-            exchange.getIn().setBody(\"Test3\");\n-        });\n-\n-        assertMockEndpointsSatisfied();\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() {\n-        return new RouteBuilder() {\n-            @Override\n-            public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n-\n-                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n-\n-                // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n-\n-            }\n-        };\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nnew file mode 100644\nindex 00000000000..d2490ebad34\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setBody(\"Test\");\n+        });\n+        \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+        \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        Thread.sleep(10000);\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() throws Exception {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                    String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucket=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+\n+            }\n+        };\n+    }\n+}\n", "next_change": {"commit": "08f2029caf83805ec099e160924b48da294350d8", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex d2490ebad34..c7dc145f51f 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -47,35 +47,36 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n     public void sendIn() throws Exception {\n         result.expectedMessageCount(3);\n \n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n-            exchange.getIn().setBody(\"Test\");\n-        });\n-        \n         template.send(\"direct:putObject\", exchange -> {\n             exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n             exchange.getIn().setBody(\"Test1\");\n         });\n-        \n+\n         template.send(\"direct:putObject\", exchange -> {\n             exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n             exchange.getIn().setBody(\"Test2\");\n         });\n \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n         Thread.sleep(10000);\n         assertMockEndpointsSatisfied();\n     }\n \n     @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n+    protected RouteBuilder createRouteBuilder() {\n         return new RouteBuilder() {\n             @Override\n             public void configure() {\n-                    String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n \n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucket=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+                // TODO: Check why this is not working\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n \n             }\n         };\n", "next_change": {"commit": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex c7dc145f51f..3f653b6a10a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -76,7 +75,7 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n \n                 // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n \n             }\n         };\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 4884ebd3455..3f653b6a10a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -46,9 +43,6 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n     @EndpointInject(\"mock:result\")\n     private MockEndpoint result;\n \n-    public MinioConsumerIntegrationTest() throws Exception {\n-    }\n-\n     @Test\n     public void sendIn() throws Exception {\n         result.expectedMessageCount(3);\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\ndeleted file mode 100644\nindex 3f653b6a10a..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,83 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio.integration;\n-\n-import io.minio.MinioClient;\n-import org.apache.camel.BindToRegistry;\n-import org.apache.camel.EndpointInject;\n-import org.apache.camel.ProducerTemplate;\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.minio.MinioConstants;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioConsumerIntegrationTest extends CamelTestSupport {\n-\n-    @BindToRegistry(\"minioClient\")\n-    MinioClient client = MinioClient.builder()\n-            .endpoint(\"https://play.min.io\")\n-            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-            .region(\"us-west-1\")\n-            .build();\n-\n-    @EndpointInject\n-    private ProducerTemplate template;\n-\n-    @EndpointInject(\"mock:result\")\n-    private MockEndpoint result;\n-\n-    @Test\n-    public void sendIn() throws Exception {\n-        result.expectedMessageCount(3);\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n-            exchange.getIn().setBody(\"Test1\");\n-        });\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n-            exchange.getIn().setBody(\"Test2\");\n-        });\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n-            exchange.getIn().setBody(\"Test3\");\n-        });\n-\n-        assertMockEndpointsSatisfied();\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() {\n-        return new RouteBuilder() {\n-            @Override\n-            public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n-\n-                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n-\n-                // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n-\n-            }\n-        };\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nnew file mode 100644\nindex 00000000000..d2490ebad34\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setBody(\"Test\");\n+        });\n+        \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+        \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        Thread.sleep(10000);\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() throws Exception {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                    String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucket=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+\n+            }\n+        };\n+    }\n+}\n", "next_change": {"commit": "08f2029caf83805ec099e160924b48da294350d8", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex d2490ebad34..c7dc145f51f 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -47,35 +47,36 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n     public void sendIn() throws Exception {\n         result.expectedMessageCount(3);\n \n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n-            exchange.getIn().setBody(\"Test\");\n-        });\n-        \n         template.send(\"direct:putObject\", exchange -> {\n             exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n             exchange.getIn().setBody(\"Test1\");\n         });\n-        \n+\n         template.send(\"direct:putObject\", exchange -> {\n             exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n             exchange.getIn().setBody(\"Test2\");\n         });\n \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n         Thread.sleep(10000);\n         assertMockEndpointsSatisfied();\n     }\n \n     @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n+    protected RouteBuilder createRouteBuilder() {\n         return new RouteBuilder() {\n             @Override\n             public void configure() {\n-                    String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n \n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucket=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+                // TODO: Check why this is not working\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n \n             }\n         };\n", "next_change": {"commit": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex c7dc145f51f..3f653b6a10a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -76,7 +75,7 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n \n                 // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n \n             }\n         };\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..4884ebd3455 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -29,12 +31,13 @@ import org.junit.jupiter.api.Test;\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n \n     @BindToRegistry(\"minioClient\")\n     MinioClient client = MinioClient.builder()\n-            .endpoint(\"https://play.min.io\")\n-            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-            .region(\"us-west-1\")\n+            .endpoint(properties.getProperty(\"endpoint\"))\n+            .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n+            .region(properties.getProperty(\"region\"))\n             .build();\n \n     @EndpointInject\n", "next_change": {"commit": "c40364a59815239e63d959faa982cb5212a217a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioConsumerIntegrationTest.java\nsimilarity index 84%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioConsumerIntegrationTest.java\nindex 4884ebd3455..f09ba432466 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -46,11 +45,11 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n     @EndpointInject(\"mock:result\")\n     private MockEndpoint result;\n \n-    public MinioConsumerIntegrationTest() throws Exception {\n+    MinioConsumerIntegrationTest() throws Exception {\n     }\n \n     @Test\n-    public void sendIn() throws Exception {\n+    void sendIn() throws Exception {\n         result.expectedMessageCount(3);\n \n         template.send(\"direct:putObject\", exchange -> {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "committedDate": "2020-08-10 20:52:18 +0200", "message": "Resolved a TODO (#4082)"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "c40364a59815239e63d959faa982cb5212a217a3", "committedDate": "2020-08-27 08:03:20 +0200", "message": "Added testcontainer integration test for Minio (#4101)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDk4Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700982", "body": "Please resolve this TODO", "bodyText": "Please resolve this TODO", "bodyHTML": "<p dir=\"auto\">Please resolve this TODO</p>", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:47Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                // TODO: Check why this is not working", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\ndeleted file mode 100644\nindex 3f653b6a10a..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,83 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio.integration;\n-\n-import io.minio.MinioClient;\n-import org.apache.camel.BindToRegistry;\n-import org.apache.camel.EndpointInject;\n-import org.apache.camel.ProducerTemplate;\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.minio.MinioConstants;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioConsumerIntegrationTest extends CamelTestSupport {\n-\n-    @BindToRegistry(\"minioClient\")\n-    MinioClient client = MinioClient.builder()\n-            .endpoint(\"https://play.min.io\")\n-            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-            .region(\"us-west-1\")\n-            .build();\n-\n-    @EndpointInject\n-    private ProducerTemplate template;\n-\n-    @EndpointInject(\"mock:result\")\n-    private MockEndpoint result;\n-\n-    @Test\n-    public void sendIn() throws Exception {\n-        result.expectedMessageCount(3);\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n-            exchange.getIn().setBody(\"Test1\");\n-        });\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n-            exchange.getIn().setBody(\"Test2\");\n-        });\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n-            exchange.getIn().setBody(\"Test3\");\n-        });\n-\n-        assertMockEndpointsSatisfied();\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() {\n-        return new RouteBuilder() {\n-            @Override\n-            public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n-\n-                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n-\n-                // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n-\n-            }\n-        };\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nnew file mode 100644\nindex 00000000000..d2490ebad34\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setBody(\"Test\");\n+        });\n+        \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+        \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        Thread.sleep(10000);\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() throws Exception {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                    String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucket=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+\n+            }\n+        };\n+    }\n+}\n", "next_change": {"commit": "08f2029caf83805ec099e160924b48da294350d8", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex d2490ebad34..c7dc145f51f 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -47,35 +47,36 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n     public void sendIn() throws Exception {\n         result.expectedMessageCount(3);\n \n-        template.send(\"direct:putObject\", exchange -> {\n-            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n-            exchange.getIn().setBody(\"Test\");\n-        });\n-        \n         template.send(\"direct:putObject\", exchange -> {\n             exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n             exchange.getIn().setBody(\"Test1\");\n         });\n-        \n+\n         template.send(\"direct:putObject\", exchange -> {\n             exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n             exchange.getIn().setBody(\"Test2\");\n         });\n \n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n         Thread.sleep(10000);\n         assertMockEndpointsSatisfied();\n     }\n \n     @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n+    protected RouteBuilder createRouteBuilder() {\n         return new RouteBuilder() {\n             @Override\n             public void configure() {\n-                    String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n \n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucket=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+                // TODO: Check why this is not working\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n \n             }\n         };\n", "next_change": {"commit": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex c7dc145f51f..3f653b6a10a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -76,7 +75,7 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n \n                 // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector\").startupOrder(2).log(\"${body}\");\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n \n             }\n         };\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..3843b62940a 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -72,10 +78,8 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n             public void configure() {\n                 String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n-                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n-\n-                // TODO: Check why this is not working\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).log(\"${body}\");\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint);\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).to(\"mock:result\");\n \n             }\n         };\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3843b62940a..366e26d3993 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n", "chunk": "@@ -79,7 +79,8 @@ public class MinioConsumerIntegrationTest extends CamelTestSupport {\n                 String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n \n                 from(\"direct:putObject\").startupOrder(1).to(minioEndpoint);\n-                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\").startupOrder(2).to(\"mock:result\");\n+                from(\"minio://mycamel?moveAfterRead=true&destinationBucketName=camel-kafka-connector&autoCreateBucket=false\")\n+                        .startupOrder(2).to(\"mock:result\");\n \n             }\n         };\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "e0b070a8f3a745b0b4237cdb87177c4d044bd95e", "committedDate": "2020-08-10 20:52:18 +0200", "message": "Resolved a TODO (#4082)"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "c40364a59815239e63d959faa982cb5212a217a3", "committedDate": "2020-08-27 08:03:20 +0200", "message": "Added testcontainer integration test for Minio (#4101)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3ODgwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463978808", "body": "```suggestion\r\n    private boolean autoCloseBody = true;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean autocloseBody = true;\n          \n          \n            \n                private boolean autoCloseBody = true;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">autocloseBody</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">autoCloseBody</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "dmvolod", "createdAt": "2020-08-01T16:41:18Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam\n+    private String region;\n+\n+    @UriParam\n+    private OkHttpClient customHttpClient;\n+\n+    private String bucketName;\n+    @UriParam(defaultValue = \"true\")\n+    private boolean autoCreateBucket = true;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean objectLock;\n+\n+    @UriParam\n+    private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n+    @UriParam\n+    private ServerSideEncryption serverSideEncryption;\n+\n+    @UriParam\n+    private MinioClient minioClient;\n+\n+    @UriParam(label = \"consumer\")\n+    private String objectName;\n+    @UriParam(label = \"consumer\")\n+    private String delimiter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeUserMetadata;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeVersions;\n+    @UriParam(label = \"consumer\")\n+    private String prefix;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean recursive;\n+    @UriParam(label = \"consumer\")\n+    private String startAfter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean useVersion1;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeFolders;\n+    @UriParam(label = \"consumer\")\n+    private long offset;\n+    @UriParam(label = \"consumer\")\n+    private long length;\n+    @UriParam(label = \"consumer\")\n+    private String matchETag;\n+    @UriParam(label = \"consumer\")\n+    private String notMatchETag;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime modifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime unModifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private String destinationBucketName;\n+    @UriParam(label = \"consumer\")\n+    private String destinationObjectName;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean deleteAfterRead = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean includeBody = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean autocloseBody = true;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..93afa8e2874 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -99,10 +100,12 @@ public class MinioConfiguration implements Cloneable {\n     private boolean deleteAfterRead = true;\n     @UriParam(label = \"consumer\", defaultValue = \"false\")\n     private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean bypassGovernanceMode;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n     private boolean includeBody = true;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autocloseBody = true;\n+    private boolean autoCloseBody = true;\n \n     @UriParam(label = \"producer\")\n     private String keyName;\n", "next_change": {"commit": "9f619c84b46945598c63f1d7ad04cdefa1329d39", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 93afa8e2874..ee18fe1d920 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -111,8 +111,6 @@ public class MinioConfiguration implements Cloneable {\n     private String keyName;\n     @UriParam(label = \"producer\")\n     private boolean deleteAfterWrite;\n-    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n-    private long partSize = 25 * 1024 * 1024;\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex ee18fe1d920..e3e6b94a989 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -105,12 +105,14 @@ public class MinioConfiguration implements Cloneable {\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n     private boolean includeBody = true;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autoCloseBody = true;\n+    private boolean autocloseBody = true;\n \n     @UriParam(label = \"producer\")\n     private String keyName;\n     @UriParam(label = \"producer\")\n     private boolean deleteAfterWrite;\n+    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n+    private long partSize = 25 * 1024 * 1024;\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\ndeleted file mode 100644\nindex e3e6b94a989..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ /dev/null\n", "chunk": "@@ -1,637 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio;\n-\n-import java.time.ZonedDateTime;\n-\n-import io.minio.MinioClient;\n-import io.minio.ServerSideEncryption;\n-import io.minio.ServerSideEncryptionCustomerKey;\n-import okhttp3.OkHttpClient;\n-import org.apache.camel.RuntimeCamelException;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriParams;\n-\n-@UriParams\n-public class MinioConfiguration implements Cloneable {\n-\n-    @UriParam(label = \"common\")\n-    private String endpoint;\n-    @UriParam(label = \"common\")\n-    private Integer proxyPort;\n-    @UriParam(label = \"common\")\n-    private boolean secure;\n-    @UriParam(label = \"common\")\n-    private String region;\n-    @UriParam(label = \"common\")\n-    private OkHttpClient customHttpClient;\n-\n-    @UriParam(label = \"security\", secret = true)\n-    private String accessKey;\n-    @UriParam(label = \"security\", secret = true)\n-    private String secretKey;\n-    @UriParam(label = \"common\", defaultValue = \"false\")\n-\n-    private String bucketName;\n-    @UriParam(label = \"common\", defaultValue = \"true\")\n-    private boolean autoCreateBucket = true;\n-    @UriParam(label = \"common\", defaultValue = \"false\")\n-    private boolean objectLock;\n-    @UriParam(label = \"common\")\n-    private String policy;\n-    @UriParam(label = \"common\")\n-    private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam(label = \"common\")\n-    private ServerSideEncryption serverSideEncryption;\n-    @UriParam(label = \"common\")\n-    private MinioClient minioClient;\n-\n-    @UriParam(label = \"consumer\")\n-    private String objectName;\n-    @UriParam(label = \"consumer\")\n-    private String delimiter;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean includeUserMetadata;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean includeVersions;\n-    @UriParam(label = \"consumer\")\n-    private String prefix;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean recursive;\n-    @UriParam(label = \"consumer\")\n-    private String startAfter;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean useVersion1;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean includeFolders;\n-    @UriParam(label = \"consumer\")\n-    private long offset;\n-    @UriParam(label = \"consumer\")\n-    private long length;\n-    @UriParam(label = \"consumer\")\n-    private String versionId;\n-    @UriParam(label = \"consumer\")\n-    private String matchETag;\n-    @UriParam(label = \"consumer\")\n-    private String notMatchETag;\n-    @UriParam(label = \"consumer\")\n-    private ZonedDateTime modifiedSince;\n-    @UriParam(label = \"consumer\")\n-    private ZonedDateTime unModifiedSince;\n-    @UriParam(label = \"consumer\")\n-    private String destinationBucketName;\n-    @UriParam(label = \"consumer\")\n-    private String destinationObjectName;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean deleteAfterRead = true;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean moveAfterRead;\n-    @UriParam(label = \"consumer\", defaultValue = \"false\")\n-    private boolean bypassGovernanceMode;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean includeBody = true;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autocloseBody = true;\n-\n-    @UriParam(label = \"producer\")\n-    private String keyName;\n-    @UriParam(label = \"producer\")\n-    private boolean deleteAfterWrite;\n-    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n-    private long partSize = 25 * 1024 * 1024;\n-    @UriParam(label = \"producer\")\n-    private String storageClass;\n-    @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n-    private MinioOperations operation;\n-    @UriParam(label = \"producer\", defaultValue = \"false\")\n-    private boolean pojoRequest;\n-\n-    public String getEndpoint() {\n-        return endpoint;\n-    }\n-\n-    /**\n-     * Endpoint can be an URL, domain name, IPv4 address or IPv6 address.\n-     */\n-    public void setEndpoint(String endpoint) {\n-        this.endpoint = endpoint;\n-    }\n-\n-    public Integer getProxyPort() {\n-        return proxyPort;\n-    }\n-\n-    /**\n-     * TCP/IP port number. 80 and 443 are used as defaults for HTTP and HTTPS.\n-     */\n-    public void setProxyPort(Integer proxyPort) {\n-        this.proxyPort = proxyPort;\n-    }\n-\n-    public boolean isSecure() {\n-        return secure;\n-    }\n-\n-    /**\n-     * Flag to indicate to use secure connection to minio service or not.\n-     */\n-    public void setSecure(boolean secure) {\n-        this.secure = secure;\n-    }\n-\n-    public String getRegion() {\n-        return region;\n-    }\n-\n-    /**\n-     * The region in which Minio client needs to work. When using this parameter,\n-     * the configuration will expect the lowercase name of the region (for\n-     * example ap-east-1). You'll need to use the name Region.EU_WEST_1.id()\n-     */\n-    public void setRegion(String region) {\n-        this.region = region;\n-    }\n-\n-    public OkHttpClient getCustomHttpClient() {\n-        return customHttpClient;\n-    }\n-\n-    /**\n-     * Set custom HTTP client for authenticated access.\n-     */\n-    public void setCustomHttpClient(OkHttpClient customHttpClient) {\n-        this.customHttpClient = customHttpClient;\n-    }\n-\n-    public String getAccessKey() {\n-        return accessKey;\n-    }\n-\n-    /**\n-     * Amazon AWS Secret Access Key or Minio Access Key.\n-     * If not set camel will connect to service for anonymous access.\n-     */\n-    public void setAccessKey(String accessKey) {\n-        this.accessKey = accessKey;\n-    }\n-\n-    public String getSecretKey() {\n-        return secretKey;\n-    }\n-\n-    /**\n-     * Amazon AWS Access Key Id or Minio Secret Key.\n-     * If not set camel will connect to service for anonymous access.\n-     */\n-    public void setSecretKey(String secretKey) {\n-        this.secretKey = secretKey;\n-    }\n-\n-    public String getBucketName() {\n-        return bucketName;\n-    }\n-\n-    /**\n-     * Name of the bucket. The bucket will be created if it doesn't already\n-     * exists.\n-     */\n-    public void setBucketName(String bucketName) {\n-        this.bucketName = bucketName;\n-    }\n-\n-    public boolean isAutoCreateBucket() {\n-        return autoCreateBucket;\n-    }\n-\n-    /**\n-     * Setting the autocreation of the bucket if bucket name not exist.\n-     */\n-    public void setAutoCreateBucket(boolean autoCreateBucket) {\n-        this.autoCreateBucket = autoCreateBucket;\n-    }\n-\n-    public boolean isObjectLock() {\n-        return objectLock;\n-    }\n-\n-    /**\n-     * Set when creating new bucket.\n-     */\n-    public void setObjectLock(boolean objectLock) {\n-        this.objectLock = objectLock;\n-    }\n-\n-    public String getPolicy() {\n-        return policy;\n-    }\n-\n-    /**\n-     * The policy for this queue to set in the method.\n-     */\n-    public void setPolicy(String policy) {\n-        this.policy = policy;\n-    }\n-\n-    public ServerSideEncryptionCustomerKey getServerSideEncryptionCustomerKey() {\n-        return serverSideEncryptionCustomerKey;\n-    }\n-\n-    /**\n-     * Server-side encryption for source object while copy/move objects.\n-     */\n-    public void setServerSideEncryptionCustomerKey(ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey) {\n-        this.serverSideEncryptionCustomerKey = serverSideEncryptionCustomerKey;\n-    }\n-\n-    public ServerSideEncryption getServerSideEncryption() {\n-        return serverSideEncryption;\n-    }\n-\n-    /**\n-     * Server-side encryption.\n-     */\n-    public void setServerSideEncryption(ServerSideEncryption serverSideEncryption) {\n-        this.serverSideEncryption = serverSideEncryption;\n-    }\n-\n-    public MinioClient getMinioClient() {\n-        return minioClient;\n-    }\n-\n-    /**\n-     * Reference to a Minio Client object in the registry.\n-     */\n-    public void setMinioClient(MinioClient minioClient) {\n-        this.minioClient = minioClient;\n-    }\n-\n-    public String getObjectName() {\n-        return objectName;\n-    }\n-\n-    /**\n-     * To get the object from the bucket with the given object name.\n-     */\n-    public void setObjectName(String objectName) {\n-        this.objectName = objectName;\n-    }\n-\n-    public String getDelimiter() {\n-        return delimiter;\n-    }\n-\n-    /**\n-     * The delimiter which is used in the\n-     * ListObjectsRequest to only consume\n-     * objects we are interested in.\n-     */\n-    public void setDelimiter(String delimiter) {\n-        this.delimiter = delimiter;\n-    }\n-\n-    public boolean isIncludeUserMetadata() {\n-        return includeUserMetadata;\n-    }\n-\n-    /**\n-     * The flag which is used in the\n-     * ListObjectsRequest to get objects with user meta data.\n-     */\n-    public void setIncludeUserMetadata(boolean includeUserMetadata) {\n-        this.includeUserMetadata = includeUserMetadata;\n-    }\n-\n-    public boolean isIncludeVersions() {\n-        return includeVersions;\n-    }\n-\n-    /**\n-     * The flag which is used in the\n-     * ListObjectsRequest to get objects with versioning.\n-     */\n-    public void setIncludeVersions(boolean includeVersions) {\n-        this.includeVersions = includeVersions;\n-    }\n-\n-    public boolean isIncludeFolders() {\n-        return includeFolders;\n-    }\n-\n-    /**\n-     * The flag which is used in the\n-     * ListObjectsRequest to set include folders.\n-     */\n-    public void setIncludeFolders(boolean includeFolders) {\n-        this.includeFolders = includeFolders;\n-    }\n-\n-    public String getPrefix() {\n-        return prefix;\n-    }\n-\n-    /**\n-     * Object name starts with prefix.\n-     */\n-    public void setPrefix(String prefix) {\n-        this.prefix = prefix;\n-    }\n-\n-    public boolean isRecursive() {\n-        return recursive;\n-    }\n-\n-    /**\n-     * List recursively than directory structure emulation.\n-     */\n-    public void setRecursive(boolean recursive) {\n-        this.recursive = recursive;\n-    }\n-\n-    public String getStartAfter() {\n-        return startAfter;\n-    }\n-\n-    /**\n-     * list objects in bucket after this object name.\n-     */\n-    public void setStartAfter(String startAfter) {\n-        this.startAfter = startAfter;\n-    }\n-\n-    public boolean isUseVersion1() {\n-        return useVersion1;\n-    }\n-\n-    /**\n-     * when true, version 1 of REST API is used.\n-     */\n-    public void setUseVersion1(boolean useVersion1) {\n-        this.useVersion1 = useVersion1;\n-    }\n-\n-    public long getOffset() {\n-        return offset;\n-    }\n-\n-    /**\n-     * Start byte position of object data.\n-     */\n-    public void setOffset(long offset) {\n-        this.offset = offset;\n-    }\n-\n-    public long getLength() {\n-        return length;\n-    }\n-\n-    /**\n-     * Number of bytes of object data from offset.\n-     */\n-    public void setLength(long length) {\n-        this.length = length;\n-    }\n-\n-    public String getVersionId() {\n-        return versionId;\n-    }\n-\n-    /**\n-     * Set specific version_ID of a object when deleting the object.\n-     */\n-    public void setVersionId(String versionId) {\n-        this.versionId = versionId;\n-    }\n-\n-    public String getMatchETag() {\n-        return matchETag;\n-    }\n-\n-    /**\n-     * Set match ETag parameter for get object(s).\n-     */\n-    public void setMatchETag(String matchETag) {\n-        this.matchETag = matchETag;\n-    }\n-\n-    public String getNotMatchETag() {\n-        return notMatchETag;\n-    }\n-\n-    /**\n-     * Set not match ETag parameter for get object(s).\n-     */\n-    public void setNotMatchETag(String notMatchETag) {\n-        this.notMatchETag = notMatchETag;\n-    }\n-\n-    public ZonedDateTime getModifiedSince() {\n-        return modifiedSince;\n-    }\n-\n-    /**\n-     * Set modified since parameter for get object(s).\n-     */\n-    public void setModifiedSince(ZonedDateTime modifiedSince) {\n-        this.modifiedSince = modifiedSince;\n-    }\n-\n-    public ZonedDateTime getUnModifiedSince() {\n-        return unModifiedSince;\n-    }\n-\n-    /**\n-     * Set un modified since parameter for get object(s).\n-     */\n-    public void setUnModifiedSince(ZonedDateTime unModifiedSince) {\n-        this.unModifiedSince = unModifiedSince;\n-    }\n-\n-    public String getDestinationBucketName() {\n-        return destinationBucketName;\n-    }\n-\n-    /**\n-     * Source bucket name.\n-     */\n-    public void setDestinationBucketName(String destinationBucketName) {\n-        this.destinationBucketName = destinationBucketName;\n-    }\n-\n-    public String getDestinationObjectName() {\n-        return destinationObjectName;\n-    }\n-\n-    /**\n-     * Source object name.\n-     */\n-    public void setDestinationObjectName(String destinationObjectName) {\n-        this.destinationObjectName = destinationObjectName;\n-    }\n-\n-    public boolean isDeleteAfterRead() {\n-        return deleteAfterRead;\n-    }\n-\n-    /**\n-     * Delete objects from Minio after they have been retrieved. The delete is only\n-     * performed if the Exchange is committed. If a rollback occurs, the object\n-     * is not deleted.\n-     * <p/>\n-     * If this option is false, then the same objects will be retrieve over and\n-     * over again on the polls. Therefore you need to use the Idempotent\n-     * Consumer EIP in the route to filter out duplicates. You can filter using\n-     * the {@link MinioConstants#BUCKET_NAME} and {@link MinioConstants#OBJECT_NAME}\n-     * headers, or only the {@link MinioConstants#OBJECT_NAME} header.\n-     */\n-    public void setDeleteAfterRead(boolean deleteAfterRead) {\n-        this.deleteAfterRead = deleteAfterRead;\n-    }\n-\n-    public boolean isMoveAfterRead() {\n-        return moveAfterRead;\n-    }\n-\n-    /**\n-     * Move objects from bucket to a different bucket after they have been retrieved. To accomplish the operation\n-     * the destinationBucket option must be set.\n-     * The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object\n-     * is not moved.\n-     */\n-    public void setMoveAfterRead(boolean moveAfterRead) {\n-        this.moveAfterRead = moveAfterRead;\n-    }\n-\n-    public boolean isBypassGovernanceMode() {\n-        return bypassGovernanceMode;\n-    }\n-\n-    /**\n-     * Set this flag if you want to bypassGovernanceMode when deleting a particular object.\n-     */\n-    public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n-        this.bypassGovernanceMode = bypassGovernanceMode;\n-    }\n-\n-    public boolean isIncludeBody() {\n-        return includeBody;\n-    }\n-\n-    /**\n-     * If it is true, the exchange body will be set to a stream to the contents\n-     * of the file. If false, the headers will be set with the Minio object\n-     * metadata, but the body will be null. This option is strongly related to\n-     * autocloseBody option. In case of setting includeBody to true and\n-     * autocloseBody to false, it will be up to the caller to close the MinioObject\n-     * stream. Setting autocloseBody to true, will close the MinioObject stream\n-     * automatically.\n-     */\n-    public void setIncludeBody(boolean includeBody) {\n-        this.includeBody = includeBody;\n-    }\n-\n-    public boolean isAutocloseBody() {\n-        return autocloseBody;\n-    }\n-\n-    /**\n-     * If this option is true and includeBody is true, then the MinioObject.close()\n-     * method will be called on exchange completion. This option is strongly\n-     * related to includeBody option. In case of setting includeBody to true and\n-     * autocloseBody to false, it will be up to the caller to close the MinioObject\n-     * stream. Setting autocloseBody to true, will close the MinioObject stream\n-     * automatically.\n-     */\n-    public void setAutocloseBody(boolean autocloseBody) {\n-        this.autocloseBody = autocloseBody;\n-    }\n-\n-    public String getKeyName() {\n-        return keyName;\n-    }\n-\n-    /**\n-     * Setting the key name for an element in the bucket through endpoint\n-     * parameter.\n-     */\n-    public void setKeyName(String keyName) {\n-        this.keyName = keyName;\n-    }\n-\n-    public boolean isDeleteAfterWrite() {\n-        return deleteAfterWrite;\n-    }\n-\n-    /**\n-     * Delete file object after the Minio file has been uploaded.\n-     */\n-    public void setDeleteAfterWrite(boolean deleteAfterWrite) {\n-        this.deleteAfterWrite = deleteAfterWrite;\n-    }\n-\n-    public long getPartSize() {\n-        return partSize;\n-    }\n-\n-    /**\n-     * Setup the partSize which is used in multi part upload, the default size\n-     * is 25M.\n-     */\n-    public void setPartSize(long partSize) {\n-        this.partSize = partSize;\n-    }\n-\n-    public String getStorageClass() {\n-        return storageClass;\n-    }\n-\n-    /**\n-     * The storage class to set in the request.\n-     */\n-    public void setStorageClass(String storageClass) {\n-        this.storageClass = storageClass;\n-    }\n-\n-    public MinioOperations getOperation() {\n-        return operation;\n-    }\n-\n-    /**\n-     * The operation to do in case the user don't want to do only an upload.\n-     */\n-    public void setOperation(MinioOperations operation) {\n-        this.operation = operation;\n-    }\n-\n-    public boolean isPojoRequest() {\n-        return pojoRequest;\n-    }\n-\n-    /**\n-     * If we want to use a POJO request as body or not.\n-     */\n-    public void setPojoRequest(boolean pojoRequest) {\n-        this.pojoRequest = pojoRequest;\n-    }\n-\n-    public MinioConfiguration copy() {\n-        try {\n-            return (MinioConfiguration) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw new RuntimeCamelException(e);\n-        }\n-    }\n-}\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nnew file mode 100644\nindex 00000000000..22dc7ae8a48\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam(defaultValue = \"false\")\n+    boolean secure;\n+    private String bucketName;\n+    @UriParam\n+    private String accessKey;\n+    @UriParam\n+    private String secretKey;\n+    @UriParam(label = \"consumer\")\n+    private String fileName;\n+    @UriParam(label = \"consumer\")\n+    private String prefix;\n+    @UriParam(label = \"producer\")\n+    private String region;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean deleteAfterRead = true;\n+    @UriParam(label = \"producer\")\n+    private boolean deleteAfterWrite;\n+    @UriParam(label = \"producer\")\n+    private boolean multiPartUpload;\n+    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n+    private long partSize = 25 * 1024 * 1024;\n+    @UriParam\n+    private String policy;\n+    @UriParam(label = \"producer\")\n+    private String storageClass;\n+    @UriParam(label = \"producer\")\n+    private String serverSideEncryption;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean includeBody = true;\n+    @UriParam\n+    private boolean pathStyleAccess;\n+    @UriParam(label = \"producer\", enums = \"copyObject,deleteBucket,listBuckets\")\n+    private MinioOperations operation;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean autocloseBody = true;\n+\n+    /**\n+     * Some description of this option(isSecure), and what it does\n+     */\n+    public boolean isSecure() {\n+        return secure;\n+    }\n+\n+    public void setSecure(boolean secure) {\n+        this.secure = secure;\n+    }\n+\n+    public String getBucketName() {\n+        return bucketName;\n+    }\n+\n+    public void setBucketName(String bucketName) {\n+        this.bucketName = bucketName;\n+    }\n+\n+    /**\n+     * Some description of this option(getAccessKey), and what it does\n+     */\n+    public String getAccessKey() {\n+        return accessKey;\n+    }\n+\n+    public void setAccessKey(String accessKey) {\n+        this.accessKey = accessKey;\n+    }\n+\n+    /**\n+     * Some description of this option(getSecretKey), and what it does\n+     */\n+    public String getSecretKey() {\n+        return secretKey;\n+    }\n+\n+    public void setSecretKey(String secretKey) {\n+        this.secretKey = secretKey;\n+    }\n+\n+    /**\n+     * Some description of this option(getFileName), and what it does\n+     */\n+    public String getFileName() {\n+        return fileName;\n+    }\n+\n+    public void setFileName(String fileName) {\n+        this.fileName = fileName;\n+    }\n+\n+    /**\n+     * Some description of this option(getPrefix), and what it does\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    public void setPrefix(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    /**\n+     * Some description of this option(getRegion), and what it does\n+     */\n+    public String getRegion() {\n+        return region;\n+    }\n+\n+    public void setRegion(String region) {\n+        this.region = region;\n+    }\n+\n+    /**\n+     * Some description of this option(isDeleteAfterRead), and what it does\n+     */\n+    public boolean isDeleteAfterRead() {\n+        return deleteAfterRead;\n+    }\n+\n+    public void setDeleteAfterRead(boolean deleteAfterRead) {\n+        this.deleteAfterRead = deleteAfterRead;\n+    }\n+\n+    /**\n+     * Some description of this option(isDeleteAfterWrite), and what it does\n+     */\n+    public boolean isDeleteAfterWrite() {\n+        return deleteAfterWrite;\n+    }\n+\n+    public void setDeleteAfterWrite(boolean deleteAfterWrite) {\n+        this.deleteAfterWrite = deleteAfterWrite;\n+    }\n+\n+    /**\n+     * Some description of this option(isMultiPartUpload), and what it does\n+     */\n+    public boolean isMultiPartUpload() {\n+        return multiPartUpload;\n+    }\n+\n+    public void setMultiPartUpload(boolean multiPartUpload) {\n+        this.multiPartUpload = multiPartUpload;\n+    }\n+\n+    /**\n+     * Some description of this option(getPartSize), and what it does\n+     */\n+    public long getPartSize() {\n+        return partSize;\n+    }\n+\n+    public void setPartSize(long partSize) {\n+        this.partSize = partSize;\n+    }\n+\n+    /**\n+     * Some description of this option(getPolicy), and what it does\n+     */\n+    public String getPolicy() {\n+        return policy;\n+    }\n+\n+    public void setPolicy(String policy) {\n+        this.policy = policy;\n+    }\n+\n+    /**\n+     * Some description of this option(getStorageClass), and what it does\n+     */\n+    public String getStorageClass() {\n+        return storageClass;\n+    }\n+\n+    public void setStorageClass(String storageClass) {\n+        this.storageClass = storageClass;\n+    }\n+\n+    /**\n+     * Some description of this option(getServerSideEncryption), and what it does\n+     */\n+    public String getServerSideEncryption() {\n+        return serverSideEncryption;\n+    }\n+\n+    public void setServerSideEncryption(String serverSideEncryption) {\n+        this.serverSideEncryption = serverSideEncryption;\n+    }\n+\n+    /**\n+     * Some description of this option(isIncludeBody), and what it does\n+     */\n+    public boolean isIncludeBody() {\n+        return includeBody;\n+    }\n+\n+    public void setIncludeBody(boolean includeBody) {\n+        this.includeBody = includeBody;\n+    }\n+\n+    /**\n+     * Some description of this option(isPathStyleAccess), and what it does\n+     */\n+    public boolean isPathStyleAccess() {\n+        return pathStyleAccess;\n+    }\n+\n+    public void setPathStyleAccess(boolean pathStyleAccess) {\n+        this.pathStyleAccess = pathStyleAccess;\n+    }\n+\n+    /**\n+     * Some description of this option(getOperation), and what it does\n+     */\n+    public MinioOperations getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(MinioOperations operation) {\n+        this.operation = operation;\n+    }\n+\n+    /**\n+     * Some description of this option(isAutocloseBody), and what it does\n+     */\n+    public boolean isAutocloseBody() {\n+        return autocloseBody;\n+    }\n+\n+    public void setAutocloseBody(boolean autocloseBody) {\n+        this.autocloseBody = autocloseBody;\n+    }\n+}\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22dc7ae8a48..365aa2009a0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -48,208 +65,287 @@ public class MinioConfiguration implements Cloneable {\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\")\n-    private String serverSideEncryption;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean includeBody = true;\n+    private ServerSideEncryption serverSideEncryption;\n+    @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteBucket,listBuckets,getObject,getObjectRange\")\n+    private MinioOperations operation;\n     @UriParam\n     private boolean pathStyleAccess;\n-    @UriParam(label = \"producer\", enums = \"copyObject,deleteBucket,listBuckets\")\n-    private MinioOperations operation;\n-    @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autocloseBody = true;\n-\n-    /**\n-     * Some description of this option(isSecure), and what it does\n-     */\n-    public boolean isSecure() {\n-        return secure;\n-    }\n-\n-    public void setSecure(boolean secure) {\n-        this.secure = secure;\n-    }\n \n     public String getBucketName() {\n         return bucketName;\n     }\n \n+    /**\n+     * Name of the bucket. The bucket will be created if it doesn't already\n+     * exists.\n+     */\n     public void setBucketName(String bucketName) {\n         this.bucketName = bucketName;\n     }\n \n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n     /**\n-     * Some description of this option(getAccessKey), and what it does\n+     * Reference to a Minio Client object in the registry.\n      */\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n     public String getAccessKey() {\n         return accessKey;\n     }\n \n+    /**\n+     * Amazon AWS Secret Access Key or Minio Access Key\n+     */\n     public void setAccessKey(String accessKey) {\n         this.accessKey = accessKey;\n     }\n \n-    /**\n-     * Some description of this option(getSecretKey), and what it does\n-     */\n     public String getSecretKey() {\n         return secretKey;\n     }\n \n+    /**\n+     * Amazon AWS Access Key Id or Minio Secret Key\n+     */\n     public void setSecretKey(String secretKey) {\n         this.secretKey = secretKey;\n     }\n \n+    public boolean isUseAWSIAMCredentials() {\n+        return useAWSIAMCredentials;\n+    }\n+\n     /**\n-     * Some description of this option(getFileName), and what it does\n+     * Set this flag true if you use AWS IAM Credentials to create MinIO client object\n      */\n-    public String getFileName() {\n-        return fileName;\n+    public void setUseAWSIAMCredentials(boolean useAWSIAMCredentials) {\n+        this.useAWSIAMCredentials = useAWSIAMCredentials;\n     }\n \n-    public void setFileName(String fileName) {\n-        this.fileName = fileName;\n+    public String getRegion() {\n+        return region;\n     }\n \n     /**\n-     * Some description of this option(getPrefix), and what it does\n+     * The region in which Minio client needs to work. When using this parameter,\n+     * the configuration will expect the lowercase name of the region (for\n+     * example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()\n      */\n+    public void setRegion(String region) {\n+        this.region = region;\n+    }\n+\n+    public String getObjectName() {\n+        return objectName;\n+    }\n+\n+    /**\n+     * To get the object from the bucket with the given object name\n+     */\n+    public void setObjectName(String objectName) {\n+        this.objectName = objectName;\n+    }\n+\n     public String getPrefix() {\n         return prefix;\n     }\n \n+    /**\n+     * Object name starts with prefix.\n+     */\n     public void setPrefix(String prefix) {\n         this.prefix = prefix;\n     }\n \n+    public boolean isRecursive() {\n+        return recursive;\n+    }\n+\n     /**\n-     * Some description of this option(getRegion), and what it does\n+     * List recursively than directory structure emulation.\n      */\n-    public String getRegion() {\n-        return region;\n+    public void setRecursive(boolean recursive) {\n+        this.recursive = recursive;\n     }\n \n-    public void setRegion(String region) {\n-        this.region = region;\n+    public boolean isUseVersion1() {\n+        return useVersion1;\n+    }\n+\n+    /**\n+     * when true, version 1 of REST API is used.\n+     */\n+    public void setUseVersion1(boolean useVersion1) {\n+        this.useVersion1 = useVersion1;\n+    }\n+\n+    public long getOffset() {\n+        return offset;\n     }\n \n     /**\n-     * Some description of this option(isDeleteAfterRead), and what it does\n+     * Start byte position of object data.\n      */\n+    public void setOffset(long offset) {\n+        this.offset = offset;\n+    }\n+\n+    /**\n+     *  Number of bytes of object data from offset.\n+     */\n+    public long getLength() {\n+        return length;\n+    }\n+\n+    public void setLength(long length) {\n+        this.length = length;\n+    }\n+\n     public boolean isDeleteAfterRead() {\n         return deleteAfterRead;\n     }\n \n+    /**\n+     * Delete objects from Minio after they have been retrieved. The delete is only\n+     * performed if the Exchange is committed. If a rollback occurs, the object\n+     * is not deleted.\n+     * <p/>\n+     * If this option is false, then the same objects will be retrieve over and\n+     * over again on the polls. Therefore you need to use the Idempotent\n+     * Consumer EIP in the route to filter out duplicates. You can filter using\n+     * the {@link MinioConstants#BUCKET_NAME} and {@link MinioConstants#KEY}\n+     * headers, or only the {@link MinioConstants#KEY} header.\n+     */\n     public void setDeleteAfterRead(boolean deleteAfterRead) {\n         this.deleteAfterRead = deleteAfterRead;\n     }\n \n+    public boolean isIncludeBody() {\n+        return includeBody;\n+    }\n+\n     /**\n-     * Some description of this option(isDeleteAfterWrite), and what it does\n+     * If it is true, the exchange body will be set to a stream to the contents\n+     * of the file. If false, the headers will be set with the Minio object\n+     * metadata, but the body will be null. This option is strongly related to\n+     * autocloseBody option. In case of setting includeBody to true and\n+     * autocloseBody to false, it will be up to the caller to close the MinioObject\n+     * stream. Setting autocloseBody to true, will close the MinioObject stream\n+     * automatically.\n      */\n+    public void setIncludeBody(boolean includeBody) {\n+        this.includeBody = includeBody;\n+    }\n+\n+    public boolean isAutocloseBody() {\n+        return autocloseBody;\n+    }\n+\n+    /**\n+     * If this option is true and includeBody is true, then the MinioObject.close()\n+     * method will be called on exchange completion. This option is strongly\n+     * related to includeBody option. In case of setting includeBody to true and\n+     * autocloseBody to false, it will be up to the caller to close the MinioObject\n+     * stream. Setting autocloseBody to true, will close the MinioObject stream\n+     * automatically.\n+     */\n+    public void setAutocloseBody(boolean autocloseBody) {\n+        this.autocloseBody = autocloseBody;\n+    }\n+\n     public boolean isDeleteAfterWrite() {\n         return deleteAfterWrite;\n     }\n \n+    /**\n+     * Delete file object after the Minio file has been uploaded\n+     */\n     public void setDeleteAfterWrite(boolean deleteAfterWrite) {\n         this.deleteAfterWrite = deleteAfterWrite;\n     }\n \n-    /**\n-     * Some description of this option(isMultiPartUpload), and what it does\n-     */\n     public boolean isMultiPartUpload() {\n         return multiPartUpload;\n     }\n \n+    /**\n+     * If it is true, camel will upload the file with multi part format, the\n+     * part size is decided by the option of `partSize`\n+     */\n     public void setMultiPartUpload(boolean multiPartUpload) {\n         this.multiPartUpload = multiPartUpload;\n     }\n \n-    /**\n-     * Some description of this option(getPartSize), and what it does\n-     */\n     public long getPartSize() {\n         return partSize;\n     }\n \n+    /**\n+     * Setup the partSize which is used in multi part upload, the default size\n+     * is 25M.\n+     */\n     public void setPartSize(long partSize) {\n         this.partSize = partSize;\n     }\n \n-    /**\n-     * Some description of this option(getPolicy), and what it does\n-     */\n     public String getPolicy() {\n         return policy;\n     }\n \n+    /**\n+     * The policy for this queue to set in the method.\n+     */\n     public void setPolicy(String policy) {\n         this.policy = policy;\n     }\n \n-    /**\n-     * Some description of this option(getStorageClass), and what it does\n-     */\n     public String getStorageClass() {\n         return storageClass;\n     }\n \n+    /**\n+     * The storage class to set in the request.\n+     */\n     public void setStorageClass(String storageClass) {\n         this.storageClass = storageClass;\n     }\n \n-    /**\n-     * Some description of this option(getServerSideEncryption), and what it does\n-     */\n-    public String getServerSideEncryption() {\n+    public ServerSideEncryption getServerSideEncryption() {\n         return serverSideEncryption;\n     }\n \n-    public void setServerSideEncryption(String serverSideEncryption) {\n-        this.serverSideEncryption = serverSideEncryption;\n-    }\n-\n     /**\n-     * Some description of this option(isIncludeBody), and what it does\n+     *  (Optional) Server-side encryption.\n      */\n-    public boolean isIncludeBody() {\n-        return includeBody;\n-    }\n-\n-    public void setIncludeBody(boolean includeBody) {\n-        this.includeBody = includeBody;\n-    }\n-\n-    /**\n-     * Some description of this option(isPathStyleAccess), and what it does\n-     */\n-    public boolean isPathStyleAccess() {\n-        return pathStyleAccess;\n-    }\n-\n-    public void setPathStyleAccess(boolean pathStyleAccess) {\n-        this.pathStyleAccess = pathStyleAccess;\n+    public void setServerSideEncryption(ServerSideEncryption serverSideEncryption) {\n+        this.serverSideEncryption = serverSideEncryption;\n     }\n \n-    /**\n-     * Some description of this option(getOperation), and what it does\n-     */\n     public MinioOperations getOperation() {\n         return operation;\n     }\n \n+    /**\n+     * The operation to do in case the user don't want to do only an upload\n+     */\n     public void setOperation(MinioOperations operation) {\n         this.operation = operation;\n     }\n \n+    public boolean isPathStyleAccess() {\n+        return pathStyleAccess;\n+    }\n+\n     /**\n-     * Some description of this option(isAutocloseBody), and what it does\n+     * Some description of this option(isPathStyleAccess), and what it does\n      */\n-    public boolean isAutocloseBody() {\n-        return autocloseBody;\n+    public void setPathStyleAccess(boolean pathStyleAccess) {\n+        this.pathStyleAccess = pathStyleAccess;\n     }\n \n-    public void setAutocloseBody(boolean autocloseBody) {\n-        this.autocloseBody = autocloseBody;\n-    }\n }\n", "next_change": {"commit": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 365aa2009a0..5a0640c8e6f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -347,5 +506,4 @@ public class MinioConfiguration implements Cloneable {\n     public void setPathStyleAccess(boolean pathStyleAccess) {\n         this.pathStyleAccess = pathStyleAccess;\n     }\n-\n }\n", "next_change": {"commit": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 5a0640c8e6f..c3065908c39 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -506,4 +527,37 @@ public class MinioConfiguration implements Cloneable {\n     public void setPathStyleAccess(boolean pathStyleAccess) {\n         this.pathStyleAccess = pathStyleAccess;\n     }\n+\n+    public boolean isPojoRequest() {\n+        return pojoRequest;\n+    }\n+\n+    /**\n+     * If we want to use a POJO request as body or not\n+     */\n+    public void setPojoRequest(boolean pojoRequest) {\n+        this.pojoRequest = pojoRequest;\n+    }\n+\n+    public String getVersionId() {\n+        return versionId;\n+    }\n+\n+    /**\n+     * Set specific version_ID of a object when deleting the object\n+     */\n+    public void setVersionId(String versionId) {\n+        this.versionId = versionId;\n+    }\n+\n+    public boolean isBypassGovernanceMode() {\n+        return bypassGovernanceMode;\n+    }\n+\n+    /**\n+     * Set this flag if you want to bypassGovernanceMode when deleting a particular object\n+     */\n+    public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n+        this.bypassGovernanceMode = bypassGovernanceMode;\n+    }\n }\n", "next_change": {"commit": "6972439ee57658ed13ff58c89df749dfafbfa18b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex c3065908c39..b866c41376f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -560,4 +629,12 @@ public class MinioConfiguration implements Cloneable {\n     public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n         this.bypassGovernanceMode = bypassGovernanceMode;\n     }\n+\n+    public MinioConfiguration copy() {\n+        try {\n+            return (MinioConfiguration)super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new RuntimeCamelException(e);\n+        }\n+    }\n }\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex b866c41376f..18ac4042a9a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -632,7 +633,7 @@ public class MinioConfiguration implements Cloneable {\n \n     public MinioConfiguration copy() {\n         try {\n-            return (MinioConfiguration)super.clone();\n+            return (MinioConfiguration) super.clone();\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeCamelException(e);\n         }\n", "next_change": {"commit": "585e4deebddd6999431c35a3b5a8f3ce72f1f974", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 18ac4042a9a..e3e6b94a989 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -603,34 +621,12 @@ public class MinioConfiguration implements Cloneable {\n     }\n \n     /**\n-     * If we want to use a POJO request as body or not\n+     * If we want to use a POJO request as body or not.\n      */\n     public void setPojoRequest(boolean pojoRequest) {\n         this.pojoRequest = pojoRequest;\n     }\n \n-    public String getVersionId() {\n-        return versionId;\n-    }\n-\n-    /**\n-     * Set specific version_ID of a object when deleting the object\n-     */\n-    public void setVersionId(String versionId) {\n-        this.versionId = versionId;\n-    }\n-\n-    public boolean isBypassGovernanceMode() {\n-        return bypassGovernanceMode;\n-    }\n-\n-    /**\n-     * Set this flag if you want to bypassGovernanceMode when deleting a particular object\n-     */\n-    public void setBypassGovernanceMode(boolean bypassGovernanceMode) {\n-        this.bypassGovernanceMode = bypassGovernanceMode;\n-    }\n-\n     public MinioConfiguration copy() {\n         try {\n             return (MinioConfiguration) super.clone();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..ee18fe1d920 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -99,30 +100,23 @@ public class MinioConfiguration implements Cloneable {\n     private boolean deleteAfterRead = true;\n     @UriParam(label = \"consumer\", defaultValue = \"false\")\n     private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean bypassGovernanceMode;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n     private boolean includeBody = true;\n     @UriParam(label = \"consumer\", defaultValue = \"true\")\n-    private boolean autocloseBody = true;\n+    private boolean autoCloseBody = true;\n \n     @UriParam(label = \"producer\")\n     private String keyName;\n     @UriParam(label = \"producer\")\n     private boolean deleteAfterWrite;\n-    @UriParam(label = \"producer\", defaultValue = \"\" + 25 * 1024 * 1024)\n-    private long partSize = 25 * 1024 * 1024;\n-    @UriParam\n-    private String policy;\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n     private MinioOperations operation;\n-\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"producer\", defaultValue = \"false\")\n     private boolean pojoRequest;\n-    private String versionId;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean bypassGovernanceMode;\n-\n \n     public String getEndpoint() {\n         return endpoint;\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex ee18fe1d920..364dc5f30c3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -113,7 +121,8 @@ public class MinioConfiguration implements Cloneable {\n     private boolean deleteAfterWrite;\n     @UriParam(label = \"producer\")\n     private String storageClass;\n-    @UriParam(label = \"producer\", enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n+    @UriParam(label = \"producer\",\n+              enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n     private MinioOperations operation;\n     @UriParam(label = \"producer\", defaultValue = \"false\")\n     private boolean pojoRequest;\n", "next_change": {"commit": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 364dc5f30c3..2914f5f7bc5 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n", "chunk": "@@ -122,7 +123,7 @@ public class MinioConfiguration implements Cloneable {\n     @UriParam(label = \"producer\")\n     private String storageClass;\n     @UriParam(label = \"producer\",\n-              enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange\")\n+              enums = \"copyObject,listObjects,deleteObject,deleteObjects,deleteBucket,listBuckets,getObject,getObjectRange,createDownloadLink,createUploadLink\")\n     private MinioOperations operation;\n     @UriParam(label = \"producer\", defaultValue = \"false\")\n     private boolean pojoRequest;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "d75a66b0734fd2e64fc0b3ef09cb29d0d753b6fc", "committedDate": "2020-08-10 16:51:26 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "0addeb0da4c77837ade865e237aefde4cee4b50e", "committedDate": "2020-11-27 09:07:24 +0000", "message": "CAMEL-15836: Add autowired metadata to camel-minio minioClient option"}, {"oid": "6c8ae5862ec0fc88d1fa4056258c73da26e99c7c", "committedDate": "2022-12-05 13:06:13 +0100", "message": "[doc] Fix MinIO bucket and object destination (#8834)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980253", "body": "I saw this implementation in large number of components, developed by @omarsmak, @oscerd and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.\r\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.", "bodyText": "I saw this implementation in large number of components, developed by @omarsmak, @oscerd and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.", "bodyHTML": "<p dir=\"auto\">I saw this implementation in large number of components, developed by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/omarsmak/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/omarsmak\">@omarsmak</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/oscerd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/oscerd\">@oscerd</a> and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.<br>\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.</p>", "author": "dmvolod", "createdAt": "2020-08-01T16:58:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);\n+    }\n+\n+    public MinioComponent(CamelContext context) {\n+        super(context);\n+        registerExtension(new MinioComponentVerifierExtension());\n+\n+    }\n+\n+    @Override\n+    protected MinioEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n+        if (remaining == null || remaining.trim().length() == 0) {\n+            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n+        }\n+\n+        final MinioConfiguration configuration = this.configuration != null ? this.configuration.copy() : new MinioConfiguration();\n+        configuration.setBucketName(remaining);\n+        MinioEndpoint endpoint = new MinioEndpoint(uri, this, configuration);\n+        setProperties(endpoint, parameters);\n+        checkAndSetRegistryClient(configuration, endpoint);\n+\n+        return endpoint;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    /**\n+     * The component configuration\n+     */\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n+            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n+            if (clients.size() == 1) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MTMyNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463981326", "bodyText": "I introduced the autoDisvoverCliebt for this situation in 3.5.0. in case it is false, that method won't be called", "author": "oscerd", "createdAt": "2020-08-01T17:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4MDc2Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464280762", "bodyText": "@dmvolod yes, I agree, this error message could be misleading, I think error message could be changed if there are two cases, one for more than one MinioClient instance and other one for in case there is no instance of MinioClient.", "author": "omarsmak", "createdAt": "2020-08-03T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NDY1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r467484654", "bodyText": "Hi all,\nif (clients.size() > 1) {\n                LOG.debug(\"Found more than one MinioClient instance in the registry, getting the first one...\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else if (clients.size() == 1) {\n                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else {\n                LOG.debug(\"No MinioClient instance in the registry\");\n            }\n\nis this approach okay?", "author": "Nayananga", "createdAt": "2020-08-08T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..16eec326a9d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -76,7 +78,7 @@ public class MinioComponent extends DefaultComponent {\n     }\n \n     private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n             LOG.debug(\"Looking for an MinioClient instance in the registry\");\n             Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n             if (clients.size() == 1) {\n", "next_change": {"commit": "4e7587acde63bffaa8966d15689af206cb9577d9", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 16eec326a9d..2c7c096201d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -81,7 +81,9 @@ public class MinioComponent extends DefaultComponent {\n         if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n             LOG.debug(\"Looking for an MinioClient instance in the registry\");\n             Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() == 1) {\n+            if (clients.size() > 1) {\n+                LOG.debug(\"Found more than one MinioClient instance in the registry\");\n+            } else if (clients.size() == 1) {\n                 LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                 configuration.setMinioClient(clients.stream().findFirst().get());\n             } else {\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 2c7c096201d..8a826098549 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -78,12 +76,10 @@ public class MinioComponent extends DefaultComponent {\n     }\n \n     private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n             LOG.debug(\"Looking for an MinioClient instance in the registry\");\n             Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() > 1) {\n-                LOG.debug(\"Found more than one MinioClient instance in the registry\");\n-            } else if (clients.size() == 1) {\n+            if (clients.size() == 1) {\n                 LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                 configuration.setMinioClient(clients.stream().findFirst().get());\n             } else {\n", "next_change": {"commit": "0e860b49082c2ce8ae735e48cfb746850711f22e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..f7bb80a776e 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -76,7 +79,7 @@ public class MinioComponent extends DefaultComponent {\n     }\n \n     private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n             LOG.debug(\"Looking for an MinioClient instance in the registry\");\n             Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n             if (clients.size() == 1) {\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex f7bb80a776e..c116f0641d2 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -17,79 +17,17 @@\n package org.apache.camel.component.minio;\n \n import java.util.Map;\n-import java.util.Set;\n \n-import io.minio.MinioClient;\n-import org.apache.camel.CamelContext;\n-import org.apache.camel.spi.Metadata;\n+import org.apache.camel.Endpoint;\n import org.apache.camel.spi.annotations.Component;\n import org.apache.camel.support.DefaultComponent;\n-import org.apache.camel.util.ObjectHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ObjectHelper.isEmpty;\n-import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n-\n-/**\n- * Represents the component that manages {@link MinioEndpoint}.\n- */\n @Component(\"minio\")\n public class MinioComponent extends DefaultComponent {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n-\n-    @Metadata\n-    private MinioConfiguration configuration = new MinioConfiguration();\n-\n-    public MinioComponent() {\n-        this(null);\n-    }\n-\n-    public MinioComponent(CamelContext context) {\n-        super(context);\n-        registerExtension(new MinioComponentVerifierExtension());\n-\n-    }\n-\n-    @Override\n-    protected MinioEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        if (isEmpty(remaining) || remaining.trim().length() == 0) {\n-            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n-        }\n-\n-        final MinioConfiguration configuration = isNotEmpty(this.configuration) ? this.configuration.copy() : new MinioConfiguration();\n-        configuration.setBucketName(remaining);\n-        MinioEndpoint endpoint = new MinioEndpoint(uri, this, configuration);\n+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n+        Endpoint endpoint = new MinioEndpoint(uri, this);\n         setProperties(endpoint, parameters);\n-        checkAndSetRegistryClient(configuration, endpoint);\n-\n         return endpoint;\n     }\n-\n-    public MinioConfiguration getConfiguration() {\n-        return configuration;\n-    }\n-\n-    /**\n-     * The component configuration\n-     */\n-    public void setConfiguration(MinioConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n-            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n-            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() == 1) {\n-                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n-                configuration.setMinioClient(clients.stream().findFirst().get());\n-            } else {\n-                LOG.debug(\"No MinioClient instance in the registry\");\n-            }\n-        } else {\n-            LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n-        }\n-    }\n }\n", "next_change": {"commit": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex c116f0641d2..ebc4de1010b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -16,18 +16,54 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.util.Map;\n-\n-import org.apache.camel.Endpoint;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.annotations.Component;\n import org.apache.camel.support.DefaultComponent;\n \n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n @Component(\"minio\")\n public class MinioComponent extends DefaultComponent {\n \n-    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        Endpoint endpoint = new MinioEndpoint(uri, this);\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        super();\n+    }\n+\n+    public MinioComponent(CamelContext context) {\n+        super(context);\n+    }\n+\n+    @Override\n+    protected MinioEndpoint createEndpoint(String uri, String remaining, java.util.Map<String, Object> parameters)\n+            throws Exception {\n+        setProperties(configuration, parameters);\n+        if (remaining == null || remaining.trim().length() == 0) {\n+            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n+        }\n+        if (remaining.startsWith(\"arn:\")) {\n+            remaining = remaining.substring(remaining.lastIndexOf(\":\") + 1, remaining.length());\n+        }\n+        configuration.setBucketName(remaining);\n+\n+        final MinioEndpoint endpoint = new MinioEndpoint(uri, remaining, this, configuration);\n         setProperties(endpoint, parameters);\n         return endpoint;\n     }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    /**\n+     * The component configuration\n+     */\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n }\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex ebc4de1010b..02f3fe3cfc0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -66,4 +82,19 @@ public class MinioComponent extends DefaultComponent {\n         this.configuration = configuration;\n     }\n \n+    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n+            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n+            if (clients.size() == 1) {\n+                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n+                configuration.setMinioClient(clients.stream().findFirst().get());\n+            } else {\n+                LOG.debug(\"No MinioClient instance in the registry\");\n+            }\n+        } else {\n+            LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 02f3fe3cfc0..92fbfdd2631 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -96,5 +88,4 @@ public class MinioComponent extends DefaultComponent {\n             LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n         }\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..2c7c096201d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -76,10 +78,12 @@ public class MinioComponent extends DefaultComponent {\n     }\n \n     private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n             LOG.debug(\"Looking for an MinioClient instance in the registry\");\n             Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() == 1) {\n+            if (clients.size() > 1) {\n+                LOG.debug(\"Found more than one MinioClient instance in the registry\");\n+            } else if (clients.size() == 1) {\n                 LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                 configuration.setMinioClient(clients.stream().findFirst().get());\n             } else {\n", "next_change": {"commit": "96eb5704825443ea891a04d108771bbcab2890d0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 2c7c096201d..a87608b6eb0 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n", "chunk": "@@ -76,21 +70,4 @@ public class MinioComponent extends DefaultComponent {\n     public void setConfiguration(MinioConfiguration configuration) {\n         this.configuration = configuration;\n     }\n-\n-    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n-        if (isEmpty(endpoint.getConfiguration().getMinioClient())) {\n-            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n-            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n-            if (clients.size() > 1) {\n-                LOG.debug(\"Found more than one MinioClient instance in the registry\");\n-            } else if (clients.size() == 1) {\n-                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n-                configuration.setMinioClient(clients.stream().findFirst().get());\n-            } else {\n-                LOG.debug(\"No MinioClient instance in the registry\");\n-            }\n-        } else {\n-            LOG.debug(\"MinioClient instance is already set at endpoint level: skipping the check in the registry\");\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "b0c56770850bad55787e78bb6b51b3f852c0e15d", "committedDate": "2020-08-10 16:56:02 +0200", "message": "CAMEL-13934: Polished and regen"}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "96eb5704825443ea891a04d108771bbcab2890d0", "committedDate": "2021-01-14 20:12:21 +0100", "message": "CAMEL-16037 Minio: if autowiredEnabled is set to false on camelContext, minioClient is still autowired (#4886)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDUyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980528", "body": "@Nayananga a little bit confusing about key name and key value. The same as for `LENGTH`", "bodyText": "@Nayananga a little bit confusing about key name and key value. The same as for LENGTH", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Nayananga/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Nayananga\">@Nayananga</a> a little bit confusing about key name and key value. The same as for <code>LENGTH</code></p>", "author": "dmvolod", "createdAt": "2020-08-01T17:01:42Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+/**\n+ * Constants used in Camel Minio module\n+ */\n+public interface MinioConstants {\n+\n+    String BUCKET_NAME = \"CamelMinioBucketName\";\n+    String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n+    String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    String CONTENT_TYPE = \"CamelMinioContentType\";\n+    String E_TAG = \"CamelMinioETag\";\n+    String OBJECT_NAME = \"CamelMinioObjectName\";\n+    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n+    String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    String VERSION_ID = \"CamelMinioVersionId\";\n+    String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    String MINIO_OPERATION = \"CamelMinioOperation\";\n+    String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    String OFFSET = \"CamelMinioRangeStart\";", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex ddc90808d2d..a9e16731984 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -40,6 +41,6 @@ public interface MinioConstants {\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioRangeStart\";\n-    String LENGTH = \"CamelMinioRangeEnd\";\n+    String OFFSET = \"CamelMinioOffset\";\n+    String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex a9e16731984..ddc90808d2d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -41,6 +40,6 @@ public interface MinioConstants {\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioOffset\";\n-    String LENGTH = \"CamelMinioLength\";\n+    String OFFSET = \"CamelMinioRangeStart\";\n+    String LENGTH = \"CamelMinioRangeEnd\";\n }\n", "next_change": {"commit": "c0038995d0dd7129eade273ff2039a79e00d49f6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex ddc90808d2d..a9e16731984 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -40,6 +41,6 @@ public interface MinioConstants {\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioRangeStart\";\n-    String LENGTH = \"CamelMinioRangeEnd\";\n+    String OFFSET = \"CamelMinioOffset\";\n+    String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\ndeleted file mode 100644\nindex a9e16731984..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ /dev/null\n", "chunk": "@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio;\n-\n-/**\n- * Constants used in Camel Minio module\n- */\n-public interface MinioConstants {\n-\n-    int BYTE_ARRAY_LENGTH = 1024;\n-    String BUCKET_NAME = \"CamelMinioBucketName\";\n-    String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n-    String CACHE_CONTROL = \"CamelMinioContentControl\";\n-    String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n-    String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n-    String CONTENT_LENGTH = \"CamelMinioContentLength\";\n-    String CONTENT_MD5 = \"CamelMinioContentMD5\";\n-    String CONTENT_TYPE = \"CamelMinioContentType\";\n-    String E_TAG = \"CamelMinioETag\";\n-    String OBJECT_NAME = \"CamelMinioObjectName\";\n-    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n-    String LAST_MODIFIED = \"CamelMinioLastModified\";\n-    String STORAGE_CLASS = \"CamelMinioStorageClass\";\n-    String VERSION_ID = \"CamelMinioVersionId\";\n-    String CANNED_ACL = \"CamelMinioCannedAcl\";\n-    String MINIO_OPERATION = \"CamelMinioOperation\";\n-    String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n-    String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n-    String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioOffset\";\n-    String LENGTH = \"CamelMinioLength\";\n-}\n", "next_change": {"commit": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nnew file mode 100644\nindex 00000000000..e9e90d15d8d\n--- /dev/null\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+/**\n+ * Constants used in Camel Minio module\n+ */\n+public interface MinioConstants {\n+\n+    String BUCKET_NAME = \"CamelMinioBucketName\";\n+    String BUCKET_DESTINATION_NAME = \"CamelMinioBucketDestinationName\";\n+    String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    String CONTENT_TYPE = \"CamelMinioContentType\";\n+    String E_TAG = \"CamelMinioETag\";\n+    String KEY = \"CamelMinioKey\";\n+    String DESTINATION_KEY = \"CamelMinioDestinationKey\";\n+    String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    String VERSION_ID = \"CamelMinioVersionId\";\n+    String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    String ACL = \"CamelMinioAcl\";\n+    String MINIO_OPERATION = \"CamelMinioOperation\";\n+    String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    String RANGE_START = \"CamelMinioRangeStart\";\n+    String RANGE_END = \"CamelMinioRangeEnd\";\n+}\n", "next_change": {"commit": "acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex e9e90d15d8d..8f09e31e8d3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -37,7 +37,7 @@ public interface MinioConstants {\n     String VERSION_ID = \"CamelMinioVersionId\";\n     String CANNED_ACL = \"CamelMinioCannedAcl\";\n     String ACL = \"CamelMinioAcl\";\n-    String MINIO_OPERATION = \"CamelMinioOperation\";\n+    String S3_OPERATION = \"CamelMinioOperation\";\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n", "next_change": {"commit": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex 8f09e31e8d3..b50a8451db3 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -37,10 +37,10 @@ public interface MinioConstants {\n     String VERSION_ID = \"CamelMinioVersionId\";\n     String CANNED_ACL = \"CamelMinioCannedAcl\";\n     String ACL = \"CamelMinioAcl\";\n-    String S3_OPERATION = \"CamelMinioOperation\";\n+    String Minio_OPERATION = \"CamelMinioOperation\";\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String RANGE_START = \"CamelMinioRangeStart\";\n-    String RANGE_END = \"CamelMinioRangeEnd\";\n+    String OFFSET = \"CamelMinioRangeStart\";\n+    String LENGTH = \"CamelMinioRangeEnd\";\n }\n", "next_change": {"commit": "c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex b50a8451db3..3d4b429a28d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -30,14 +30,14 @@ public interface MinioConstants {\n     String CONTENT_MD5 = \"CamelMinioContentMD5\";\n     String CONTENT_TYPE = \"CamelMinioContentType\";\n     String E_TAG = \"CamelMinioETag\";\n-    String KEY = \"CamelMinioKey\";\n+    String OBJECT_NAME = \"CamelMinioKey\";\n     String DESTINATION_KEY = \"CamelMinioDestinationKey\";\n     String LAST_MODIFIED = \"CamelMinioLastModified\";\n     String STORAGE_CLASS = \"CamelMinioStorageClass\";\n     String VERSION_ID = \"CamelMinioVersionId\";\n     String CANNED_ACL = \"CamelMinioCannedAcl\";\n     String ACL = \"CamelMinioAcl\";\n-    String Minio_OPERATION = \"CamelMinioOperation\";\n+    String MINIO_OPERATION = \"CamelMinioOperation\";\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n", "next_change": {"commit": "217cea4fdb007779cfeaa3f709c8b5111de0ec22", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex 3d4b429a28d..2b1edc4df6a 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -30,13 +30,12 @@ public interface MinioConstants {\n     String CONTENT_MD5 = \"CamelMinioContentMD5\";\n     String CONTENT_TYPE = \"CamelMinioContentType\";\n     String E_TAG = \"CamelMinioETag\";\n-    String OBJECT_NAME = \"CamelMinioKey\";\n-    String DESTINATION_KEY = \"CamelMinioDestinationKey\";\n+    String OBJECT_NAME = \"CamelMinioObjectName\";\n+    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationKey\";\n     String LAST_MODIFIED = \"CamelMinioLastModified\";\n     String STORAGE_CLASS = \"CamelMinioStorageClass\";\n     String VERSION_ID = \"CamelMinioVersionId\";\n     String CANNED_ACL = \"CamelMinioCannedAcl\";\n-    String ACL = \"CamelMinioAcl\";\n     String MINIO_OPERATION = \"CamelMinioOperation\";\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n", "next_change": {"commit": "6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex 2b1edc4df6a..ddc90808d2d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -31,7 +31,7 @@ public interface MinioConstants {\n     String CONTENT_TYPE = \"CamelMinioContentType\";\n     String E_TAG = \"CamelMinioETag\";\n     String OBJECT_NAME = \"CamelMinioObjectName\";\n-    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationKey\";\n+    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n     String LAST_MODIFIED = \"CamelMinioLastModified\";\n     String STORAGE_CLASS = \"CamelMinioStorageClass\";\n     String VERSION_ID = \"CamelMinioVersionId\";\n", "next_change": {"commit": "5a8af2544004b9d92e26d5db558932c2bb446f4f", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex ddc90808d2d..586bfe3aa33 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -40,6 +40,6 @@ public interface MinioConstants {\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioRangeStart\";\n-    String LENGTH = \"CamelMinioRangeEnd\";\n+    String OFFSET = \"CamelMinioOffset\";\n+    String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex ddc90808d2d..a9e16731984 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -40,6 +41,6 @@ public interface MinioConstants {\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n-    String OFFSET = \"CamelMinioRangeStart\";\n-    String LENGTH = \"CamelMinioRangeEnd\";\n+    String OFFSET = \"CamelMinioOffset\";\n+    String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": {"commit": "73b5e0f88924fa999e85896fd610097324e83ff7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex a9e16731984..545d17d2239 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -16,31 +16,104 @@\n  */\n package org.apache.camel.component.minio;\n \n+import org.apache.camel.spi.Metadata;\n+\n /**\n  * Constants used in Camel Minio module\n  */\n public interface MinioConstants {\n \n     int BYTE_ARRAY_LENGTH = 1024;\n+    @Metadata(description = \"*Producer:* The bucket Name which this object will be stored or which will be used for the current operation. \"\n+                            +\n+                            \"*Consumer:* The name of the bucket in which this object is contained.\",\n+              javaType = \"String\")\n     String BUCKET_NAME = \"CamelMinioBucketName\";\n+    @Metadata(label = \"producer\", description = \"The bucket Destination Name which will be used for the current operation.\",\n+              javaType = \"String\")\n     String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n+    @Metadata(description = \"*Producer:* The content control of this object. \" +\n+                            \"*Consumer:* The *optional* Cache-Control HTTP header which allows the user to\\n\" +\n+                            \"specify caching behavior along the HTTP request/reply chain.\",\n+              javaType = \"String\")\n     String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    @Metadata(description = \"*Producer:* The content disposition of this object. \" +\n+                            \"*Consumer:* The *optional* Content-Disposition HTTP header, which specifies\\n\" +\n+                            \"presentational information such as the recommended filename for the\\n\" +\n+                            \"object to be saved as.\",\n+              javaType = \"String\")\n     String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    @Metadata(description = \"*Producer:* The content encoding of this object. \" +\n+                            \"*Consumer:* The *optional* Content-Encoding HTTP header specifying what content\\n\" +\n+                            \"encodings have been applied to the object and what decoding mechanisms\\n\" +\n+                            \"must be applied in order to obtain the media-type referenced by the\\n\" +\n+                            \"Content-Type field.\",\n+              javaType = \"String\")\n     String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    @Metadata(description = \"*Producer:* The content length of this object. \" +\n+                            \"*Consumer:* The Content-Length HTTP header indicating the size of the associated\\n\" +\n+                            \"object in bytes.\",\n+              javaType = \"Long\")\n     String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    @Metadata(description = \"*Producer:* The md5 checksum of this object. \" +\n+                            \"*Consumer:* The base64 encoded 128-bit MD5 digest of the associated object (content\\n\" +\n+                            \"- not including headers) according to RFC 1864. This data is used as a\\n\" +\n+                            \"message integrity check to verify that the data received by Minio is\\n\" +\n+                            \"the same data that the caller sent.\",\n+              javaType = \"String\")\n     String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    @Metadata(description = \"*Producer:* The content type of this object. \" +\n+                            \"*Consumer:* The Content-Type HTTP header, which indicates the type of content stored\\n\" +\n+                            \"in the associated object. The value of this header is a standard MIME\\n\" +\n+                            \"type.\",\n+              javaType = \"String\")\n     String CONTENT_TYPE = \"CamelMinioContentType\";\n+    @Metadata(description = \"*Producer:* The ETag value for the newly uploaded object. \" +\n+                            \"*Consumer:* The hex encoded 128-bit MD5 digest of the associated object according to\\n\" +\n+                            \"RFC 1864. This data is used as an integrity check to verify that the\\n\" +\n+                            \"data received by the caller is the same data that was sent by Minio\",\n+              javaType = \"String\")\n     String E_TAG = \"CamelMinioETag\";\n+    @Metadata(description = \"*Producer:* The key under which this object will be stored or which will be used for the current operation. \"\n+                            +\n+                            \"*Consumer:* The key under which this object is stored.\",\n+              javaType = \"String\")\n     String OBJECT_NAME = \"CamelMinioObjectName\";\n+    @Metadata(label = \"producer\", description = \"The Destination key which will be used for the current operation.\",\n+              javaType = \"String\")\n     String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n+    @Metadata(description = \"*Producer:* The last modified timestamp of this object. \" +\n+                            \"*Consumer:* The value of the Last-Modified header, indicating the date and time at\\n\" +\n+                            \"which Minio last recorded a modification to the associated object.\",\n+              javaType = \"java.util.Date\")\n     String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    @Metadata(label = \"producer\", description = \"The storage class of this object.\", javaType = \"String\")\n     String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    @Metadata(description = \"*Producer:* The version Id of the object to be stored or returned from the current operation. \" +\n+                            \"*Consumer:* The version ID of the associated Minio object if available. Version\\n\" +\n+                            \"IDs are only assigned to objects when an object is uploaded to an Minio bucket that has object versioning enabled.\",\n+              javaType = \"String\")\n     String VERSION_ID = \"CamelMinioVersionId\";\n+    @Metadata(label = \"producer\", description = \"The canned acl that will be applied to the object. see\\n\" +\n+                                                \"`com.amazonaws.services.s3.model.CannedAccessControlList` for allowed\\n\" +\n+                                                \"values.\",\n+              javaType = \"String\")\n     String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    @Metadata(label = \"producer\", description = \"The operation to perform.\",\n+              javaType = \"org.apache.camel.component.minio.MinioOperations\")\n     String MINIO_OPERATION = \"CamelMinioOperation\";\n+    @Metadata(description = \"*Producer:* Sets the server-side encryption algorithm when encrypting\\n\" +\n+                            \"the object using Minio-managed keys. For example use AES256. \" +\n+                            \"*Consumer:* The server-side encryption algorithm when encrypting the\\n\" +\n+                            \"object using Minio-managed keys.\",\n+              javaType = \"String\")\n     String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    @Metadata(description = \"The expiration time\", javaType = \"String\")\n     String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    @Metadata(description = \"The replication status\", javaType = \"String\")\n     String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    @Metadata(label = \"producer\", description = \"The offset\", javaType = \"String\")\n     String OFFSET = \"CamelMinioOffset\";\n+    @Metadata(label = \"producer\", description = \"The length\", javaType = \"String\")\n     String LENGTH = \"CamelMinioLength\";\n }\n", "next_change": {"commit": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "changed_code": [{"header": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex 545d17d2239..35af578594b 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n", "chunk": "@@ -116,4 +116,6 @@ public interface MinioConstants {\n     String OFFSET = \"CamelMinioOffset\";\n     @Metadata(label = \"producer\", description = \"The length\", javaType = \"String\")\n     String LENGTH = \"CamelMinioLength\";\n+    @Metadata(label = \"producer\", description = \"Expiration of minio presigned url in Seconds\", javaType = \"int\")\n+    String PRESIGNED_URL_EXPIRATION_TIME = \"CamelMinioPresignedURLExpirationTime\";\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "73b5e0f88924fa999e85896fd610097324e83ff7", "committedDate": "2022-04-01 12:05:08 +0200", "message": "CAMEL-17792: Add documentation about the message headers (K-M) (#7318)"}, {"oid": "0fad6a84fdd8a63d9ac522ed32131ef4b8300c5b", "committedDate": "2023-02-17 18:13:52 +0100", "message": "CAMEL-19069 (#9369)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NTY5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464275690", "body": "@Nayananga a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the `@Disabled`. An example, take a look at this [component IT tests](https://github.com/apache/camel/tree/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob). You will need to add a maven profile that will run IT tests that end with IT [here](https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/pom.xml#L87). And then, you can add a [Util class](https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/BlobTestUtils.java#L40) to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:\r\n`mvn clean test -PfullTests` ", "bodyText": "@Nayananga a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the @Disabled. An example, take a look at this component IT tests. You will need to add a maven profile that will run IT tests that end with IT here. And then, you can add a Util class to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:\nmvn clean test -PfullTests", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Nayananga/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Nayananga\">@Nayananga</a> a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the <code>@Disabled</code>. An example, take a look at this <a href=\"https://github.com/apache/camel/tree/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob\">component IT tests</a>. You will need to add a maven profile that will run IT tests that end with IT <a href=\"https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/pom.xml#L87\">here</a>. And then, you can add a <a href=\"https://github.com/apache/camel/blob/master/components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/BlobTestUtils.java#L40\">Util class</a> to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:<br>\n<code>mvn clean test -PfullTests</code></p>", "author": "omarsmak", "createdAt": "2020-08-03T08:45:16Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.UUID;\n+\n+import javax.crypto.KeyGenerator;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.PutObjectArgs;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.minio.MinioOperations;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 9593d44cb13..7fec2fc9332 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -49,13 +55,15 @@ import static org.junit.jupiter.api.Assertions.fail;\n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n \n+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n     final ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n     String key = UUID.randomUUID().toString();\n+\n     @BindToRegistry(\"minioClient\")\n     MinioClient minioClient =\n             MinioClient.builder()\n-                    .endpoint(\"https://play.min.io\")\n-                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+                    .endpoint(properties.getProperty(\"endpoint\"))\n+                    .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n                     .build();\n     @EndpointInject\n     private ProducerTemplate template;\n", "next_change": {"commit": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 7fec2fc9332..9593d44cb13 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -55,15 +49,13 @@ import static org.junit.jupiter.api.Assertions.fail;\n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n \n-    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n     final ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n     String key = UUID.randomUUID().toString();\n-\n     @BindToRegistry(\"minioClient\")\n     MinioClient minioClient =\n             MinioClient.builder()\n-                    .endpoint(properties.getProperty(\"endpoint\"))\n-                    .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n+                    .endpoint(\"https://play.min.io\")\n+                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n                     .build();\n     @EndpointInject\n     private ProducerTemplate template;\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\ndeleted file mode 100644\nindex 9593d44cb13..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,161 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio.integration;\n-\n-import java.io.*;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.security.SecureRandom;\n-import java.util.UUID;\n-\n-import javax.crypto.KeyGenerator;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.MinioClient;\n-import io.minio.PutObjectArgs;\n-import io.minio.ServerSideEncryption;\n-import io.minio.ServerSideEncryptionCustomerKey;\n-import org.apache.camel.BindToRegistry;\n-import org.apache.camel.EndpointInject;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ProducerTemplate;\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.minio.MinioConstants;\n-import org.apache.camel.component.minio.MinioOperations;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n-\n-    final ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n-    String key = UUID.randomUUID().toString();\n-    @BindToRegistry(\"minioClient\")\n-    MinioClient minioClient =\n-            MinioClient.builder()\n-                    .endpoint(\"https://play.min.io\")\n-                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-                    .build();\n-    @EndpointInject\n-    private ProducerTemplate template;\n-\n-    @EndpointInject(\"mock:result\")\n-    private MockEndpoint result;\n-\n-    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n-        KeyGenerator generator;\n-        try {\n-            generator = KeyGenerator.getInstance(\"AES\");\n-            generator.init(256, new SecureRandom());\n-            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n-        } catch (Exception e) {\n-            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n-            return null;\n-        }\n-    }\n-\n-    @Test\n-    public void sendIn() throws Exception {\n-\n-        result.expectedMessageCount(1);\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            String string = \"Test\";\n-\n-            //use ByteArrayInputStream to get the bytes of the String and convert them to InputStream.\n-            InputStream inputStream = new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8));\n-\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(\"mycamel\")\n-                    .object(\"test.txt\")\n-                    .sse(secretKey);\n-\n-            exchange.getIn().setBody(putObjectRequest);\n-        });\n-\n-        template.send(\"direct:copyObject\", exchange -> {\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(\"mycamel\")\n-                    .object(\"test.txt\")\n-                    .ssec(secretKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(\"mycamel1\")\n-                    .object(\"test1.txt\")\n-                    .source(copySourceBuilder.build())\n-                    .sse(secretKey);\n-\n-            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.copyObject);\n-            exchange.getIn().setBody(copyObjectRequest);\n-        });\n-\n-        Exchange respond = template.request(\"direct:getObject\", exchange -> {\n-            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder()\n-                    .object(\"test1.txt\")\n-                    .bucket(\"mycamel1\")\n-                    .ssec(secretKey);\n-\n-            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.getObject);\n-            exchange.getIn().setBody(getObjectRequest);\n-        });\n-\n-        InputStream minio = respond.getIn().getBody(InputStream.class);\n-\n-\n-        assertEquals(\"Test\", readInputStream(minio));\n-\n-        assertMockEndpointsSatisfied();\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() {\n-        return new RouteBuilder() {\n-            @Override\n-            public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false&pojoRequest=true\";\n-                String minioEndpoint1 = \"minio://mycamel1?autoCreateBucket=false&pojoRequest=true\";\n-\n-                from(\"direct:putObject\").to(minioEndpoint);\n-\n-                from(\"direct:copyObject\").to(minioEndpoint);\n-\n-                from(\"direct:getObject\").to(minioEndpoint1).to(\"mock:result\");\n-\n-            }\n-        };\n-    }\n-\n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nnew file mode 100644\nindex 00000000000..f5b0c61608c\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.UUID;\n+\n+import javax.crypto.KeyGenerator;\n+\n+import io.minio.GetObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.minio.MinioOperations;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n+    \n+    String key = UUID.randomUUID().toString();\n+    ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient minioClient =\n+            MinioClient.builder()\n+                    .endpoint(\"https://play.min.io\")\n+                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+                    .build();\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+\n+        result.expectedMessageCount(1);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setBody(\"Test\");\n+        });\n+\n+        template.send(\"direct:copyObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setHeader(MinioConstants.DESTINATION_OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setHeader(MinioConstants.BUCKET_DESTINATION_NAME, \"mycamel1\");\n+            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.copyObject);\n+        });\n+        \n+        Exchange respond = template.request(\"direct:getObject\", exchange -> {\n+            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder()\n+                    .object(\"test1.txt\")\n+                    .bucket(\"mycamel1\")\n+                    .ssec(secretKey);\n+            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.getObject);\n+            exchange.getIn().setBody(getObjectRequest);\n+        });\n+        \n+        InputStream minio = respond.getIn().getBody(InputStream.class);\n+        \n+\n+        assertEquals(\"Test\", readInputStream(minio));\n+\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() throws Exception {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint1 = \"minio://mycamel1?autoCreateBucket=false&pojoRequest=true\";\n+                from(\"direct:putObject\").setHeader(MinioConstants.OBJECT_NAME, constant(\"test.txt\")).setBody(constant(\"Test\")).to(minioEndpoint);\n+\n+                from(\"direct:copyObject\").to(minioEndpoint);\n+                \n+                from(\"direct:getObject\").to(minioEndpoint1).to(\"mock:result\");\n+\n+            }\n+        };\n+    }\n+    \n+    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n+        KeyGenerator generator;\n+        try {\n+            generator = KeyGenerator.getInstance(\"AES\");\n+            generator.init(256, new SecureRandom());\n+            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n+        } catch (Exception e) {\n+            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n+            return null;\n+        }\n+    }\n+    \n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n+}\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex f5b0c61608c..9593d44cb13 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -96,40 +131,29 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n     }\n \n     @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n+    protected RouteBuilder createRouteBuilder() {\n         return new RouteBuilder() {\n             @Override\n             public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false&pojoRequest=true\";\n                 String minioEndpoint1 = \"minio://mycamel1?autoCreateBucket=false&pojoRequest=true\";\n-                from(\"direct:putObject\").setHeader(MinioConstants.OBJECT_NAME, constant(\"test.txt\")).setBody(constant(\"Test\")).to(minioEndpoint);\n+\n+                from(\"direct:putObject\").to(minioEndpoint);\n \n                 from(\"direct:copyObject\").to(minioEndpoint);\n-                \n+\n                 from(\"direct:getObject\").to(minioEndpoint1).to(\"mock:result\");\n \n             }\n         };\n     }\n-    \n-    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n-        KeyGenerator generator;\n-        try {\n-            generator = KeyGenerator.getInstance(\"AES\");\n-            generator.init(256, new SecureRandom());\n-            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n-        } catch (Exception e) {\n-            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n-            return null;\n-        }\n-    }\n-    \n+\n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n-                textBuilder.append((char)c);\n+                textBuilder.append((char) c);\n             }\n         }\n         return textBuilder.toString();\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 7fec2fc9332..9593d44cb13 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -71,7 +63,16 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n     @EndpointInject(\"mock:result\")\n     private MockEndpoint result;\n \n-    public MinioCopyObjectCustomerKeyOperationIntegrationTest() throws IOException {\n+    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n+        KeyGenerator generator;\n+        try {\n+            generator = KeyGenerator.getInstance(\"AES\");\n+            generator.init(256, new SecureRandom());\n+            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n+        } catch (Exception e) {\n+            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n+            return null;\n+        }\n     }\n \n     @Test\n", "next_change": {"commit": "1535a16a62132c3be469a43230d0507eba76063c", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\ndeleted file mode 100644\nindex 9593d44cb13..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ /dev/null\n", "chunk": "@@ -1,161 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio.integration;\n-\n-import java.io.*;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.security.SecureRandom;\n-import java.util.UUID;\n-\n-import javax.crypto.KeyGenerator;\n-\n-import io.minio.CopyObjectArgs;\n-import io.minio.CopySource;\n-import io.minio.GetObjectArgs;\n-import io.minio.MinioClient;\n-import io.minio.PutObjectArgs;\n-import io.minio.ServerSideEncryption;\n-import io.minio.ServerSideEncryptionCustomerKey;\n-import org.apache.camel.BindToRegistry;\n-import org.apache.camel.EndpointInject;\n-import org.apache.camel.Exchange;\n-import org.apache.camel.ProducerTemplate;\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.minio.MinioConstants;\n-import org.apache.camel.component.minio.MinioOperations;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit5.CamelTestSupport;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n-@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n-public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n-\n-    final ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n-    String key = UUID.randomUUID().toString();\n-    @BindToRegistry(\"minioClient\")\n-    MinioClient minioClient =\n-            MinioClient.builder()\n-                    .endpoint(\"https://play.min.io\")\n-                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n-                    .build();\n-    @EndpointInject\n-    private ProducerTemplate template;\n-\n-    @EndpointInject(\"mock:result\")\n-    private MockEndpoint result;\n-\n-    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n-        KeyGenerator generator;\n-        try {\n-            generator = KeyGenerator.getInstance(\"AES\");\n-            generator.init(256, new SecureRandom());\n-            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n-        } catch (Exception e) {\n-            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n-            return null;\n-        }\n-    }\n-\n-    @Test\n-    public void sendIn() throws Exception {\n-\n-        result.expectedMessageCount(1);\n-\n-        template.send(\"direct:putObject\", exchange -> {\n-            String string = \"Test\";\n-\n-            //use ByteArrayInputStream to get the bytes of the String and convert them to InputStream.\n-            InputStream inputStream = new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8));\n-\n-            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n-                    .stream(inputStream, inputStream.available(), -1)\n-                    .bucket(\"mycamel\")\n-                    .object(\"test.txt\")\n-                    .sse(secretKey);\n-\n-            exchange.getIn().setBody(putObjectRequest);\n-        });\n-\n-        template.send(\"direct:copyObject\", exchange -> {\n-\n-            CopySource.Builder copySourceBuilder = CopySource.builder()\n-                    .bucket(\"mycamel\")\n-                    .object(\"test.txt\")\n-                    .ssec(secretKey);\n-\n-            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n-                    .bucket(\"mycamel1\")\n-                    .object(\"test1.txt\")\n-                    .source(copySourceBuilder.build())\n-                    .sse(secretKey);\n-\n-            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.copyObject);\n-            exchange.getIn().setBody(copyObjectRequest);\n-        });\n-\n-        Exchange respond = template.request(\"direct:getObject\", exchange -> {\n-            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder()\n-                    .object(\"test1.txt\")\n-                    .bucket(\"mycamel1\")\n-                    .ssec(secretKey);\n-\n-            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.getObject);\n-            exchange.getIn().setBody(getObjectRequest);\n-        });\n-\n-        InputStream minio = respond.getIn().getBody(InputStream.class);\n-\n-\n-        assertEquals(\"Test\", readInputStream(minio));\n-\n-        assertMockEndpointsSatisfied();\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() {\n-        return new RouteBuilder() {\n-            @Override\n-            public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false&pojoRequest=true\";\n-                String minioEndpoint1 = \"minio://mycamel1?autoCreateBucket=false&pojoRequest=true\";\n-\n-                from(\"direct:putObject\").to(minioEndpoint);\n-\n-                from(\"direct:copyObject\").to(minioEndpoint);\n-\n-                from(\"direct:getObject\").to(minioEndpoint1).to(\"mock:result\");\n-\n-            }\n-        };\n-    }\n-\n-    private String readInputStream(InputStream minioObject) throws IOException {\n-        StringBuilder textBuilder = new StringBuilder();\n-        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n-            int c;\n-            while ((c = reader.read()) != -1) {\n-                textBuilder.append((char) c);\n-            }\n-        }\n-        return textBuilder.toString();\n-    }\n-}\n", "next_change": {"commit": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nnew file mode 100644\nindex 00000000000..f5b0c61608c\n--- /dev/null\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.UUID;\n+\n+import javax.crypto.KeyGenerator;\n+\n+import io.minio.GetObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.minio.MinioOperations;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n+    \n+    String key = UUID.randomUUID().toString();\n+    ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient minioClient =\n+            MinioClient.builder()\n+                    .endpoint(\"https://play.min.io\")\n+                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+                    .build();\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+\n+        result.expectedMessageCount(1);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setBody(\"Test\");\n+        });\n+\n+        template.send(\"direct:copyObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test.txt\");\n+            exchange.getIn().setHeader(MinioConstants.DESTINATION_OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setHeader(MinioConstants.BUCKET_DESTINATION_NAME, \"mycamel1\");\n+            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.copyObject);\n+        });\n+        \n+        Exchange respond = template.request(\"direct:getObject\", exchange -> {\n+            GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder()\n+                    .object(\"test1.txt\")\n+                    .bucket(\"mycamel1\")\n+                    .ssec(secretKey);\n+            exchange.getIn().setHeader(MinioConstants.MINIO_OPERATION, MinioOperations.getObject);\n+            exchange.getIn().setBody(getObjectRequest);\n+        });\n+        \n+        InputStream minio = respond.getIn().getBody(InputStream.class);\n+        \n+\n+        assertEquals(\"Test\", readInputStream(minio));\n+\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() throws Exception {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint1 = \"minio://mycamel1?autoCreateBucket=false&pojoRequest=true\";\n+                from(\"direct:putObject\").setHeader(MinioConstants.OBJECT_NAME, constant(\"test.txt\")).setBody(constant(\"Test\")).to(minioEndpoint);\n+\n+                from(\"direct:copyObject\").to(minioEndpoint);\n+                \n+                from(\"direct:getObject\").to(minioEndpoint1).to(\"mock:result\");\n+\n+            }\n+        };\n+    }\n+    \n+    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n+        KeyGenerator generator;\n+        try {\n+            generator = KeyGenerator.getInstance(\"AES\");\n+            generator.init(256, new SecureRandom());\n+            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n+        } catch (Exception e) {\n+            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n+            return null;\n+        }\n+    }\n+    \n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char)c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n+}\n", "next_change": {"commit": "f2e79fda016b69999310571208bcda56d08251a4", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex f5b0c61608c..9593d44cb13 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -96,40 +131,29 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n     }\n \n     @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n+    protected RouteBuilder createRouteBuilder() {\n         return new RouteBuilder() {\n             @Override\n             public void configure() {\n-                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false&pojoRequest=true\";\n                 String minioEndpoint1 = \"minio://mycamel1?autoCreateBucket=false&pojoRequest=true\";\n-                from(\"direct:putObject\").setHeader(MinioConstants.OBJECT_NAME, constant(\"test.txt\")).setBody(constant(\"Test\")).to(minioEndpoint);\n+\n+                from(\"direct:putObject\").to(minioEndpoint);\n \n                 from(\"direct:copyObject\").to(minioEndpoint);\n-                \n+\n                 from(\"direct:getObject\").to(minioEndpoint1).to(\"mock:result\");\n \n             }\n         };\n     }\n-    \n-    protected static ServerSideEncryptionCustomerKey generateSecretKey() {\n-        KeyGenerator generator;\n-        try {\n-            generator = KeyGenerator.getInstance(\"AES\");\n-            generator.init(256, new SecureRandom());\n-            return ServerSideEncryption.withCustomerKey(generator.generateKey());\n-        } catch (Exception e) {\n-            fail(\"Unable to generate symmetric key: \" + e.getMessage());\n-            return null;\n-        }\n-    }\n-    \n+\n     private String readInputStream(InputStream minioObject) throws IOException {\n         StringBuilder textBuilder = new StringBuilder();\n         try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n             int c;\n             while ((c = reader.read()) != -1) {\n-                textBuilder.append((char)c);\n+                textBuilder.append((char) c);\n             }\n         }\n         return textBuilder.toString();\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 9593d44cb13..7fec2fc9332 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -49,13 +55,15 @@ import static org.junit.jupiter.api.Assertions.fail;\n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTestSupport {\n \n+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();\n     final ServerSideEncryptionCustomerKey secretKey = generateSecretKey();\n     String key = UUID.randomUUID().toString();\n+\n     @BindToRegistry(\"minioClient\")\n     MinioClient minioClient =\n             MinioClient.builder()\n-                    .endpoint(\"https://play.min.io\")\n-                    .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+                    .endpoint(properties.getProperty(\"endpoint\"))\n+                    .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n                     .build();\n     @EndpointInject\n     private ProducerTemplate template;\n", "next_change": {"commit": "4ea9e6c357371682b855d2d79655b41120331b7a", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 7fec2fc9332..226927fb7e2 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -60,11 +60,10 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n     String key = UUID.randomUUID().toString();\n \n     @BindToRegistry(\"minioClient\")\n-    MinioClient minioClient =\n-            MinioClient.builder()\n-                    .endpoint(properties.getProperty(\"endpoint\"))\n-                    .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n-                    .build();\n+    MinioClient minioClient = MinioClient.builder()\n+            .endpoint(properties.getProperty(\"endpoint\"))\n+            .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n+            .build();\n     @EndpointInject\n     private ProducerTemplate template;\n \n", "next_change": {"commit": "c40364a59815239e63d959faa982cb5212a217a3", "changed_code": [{"header": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nsimilarity index 93%\nrename from components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nrename to components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 226927fb7e2..aa75e775901 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/remoteTests/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n", "chunk": "@@ -64,17 +63,18 @@ public class MinioCopyObjectCustomerKeyOperationIntegrationTest extends CamelTes\n             .endpoint(properties.getProperty(\"endpoint\"))\n             .credentials(properties.getProperty(\"accessKey\"), properties.getProperty(\"secretKey\"))\n             .build();\n+\n     @EndpointInject\n     private ProducerTemplate template;\n \n     @EndpointInject(\"mock:result\")\n     private MockEndpoint result;\n \n-    public MinioCopyObjectCustomerKeyOperationIntegrationTest() throws IOException {\n+    MinioCopyObjectCustomerKeyOperationIntegrationTest() throws IOException {\n     }\n \n     @Test\n-    public void sendIn() throws Exception {\n+    void sendIn() throws Exception {\n \n         result.expectedMessageCount(1);\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67bad5a5978af29bb4d3894a2a1b576c564a5408", "message": "Merge commit", "committedDate": null}, {"oid": "4ea9e6c357371682b855d2d79655b41120331b7a", "committedDate": "2020-08-18 09:33:29 +0200", "message": "[CAMEL-14578] Reformat"}, {"oid": "c40364a59815239e63d959faa982cb5212a217a3", "committedDate": "2020-08-27 08:03:20 +0200", "message": "Added testcontainer integration test for Minio (#4101)"}]}, {"oid": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "url": "https://github.com/apache/camel/commit/fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-03T18:42:35Z", "type": "forcePushed"}, {"oid": "c0038995d0dd7129eade273ff2039a79e00d49f6", "url": "https://github.com/apache/camel/commit/c0038995d0dd7129eade273ff2039a79e00d49f6", "message": "Code simplified", "committedDate": "2020-08-06T07:48:09Z", "type": "forcePushed"}, {"oid": "d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "url": "https://github.com/apache/camel/commit/d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-06T18:25:17Z", "type": "forcePushed"}, {"oid": "0e860b49082c2ce8ae735e48cfb746850711f22e", "url": "https://github.com/apache/camel/commit/0e860b49082c2ce8ae735e48cfb746850711f22e", "message": "Removed redundant check", "committedDate": "2020-08-07T05:02:20Z", "type": "forcePushed"}, {"oid": "1535a16a62132c3be469a43230d0507eba76063c", "url": "https://github.com/apache/camel/commit/1535a16a62132c3be469a43230d0507eba76063c", "message": "Added component basic sketch", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "228df3f1623107af49b9755bf053b063e3375dda", "url": "https://github.com/apache/camel/commit/228df3f1623107af49b9755bf053b063e3375dda", "message": "Ran mvn clean install -Pfastinstall", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "0fd206c77f5d3fa320bad1cd34683710c229b2cf", "url": "https://github.com/apache/camel/commit/0fd206c77f5d3fa320bad1cd34683710c229b2cf", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "url": "https://github.com/apache/camel/commit/90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "message": "Added existing implementation and fixed build failures", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1e66a510a172e04b1bbeece7e1a5d330944daf14", "url": "https://github.com/apache/camel/commit/1e66a510a172e04b1bbeece7e1a5d330944daf14", "message": "Code reformatted", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "c6a9b5ac3b4d5a128c045495008174d905492576", "url": "https://github.com/apache/camel/commit/c6a9b5ac3b4d5a128c045495008174d905492576", "message": "Updated imports", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "cfce4fb8f46ec8057652ad366b47bbc93da82849", "url": "https://github.com/apache/camel/commit/cfce4fb8f46ec8057652ad366b47bbc93da82849", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "url": "https://github.com/apache/camel/commit/1328d8106703a3d90d671d8d32c5eaa7419fa147", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "843335696c2da037e026ad7cc0318cf36494b183", "url": "https://github.com/apache/camel/commit/843335696c2da037e026ad7cc0318cf36494b183", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "2de2427460630152d5be00c6c33bad22c015f2cd", "url": "https://github.com/apache/camel/commit/2de2427460630152d5be00c6c33bad22c015f2cd", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "url": "https://github.com/apache/camel/commit/bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "152fd8b381686621d3de6a6300323fe89f42720b", "url": "https://github.com/apache/camel/commit/152fd8b381686621d3de6a6300323fe89f42720b", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "url": "https://github.com/apache/camel/commit/cce1852e6ad88c7c3a35134e8b0771f3a216e754", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "0acedfcedaaf81796626b5f205f187b1262137ec", "url": "https://github.com/apache/camel/commit/0acedfcedaaf81796626b5f205f187b1262137ec", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "url": "https://github.com/apache/camel/commit/acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "message": "Added new implementations for MinioProducer", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "url": "https://github.com/apache/camel/commit/45beb5ddeaad938003b700bcf4f34b1da4105be3", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "url": "https://github.com/apache/camel/commit/c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "message": "Updated to Minio 7.1.0", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "6972439ee57658ed13ff58c89df749dfafbfa18b", "url": "https://github.com/apache/camel/commit/6972439ee57658ed13ff58c89df749dfafbfa18b", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "f4aea6f0902b2108a296a183973813785969618b", "url": "https://github.com/apache/camel/commit/f4aea6f0902b2108a296a183973813785969618b", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "url": "https://github.com/apache/camel/commit/9dd0f1297a490222db92d0e8aee5919403fdcda7", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "3e2463ac08dfe95e015a7c22394bba783110e159", "url": "https://github.com/apache/camel/commit/3e2463ac08dfe95e015a7c22394bba783110e159", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "217cea4fdb007779cfeaa3f709c8b5111de0ec22", "url": "https://github.com/apache/camel/commit/217cea4fdb007779cfeaa3f709c8b5111de0ec22", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "a118ffe604943fd210497c88aaf14265888eceb8", "url": "https://github.com/apache/camel/commit/a118ffe604943fd210497c88aaf14265888eceb8", "message": "ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "f2e79fda016b69999310571208bcda56d08251a4", "url": "https://github.com/apache/camel/commit/f2e79fda016b69999310571208bcda56d08251a4", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "08f2029caf83805ec099e160924b48da294350d8", "url": "https://github.com/apache/camel/commit/08f2029caf83805ec099e160924b48da294350d8", "message": "Integration test fixed", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "url": "https://github.com/apache/camel/commit/dbe1b9d6a59d2d844b774b48c576d31519b8239e", "message": "Updated code to mimic the AWS2 s3 component", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "5e215f54a6df69b8da845a48ab9966c6f5afdef8", "url": "https://github.com/apache/camel/commit/5e215f54a6df69b8da845a48ab9966c6f5afdef8", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "0c39393a1c2b10699825ca6286d2d5f3c0062dab", "url": "https://github.com/apache/camel/commit/0c39393a1c2b10699825ca6286d2d5f3c0062dab", "message": "Ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "url": "https://github.com/apache/camel/commit/bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "url": "https://github.com/apache/camel/commit/c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "url": "https://github.com/apache/camel/commit/6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "message": "Added documentation", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "url": "https://github.com/apache/camel/commit/166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "message": "Minor changes to the tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "429db9080e37920a959ef6837141e7ed94357f9d", "url": "https://github.com/apache/camel/commit/429db9080e37920a959ef6837141e7ed94357f9d", "message": "Fixed typo", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "585e4deebddd6999431c35a3b5a8f3ce72f1f974", "url": "https://github.com/apache/camel/commit/585e4deebddd6999431c35a3b5a8f3ce72f1f974", "message": "Added missing labels", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "d09d6135cbb90dde34b080b393621fa69c16777d", "url": "https://github.com/apache/camel/commit/d09d6135cbb90dde34b080b393621fa69c16777d", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c627c28ed07400606c1f31ef1a6a6e0ce975da10", "url": "https://github.com/apache/camel/commit/c627c28ed07400606c1f31ef1a6a6e0ce975da10", "message": "Removed wildcard imports", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "e01c571ced63b6f85456cb419085ad2a5db9df3d", "url": "https://github.com/apache/camel/commit/e01c571ced63b6f85456cb419085ad2a5db9df3d", "message": "Removed redundant error handling and extracted removeObject method in MinioConsumer.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "652ceb5290bc403dfa12cc3dfc27447163f07e20", "url": "https://github.com/apache/camel/commit/652ceb5290bc403dfa12cc3dfc27447163f07e20", "message": "Renamed GetMinioClient.java to MinioRemoteClientImpl.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5a8af2544004b9d92e26d5db558932c2bb446f4f", "url": "https://github.com/apache/camel/commit/5a8af2544004b9d92e26d5db558932c2bb446f4f", "message": "Renamed Offset and Length in MinioConstants.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "170ea27658ce31d585e0df8cddc599d6e2e63d74", "url": "https://github.com/apache/camel/commit/170ea27658ce31d585e0df8cddc599d6e2e63d74", "message": "Added more cases in MinioComponentConfigurationTest.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5c97f24959e7766acbc0e8159512233954d0ecbb", "url": "https://github.com/apache/camel/commit/5c97f24959e7766acbc0e8159512233954d0ecbb", "message": "Added new MinioConstant", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "1f08aa281662d69aecfdbad038df3b1d8add228b", "url": "https://github.com/apache/camel/commit/1f08aa281662d69aecfdbad038df3b1d8add228b", "message": "Replaced != 0 with > 0", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "fa241fb3e2068636d81e3e918a63414639c06eec", "url": "https://github.com/apache/camel/commit/fa241fb3e2068636d81e3e918a63414639c06eec", "message": "Handled processCommit exception", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "url": "https://github.com/apache/camel/commit/27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "message": "Handled createExchange exceptions", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "url": "https://github.com/apache/camel/commit/73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "message": "Reformatted code", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "7136941423266b6a21f290a250e1e0017e439219", "url": "https://github.com/apache/camel/commit/7136941423266b6a21f290a250e1e0017e439219", "message": "Code simplified", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "url": "https://github.com/apache/camel/commit/2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "url": "https://github.com/apache/camel/commit/56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "message": "Renamed autocloseBody to autoCloseBody in MinioConfiguration.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "409614e6426f1393c9c465c7dae4ff670902b2d2", "url": "https://github.com/apache/camel/commit/409614e6426f1393c9c465c7dae4ff670902b2d2", "message": "Minor fix", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "url": "https://github.com/apache/camel/commit/c308169b9ee19d93399a599b1a4df08e7816b5fd", "message": "Replaced == null / != null with isEmpty / isNotEmpty", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "url": "https://github.com/apache/camel/commit/c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "message": "Removed redundant check", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "b08f49d96a2ce88cc46a80decd169986249b5779", "url": "https://github.com/apache/camel/commit/b08f49d96a2ce88cc46a80decd169986249b5779", "message": "Extracted all credentials into minio_key.properties file", "committedDate": "2020-08-08T16:44:10Z", "type": "commit"}]}