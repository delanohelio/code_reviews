{"pr_number": 355, "pr_title": "Slim 2077 create new secret mgmt application", "pr_author": "evanbarn", "pr_createdAt": "2020-06-18T12:57:42Z", "pr_url": "https://github.com/OSGP/open-smart-grid-platform/pull/355", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4NzMwOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450787308", "body": "this seems confusing. Can these file ever be null? \r\n\r\nin case any of the files is null, the Provider does not work, correct ? RSA does not work unless both keys are in order.", "bodyText": "this seems confusing. Can these file ever be null?\nin case any of the files is null, the Provider does not work, correct ? RSA does not work unless both keys are in order.", "bodyHTML": "<p dir=\"auto\">this seems confusing. Can these file ever be null?</p>\n<p dir=\"auto\">in case any of the files is null, the Provider does not work, correct ? RSA does not work unless both keys are in order.</p>", "author": "coendamen", "createdAt": "2020-07-07T11:13:00Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -16,31 +18,25 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String ALG = \"RSA\";\n-    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n \n     private Key publicKey;\n     private Key privateKey;\n \n-    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n-        try {\n-            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+    public void setPrivateKeyStore(File privateKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        super.setKeyFile(privateKeyStoreFile);\n+    }\n \n-            if (privateKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-                privateKey = keyFactory.generatePrivate(privateKeySpec);\n-                super.setKeyFile(privateKeyStoreFile);\n-            }\n-            if (publicKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-                publicKey = keyFactory.generatePublic(publicKeySpec);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Something went wrong during construction of \"\n-                    + \"RsaEncryptionProvider\", e);\n-        }\n+    public void setPublicKeyStore(File publicKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n     }\n \n     protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4NzU3MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450787570", "body": "these can be final I think? ", "bodyText": "these can be final I think?", "bodyHTML": "<p dir=\"auto\">these can be final I think?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:13:36Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -16,31 +18,25 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String ALG = \"RSA\";\n-    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n \n     private Key publicKey;\n     private Key privateKey;\n \n-    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n-        try {\n-            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+    public void setPrivateKeyStore(File privateKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        super.setKeyFile(privateKeyStoreFile);\n+    }\n \n-            if (privateKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-                privateKey = keyFactory.generatePrivate(privateKeySpec);\n-                super.setKeyFile(privateKeyStoreFile);\n-            }\n-            if (publicKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-                publicKey = keyFactory.generatePublic(publicKeySpec);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Something went wrong during construction of \"\n-                    + \"RsaEncryptionProvider\", e);\n-        }\n+    public void setPublicKeyStore(File publicKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n     }\n \n     protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4ODc4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450788787", "body": "Why check on null if this would never be the case? consider rewriting the constructor.\r\n\r\n", "bodyText": "Why check on null if this would never be the case? consider rewriting the constructor.", "bodyHTML": "<p dir=\"auto\">Why check on null if this would never be the case? consider rewriting the constructor.</p>", "author": "coendamen", "createdAt": "2020-07-07T11:16:07Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n+        try {\n+            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+\n+            if (privateKeyStoreFile != null) {\n+                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+                privateKey = keyFactory.generatePrivate(privateKeySpec);\n+                super.setKeyFile(privateKeyStoreFile);\n+            }\n+            if (publicKeyStoreFile != null) {\n+                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+                publicKey = keyFactory.generatePublic(publicKeySpec);\n+            }\n+        } catch (Exception e) {\n+            throw new EncrypterException(\"Something went wrong during construction of \"\n+                    + \"RsaEncryptionProvider\", e);\n+        }\n+    }\n+\n+    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n+        return Cipher.getInstance(ALGORITHM);\n+    }\n+\n+    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n+        if (cipherMode == Cipher.ENCRYPT_MODE) {\n+            if (publicKey == null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -48,18 +44,7 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        if (cipherMode == Cipher.ENCRYPT_MODE) {\n-            if (publicKey == null) {\n-                throw new EncrypterException(\"Cannot RSA encrypt because no public key is defined.\");\n-            }\n-            return publicKey;\n-        } else if (cipherMode == Cipher.DECRYPT_MODE) {\n-            if (privateKey == null) {\n-                throw new EncrypterException(\"Cannot RSA encrypt because no private key is defined.\");\n-            }\n-            return privateKey;\n-        }\n-        throw new EncrypterException(\"Invalid cipher mode specified.\");\n+        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n     }\n \n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTMxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450789312", "body": "I would rewrite this into several methods:\r\n", "bodyText": "I would rewrite this into several methods:", "bodyHTML": "<p dir=\"auto\">I would rewrite this into several methods:</p>", "author": "coendamen", "createdAt": "2020-07-07T11:17:11Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n+        try {\n+            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+\n+            if (privateKeyStoreFile != null) {\n+                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+                privateKey = keyFactory.generatePrivate(privateKeySpec);\n+                super.setKeyFile(privateKeyStoreFile);\n+            }\n+            if (publicKeyStoreFile != null) {\n+                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+                publicKey = keyFactory.generatePublic(publicKeySpec);\n+            }\n+        } catch (Exception e) {\n+            throw new EncrypterException(\"Something went wrong during construction of \"\n+                    + \"RsaEncryptionProvider\", e);\n+        }\n+    }\n+\n+    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n+        return Cipher.getInstance(ALGORITHM);\n+    }\n+\n+    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n+        if (cipherMode == Cipher.ENCRYPT_MODE) {\n+            if (publicKey == null) {\n+                throw new EncrypterException(\"Cannot RSA encrypt because no public key is defined.\");\n+            }\n+            return publicKey;\n+        } else if (cipherMode == Cipher.DECRYPT_MODE) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -48,18 +44,7 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        if (cipherMode == Cipher.ENCRYPT_MODE) {\n-            if (publicKey == null) {\n-                throw new EncrypterException(\"Cannot RSA encrypt because no public key is defined.\");\n-            }\n-            return publicKey;\n-        } else if (cipherMode == Cipher.DECRYPT_MODE) {\n-            if (privateKey == null) {\n-                throw new EncrypterException(\"Cannot RSA encrypt because no private key is defined.\");\n-            }\n-            return privateKey;\n-        }\n-        throw new EncrypterException(\"Invalid cipher mode specified.\");\n+        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n     }\n \n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTYxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450789612", "body": "are these constants used on other classes? If not, make private", "bodyText": "are these constants used on other classes? If not, make private", "bodyHTML": "<p dir=\"auto\">are these constants used on other classes? If not, make private</p>", "author": "coendamen", "createdAt": "2020-07-07T11:17:50Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -16,31 +18,25 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String ALG = \"RSA\";\n-    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n \n     private Key publicKey;\n     private Key privateKey;\n \n-    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n-        try {\n-            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+    public void setPrivateKeyStore(File privateKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        super.setKeyFile(privateKeyStoreFile);\n+    }\n \n-            if (privateKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-                privateKey = keyFactory.generatePrivate(privateKeySpec);\n-                super.setKeyFile(privateKeyStoreFile);\n-            }\n-            if (publicKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-                publicKey = keyFactory.generatePublic(publicKeySpec);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Something went wrong during construction of \"\n-                    + \"RsaEncryptionProvider\", e);\n-        }\n+    public void setPublicKeyStore(File publicKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n     }\n \n     protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5MDA1NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450790054", "body": "why not create a SecretKey class with a constuctor and use Lombok ?", "bodyText": "why not create a SecretKey class with a constuctor and use Lombok ?", "bodyHTML": "<p dir=\"auto\">why not create a SecretKey class with a constuctor and use Lombok ?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:18:43Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    public static final String ALG = \"AES\";\n+    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    public static final String PROVIDER = \"SunJCE\";\n+    public static final String FORMAT = \"RAW\";\n+    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+\n+    private byte[] key;\n+\n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n+    public JreEncryptionProvider(File keyStoreFile) {\n+        try {\n+            super.setKeyFile(keyStoreFile);\n+            this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n+        } catch (IOException e) {\n+            throw new EncrypterException(\"Could not read keystore\");\n+        }\n+    }\n+\n+    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+\n+        if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n+            throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n+        }\n+\n+        return new SecretKey() {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex eb9e9df8d0..6268a9fb92 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -27,28 +27,28 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    public static final String ALG = \"AES\";\n-    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    public static final String PROVIDER = \"SunJCE\";\n-    public static final String FORMAT = \"RAW\";\n+    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    private static final String ALG = \"AES\";\n+    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    private static final String PROVIDER = \"SunJCE\";\n+    private static final String FORMAT = \"RAW\";\n     private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n \n-    private byte[] key;\n-\n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n-    }\n+    private final byte[] key;\n \n     public JreEncryptionProvider(File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n         } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\");\n+            throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 6268a9fb92..a6a0ea3bc2 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -45,8 +45,12 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM, PROVIDER);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a6a0ea3bc2..877b3ded42 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -53,13 +55,16 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n             throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n         }\n \n         return new SecretKey() {\n+            private static final long serialVersionUID = 4555243342661334965L;\n+\n             @Override\n             public String getAlgorithm() {\n                 return ALG;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 877b3ded42..a379c98f07 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -16,90 +16,94 @@ import java.security.Key;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n import java.security.spec.AlgorithmParameterSpec;\n-\n import javax.crypto.Cipher;\n import javax.crypto.KeyGenerator;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.SecretKey;\n import javax.crypto.spec.IvParameterSpec;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n-public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class JreEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    private static final String ALG = \"AES\";\n-    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    private static final String PROVIDER = \"SunJCE\";\n-    private static final String FORMAT = \"RAW\";\n-    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+  private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+  private static final String ALG = \"AES\";\n+  private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+  private static final String PROVIDER = \"SunJCE\";\n+  private static final String FORMAT = \"RAW\";\n+  private static final byte[] IV = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+  private static final int KEY_LENGTH = 16;\n \n-    private final byte[] key;\n+  private final byte[] key;\n \n-    public JreEncryptionProvider(File keyStoreFile) throws EncrypterException {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n-        } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public JreEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n+    } catch (final IOException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n-\n-    @Override\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  }\n+\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    @Override\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n-\n-        if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n-            throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n-        }\n-\n-        return new SecretKey() {\n-            private static final long serialVersionUID = 4555243342661334965L;\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n \n-            @Override\n-            public String getAlgorithm() {\n-                return ALG;\n-            }\n-\n-            @Override\n-            public String getFormat() {\n-                return FORMAT;\n-            }\n-\n-            @Override\n-            public byte[] getEncoded() {\n-                return JreEncryptionProvider.this.key;\n-            }\n-        };\n+    if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n+      throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n     }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n+    return new SecretKey() {\n+      private static final long serialVersionUID = 4555243342661334965L;\n+\n+      @Override\n+      public String getAlgorithm() {\n+        return ALG;\n+      }\n+\n+      @Override\n+      public String getFormat() {\n+        return FORMAT;\n+      }\n+\n+      @Override\n+      public byte[] getEncoded() {\n+        return JreEncryptionProvider.this.key;\n+      }\n+    };\n+  }\n+\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n+      keyGenerator.init(KEY_LENGTH * 8);\n+      return this.encrypt(keyGenerator.generateKey().getEncoded(), keyReference).getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n-        try {\n-            KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n-            keyGenerator.init(128);\n-            return this.encrypt(keyGenerator.generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n-    }\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.JRE;\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.JRE;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n }\n", "next_change": {"commit": "fc313d9098483fe1fecab5e9fadb92a1db5d471e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a379c98f07..7bc14faf63 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -106,4 +103,52 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider {\n   public int getSecretByteLength() {\n     return KEY_LENGTH;\n   }\n+\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+\n+      final byte[] iv = new byte[GCM_IV_LENGTH]; // NEVER REUSE THIS IV WITH SAME KEY\n+      this.secureRandom.nextBytes(iv);\n+\n+      final GCMParameterSpec parameterSpec = new GCMParameterSpec(KEY_LENGTH * 8, iv);\n+\n+      cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference), parameterSpec);\n+\n+      final byte[] bytes = cipher.doFinal(secret);\n+      final ByteBuffer byteBuffer = ByteBuffer.allocate(GCM_IV_LENGTH + bytes.length);\n+      byteBuffer.put(iv);\n+      byteBuffer.put(bytes);\n+\n+      return new EncryptedSecret(this.getType(), byteBuffer.array());\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n+\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          String.format(\n+              \"EncryptionProvider for type %s cannot decrypt secrets of type %s\",\n+              this.getType().name(), secret.getType().name()));\n+    }\n+\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      final AlgorithmParameterSpec gcmIv =\n+          new GCMParameterSpec(KEY_LENGTH * 8, secret.getSecret(), 0, GCM_IV_LENGTH);\n+      cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference), gcmIv);\n+\n+      return cipher.doFinal(\n+          secret.getSecret(), GCM_IV_LENGTH, secret.getSecret().length - GCM_IV_LENGTH);\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5MDQ3NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450790474", "body": "I think all these values can be private", "bodyText": "I think all these values can be private", "bodyHTML": "<p dir=\"auto\">I think all these values can be private</p>", "author": "coendamen", "createdAt": "2020-07-07T11:19:32Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex eb9e9df8d0..6268a9fb92 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -27,28 +27,28 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    public static final String ALG = \"AES\";\n-    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    public static final String PROVIDER = \"SunJCE\";\n-    public static final String FORMAT = \"RAW\";\n+    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    private static final String ALG = \"AES\";\n+    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    private static final String PROVIDER = \"SunJCE\";\n+    private static final String FORMAT = \"RAW\";\n     private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n \n-    private byte[] key;\n-\n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n-    }\n+    private final byte[] key;\n \n     public JreEncryptionProvider(File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n         } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\");\n+            throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 6268a9fb92..a6a0ea3bc2 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -45,8 +45,12 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM, PROVIDER);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a6a0ea3bc2..877b3ded42 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -53,13 +55,16 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n             throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n         }\n \n         return new SecretKey() {\n+            private static final long serialVersionUID = 4555243342661334965L;\n+\n             @Override\n             public String getAlgorithm() {\n                 return ALG;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 877b3ded42..a379c98f07 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -16,90 +16,94 @@ import java.security.Key;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n import java.security.spec.AlgorithmParameterSpec;\n-\n import javax.crypto.Cipher;\n import javax.crypto.KeyGenerator;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.SecretKey;\n import javax.crypto.spec.IvParameterSpec;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n-public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class JreEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    private static final String ALG = \"AES\";\n-    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    private static final String PROVIDER = \"SunJCE\";\n-    private static final String FORMAT = \"RAW\";\n-    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+  private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+  private static final String ALG = \"AES\";\n+  private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+  private static final String PROVIDER = \"SunJCE\";\n+  private static final String FORMAT = \"RAW\";\n+  private static final byte[] IV = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+  private static final int KEY_LENGTH = 16;\n \n-    private final byte[] key;\n+  private final byte[] key;\n \n-    public JreEncryptionProvider(File keyStoreFile) throws EncrypterException {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n-        } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public JreEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n+    } catch (final IOException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n-\n-    @Override\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  }\n+\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    @Override\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n-\n-        if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n-            throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n-        }\n-\n-        return new SecretKey() {\n-            private static final long serialVersionUID = 4555243342661334965L;\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n \n-            @Override\n-            public String getAlgorithm() {\n-                return ALG;\n-            }\n-\n-            @Override\n-            public String getFormat() {\n-                return FORMAT;\n-            }\n-\n-            @Override\n-            public byte[] getEncoded() {\n-                return JreEncryptionProvider.this.key;\n-            }\n-        };\n+    if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n+      throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n     }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n+    return new SecretKey() {\n+      private static final long serialVersionUID = 4555243342661334965L;\n+\n+      @Override\n+      public String getAlgorithm() {\n+        return ALG;\n+      }\n+\n+      @Override\n+      public String getFormat() {\n+        return FORMAT;\n+      }\n+\n+      @Override\n+      public byte[] getEncoded() {\n+        return JreEncryptionProvider.this.key;\n+      }\n+    };\n+  }\n+\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n+      keyGenerator.init(KEY_LENGTH * 8);\n+      return this.encrypt(keyGenerator.generateKey().getEncoded(), keyReference).getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n-        try {\n-            KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n-            keyGenerator.init(128);\n-            return this.encrypt(keyGenerator.generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n-    }\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.JRE;\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.JRE;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n }\n", "next_change": {"commit": "fc313d9098483fe1fecab5e9fadb92a1db5d471e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a379c98f07..7bc14faf63 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -106,4 +103,52 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider {\n   public int getSecretByteLength() {\n     return KEY_LENGTH;\n   }\n+\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+\n+      final byte[] iv = new byte[GCM_IV_LENGTH]; // NEVER REUSE THIS IV WITH SAME KEY\n+      this.secureRandom.nextBytes(iv);\n+\n+      final GCMParameterSpec parameterSpec = new GCMParameterSpec(KEY_LENGTH * 8, iv);\n+\n+      cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference), parameterSpec);\n+\n+      final byte[] bytes = cipher.doFinal(secret);\n+      final ByteBuffer byteBuffer = ByteBuffer.allocate(GCM_IV_LENGTH + bytes.length);\n+      byteBuffer.put(iv);\n+      byteBuffer.put(bytes);\n+\n+      return new EncryptedSecret(this.getType(), byteBuffer.array());\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n+\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          String.format(\n+              \"EncryptionProvider for type %s cannot decrypt secrets of type %s\",\n+              this.getType().name(), secret.getType().name()));\n+    }\n+\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      final AlgorithmParameterSpec gcmIv =\n+          new GCMParameterSpec(KEY_LENGTH * 8, secret.getSecret(), 0, GCM_IV_LENGTH);\n+      cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference), gcmIv);\n+\n+      return cipher.doFinal(\n+          secret.getSecret(), GCM_IV_LENGTH, secret.getSecret().length - GCM_IV_LENGTH);\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5MTg0NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450791844", "body": "I would consider creating a super constructor with the Key File instead of a setter, to make the values immutable", "bodyText": "I would consider creating a super constructor with the Key File instead of a setter, to make the values immutable", "bodyHTML": "<p dir=\"auto\">I would consider creating a super constructor with the Key File instead of a setter, to make the values immutable</p>", "author": "coendamen", "createdAt": "2020-07-07T11:22:26Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+    private static final String PROVIDER = \"nCipherKM\";\n+    private static final String TYPE = \"ncipher.sworld\";\n+    private static final byte[] IV = new byte[16];\n+\n+    private KeyStore keyStore;\n+\n+    public HsmEncryptionProvider(File keyStoreFile) {\n+        try {\n+            super.setKeyFile(keyStoreFile);", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex b07f1cdd7b..50b47ff5d4 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -34,7 +34,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     private static final String TYPE = \"ncipher.sworld\";\n     private static final byte[] IV = new byte[16];\n \n-    private KeyStore keyStore;\n+    private final KeyStore keyStore;\n \n     public HsmEncryptionProvider(File keyStoreFile) {\n         try {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 50b47ff5d4..0e72e615b9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -19,20 +19,29 @@ import java.security.NoSuchProviderException;\n import java.security.UnrecoverableKeyException;\n import java.security.cert.CertificateException;\n import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n \n import javax.crypto.Cipher;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.spec.IvParameterSpec;\n \n+import org.apache.commons.codec.binary.Hex;\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+\n+    private static final int KEY_LENGTH = 16;\n     private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n     private static final String PROVIDER = \"nCipherKM\";\n     private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[16];\n+    private static final byte[] IV = new byte[KEY_LENGTH];\n \n     private final KeyStore keyStore;\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 0e72e615b9..18615dbf1f 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -45,27 +45,28 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+    @Override\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         Secret decryptedSecret = super.decrypt(secret, keyReference);\n \n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n+        final byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n \n         if (decryptedSecretBytes.length > KEY_LENGTH) {\n \n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes,\n-                    decryptedSecretBytes.length-16, decryptedSecretBytes.length);\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n+                    decryptedSecretBytes.length-16);\n \n             LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 18615dbf1f..5736344a37 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -57,21 +56,19 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n+        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n \n-        final byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n+        if (decryptedSecret.length > KEY_LENGTH) {\n \n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n+                    decryptedSecret.length-16);\n \n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n \n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+            return truncatedDecryptedSecretBytes;\n         }\n \n         return decryptedSecret;\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 5736344a37..6af1bab88c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -75,7 +76,19 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     @Override\n-    protected Cipher getCipher() {\n+    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n+        //byte[] newSecret = new byte[128/8];\n+        try {\n+            //SecureRandom.getInstance(\"SHA1PRNG\",PROVIDER).nextBytes(newSecret);\n+            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n+        } catch (NoSuchAlgorithmException exc) {\n+            throw new EncrypterException(\"Could not generate secret\", exc);\n+        }\n+        //return newSecret;\n+    }\n+\n+    @Override\n+    protected Cipher getCipher() throws EncrypterException {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n         } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n", "next_change": {"commit": "db4ef46ae5ce0bac840ce7df1675cc1e247fc807", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 6af1bab88c..af000b83c9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -58,33 +58,24 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n \n     @Override\n     public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n-\n         byte[] decryptedSecret = super.decrypt(secret, keyReference);\n-\n         if (decryptedSecret.length > KEY_LENGTH) {\n-\n             final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n                     decryptedSecret.length-16);\n-\n             LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n             return truncatedDecryptedSecretBytes;\n         }\n-\n         return decryptedSecret;\n     }\n \n     @Override\n     public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n-        //byte[] newSecret = new byte[128/8];\n         try {\n-            //SecureRandom.getInstance(\"SHA1PRNG\",PROVIDER).nextBytes(newSecret);\n             return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n         } catch (NoSuchAlgorithmException exc) {\n             throw new EncrypterException(\"Could not generate secret\", exc);\n         }\n-        //return newSecret;\n     }\n \n     @Override\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex af000b83c9..9bdf890046 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -78,6 +78,11 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n+    @Override\n+    public int getSecretByteLength() {\n+        return KEY_LENGTH;\n+    }\n+\n     @Override\n     protected Cipher getCipher() throws EncrypterException {\n         try {\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 9bdf890046..cd2a57088b 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -84,7 +84,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     @Override\n-    protected Cipher getCipher() throws EncrypterException {\n+    protected Cipher getCipher() {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n         } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex cd2a57088b..5717cc229a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -33,86 +31,97 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n \n-    private static final int KEY_LENGTH = 16;\n-    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n-    private static final String PROVIDER = \"nCipherKM\";\n-    private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[KEY_LENGTH];\n+  private static final int KEY_LENGTH = 16;\n+  private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+  private static final String PROVIDER = \"nCipherKM\";\n+  private static final String TYPE = \"ncipher.sworld\";\n+  private static final byte[] IV = new byte[KEY_LENGTH];\n \n-    private final KeyStore keyStore;\n+  private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(final File keyStoreFile) {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n-            this.keyStore.load(fIn, null);\n-        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public HsmEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n+      final FileInputStream fIn = new FileInputStream(keyStoreFile);\n+      this.keyStore.load(fIn, null);\n+    } catch (final CertificateException\n+        | NoSuchAlgorithmException\n+        | NoSuchProviderException\n+        | IOException\n+        | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n-        if (decryptedSecret.length > KEY_LENGTH) {\n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n-                    decryptedSecret.length-16);\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n-                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-            return truncatedDecryptedSecretBytes;\n-        }\n-        return decryptedSecret;\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    final byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+    if (decryptedSecret.length > KEY_LENGTH) {\n+      // This provider uses NoPadding, but since decrypted byte size is bigger than key byte size,\n+      // the secrets were apparently encrypted using padding of some kind; truncate the padded\n+      // bytes.\n+      final byte[] truncatedDecryptedSecretBytes =\n+          Arrays.copyOfRange(decryptedSecret, 0, KEY_LENGTH);\n+      LOGGER.trace(\n+          \"Truncating decrypted key from \"\n+              + Hex.encodeHexString(decryptedSecret)\n+              + \" to \"\n+              + Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+      return truncatedDecryptedSecretBytes;\n     }\n+    return decryptedSecret;\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) {\n-        try {\n-            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(), keyReference)\n+          .getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public int getSecretByteLength() {\n-        return KEY_LENGTH;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n \n-    @Override\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    /**\n-     * This method reads the encryption key specified by keyReference from the Hsm.\n-     *\n-     * @return the key that must be used for encryption/decryption\n-     */\n-    @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n-        try {\n-            return this.keyStore.getKey(keyReference, null);\n-        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not get keystore from key\", e);\n-        }\n+  /**\n+   * This method reads the encryption key specified by keyReference from the Hsm.\n+   *\n+   * @return the key that must be used for encryption/decryption\n+   */\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    try {\n+      return this.keyStore.getKey(keyReference, null);\n+    } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not get keystore from key\", e);\n     }\n+  }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n-    }\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.HSM;\n-    }\n-}\n\\ No newline at end of file\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.HSM;\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 50b47ff5d4..0e72e615b9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -43,12 +52,36 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n             FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n         } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\");\n+            throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+\n+        Secret decryptedSecret = super.decrypt(secret, keyReference);\n+\n+        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n+\n+        if (decryptedSecretBytes.length > KEY_LENGTH) {\n+\n+            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes,\n+                    decryptedSecretBytes.length-16, decryptedSecretBytes.length);\n+\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+\n+            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+        }\n+\n+        return decryptedSecret;\n+    }\n+\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM, PROVIDER);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 0e72e615b9..18615dbf1f 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -76,10 +77,11 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n         return decryptedSecret;\n     }\n \n-    protected Cipher getCipher() throws EncrypterException {\n+    @Override\n+    protected Cipher getCipher() {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n             throw new EncrypterException(\"Could not get cipher\", e);\n         }\n     }\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 18615dbf1f..5736344a37 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -87,8 +84,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     /**\n-     * This method reads the 'actual' encryption key (from the database).\n-     * Normally this is the key start isValidFrom(now) and isValidUntil(now).\n+     * This method reads the encryption key specified by keyReference from the Hsm.\n      *\n      * @return the key that must be used for encryption/decryption\n      */\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 5736344a37..6af1bab88c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -89,7 +102,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n      * @return the key that must be used for encryption/decryption\n      */\n     @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) throws EncrypterException {\n         try {\n             return this.keyStore.getKey(keyReference, null);\n         } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 6af1bab88c..cd2a57088b 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -102,7 +98,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n      * @return the key that must be used for encryption/decryption\n      */\n     @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) throws EncrypterException {\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n         try {\n             return this.keyStore.getKey(keyReference, null);\n         } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex cd2a57088b..5717cc229a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -33,86 +31,97 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n \n-    private static final int KEY_LENGTH = 16;\n-    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n-    private static final String PROVIDER = \"nCipherKM\";\n-    private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[KEY_LENGTH];\n+  private static final int KEY_LENGTH = 16;\n+  private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+  private static final String PROVIDER = \"nCipherKM\";\n+  private static final String TYPE = \"ncipher.sworld\";\n+  private static final byte[] IV = new byte[KEY_LENGTH];\n \n-    private final KeyStore keyStore;\n+  private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(final File keyStoreFile) {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n-            this.keyStore.load(fIn, null);\n-        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public HsmEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n+      final FileInputStream fIn = new FileInputStream(keyStoreFile);\n+      this.keyStore.load(fIn, null);\n+    } catch (final CertificateException\n+        | NoSuchAlgorithmException\n+        | NoSuchProviderException\n+        | IOException\n+        | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n-        if (decryptedSecret.length > KEY_LENGTH) {\n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n-                    decryptedSecret.length-16);\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n-                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-            return truncatedDecryptedSecretBytes;\n-        }\n-        return decryptedSecret;\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    final byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+    if (decryptedSecret.length > KEY_LENGTH) {\n+      // This provider uses NoPadding, but since decrypted byte size is bigger than key byte size,\n+      // the secrets were apparently encrypted using padding of some kind; truncate the padded\n+      // bytes.\n+      final byte[] truncatedDecryptedSecretBytes =\n+          Arrays.copyOfRange(decryptedSecret, 0, KEY_LENGTH);\n+      LOGGER.trace(\n+          \"Truncating decrypted key from \"\n+              + Hex.encodeHexString(decryptedSecret)\n+              + \" to \"\n+              + Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+      return truncatedDecryptedSecretBytes;\n     }\n+    return decryptedSecret;\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) {\n-        try {\n-            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(), keyReference)\n+          .getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public int getSecretByteLength() {\n-        return KEY_LENGTH;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n \n-    @Override\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    /**\n-     * This method reads the encryption key specified by keyReference from the Hsm.\n-     *\n-     * @return the key that must be used for encryption/decryption\n-     */\n-    @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n-        try {\n-            return this.keyStore.getKey(keyReference, null);\n-        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not get keystore from key\", e);\n-        }\n+  /**\n+   * This method reads the encryption key specified by keyReference from the Hsm.\n+   *\n+   * @return the key that must be used for encryption/decryption\n+   */\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    try {\n+      return this.keyStore.getKey(keyReference, null);\n+    } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not get keystore from key\", e);\n     }\n+  }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n-    }\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.HSM;\n-    }\n-}\n\\ No newline at end of file\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.HSM;\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 0e72e615b9..18615dbf1f 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -90,18 +92,21 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n      *\n      * @return the key that must be used for encryption/decryption\n      */\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n         try {\n             return this.keyStore.getKey(keyReference, null);\n-        } catch (UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not get keystore from key\", e);\n         }\n     }\n \n+    @Override\n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n         return new IvParameterSpec(IV);\n     }\n \n+    @Override\n     public EncryptionProviderType getType() {\n         return EncryptionProviderType.HSM;\n     }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 18615dbf1f..5717cc229a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -20,94 +20,108 @@ import java.security.UnrecoverableKeyException;\n import java.security.cert.CertificateException;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.spec.IvParameterSpec;\n-\n import org.apache.commons.codec.binary.Hex;\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n-\n-    private static final int KEY_LENGTH = 16;\n-    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n-    private static final String PROVIDER = \"nCipherKM\";\n-    private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[KEY_LENGTH];\n-\n-    private final KeyStore keyStore;\n-\n-    public HsmEncryptionProvider(final File keyStoreFile) {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n-            this.keyStore.load(fIn, null);\n-        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+\n+  private static final int KEY_LENGTH = 16;\n+  private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+  private static final String PROVIDER = \"nCipherKM\";\n+  private static final String TYPE = \"ncipher.sworld\";\n+  private static final byte[] IV = new byte[KEY_LENGTH];\n+\n+  private final KeyStore keyStore;\n+\n+  public HsmEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n+      final FileInputStream fIn = new FileInputStream(keyStoreFile);\n+      this.keyStore.load(fIn, null);\n+    } catch (final CertificateException\n+        | NoSuchAlgorithmException\n+        | NoSuchProviderException\n+        | IOException\n+        | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n-\n-    @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        final byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n-                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n-        }\n-\n-        return decryptedSecret;\n+  }\n+\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    final byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+    if (decryptedSecret.length > KEY_LENGTH) {\n+      // This provider uses NoPadding, but since decrypted byte size is bigger than key byte size,\n+      // the secrets were apparently encrypted using padding of some kind; truncate the padded\n+      // bytes.\n+      final byte[] truncatedDecryptedSecretBytes =\n+          Arrays.copyOfRange(decryptedSecret, 0, KEY_LENGTH);\n+      LOGGER.trace(\n+          \"Truncating decrypted key from \"\n+              + Hex.encodeHexString(decryptedSecret)\n+              + \" to \"\n+              + Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+      return truncatedDecryptedSecretBytes;\n     }\n-\n-    @Override\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+    return decryptedSecret;\n+  }\n+\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(), keyReference)\n+          .getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n-\n-    /**\n-     * This method reads the 'actual' encryption key (from the database).\n-     * Normally this is the key start isValidFrom(now) and isValidUntil(now).\n-     *\n-     * @return the key that must be used for encryption/decryption\n-     */\n-    @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n-        try {\n-            return this.keyStore.getKey(keyReference, null);\n-        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not get keystore from key\", e);\n-        }\n-    }\n-\n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n+\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n-\n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.HSM;\n+  }\n+\n+  /**\n+   * This method reads the encryption key specified by keyReference from the Hsm.\n+   *\n+   * @return the key that must be used for encryption/decryption\n+   */\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    try {\n+      return this.keyStore.getKey(keyReference, null);\n+    } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not get keystore from key\", e);\n     }\n-}\n\\ No newline at end of file\n+  }\n+\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.HSM;\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5MjMxMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450792313", "body": "this else could be removed, just return false.", "bodyText": "this else could be removed, just return false.", "bodyHTML": "<p dir=\"auto\">this else could be removed, just return false.</p>", "author": "coendamen", "createdAt": "2020-07-07T11:23:28Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final int BLOCK_SIZE=16;\n+\n+    protected File keyFile;\n+\n+    public abstract EncryptionProviderType getType();\n+\n+    protected abstract Cipher getCipher()\n+            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException;\n+\n+    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+\n+    public void setKeyFile(File keyFile) {\n+        this.keyFile = keyFile;\n+    }\n+\n+    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n+            // InvalidAlgorithmParameterException |\n+            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n+            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+        }\n+    }\n+\n+    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+\n+        if (secret.getType() != this.getType()) {\n+            throw new EncrypterException(\n+                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \"\n+                            + secret.getType().name());\n+        }\n+\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+\n+            if (this.checkNullBytesPrepended(decryptedData)) {\n+                return new Secret(Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length));\n+            } else {\n+                return new Secret(decryptedData);\n+            }\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n+            // InvalidAlgorithmParameterException |\n+            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n+            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n+        }\n+    }\n+\n+    private boolean checkNullBytesPrepended(final byte[] bytes) {\n+        if (bytes.length > BLOCK_SIZE) {\n+            for (short s = 0; s < BLOCK_SIZE; s++) {\n+                if (bytes[s] != 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } else {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 57084c5361..4c7378d2c8 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -91,8 +84,7 @@ public abstract class AbstractEncryptionProvider {\n                 }\n             }\n             return true;\n-        } else {\n-            return false;\n         }\n+        return false;\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 4c7378d2c8..d3c3874cfb 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -10,81 +10,83 @@ package org.opensmartgridplatform.shared.security.providers;\n \n import java.io.File;\n import java.security.Key;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.NoSuchProviderException;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n \n-public abstract class AbstractEncryptionProvider {\n+public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n \n-    private static final int BLOCK_SIZE=16;\n+  private static final int BLOCK_SIZE = 16;\n \n-    protected File keyFile;\n+  protected File keyFile;\n \n-    public abstract EncryptionProviderType getType();\n+  @Override\n+  public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher() throws EncrypterException;\n+  protected abstract Cipher getCipher();\n \n-    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+  protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+  protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(File keyFile) {\n-        this.keyFile = keyFile;\n-    }\n+  protected void setKeyFile(final File keyFile) {\n+    this.keyFile = keyFile;\n+  }\n \n-    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n-        }\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.ENCRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        if (secret.getType() != this.getType()) {\n-            throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \"\n-                            + secret.getType().name());\n-        }\n-\n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          \"EncryptionProvider for type \"\n+              + this.getType().name()\n+              + \" cannot decrypt secrets of type \"\n+              + secret.getType().name());\n+    }\n \n-            if (this.checkNullBytesPrepended(decryptedData)) {\n-                return new Secret(Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length));\n-            } else {\n-                return new Secret(decryptedData);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n-        }\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.DECRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+      if (this.checkNullBytesPrepended(decryptedData)) {\n+        return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n+      } else {\n+        return decryptedData;\n+      }\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    private boolean checkNullBytesPrepended(final byte[] bytes) {\n-        if (bytes.length > BLOCK_SIZE) {\n-            for (short s = 0; s < BLOCK_SIZE; s++) {\n-                if (bytes[s] != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+  private boolean checkNullBytesPrepended(final byte[] bytes) {\n+    if (bytes.length > BLOCK_SIZE) {\n+      for (short s = 0; s < BLOCK_SIZE; s++) {\n+        if (bytes[s] != 0) {\n+          return false;\n         }\n-        return false;\n+      }\n+      return true;\n     }\n+    return false;\n+  }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5MjU1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450792552", "body": "remove?", "bodyText": "remove?", "bodyHTML": "<p dir=\"auto\">remove?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:23:57Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final int BLOCK_SIZE=16;\n+\n+    protected File keyFile;\n+\n+    public abstract EncryptionProviderType getType();\n+\n+    protected abstract Cipher getCipher()\n+            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException;\n+\n+    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+\n+    public void setKeyFile(File keyFile) {\n+        this.keyFile = keyFile;\n+    }\n+\n+    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n+            // InvalidAlgorithmParameterException |\n+            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n+            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+        }\n+    }\n+\n+    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+\n+        if (secret.getType() != this.getType()) {\n+            throw new EncrypterException(\n+                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \"\n+                            + secret.getType().name());\n+        }\n+\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+\n+            if (this.checkNullBytesPrepended(decryptedData)) {\n+                return new Secret(Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length));\n+            } else {\n+                return new Secret(decryptedData);\n+            }\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 57084c5361..4c7378d2c8 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -76,9 +72,6 @@ public abstract class AbstractEncryptionProvider {\n                 return new Secret(decryptedData);\n             }\n         } catch (Exception e) {\n-            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n-            // InvalidAlgorithmParameterException |\n-            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n             throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 4c7378d2c8..44d5754d51 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -71,7 +68,7 @@ public abstract class AbstractEncryptionProvider {\n             } else {\n                 return new Secret(decryptedData);\n             }\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 44d5754d51..c7fcdc6c7e 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -64,9 +63,9 @@ public abstract class AbstractEncryptionProvider {\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n \n             if (this.checkNullBytesPrepended(decryptedData)) {\n-                return new Secret(Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length));\n+                return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n-                return new Secret(decryptedData);\n+                return decryptedData;\n             }\n         } catch (final Exception e) {\n             throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n", "next_change": {"commit": "9a8abb71dec97e80e9a47cee6e2ee07652250e83", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex c7fcdc6c7e..252623e5f9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -61,7 +64,11 @@ public abstract class AbstractEncryptionProvider {\n             cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-\n+            if (decryptedData.length != this.getSecretByteLength()) {\n+                throw new EncrypterException(\n+                        String.format(\"Incorrect key byte length: expected %s, but was %s\", this.getSecretByteLength(),\n+                                decryptedData.length));\n+            }\n             if (this.checkNullBytesPrepended(decryptedData)) {\n                 return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n", "next_change": {"commit": "4b1676dc8f0cc9eff0bcb9e20a3bd14ca54e6e1d", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 252623e5f9..948316b6b4 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -64,11 +64,6 @@ public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n             cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (decryptedData.length != this.getSecretByteLength()) {\n-                throw new EncrypterException(\n-                        String.format(\"Incorrect key byte length: expected %s, but was %s\", this.getSecretByteLength(),\n-                                decryptedData.length));\n-            }\n             if (this.checkNullBytesPrepended(decryptedData)) {\n                 return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 948316b6b4..d3c3874cfb 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -12,77 +12,81 @@ import java.io.File;\n import java.security.Key;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n \n-    private static final int BLOCK_SIZE = 16;\n+  private static final int BLOCK_SIZE = 16;\n \n-    protected File keyFile;\n+  protected File keyFile;\n \n-    @Override\n-    public abstract EncryptionProviderType getType();\n+  @Override\n+  public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+  protected abstract Cipher getCipher();\n \n-    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+  protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+  protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(final File keyFile) {\n-        this.keyFile = keyFile;\n-    }\n+  protected void setKeyFile(final File keyFile) {\n+    this.keyFile = keyFile;\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n-        }\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.ENCRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        if (secret.getType() != this.getType()) {\n-            throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \" + secret\n-                            .getType().name());\n-        }\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          \"EncryptionProvider for type \"\n+              + this.getType().name()\n+              + \" cannot decrypt secrets of type \"\n+              + secret.getType().name());\n+    }\n \n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (this.checkNullBytesPrepended(decryptedData)) {\n-                return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n-            } else {\n-                return decryptedData;\n-            }\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n-        }\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.DECRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+      if (this.checkNullBytesPrepended(decryptedData)) {\n+        return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n+      } else {\n+        return decryptedData;\n+      }\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    private boolean checkNullBytesPrepended(final byte[] bytes) {\n-        if (bytes.length > BLOCK_SIZE) {\n-            for (short s = 0; s < BLOCK_SIZE; s++) {\n-                if (bytes[s] != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+  private boolean checkNullBytesPrepended(final byte[] bytes) {\n+    if (bytes.length > BLOCK_SIZE) {\n+      for (short s = 0; s < BLOCK_SIZE; s++) {\n+        if (bytes[s] != 0) {\n+          return false;\n         }\n-        return false;\n+      }\n+      return true;\n     }\n+    return false;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5Mjk3MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450792970", "body": "remove ?", "bodyText": "remove ?", "bodyHTML": "<p dir=\"auto\">remove ?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:24:48Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final int BLOCK_SIZE=16;\n+\n+    protected File keyFile;\n+\n+    public abstract EncryptionProviderType getType();\n+\n+    protected abstract Cipher getCipher()\n+            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException;\n+\n+    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+\n+    public void setKeyFile(File keyFile) {\n+        this.keyFile = keyFile;\n+    }\n+\n+    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 57084c5361..4c7378d2c8 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -49,9 +48,6 @@ public abstract class AbstractEncryptionProvider {\n                     this.getAlgorithmParameterSpec());\n             return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n         } catch (Exception e) {\n-            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n-            // InvalidAlgorithmParameterException |\n-            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n             throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 4c7378d2c8..44d5754d51 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -31,28 +28,28 @@ public abstract class AbstractEncryptionProvider {\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher() throws EncrypterException;\n+    protected abstract Cipher getCipher();\n \n     protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n     protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(File keyFile) {\n+        protected void setKeyFile(final File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n-    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+    public EncryptedSecret encrypt(final Secret secret, final String keyReference) {\n         try {\n             final Cipher cipher = this.getCipher();\n             cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 44d5754d51..c7fcdc6c7e 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -34,22 +33,22 @@ public abstract class AbstractEncryptionProvider {\n \n     protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-        protected void setKeyFile(final File keyFile) {\n+    protected void setKeyFile(final File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n-    public EncryptedSecret encrypt(final Secret secret, final String keyReference) {\n+    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n         try {\n             final Cipher cipher = this.getCipher();\n             cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n         } catch (final Exception e) {\n             throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n \n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex c7fcdc6c7e..6271d01916 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -48,7 +48,7 @@ public abstract class AbstractEncryptionProvider {\n         }\n     }\n \n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 6271d01916..bb4fd7da47 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -48,7 +48,7 @@ public abstract class AbstractEncryptionProvider {\n         }\n     }\n \n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "9a8abb71dec97e80e9a47cee6e2ee07652250e83", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex bb4fd7da47..252623e5f9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -48,12 +50,13 @@ public abstract class AbstractEncryptionProvider {\n         }\n     }\n \n+    @Override\n     public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \"\n-                            + secret.getType().name());\n+                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \" + secret\n+                            .getType().name());\n         }\n \n         try {\n", "next_change": {"commit": "4b1676dc8f0cc9eff0bcb9e20a3bd14ca54e6e1d", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 252623e5f9..948316b6b4 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -64,11 +64,6 @@ public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n             cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (decryptedData.length != this.getSecretByteLength()) {\n-                throw new EncrypterException(\n-                        String.format(\"Incorrect key byte length: expected %s, but was %s\", this.getSecretByteLength(),\n-                                decryptedData.length));\n-            }\n             if (this.checkNullBytesPrepended(decryptedData)) {\n                 return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 948316b6b4..d3c3874cfb 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -12,77 +12,81 @@ import java.io.File;\n import java.security.Key;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n \n-    private static final int BLOCK_SIZE = 16;\n+  private static final int BLOCK_SIZE = 16;\n \n-    protected File keyFile;\n+  protected File keyFile;\n \n-    @Override\n-    public abstract EncryptionProviderType getType();\n+  @Override\n+  public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+  protected abstract Cipher getCipher();\n \n-    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+  protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+  protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(final File keyFile) {\n-        this.keyFile = keyFile;\n-    }\n+  protected void setKeyFile(final File keyFile) {\n+    this.keyFile = keyFile;\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n-        }\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.ENCRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        if (secret.getType() != this.getType()) {\n-            throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \" + secret\n-                            .getType().name());\n-        }\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          \"EncryptionProvider for type \"\n+              + this.getType().name()\n+              + \" cannot decrypt secrets of type \"\n+              + secret.getType().name());\n+    }\n \n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (this.checkNullBytesPrepended(decryptedData)) {\n-                return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n-            } else {\n-                return decryptedData;\n-            }\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n-        }\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.DECRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+      if (this.checkNullBytesPrepended(decryptedData)) {\n+        return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n+      } else {\n+        return decryptedData;\n+      }\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    private boolean checkNullBytesPrepended(final byte[] bytes) {\n-        if (bytes.length > BLOCK_SIZE) {\n-            for (short s = 0; s < BLOCK_SIZE; s++) {\n-                if (bytes[s] != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+  private boolean checkNullBytesPrepended(final byte[] bytes) {\n+    if (bytes.length > BLOCK_SIZE) {\n+      for (short s = 0; s < BLOCK_SIZE; s++) {\n+        if (bytes[s] != 0) {\n+          return false;\n         }\n-        return false;\n+      }\n+      return true;\n     }\n+    return false;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5NDE2Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450794163", "body": "why not use the Secret class here? it already has the byte array", "bodyText": "why not use the Secret class here? it already has the byte array", "bodyHTML": "<p dir=\"auto\">why not use the Secret class here? it already has the byte array</p>", "author": "coendamen", "createdAt": "2020-07-07T11:27:15Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+/**\n+ * Secret class to store any binary encrypted secret. The secret can be anything.\n+ * A secret contains the type of encryption provider that was used to encrypt it.\n+ * There is no encoding/decoding.\n+ */\n+public class EncryptedSecret {\n+    private final byte[] secret;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\nindex 893dd1abb0..3c4df1bc53 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n", "chunk": "@@ -14,12 +14,12 @@ package org.opensmartgridplatform.shared.security;\n  * There is no encoding/decoding.\n  */\n public class EncryptedSecret {\n-    private final byte[] secret;\n+    private final Secret secret;\n     private final EncryptionProviderType type;\n \n-    public EncryptedSecret(final EncryptionProviderType type, final byte[] secret) {\n+    public EncryptedSecret(final EncryptionProviderType type, final byte[] secretBytes) {\n         this.type = type;\n-        this.secret = secret;\n+        this.secret = new Secret(secretBytes);\n     }\n \n     public EncryptionProviderType getType() {\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\nindex 3c4df1bc53..2e3e98a285 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n", "chunk": "@@ -14,12 +14,12 @@ package org.opensmartgridplatform.shared.security;\n  * There is no encoding/decoding.\n  */\n public class EncryptedSecret {\n-    private final Secret secret;\n+    private final byte[] secret;\n     private final EncryptionProviderType type;\n \n     public EncryptedSecret(final EncryptionProviderType type, final byte[] secretBytes) {\n         this.type = type;\n-        this.secret = new Secret(secretBytes);\n+        this.secret = secretBytes;\n     }\n \n     public EncryptionProviderType getType() {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\nindex 2e3e98a285..dfc0bdf87d 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n", "chunk": "@@ -1,32 +1,31 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.shared.security;\n \n /**\n- * Secret class to store any binary encrypted secret. The secret can be anything.\n- * A secret contains the type of encryption provider that was used to encrypt it.\n- * There is no encoding/decoding.\n+ * Secret class to store any binary encrypted secret. The secret can be anything. A secret contains\n+ * the type of encryption provider that was used to encrypt it. There is no encoding/decoding.\n  */\n public class EncryptedSecret {\n-    private final byte[] secret;\n-    private final EncryptionProviderType type;\n+  private final byte[] secret;\n+  private final EncryptionProviderType type;\n \n-    public EncryptedSecret(final EncryptionProviderType type, final byte[] secretBytes) {\n-        this.type = type;\n-        this.secret = secretBytes;\n-    }\n+  public EncryptedSecret(final EncryptionProviderType type, final byte[] secretBytes) {\n+    this.type = type;\n+    this.secret = secretBytes;\n+  }\n \n-    public EncryptionProviderType getType() {\n-        return this.type;\n-    }\n+  public EncryptionProviderType getType() {\n+    return this.type;\n+  }\n \n-    public byte[] getSecret() {\n-        return this.secret;\n-    }\n+  public byte[] getSecret() {\n+    return this.secret;\n+  }\n }\n", "next_change": null}]}}, {"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\nindex 3c4df1bc53..2e3e98a285 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n", "chunk": "@@ -27,6 +27,6 @@ public class EncryptedSecret {\n     }\n \n     public byte[] getSecret() {\n-        return this.secret.getSecret();\n+        return this.secret;\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\nindex 2e3e98a285..dfc0bdf87d 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/EncryptedSecret.java\n", "chunk": "@@ -1,32 +1,31 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.shared.security;\n \n /**\n- * Secret class to store any binary encrypted secret. The secret can be anything.\n- * A secret contains the type of encryption provider that was used to encrypt it.\n- * There is no encoding/decoding.\n+ * Secret class to store any binary encrypted secret. The secret can be anything. A secret contains\n+ * the type of encryption provider that was used to encrypt it. There is no encoding/decoding.\n  */\n public class EncryptedSecret {\n-    private final byte[] secret;\n-    private final EncryptionProviderType type;\n+  private final byte[] secret;\n+  private final EncryptionProviderType type;\n \n-    public EncryptedSecret(final EncryptionProviderType type, final byte[] secretBytes) {\n-        this.type = type;\n-        this.secret = secretBytes;\n-    }\n+  public EncryptedSecret(final EncryptionProviderType type, final byte[] secretBytes) {\n+    this.type = type;\n+    this.secret = secretBytes;\n+  }\n \n-    public EncryptionProviderType getType() {\n-        return this.type;\n-    }\n+  public EncryptionProviderType getType() {\n+    return this.type;\n+  }\n \n-    public byte[] getSecret() {\n-        return this.secret;\n-    }\n+  public byte[] getSecret() {\n+    return this.secret;\n+  }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5NDcxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450794712", "body": "I think this line and the next can be combined into one.", "bodyText": "I think this line and the next can be combined into one.", "bodyHTML": "<p dir=\"auto\">I think this line and the next can be combined into one.</p>", "author": "coendamen", "createdAt": "2020-07-07T11:28:28Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+@Component\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers;\n+\n+    public DefaultEncryptionDelegate(final EncryptionProvider[] encryptionProviders) {\n+        this.providers = Arrays.asList(encryptionProviders);\n+    }\n+\n+    @Override\n+    public EncryptedSecret encrypt(\n+            final EncryptionProviderType encryptionProviderType, final Secret secret, final String keyReference) {\n+        final Optional<EncryptionProvider> oep = this.providers.stream().filter(\n+                ep -> ep.getType().equals(encryptionProviderType)).findFirst();\n+\n+        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).encrypt(secret, keyReference);\n+    }\n+\n+    @Override\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+        final EncryptionProviderType encType = secret.getType();\n+        final Optional<EncryptionProvider> oep = this.providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex ecfdddc866..c7d8dd4bdc 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -22,27 +22,24 @@ import org.springframework.stereotype.Component;\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n     private final List<EncryptionProvider> providers;\n \n-    public DefaultEncryptionDelegate(final EncryptionProvider[] encryptionProviders) {\n-        this.providers = Arrays.asList(encryptionProviders);\n+    public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n+        this.providers = encryptionProviders;\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(\n-            final EncryptionProviderType encryptionProviderType, final Secret secret, final String keyReference) {\n-        final Optional<EncryptionProvider> oep = this.providers.stream().filter(\n-                ep -> ep.getType().equals(encryptionProviderType)).findFirst();\n-\n-        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).encrypt(secret, keyReference);\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+            final String keyReference) {\n+        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n     public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n-        final EncryptionProviderType encType = secret.getType();\n-        final Optional<EncryptionProvider> oep = this.providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();\n-\n-        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).decrypt(secret, keyReference);\n+        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n }\n \n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex c7d8dd4bdc..915b931080 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -30,14 +28,14 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n             final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 915b931080..e8448f76dd 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -28,16 +28,22 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n             final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n+\n+    /*@Override\n+    public Secret generate128BitsSecret(final EncryptionProviderType encryptionProviderType) {\n+        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).;\n+    }*/\n }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex e8448f76dd..976772ae35 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -28,22 +28,23 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n-            final String keyReference) {\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+            final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n \n-    /*@Override\n-    public Secret generate128BitsSecret(final EncryptionProviderType encryptionProviderType) {\n+    @Override\n+    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n+            final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).;\n-    }*/\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).generateAes128BitsSecret(keyReference);\n+    }\n }\n \n", "next_change": {"commit": "4907e8e319e25c4244e13387cf346c816ff1037a", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 976772ae35..640b63feac 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -20,31 +20,33 @@ import org.springframework.stereotype.Component;\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s\";\n     private final List<EncryptionProvider> providers;\n \n     public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n         this.providers = encryptionProviders;\n     }\n \n+    private EncryptionProvider getEncryptionProvider(EncryptionProviderType type) {\n+        return this.providers.stream().filter(type::equals).findFirst()\n+                             .orElseThrow(() -> new EncrypterException(String.format(ERROR_NO_PROVIDER, type)));\n+    }\n+\n     @Override\n     public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n-            final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n     }\n \n     @Override\n     public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n-            final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).generateAes128BitsSecret(keyReference);\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n }\n \n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 640b63feac..21d5351275 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -48,5 +49,10 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n             final String keyReference) {\n         return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n+\n+    @Override\n+    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {\n+        return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n+    }\n }\n \n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 21d5351275..bf4190c1fc 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -51,7 +54,7 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {\n+    public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n         return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex bf4190c1fc..4ad72a5757 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -10,52 +10,56 @@ package org.opensmartgridplatform.shared.security;\n \n import java.util.EnumMap;\n import java.util.List;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n import org.springframework.stereotype.Component;\n \n /**\n- * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by\n+ * the JRE\n  */\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s; available providers are %s\";\n-    private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n+  private static final String ERROR_NO_PROVIDER =\n+      \"Could not find a provider of type %s; available providers are %s\";\n+  private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n \n-    public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n-        this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n-        encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n-    }\n+  public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n+    this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n+    encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n+  }\n \n-    private EncryptionProvider getEncryptionProvider(final EncryptionProviderType type) {\n-        if (!this.encryptionProviders.containsKey(type)) {\n-            throw new EncrypterException(String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n-        }\n-        return this.encryptionProviders.get(type);\n+  private EncryptionProvider getEncryptionProvider(final EncryptionProviderType type) {\n+    if (!this.encryptionProviders.containsKey(type)) {\n+      throw new EncrypterException(\n+          String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n     }\n+    return this.encryptionProviders.get(type);\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n-            final String keyReference) {\n-        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n-    }\n+  @Override\n+  public EncryptedSecret encrypt(\n+      final EncryptionProviderType encryptionProviderType,\n+      final byte[] secret,\n+      final String keyReference) {\n+    return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n-    }\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n-            final String keyReference) {\n-        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n-    }\n+  @Override\n+  public byte[] generateAes128BitsSecret(\n+      final EncryptionProviderType encryptionProviderType, final String keyReference) {\n+    return this.getEncryptionProvider(encryptionProviderType)\n+        .generateAes128BitsSecret(keyReference);\n+  }\n \n-    @Override\n-    public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n-        return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n-    }\n+  @Override\n+  public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n+    return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n+  }\n }\n-\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5NTAxMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450795012", "body": "could be one liner", "bodyText": "could be one liner", "bodyHTML": "<p dir=\"auto\">could be one liner</p>", "author": "coendamen", "createdAt": "2020-07-07T11:29:05Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+@Component\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers;\n+\n+    public DefaultEncryptionDelegate(final EncryptionProvider[] encryptionProviders) {\n+        this.providers = Arrays.asList(encryptionProviders);\n+    }\n+\n+    @Override\n+    public EncryptedSecret encrypt(\n+            final EncryptionProviderType encryptionProviderType, final Secret secret, final String keyReference) {\n+        final Optional<EncryptionProvider> oep = this.providers.stream().filter(\n+                ep -> ep.getType().equals(encryptionProviderType)).findFirst();\n+\n+        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).encrypt(secret, keyReference);", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex ecfdddc866..c7d8dd4bdc 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -22,27 +22,24 @@ import org.springframework.stereotype.Component;\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n     private final List<EncryptionProvider> providers;\n \n-    public DefaultEncryptionDelegate(final EncryptionProvider[] encryptionProviders) {\n-        this.providers = Arrays.asList(encryptionProviders);\n+    public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n+        this.providers = encryptionProviders;\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(\n-            final EncryptionProviderType encryptionProviderType, final Secret secret, final String keyReference) {\n-        final Optional<EncryptionProvider> oep = this.providers.stream().filter(\n-                ep -> ep.getType().equals(encryptionProviderType)).findFirst();\n-\n-        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).encrypt(secret, keyReference);\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+            final String keyReference) {\n+        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n     public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n-        final EncryptionProviderType encType = secret.getType();\n-        final Optional<EncryptionProvider> oep = this.providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();\n-\n-        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).decrypt(secret, keyReference);\n+        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n }\n \n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex c7d8dd4bdc..915b931080 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -30,14 +28,14 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n             final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 915b931080..e8448f76dd 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -28,16 +28,22 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n             final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n+\n+    /*@Override\n+    public Secret generate128BitsSecret(final EncryptionProviderType encryptionProviderType) {\n+        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).;\n+    }*/\n }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex e8448f76dd..976772ae35 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -28,22 +28,23 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n-            final String keyReference) {\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+            final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n \n-    /*@Override\n-    public Secret generate128BitsSecret(final EncryptionProviderType encryptionProviderType) {\n+    @Override\n+    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n+            final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).;\n-    }*/\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).generateAes128BitsSecret(keyReference);\n+    }\n }\n \n", "next_change": {"commit": "4907e8e319e25c4244e13387cf346c816ff1037a", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 976772ae35..640b63feac 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -20,31 +20,33 @@ import org.springframework.stereotype.Component;\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s\";\n     private final List<EncryptionProvider> providers;\n \n     public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n         this.providers = encryptionProviders;\n     }\n \n+    private EncryptionProvider getEncryptionProvider(EncryptionProviderType type) {\n+        return this.providers.stream().filter(type::equals).findFirst()\n+                             .orElseThrow(() -> new EncrypterException(String.format(ERROR_NO_PROVIDER, type)));\n+    }\n+\n     @Override\n     public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n-            final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n     }\n \n     @Override\n     public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n-            final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).generateAes128BitsSecret(keyReference);\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n }\n \n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 640b63feac..21d5351275 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -48,5 +49,10 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n             final String keyReference) {\n         return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n+\n+    @Override\n+    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {\n+        return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n+    }\n }\n \n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 21d5351275..bf4190c1fc 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -51,7 +54,7 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {\n+    public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n         return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex bf4190c1fc..4ad72a5757 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -10,52 +10,56 @@ package org.opensmartgridplatform.shared.security;\n \n import java.util.EnumMap;\n import java.util.List;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n import org.springframework.stereotype.Component;\n \n /**\n- * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by\n+ * the JRE\n  */\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s; available providers are %s\";\n-    private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n+  private static final String ERROR_NO_PROVIDER =\n+      \"Could not find a provider of type %s; available providers are %s\";\n+  private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n \n-    public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n-        this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n-        encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n-    }\n+  public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n+    this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n+    encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n+  }\n \n-    private EncryptionProvider getEncryptionProvider(final EncryptionProviderType type) {\n-        if (!this.encryptionProviders.containsKey(type)) {\n-            throw new EncrypterException(String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n-        }\n-        return this.encryptionProviders.get(type);\n+  private EncryptionProvider getEncryptionProvider(final EncryptionProviderType type) {\n+    if (!this.encryptionProviders.containsKey(type)) {\n+      throw new EncrypterException(\n+          String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n     }\n+    return this.encryptionProviders.get(type);\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n-            final String keyReference) {\n-        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n-    }\n+  @Override\n+  public EncryptedSecret encrypt(\n+      final EncryptionProviderType encryptionProviderType,\n+      final byte[] secret,\n+      final String keyReference) {\n+    return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n-    }\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n-            final String keyReference) {\n-        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n-    }\n+  @Override\n+  public byte[] generateAes128BitsSecret(\n+      final EncryptionProviderType encryptionProviderType, final String keyReference) {\n+    return this.getEncryptionProvider(encryptionProviderType)\n+        .generateAes128BitsSecret(keyReference);\n+  }\n \n-    @Override\n-    public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n-        return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n-    }\n+  @Override\n+  public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n+    return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n+  }\n }\n-\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5NTMxMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450795311", "body": "why is this an array parameter and not a List ?", "bodyText": "why is this an array parameter and not a List ?", "bodyHTML": "<p dir=\"auto\">why is this an array parameter and not a List ?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:29:41Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+@Component\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers;\n+\n+    public DefaultEncryptionDelegate(final EncryptionProvider[] encryptionProviders) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex ecfdddc866..c7d8dd4bdc 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -22,27 +22,24 @@ import org.springframework.stereotype.Component;\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n     private final List<EncryptionProvider> providers;\n \n-    public DefaultEncryptionDelegate(final EncryptionProvider[] encryptionProviders) {\n-        this.providers = Arrays.asList(encryptionProviders);\n+    public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n+        this.providers = encryptionProviders;\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(\n-            final EncryptionProviderType encryptionProviderType, final Secret secret, final String keyReference) {\n-        final Optional<EncryptionProvider> oep = this.providers.stream().filter(\n-                ep -> ep.getType().equals(encryptionProviderType)).findFirst();\n-\n-        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).encrypt(secret, keyReference);\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+            final String keyReference) {\n+        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n     public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n-        final EncryptionProviderType encType = secret.getType();\n-        final Optional<EncryptionProvider> oep = this.providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();\n-\n-        return oep.orElseThrow(()->new EncrypterException(\"Could not find a provider\")).decrypt(secret, keyReference);\n+        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n }\n \n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex c7d8dd4bdc..915b931080 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -30,14 +28,14 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n             final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 915b931080..e8448f76dd 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -28,16 +28,22 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n             final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n+\n+    /*@Override\n+    public Secret generate128BitsSecret(final EncryptionProviderType encryptionProviderType) {\n+        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).;\n+    }*/\n }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex e8448f76dd..976772ae35 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -28,22 +28,23 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final Secret secret,\n-            final String keyReference) {\n+    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n+            final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n                 () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n     }\n \n-    /*@Override\n-    public Secret generate128BitsSecret(final EncryptionProviderType encryptionProviderType) {\n+    @Override\n+    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n+            final String keyReference) throws EncrypterException {\n         return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).;\n-    }*/\n+                () -> new EncrypterException(ERROR_NO_PROVIDER)).generateAes128BitsSecret(keyReference);\n+    }\n }\n \n", "next_change": {"commit": "4907e8e319e25c4244e13387cf346c816ff1037a", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 976772ae35..640b63feac 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -20,31 +20,33 @@ import org.springframework.stereotype.Component;\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider\";\n+    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s\";\n     private final List<EncryptionProvider> providers;\n \n     public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n         this.providers = encryptionProviders;\n     }\n \n+    private EncryptionProvider getEncryptionProvider(EncryptionProviderType type) {\n+        return this.providers.stream().filter(type::equals).findFirst()\n+                             .orElseThrow(() -> new EncrypterException(String.format(ERROR_NO_PROVIDER, type)));\n+    }\n+\n     @Override\n     public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n-            final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).encrypt(secret, keyReference);\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n     }\n \n     @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(secret.getType())).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).decrypt(secret, keyReference);\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n     }\n \n     @Override\n     public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n-            final String keyReference) throws EncrypterException {\n-        return this.providers.stream().filter(ep -> ep.getType().equals(encryptionProviderType)).findFirst().orElseThrow(\n-                () -> new EncrypterException(ERROR_NO_PROVIDER)).generateAes128BitsSecret(keyReference);\n+            final String keyReference) {\n+        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n }\n \n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 640b63feac..21d5351275 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -48,5 +49,10 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n             final String keyReference) {\n         return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n     }\n+\n+    @Override\n+    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {\n+        return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n+    }\n }\n \n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex 21d5351275..bf4190c1fc 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -51,7 +54,7 @@ public class DefaultEncryptionDelegate implements EncryptionDelegate {\n     }\n \n     @Override\n-    public int getSecretByteLength(EncryptionProviderType encryptionProviderType) {\n+    public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n         return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\nindex bf4190c1fc..4ad72a5757 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/DefaultEncryptionDelegate.java\n", "chunk": "@@ -10,52 +10,56 @@ package org.opensmartgridplatform.shared.security;\n \n import java.util.EnumMap;\n import java.util.List;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n import org.springframework.stereotype.Component;\n \n /**\n- * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by\n+ * the JRE\n  */\n @Component\n public class DefaultEncryptionDelegate implements EncryptionDelegate {\n \n-    private static final String ERROR_NO_PROVIDER = \"Could not find a provider of type %s; available providers are %s\";\n-    private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n+  private static final String ERROR_NO_PROVIDER =\n+      \"Could not find a provider of type %s; available providers are %s\";\n+  private final EnumMap<EncryptionProviderType, EncryptionProvider> encryptionProviders;\n \n-    public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n-        this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n-        encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n-    }\n+  public DefaultEncryptionDelegate(final List<EncryptionProvider> encryptionProviders) {\n+    this.encryptionProviders = new EnumMap<>(EncryptionProviderType.class);\n+    encryptionProviders.stream().forEach(p -> this.encryptionProviders.put(p.getType(), p));\n+  }\n \n-    private EncryptionProvider getEncryptionProvider(final EncryptionProviderType type) {\n-        if (!this.encryptionProviders.containsKey(type)) {\n-            throw new EncrypterException(String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n-        }\n-        return this.encryptionProviders.get(type);\n+  private EncryptionProvider getEncryptionProvider(final EncryptionProviderType type) {\n+    if (!this.encryptionProviders.containsKey(type)) {\n+      throw new EncrypterException(\n+          String.format(ERROR_NO_PROVIDER, type, this.encryptionProviders));\n     }\n+    return this.encryptionProviders.get(type);\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final EncryptionProviderType encryptionProviderType, final byte[] secret,\n-            final String keyReference) {\n-        return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n-    }\n+  @Override\n+  public EncryptedSecret encrypt(\n+      final EncryptionProviderType encryptionProviderType,\n+      final byte[] secret,\n+      final String keyReference) {\n+    return this.getEncryptionProvider(encryptionProviderType).encrypt(secret, keyReference);\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n-    }\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    return this.getEncryptionProvider(secret.getType()).decrypt(secret, keyReference);\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(final EncryptionProviderType encryptionProviderType,\n-            final String keyReference) {\n-        return this.getEncryptionProvider(encryptionProviderType).generateAes128BitsSecret(keyReference);\n-    }\n+  @Override\n+  public byte[] generateAes128BitsSecret(\n+      final EncryptionProviderType encryptionProviderType, final String keyReference) {\n+    return this.getEncryptionProvider(encryptionProviderType)\n+        .generateAes128BitsSecret(keyReference);\n+  }\n \n-    @Override\n-    public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n-        return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n-    }\n+  @Override\n+  public int getSecretByteLength(final EncryptionProviderType encryptionProviderType) {\n+    return this.getEncryptionProvider(encryptionProviderType).getSecretByteLength();\n+  }\n }\n-\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5NzY3Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450797676", "body": "I don't think you need this qualifier, there is only one bean named SecretManagementService", "bodyText": "I don't think you need this qualifier, there is only one bean named SecretManagementService", "bodyHTML": "<p dir=\"auto\">I don't think you need this qualifier, there is only one bean named SecretManagementService</p>", "author": "coendamen", "createdAt": "2020-07-07T11:34:33Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java", "diffHunk": "@@ -28,12 +28,14 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n \n public class Lls1Connector extends SecureDlmsConnector {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n \n     @Autowired\n+    @Qualifier(\"secretManagementService\")", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\nindex 8836bcc9a5..690d7fc5fa 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n", "chunk": "@@ -28,15 +29,13 @@ import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Qualifier;\n \n public class Lls1Connector extends SecureDlmsConnector {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n \n     @Autowired\n-    @Qualifier(\"secretManagementService\")\n-    private SecurityKeyService securityKeyService;\n+    private SecretManagementService secretManagementService;\n \n     public Lls1Connector(final int responseTimeout, final int logicalDeviceAddress,\n             final DlmsDeviceAssociation deviceAssociation) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\nindex 690d7fc5fa..eac36cb092 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n", "chunk": "@@ -32,63 +31,71 @@ import org.springframework.beans.factory.annotation.Autowired;\n \n public class Lls1Connector extends SecureDlmsConnector {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n \n-    @Autowired\n-    private SecretManagementService secretManagementService;\n+  @Autowired private SecretManagementService secretManagementService;\n \n-    public Lls1Connector(final int responseTimeout, final int logicalDeviceAddress,\n-            final DlmsDeviceAssociation deviceAssociation) {\n-        super(responseTimeout, logicalDeviceAddress, deviceAssociation);\n-    }\n+  public Lls1Connector(\n+      final int responseTimeout,\n+      final int logicalDeviceAddress,\n+      final DlmsDeviceAssociation deviceAssociation) {\n+    super(responseTimeout, logicalDeviceAddress, deviceAssociation);\n+  }\n \n-    @Override\n-    public DlmsConnection connect(final DlmsDevice device, final DlmsMessageListener dlmsMessageListener)\n-            throws OsgpException {\n+  @Override\n+  public DlmsConnection connect(\n+      final DlmsDevice device, final DlmsMessageListener dlmsMessageListener) throws OsgpException {\n \n-        // Make sure neither device or device.getIpAddress() is null.\n-        this.checkDevice(device);\n-        this.checkIpAddress(device);\n+    // Make sure neither device or device.getIpAddress() is null.\n+    this.checkDevice(device);\n+    this.checkIpAddress(device);\n \n-        try {\n-            return this.createConnection(device, dlmsMessageListener);\n-        } catch (final UnknownHostException e) {\n-            LOGGER.warn(\"The IP address is not found: {}\", device.getIpAddress(), e);\n-            // Unknown IP, unrecoverable.\n-            throw new TechnicalException(ComponentType.PROTOCOL_DLMS,\n-                    \"The IP address is not found: \" + device.getIpAddress());\n-        } catch (final IOException e) {\n-            throw new ConnectionException(e);\n-        } catch (final EncrypterException e) {\n-            LOGGER.error(\"decryption of security keys failed for device: {}\", device.getDeviceIdentification(), e);\n-            throw new TechnicalException(ComponentType.PROTOCOL_DLMS,\n-                    \"decryption of security keys failed for device: \" + device.getDeviceIdentification());\n-        }\n+    try {\n+      return this.createConnection(device, dlmsMessageListener);\n+    } catch (final UnknownHostException e) {\n+      LOGGER.warn(\"The IP address is not found: {}\", device.getIpAddress(), e);\n+      // Unknown IP, unrecoverable.\n+      throw new TechnicalException(\n+          ComponentType.PROTOCOL_DLMS, \"The IP address is not found: \" + device.getIpAddress());\n+    } catch (final IOException e) {\n+      throw new ConnectionException(e);\n+    } catch (final EncrypterException e) {\n+      LOGGER.error(\n+          \"decryption of security keys failed for device: {}\", device.getDeviceIdentification(), e);\n+      throw new TechnicalException(\n+          ComponentType.PROTOCOL_DLMS,\n+          \"decryption of security keys failed for device: \" + device.getDeviceIdentification());\n     }\n+  }\n \n-    @Override\n-    protected void setSecurity(final DlmsDevice device, final TcpConnectionBuilder tcpConnectionBuilder)\n-            throws OsgpException {\n-\n-        final byte[] password;\n-        try {\n-            password = this.secretManagementService.getKey(device.getDeviceIdentification(), SecurityKeyType.PASSWORD);\n-        } catch (final EncrypterException e) {\n-            LOGGER.error(\"Error determining DLMS password setting up LLS1 connection\", e);\n-            throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION,\n-                    ComponentType.PROTOCOL_DLMS);\n-        }\n-        if (password == null) {\n-            LOGGER.error(\"There is no password available for device {}\", device.getDeviceIdentification());\n-            throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION,\n-                    ComponentType.PROTOCOL_DLMS);\n-        }\n+  @Override\n+  protected void setSecurity(\n+      final DlmsDevice device, final TcpConnectionBuilder tcpConnectionBuilder)\n+      throws OsgpException {\n \n-        final SecuritySuite securitySuite = SecuritySuite.builder()\n-                                                         .setAuthenticationMechanism(AuthenticationMechanism.LOW)\n-                                                         .setPassword(password).build();\n-\n-        tcpConnectionBuilder.setSecuritySuite(securitySuite).setClientId(this.clientId);\n+    final byte[] password;\n+    try {\n+      password =\n+          this.secretManagementService.getKey(\n+              device.getDeviceIdentification(), SecurityKeyType.PASSWORD);\n+    } catch (final EncrypterException e) {\n+      LOGGER.error(\"Error determining DLMS password setting up LLS1 connection\", e);\n+      throw new FunctionalException(\n+          FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION, ComponentType.PROTOCOL_DLMS);\n+    }\n+    if (password == null) {\n+      LOGGER.error(\n+          \"There is no password available for device {}\", device.getDeviceIdentification());\n+      throw new FunctionalException(\n+          FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION, ComponentType.PROTOCOL_DLMS);\n     }\n \n+    final SecuritySuite securitySuite =\n+        SecuritySuite.builder()\n+            .setAuthenticationMechanism(AuthenticationMechanism.LOW)\n+            .setPassword(password)\n+            .build();\n+\n+    tcpConnectionBuilder.setSecuritySuite(securitySuite).setClientId(this.clientId);\n+  }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5ODA0Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450798043", "body": "move this autowired to constructor injection.", "bodyText": "move this autowired to constructor injection.", "bodyHTML": "<p dir=\"auto\">move this autowired to constructor injection.</p>", "author": "coendamen", "createdAt": "2020-07-07T11:35:16Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java", "diffHunk": "@@ -28,12 +28,14 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n \n public class Lls1Connector extends SecureDlmsConnector {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n \n     @Autowired", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\nindex 8836bcc9a5..690d7fc5fa 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n", "chunk": "@@ -28,15 +29,13 @@ import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Qualifier;\n \n public class Lls1Connector extends SecureDlmsConnector {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n \n     @Autowired\n-    @Qualifier(\"secretManagementService\")\n-    private SecurityKeyService securityKeyService;\n+    private SecretManagementService secretManagementService;\n \n     public Lls1Connector(final int responseTimeout, final int logicalDeviceAddress,\n             final DlmsDeviceAssociation deviceAssociation) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\nindex 690d7fc5fa..eac36cb092 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Lls1Connector.java\n", "chunk": "@@ -32,63 +31,71 @@ import org.springframework.beans.factory.annotation.Autowired;\n \n public class Lls1Connector extends SecureDlmsConnector {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(Lls1Connector.class);\n \n-    @Autowired\n-    private SecretManagementService secretManagementService;\n+  @Autowired private SecretManagementService secretManagementService;\n \n-    public Lls1Connector(final int responseTimeout, final int logicalDeviceAddress,\n-            final DlmsDeviceAssociation deviceAssociation) {\n-        super(responseTimeout, logicalDeviceAddress, deviceAssociation);\n-    }\n+  public Lls1Connector(\n+      final int responseTimeout,\n+      final int logicalDeviceAddress,\n+      final DlmsDeviceAssociation deviceAssociation) {\n+    super(responseTimeout, logicalDeviceAddress, deviceAssociation);\n+  }\n \n-    @Override\n-    public DlmsConnection connect(final DlmsDevice device, final DlmsMessageListener dlmsMessageListener)\n-            throws OsgpException {\n+  @Override\n+  public DlmsConnection connect(\n+      final DlmsDevice device, final DlmsMessageListener dlmsMessageListener) throws OsgpException {\n \n-        // Make sure neither device or device.getIpAddress() is null.\n-        this.checkDevice(device);\n-        this.checkIpAddress(device);\n+    // Make sure neither device or device.getIpAddress() is null.\n+    this.checkDevice(device);\n+    this.checkIpAddress(device);\n \n-        try {\n-            return this.createConnection(device, dlmsMessageListener);\n-        } catch (final UnknownHostException e) {\n-            LOGGER.warn(\"The IP address is not found: {}\", device.getIpAddress(), e);\n-            // Unknown IP, unrecoverable.\n-            throw new TechnicalException(ComponentType.PROTOCOL_DLMS,\n-                    \"The IP address is not found: \" + device.getIpAddress());\n-        } catch (final IOException e) {\n-            throw new ConnectionException(e);\n-        } catch (final EncrypterException e) {\n-            LOGGER.error(\"decryption of security keys failed for device: {}\", device.getDeviceIdentification(), e);\n-            throw new TechnicalException(ComponentType.PROTOCOL_DLMS,\n-                    \"decryption of security keys failed for device: \" + device.getDeviceIdentification());\n-        }\n+    try {\n+      return this.createConnection(device, dlmsMessageListener);\n+    } catch (final UnknownHostException e) {\n+      LOGGER.warn(\"The IP address is not found: {}\", device.getIpAddress(), e);\n+      // Unknown IP, unrecoverable.\n+      throw new TechnicalException(\n+          ComponentType.PROTOCOL_DLMS, \"The IP address is not found: \" + device.getIpAddress());\n+    } catch (final IOException e) {\n+      throw new ConnectionException(e);\n+    } catch (final EncrypterException e) {\n+      LOGGER.error(\n+          \"decryption of security keys failed for device: {}\", device.getDeviceIdentification(), e);\n+      throw new TechnicalException(\n+          ComponentType.PROTOCOL_DLMS,\n+          \"decryption of security keys failed for device: \" + device.getDeviceIdentification());\n     }\n+  }\n \n-    @Override\n-    protected void setSecurity(final DlmsDevice device, final TcpConnectionBuilder tcpConnectionBuilder)\n-            throws OsgpException {\n-\n-        final byte[] password;\n-        try {\n-            password = this.secretManagementService.getKey(device.getDeviceIdentification(), SecurityKeyType.PASSWORD);\n-        } catch (final EncrypterException e) {\n-            LOGGER.error(\"Error determining DLMS password setting up LLS1 connection\", e);\n-            throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION,\n-                    ComponentType.PROTOCOL_DLMS);\n-        }\n-        if (password == null) {\n-            LOGGER.error(\"There is no password available for device {}\", device.getDeviceIdentification());\n-            throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION,\n-                    ComponentType.PROTOCOL_DLMS);\n-        }\n+  @Override\n+  protected void setSecurity(\n+      final DlmsDevice device, final TcpConnectionBuilder tcpConnectionBuilder)\n+      throws OsgpException {\n \n-        final SecuritySuite securitySuite = SecuritySuite.builder()\n-                                                         .setAuthenticationMechanism(AuthenticationMechanism.LOW)\n-                                                         .setPassword(password).build();\n-\n-        tcpConnectionBuilder.setSecuritySuite(securitySuite).setClientId(this.clientId);\n+    final byte[] password;\n+    try {\n+      password =\n+          this.secretManagementService.getKey(\n+              device.getDeviceIdentification(), SecurityKeyType.PASSWORD);\n+    } catch (final EncrypterException e) {\n+      LOGGER.error(\"Error determining DLMS password setting up LLS1 connection\", e);\n+      throw new FunctionalException(\n+          FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION, ComponentType.PROTOCOL_DLMS);\n+    }\n+    if (password == null) {\n+      LOGGER.error(\n+          \"There is no password available for device {}\", device.getDeviceIdentification());\n+      throw new FunctionalException(\n+          FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION, ComponentType.PROTOCOL_DLMS);\n     }\n \n+    final SecuritySuite securitySuite =\n+        SecuritySuite.builder()\n+            .setAuthenticationMechanism(AuthenticationMechanism.LOW)\n+            .setPassword(password)\n+            .build();\n+\n+    tcpConnectionBuilder.setSecuritySuite(securitySuite).setClientId(this.clientId);\n+  }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5ODgxMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450798813", "body": "I don;t understand why the class is SecurityKeyService, why not inject the SecretManagementService ?", "bodyText": "I don;t understand why the class is SecurityKeyService, why not inject the SecretManagementService ?", "bodyHTML": "<p dir=\"auto\">I don;t understand why the class is SecurityKeyService, why not inject the SecretManagementService ?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:36:49Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java", "diffHunk": "@@ -44,6 +45,7 @@\n     private final RecoverKeyProcessInitiator recoverKeyProcessInitiator;\n \n     @Autowired\n+    @Qualifier(\"secretManagementService\")\n     private SecurityKeyService securityKeyService;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java\nindex e75e9987c9..4e50703d5a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java\n", "chunk": "@@ -45,8 +49,7 @@ public class Hls5Connector extends SecureDlmsConnector {\n     private final RecoverKeyProcessInitiator recoverKeyProcessInitiator;\n \n     @Autowired\n-    @Qualifier(\"secretManagementService\")\n-    private SecurityKeyService securityKeyService;\n+    private SecretManagementService secretManagementService;\n \n     public Hls5Connector(final RecoverKeyProcessInitiator recoverKeyProcessInitiator, final int responseTimeout,\n             final int logicalDeviceAddress, final DlmsDeviceAssociation deviceAssociation) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java\nindex 4e50703d5a..3ca66a6f51 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/factories/Hls5Connector.java\n", "chunk": "@@ -42,152 +41,169 @@ import org.springframework.stereotype.Component;\n @Component\n public class Hls5Connector extends SecureDlmsConnector {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(Hls5Connector.class);\n-\n-    private static final int AES_GMC_128 = 128;\n-\n-    private final RecoverKeyProcessInitiator recoverKeyProcessInitiator;\n-\n-    @Autowired\n-    private SecretManagementService secretManagementService;\n-\n-    public Hls5Connector(final RecoverKeyProcessInitiator recoverKeyProcessInitiator, final int responseTimeout,\n-            final int logicalDeviceAddress, final DlmsDeviceAssociation deviceAssociation) {\n-        super(responseTimeout, logicalDeviceAddress, deviceAssociation);\n-        this.recoverKeyProcessInitiator = recoverKeyProcessInitiator;\n+  private static final Logger LOGGER = LoggerFactory.getLogger(Hls5Connector.class);\n+\n+  private static final int AES_GMC_128 = 128;\n+\n+  private final RecoverKeyProcessInitiator recoverKeyProcessInitiator;\n+\n+  @Autowired private SecretManagementService secretManagementService;\n+\n+  public Hls5Connector(\n+      final RecoverKeyProcessInitiator recoverKeyProcessInitiator,\n+      final int responseTimeout,\n+      final int logicalDeviceAddress,\n+      final DlmsDeviceAssociation deviceAssociation) {\n+    super(responseTimeout, logicalDeviceAddress, deviceAssociation);\n+    this.recoverKeyProcessInitiator = recoverKeyProcessInitiator;\n+  }\n+\n+  @Override\n+  public DlmsConnection connect(\n+      final DlmsDevice device, final DlmsMessageListener dlmsMessageListener) throws OsgpException {\n+\n+    // Make sure neither device or device.getIpAddress() is null.\n+    this.checkDevice(device);\n+    this.checkIpAddress(device);\n+\n+    try {\n+      return this.createConnection(device, dlmsMessageListener);\n+    } catch (final UnknownHostException e) { // Unknown IP, unrecoverable.\n+      LOGGER.error(\"The IP address is not found: {}\", device.getIpAddress(), e);\n+      throw new TechnicalException(\n+          ComponentType.PROTOCOL_DLMS, \"The IP address is not found: \" + device.getIpAddress());\n+    } catch (final IOException e) { // Queue key recovery process\n+      if (this.secretManagementService.hasNewSecretOfType(\n+          device.getDeviceIdentification(), E_METER_ENCRYPTION)) {\n+        this.recoverKeyProcessInitiator.initiate(\n+            device.getDeviceIdentification(), device.getIpAddress());\n+      }\n+\n+      final String msg =\n+          String.format(\n+              \"Error creating connection for device %s with Ip address:%s Port:%d UseHdlc:%b UseSn:%b \"\n+                  + \"Message:%s\",\n+              device.getDeviceIdentification(),\n+              device.getIpAddress(),\n+              device.getPort(),\n+              device.isUseHdlc(),\n+              device.isUseSn(),\n+              e.getMessage());\n+      LOGGER.error(msg);\n+      throw new ConnectionException(msg, e);\n+    } catch (final EncrypterException e) {\n+      throw new FunctionalException(\n+          FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT, ComponentType.PROTOCOL_DLMS, e);\n     }\n-\n-    @Override\n-    public DlmsConnection connect(final DlmsDevice device, final DlmsMessageListener dlmsMessageListener)\n-            throws OsgpException {\n-\n-        // Make sure neither device or device.getIpAddress() is null.\n-        this.checkDevice(device);\n-        this.checkIpAddress(device);\n-\n-        try {\n-            return this.createConnection(device, dlmsMessageListener);\n-        } catch (final UnknownHostException e) { // Unknown IP, unrecoverable.\n-            LOGGER.error(\"The IP address is not found: {}\", device.getIpAddress(), e);\n-            throw new TechnicalException(ComponentType.PROTOCOL_DLMS,\n-                    \"The IP address is not found: \" + device.getIpAddress());\n-        } catch (final IOException e) { //Queue key recovery process\n-            if(this.secretManagementService.hasNewSecretOfType(device.getDeviceIdentification(), E_METER_ENCRYPTION)) {\n-               this.recoverKeyProcessInitiator.initiate(device.getDeviceIdentification(), device.getIpAddress());\n-            }\n-\n-            final String msg = String\n-                    .format(\"Error creating connection for device %s with Ip address:%s Port:%d UseHdlc:%b UseSn:%b \"\n-                                    + \"Message:%s\", device.getDeviceIdentification(), device.getIpAddress(),\n-                            device.getPort(),\n-                            device.isUseHdlc(), device.isUseSn(), e.getMessage());\n-            LOGGER.error(msg);\n-            throw new ConnectionException(msg, e);\n-        } catch (final EncrypterException e) {\n-            throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT, ComponentType.PROTOCOL_DLMS,\n-                    e);\n-        }\n+  }\n+\n+  @Override\n+  protected void setSecurity(\n+      final DlmsDevice device, final TcpConnectionBuilder tcpConnectionBuilder)\n+      throws OsgpException {\n+\n+    final String deviceIdentification = device.getDeviceIdentification();\n+    final byte[] dlmsAuthenticationKey;\n+    final byte[] dlmsEncryptionKey;\n+    try {\n+      final Map<SecurityKeyType, byte[]> encryptedKeys =\n+          this.secretManagementService.getKeys(\n+              deviceIdentification, Arrays.asList(E_METER_AUTHENTICATION, E_METER_ENCRYPTION));\n+      dlmsAuthenticationKey = encryptedKeys.get(E_METER_AUTHENTICATION);\n+      dlmsEncryptionKey = encryptedKeys.get(E_METER_ENCRYPTION);\n+    } catch (final EncrypterException e) {\n+      throw new FunctionalException(\n+          FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION, ComponentType.PROTOCOL_DLMS, e);\n     }\n \n-    @Override\n-    protected void setSecurity(final DlmsDevice device, final TcpConnectionBuilder tcpConnectionBuilder)\n-            throws OsgpException {\n-\n-        final String deviceIdentification = device.getDeviceIdentification();\n-        final byte[] dlmsAuthenticationKey;\n-        final byte[] dlmsEncryptionKey;\n-        try {\n-            Map<SecurityKeyType,byte[]> encryptedKeys = this.secretManagementService.getKeys(deviceIdentification,\n-                    Arrays.asList(E_METER_AUTHENTICATION, E_METER_ENCRYPTION));\n-            dlmsAuthenticationKey = encryptedKeys.get(E_METER_AUTHENTICATION);\n-            dlmsEncryptionKey = encryptedKeys.get(E_METER_ENCRYPTION);\n-        } catch (final EncrypterException e) {\n-            LOGGER.error(\"Error determining DLMS communication key setting up HLS5 connection\", e);\n-            throw new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION,\n-                    ComponentType.PROTOCOL_DLMS);\n-        }\n-\n-        // Validate keys before JDLMS does and throw a FunctionalException if\n-        // necessary\n-        this.validateKeys(dlmsAuthenticationKey, dlmsEncryptionKey);\n-\n-        this.configureIvData(tcpConnectionBuilder, device);\n-\n-        final SecuritySuite securitySuite = SecuritySuite.builder().setAuthenticationKey(dlmsAuthenticationKey)\n-                                                         .setAuthenticationMechanism(AuthenticationMechanism.HLS5_GMAC)\n-                                                         .setGlobalUnicastEncryptionKey(dlmsEncryptionKey)\n-                                                         .setEncryptionMechanism(EncryptionMechanism.AES_GCM_128)\n-                                                         .build();\n-\n-        tcpConnectionBuilder.setSecuritySuite(securitySuite).setClientId(this.clientId);\n+    // Validate keys before JDLMS does and throw a FunctionalException if\n+    // necessary\n+    this.validateKeys(dlmsAuthenticationKey, dlmsEncryptionKey);\n+\n+    this.configureIvData(tcpConnectionBuilder, device);\n+\n+    final SecuritySuite securitySuite =\n+        SecuritySuite.builder()\n+            .setAuthenticationKey(dlmsAuthenticationKey)\n+            .setAuthenticationMechanism(AuthenticationMechanism.HLS5_GMAC)\n+            .setGlobalUnicastEncryptionKey(dlmsEncryptionKey)\n+            .setEncryptionMechanism(EncryptionMechanism.AES_GCM_128)\n+            .build();\n+\n+    tcpConnectionBuilder.setSecuritySuite(securitySuite).setClientId(this.clientId);\n+  }\n+\n+  private void configureIvData(\n+      final TcpConnectionBuilder tcpConnectionBuilder, final DlmsDevice device) {\n+    /*\n+     * HLS5 communication needs an IV (initialization vector) that is unique\n+     * per encrypted message.\n+     *\n+     * This is taken care of by setting up a fixed 8 byte part which is\n+     * unique per device (the system title) and an invocation counter that\n+     * is incremented on each communication, and should never be used with\n+     * the same value for the same encryption key on the device.\n+     *\n+     * By setting the system title and frame counter on the connection\n+     * builder the library is enabled to meet the IV requirements of DLMS\n+     * HLS5 communication.\n+     */\n+    final String manufacturerId;\n+    if (StringUtils.isEmpty(device.getManufacturerId())) {\n+      LOGGER.warn(\n+          \"Device {} does not have its manufacturer ID stored in the database. \"\n+              + \"Using a default value which makes the system title (part of the IV in HLS 5) less \"\n+              + \"unique.\",\n+          device.getDeviceIdentification());\n+      manufacturerId = \"   \";\n+    } else {\n+      manufacturerId = device.getManufacturerId();\n     }\n+    tcpConnectionBuilder.setSystemTitle(manufacturerId, device.getDeviceId());\n \n-    private void configureIvData(final TcpConnectionBuilder tcpConnectionBuilder, final DlmsDevice device) {\n-        /*\n-         * HLS5 communication needs an IV (initialization vector) that is unique\n-         * per encrypted message.\n-         *\n-         * This is taken care of by setting up a fixed 8 byte part which is\n-         * unique per device (the system title) and an invocation counter that\n-         * is incremented on each communication, and should never be used with\n-         * the same value for the same encryption key on the device.\n-         *\n-         * By setting the system title and frame counter on the connection\n-         * builder the library is enabled to meet the IV requirements of DLMS\n-         * HLS5 communication.\n-         */\n-        final String manufacturerId;\n-        if (StringUtils.isEmpty(device.getManufacturerId())) {\n-            LOGGER.warn(\"Device {} does not have its manufacturer ID stored in the database. \"\n-                            + \"Using a default value which makes the system title (part of the IV in HLS 5) less \" +\n-                            \"unique.\",\n-                    device.getDeviceIdentification());\n-            manufacturerId = \"   \";\n-        } else {\n-            manufacturerId = device.getManufacturerId();\n-        }\n-        tcpConnectionBuilder.setSystemTitle(manufacturerId, device.getDeviceId());\n-\n-        long frameCounter = device.getInvocationCounter();\n-\n-        tcpConnectionBuilder.setFrameCounter(frameCounter);\n-        LOGGER.debug(\"Framecounter for device {} set to {}\", device.getDeviceIdentification(), frameCounter);\n+    final long frameCounter = device.getInvocationCounter();\n \n-    }\n+    tcpConnectionBuilder.setFrameCounter(frameCounter);\n+    LOGGER.debug(\n+        \"Framecounter for device {} set to {}\", device.getDeviceIdentification(), frameCounter);\n+  }\n \n-    private void validateKeys(final byte[] encryptionKey, final byte[] authenticationKey) throws FunctionalException {\n-        if (this.checkEmptyKey(encryptionKey)) {\n-            this.throwFunctionalException(\"The encryption key is empty\",\n-                    FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION);\n-        }\n-\n-        if (this.checkEmptyKey(authenticationKey)) {\n-            this.throwFunctionalException(\"The authentication key is empty\",\n-                    FunctionalExceptionType.INVALID_DLMS_KEY_ENCRYPTION);\n-        }\n-\n-        if (this.checkLenghtKey(encryptionKey)) {\n-            this.throwFunctionalException(\"The encryption key has an invalid length\",\n-                    FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT);\n-        }\n-\n-        if (this.checkLenghtKey(authenticationKey)) {\n-            this.throwFunctionalException(\"The authentication key has an invalid length\",\n-                    FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT);\n-        }\n+  private void validateKeys(final byte[] encryptionKey, final byte[] authenticationKey)\n+      throws FunctionalException {\n+    if (this.checkEmptyKey(encryptionKey)) {\n+      this.throwFunctionalException(\n+          \"The encryption key is empty\", FunctionalExceptionType.KEY_NOT_PRESENT);\n     }\n \n-    private boolean checkEmptyKey(final byte[] key) {\n-        return key == null;\n+    if (this.checkEmptyKey(authenticationKey)) {\n+      this.throwFunctionalException(\n+          \"The authentication key is empty\", FunctionalExceptionType.KEY_NOT_PRESENT);\n     }\n \n-    private boolean checkLenghtKey(final byte[] key) {\n-        return key.length * 8 != AES_GMC_128;\n+    if (this.checkLenghtKey(encryptionKey)) {\n+      this.throwFunctionalException(\n+          \"The encryption key has an invalid length\",\n+          FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT);\n     }\n \n-    private void throwFunctionalException(final String msg, final FunctionalExceptionType type)\n-            throws FunctionalException {\n-        LOGGER.error(msg);\n-        throw new FunctionalException(type, ComponentType.PROTOCOL_DLMS);\n+    if (this.checkLenghtKey(authenticationKey)) {\n+      this.throwFunctionalException(\n+          \"The authentication key has an invalid length\",\n+          FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT);\n     }\n+  }\n+\n+  private boolean checkEmptyKey(final byte[] key) {\n+    return key == null;\n+  }\n+\n+  private boolean checkLenghtKey(final byte[] key) {\n+    return key.length * 8 != AES_GMC_128;\n+  }\n+\n+  private void throwFunctionalException(final String msg, final FunctionalExceptionType type)\n+      throws FunctionalException {\n+    LOGGER.error(msg);\n+    throw new FunctionalException(type, ComponentType.PROTOCOL_DLMS);\n+  }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5OTE2NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450799164", "body": "change to constructor injection", "bodyText": "change to constructor injection", "bodyHTML": "<p dir=\"auto\">change to constructor injection</p>", "author": "coendamen", "createdAt": "2020-07-07T11:37:31Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java", "diffHunk": "@@ -57,6 +58,7 @@\n     }\n \n     @Autowired\n+    @Qualifier(\"secretManagementService\")\n     private SecurityKeyService securityKeyService;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\nindex c78c6a57ca..8bbfb96194 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\n", "chunk": "@@ -58,8 +71,7 @@ public class SetEncryptionKeyExchangeOnGMeterCommandExecutor\n     }\n \n     @Autowired\n-    @Qualifier(\"secretManagementService\")\n-    private SecurityKeyService securityKeyService;\n+    private SecretManagementService secretManagementService;\n \n     @Autowired\n     private DlmsDeviceRepository dlmsDeviceRepository;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\nindex 8bbfb96194..38956f1406 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\n", "chunk": "@@ -51,161 +48,186 @@ import org.springframework.stereotype.Component;\n \n @Component()\n public class SetEncryptionKeyExchangeOnGMeterCommandExecutor\n-        extends AbstractCommandExecutor<GMeterInfoDto, MethodResultCode> {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SetEncryptionKeyExchangeOnGMeterCommandExecutor.class);\n-\n-    private static final int CLASS_ID = 72;\n-    private static final ObisCode OBIS_CODE_INTERVAL_MBUS_1 = new ObisCode(\"0.1.24.1.0.255\");\n-    private static final ObisCode OBIS_CODE_INTERVAL_MBUS_2 = new ObisCode(\"0.2.24.1.0.255\");\n-    private static final ObisCode OBIS_CODE_INTERVAL_MBUS_3 = new ObisCode(\"0.3.24.1.0.255\");\n-    private static final ObisCode OBIS_CODE_INTERVAL_MBUS_4 = new ObisCode(\"0.4.24.1.0.255\");\n-\n-    private static final Map<Integer, ObisCode> OBIS_HASHMAP = new HashMap<>();\n-\n-    static {\n-        OBIS_HASHMAP.put(1, OBIS_CODE_INTERVAL_MBUS_1);\n-        OBIS_HASHMAP.put(2, OBIS_CODE_INTERVAL_MBUS_2);\n-        OBIS_HASHMAP.put(3, OBIS_CODE_INTERVAL_MBUS_3);\n-        OBIS_HASHMAP.put(4, OBIS_CODE_INTERVAL_MBUS_4);\n-    }\n-\n-    @Autowired\n-    private SecretManagementService secretManagementService;\n-\n-    @Autowired\n-    private DlmsDeviceRepository dlmsDeviceRepository;\n-\n-    public SetEncryptionKeyExchangeOnGMeterCommandExecutor() {\n-        super(GMeterInfoDto.class);\n-    }\n-\n-    @Override\n-    public ActionResponseDto asBundleResponse(final MethodResultCode executionResult) throws ProtocolAdapterException {\n-        this.checkMethodResultCode(executionResult);\n-        return new ActionResponseDto(\"M-Bus User key exchange on Gas meter was successful\");\n+    extends AbstractCommandExecutor<GMeterInfoDto, MethodResultCode> {\n+\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(SetEncryptionKeyExchangeOnGMeterCommandExecutor.class);\n+\n+  private static final int CLASS_ID = 72;\n+  private static final ObisCode OBIS_CODE_INTERVAL_MBUS_1 = new ObisCode(\"0.1.24.1.0.255\");\n+  private static final ObisCode OBIS_CODE_INTERVAL_MBUS_2 = new ObisCode(\"0.2.24.1.0.255\");\n+  private static final ObisCode OBIS_CODE_INTERVAL_MBUS_3 = new ObisCode(\"0.3.24.1.0.255\");\n+  private static final ObisCode OBIS_CODE_INTERVAL_MBUS_4 = new ObisCode(\"0.4.24.1.0.255\");\n+\n+  private static final Map<Integer, ObisCode> OBIS_HASHMAP = new HashMap<>();\n+\n+  static {\n+    OBIS_HASHMAP.put(1, OBIS_CODE_INTERVAL_MBUS_1);\n+    OBIS_HASHMAP.put(2, OBIS_CODE_INTERVAL_MBUS_2);\n+    OBIS_HASHMAP.put(3, OBIS_CODE_INTERVAL_MBUS_3);\n+    OBIS_HASHMAP.put(4, OBIS_CODE_INTERVAL_MBUS_4);\n+  }\n+\n+  @Autowired private SecretManagementService secretManagementService;\n+\n+  @Autowired private DlmsDeviceRepository dlmsDeviceRepository;\n+\n+  public SetEncryptionKeyExchangeOnGMeterCommandExecutor() {\n+    super(GMeterInfoDto.class);\n+  }\n+\n+  @Override\n+  public ActionResponseDto asBundleResponse(final MethodResultCode executionResult)\n+      throws ProtocolAdapterException {\n+    this.checkMethodResultCode(executionResult);\n+    return new ActionResponseDto(\"M-Bus User key exchange on Gas meter was successful\");\n+  }\n+\n+  @Override\n+  public MethodResultCode execute(\n+      final DlmsConnectionManager conn, final DlmsDevice device, final GMeterInfoDto gMeterInfo)\n+      throws ProtocolAdapterException {\n+    try {\n+      LOGGER.debug(\"SetEncryptionKeyExchangeOnGMeterCommandExecutor.execute called\");\n+\n+      final String mbusDeviceIdentification = gMeterInfo.getDeviceIdentification();\n+      final int channel = gMeterInfo.getChannel();\n+      final ObisCode obisCode = OBIS_HASHMAP.get(channel);\n+      final byte[] gMeterEncryptionKey =\n+          this.secretManagementService.generate128BitsKeyAndStoreAsNewKey(\n+              mbusDeviceIdentification, G_METER_ENCRYPTION);\n+\n+      MethodResult methodResultCode =\n+          this.transferKey(conn, mbusDeviceIdentification, channel, gMeterEncryptionKey);\n+      this.checkMethodResultCode(methodResultCode, \"M-Bus Setup transfer_key\", obisCode);\n+\n+      methodResultCode = this.setEncryptionKey(conn, channel, gMeterEncryptionKey);\n+      this.checkMethodResultCode(methodResultCode, \"M-Bus Setup set_encryption_key\", obisCode);\n+\n+      this.secretManagementService.activateNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n+      return MethodResultCode.SUCCESS;\n+    } catch (final IOException e) {\n+      throw new ConnectionException(e);\n+    } catch (final EncrypterException e) {\n+      throw new ProtocolAdapterException(\n+          \"Unexpected exception during decryption of security keys, reason = \" + e.getMessage(), e);\n     }\n-\n-    @Override\n-    public MethodResultCode execute(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final GMeterInfoDto gMeterInfo) throws ProtocolAdapterException {\n-        try {\n-            LOGGER.debug(\"SetEncryptionKeyExchangeOnGMeterCommandExecutor.execute called\");\n-\n-            final String mbusDeviceIdentification = gMeterInfo.getDeviceIdentification();\n-            final int channel = gMeterInfo.getChannel();\n-            final ObisCode obisCode = OBIS_HASHMAP.get(channel);\n-            final byte[] gMeterEncryptionKey = this.secretManagementService\n-                    .generate128BitsKeyAndStoreAsNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n-\n-            MethodResult methodResultCode = this\n-                    .transferKey(conn, mbusDeviceIdentification, channel, gMeterEncryptionKey);\n-            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup transfer_key\", obisCode);\n-\n-            methodResultCode = this.setEncryptionKey(conn, channel, gMeterEncryptionKey);\n-            this.checkMethodResultCode(methodResultCode, \"M-Bus Setup set_encryption_key\", obisCode);\n-\n-            this.secretManagementService.activateNewKey(mbusDeviceIdentification, G_METER_ENCRYPTION);\n-            return MethodResultCode.SUCCESS;\n-        } catch (final IOException e) {\n-            throw new ConnectionException(e);\n-        } catch (final EncrypterException e) {\n-            throw new ProtocolAdapterException(\n-                    \"Unexpected exception during decryption of security keys, reason = \" + e.getMessage(), e);\n-        } catch (final FunctionalException e) {\n-            throw new ProtocolAdapterException(\"Unexpected exception: \" + e.toString(), e);\n-        }\n-    }\n-\n-    private MethodResult setEncryptionKey(DlmsConnectionManager conn, int channel, byte[] encryptionKey)\n-            throws IOException {\n-        MethodResult methodResultCode;\n-        final MethodParameter methodSetEncryptionKey = this\n-                .getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n-        conn.getDlmsMessageListener().setDescription(\"SetEncryptionKeyExchangeOnGMeter for channel \" + channel\n-                + \", call M-Bus Setup set_encryption_key method: \" + JdlmsObjectToStringUtil\n-                .describeMethod(methodSetEncryptionKey));\n-        methodResultCode = conn.getConnection().action(methodSetEncryptionKey);\n-        return methodResultCode;\n-    }\n-\n-    private MethodResult transferKey(DlmsConnectionManager conn, String mbusDeviceIdentification, int channel,\n-            byte[] encryptionKey) throws ProtocolAdapterException, IOException, FunctionalException {\n-        final MethodParameter methodTransferKey = this\n-                .getTransferKeyMethodParameter(mbusDeviceIdentification, channel, encryptionKey);\n-        conn.getDlmsMessageListener().setDescription(\n-                \"SetEncryptionKeyExchangeOnGMeter for channel \" + channel + \", call M-Bus Setup transfer_key method: \"\n-                        + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n-\n-        return conn.getConnection().action(methodTransferKey);\n+  }\n+\n+  private MethodResult setEncryptionKey(\n+      final DlmsConnectionManager conn, final int channel, final byte[] encryptionKey)\n+      throws IOException {\n+    final MethodParameter methodSetEncryptionKey =\n+        this.getSetEncryptionKeyMethodParameter(OBIS_HASHMAP.get(channel), encryptionKey);\n+    conn.getDlmsMessageListener()\n+        .setDescription(\n+            \"SetEncryptionKeyExchangeOnGMeter for channel \"\n+                + channel\n+                + \", call M-Bus Setup set_encryption_key method: \"\n+                + JdlmsObjectToStringUtil.describeMethod(methodSetEncryptionKey));\n+    return conn.getConnection().action(methodSetEncryptionKey);\n+  }\n+\n+  private MethodResult transferKey(\n+      final DlmsConnectionManager conn,\n+      final String mbusDeviceIdentification,\n+      final int channel,\n+      final byte[] encryptionKey)\n+      throws ProtocolAdapterException, IOException {\n+    final MethodParameter methodTransferKey =\n+        this.getTransferKeyMethodParameter(mbusDeviceIdentification, channel, encryptionKey);\n+    conn.getDlmsMessageListener()\n+        .setDescription(\n+            \"SetEncryptionKeyExchangeOnGMeter for channel \"\n+                + channel\n+                + \", call M-Bus Setup transfer_key method: \"\n+                + JdlmsObjectToStringUtil.describeMethod(methodTransferKey));\n+\n+    return conn.getConnection().action(methodTransferKey);\n+  }\n+\n+  private MethodParameter getTransferKeyMethodParameter(\n+      final String mbusDeviceIdentification, final int channel, final byte[] gMeterUserKey)\n+      throws ProtocolAdapterException {\n+    final DlmsDevice mbusDevice =\n+        this.dlmsDeviceRepository.findByDeviceIdentification(mbusDeviceIdentification);\n+    if (mbusDevice == null) {\n+      throw new ProtocolAdapterException(\"Unknown M-Bus device: \" + mbusDeviceIdentification);\n     }\n-\n-    private MethodParameter getTransferKeyMethodParameter(String mbusDeviceIdentification, int channel,\n-            byte[] gMeterUserKey) throws ProtocolAdapterException, FunctionalException {\n-        DlmsDevice mbusDevice = this.dlmsDeviceRepository.findByDeviceIdentification(mbusDeviceIdentification);\n-        if (mbusDevice == null) {\n-            throw new ProtocolAdapterException(\"Unknown M-Bus device: \" + mbusDeviceIdentification);\n-        }\n-        final byte[] mbusDefaultKey = this.secretManagementService.getKey(mbusDeviceIdentification, G_METER_MASTER);\n-        final byte[] encryptedUserKey = this.encryptMbusUserKey(mbusDefaultKey, gMeterUserKey);\n-        final DataObject methodParameter = DataObject.newOctetStringData(encryptedUserKey);\n-        final MBusClientMethod method = MBusClientMethod.TRANSFER_KEY;\n-        return new MethodParameter(method.getInterfaceClass().id(), OBIS_HASHMAP.get(channel), method.getMethodId(),\n-                methodParameter);\n-    }\n-\n-    private void checkMethodResultCode(final MethodResult methodResultCode, final String methodParameterName,\n-            ObisCode obisCode) throws ProtocolAdapterException {\n-        if (methodResultCode == null || !MethodResultCode.SUCCESS.equals(methodResultCode.getResultCode())) {\n-            String message = \"Error while executing \" + methodParameterName + \".\";\n-            if (methodResultCode != null) {\n-                message += \" Reason = \" + methodResultCode.getResultCode();\n-            }\n-            throw new ProtocolAdapterException(message);\n-        } else {\n-            LOGGER.info(\"Successfully invoked '{}' method: class_id {} obis_code {}\", methodParameterName, CLASS_ID,\n-                    obisCode);\n-        }\n+    final byte[] mbusDefaultKey =\n+        this.secretManagementService.getKey(mbusDeviceIdentification, G_METER_MASTER);\n+    final byte[] encryptedUserKey = this.encryptMbusUserKey(mbusDefaultKey, gMeterUserKey);\n+    final DataObject methodParameter = DataObject.newOctetStringData(encryptedUserKey);\n+    final MBusClientMethod method = MBusClientMethod.TRANSFER_KEY;\n+    return new MethodParameter(\n+        method.getInterfaceClass().id(),\n+        OBIS_HASHMAP.get(channel),\n+        method.getMethodId(),\n+        methodParameter);\n+  }\n+\n+  private void checkMethodResultCode(\n+      final MethodResult methodResultCode,\n+      final String methodParameterName,\n+      final ObisCode obisCode)\n+      throws ProtocolAdapterException {\n+    if (methodResultCode == null\n+        || !MethodResultCode.SUCCESS.equals(methodResultCode.getResultCode())) {\n+      String message = \"Error while executing \" + methodParameterName + \".\";\n+      if (methodResultCode != null) {\n+        message += \" Reason = \" + methodResultCode.getResultCode();\n+      }\n+      throw new ProtocolAdapterException(message);\n+    } else {\n+      LOGGER.info(\n+          \"Successfully invoked '{}' method: class_id {} obis_code {}\",\n+          methodParameterName,\n+          CLASS_ID,\n+          obisCode);\n     }\n-\n-    private MethodParameter getSetEncryptionKeyMethodParameter(final ObisCode obisCode, final byte[] encryptionKey) {\n-        final DataObject methodParameter = DataObject.newOctetStringData(encryptionKey);\n-        final MBusClientMethod method = MBusClientMethod.SET_ENCRYPTION_KEY;\n-        return new MethodParameter(method.getInterfaceClass().id(), obisCode, method.getMethodId(), methodParameter);\n-    }\n-\n-    /**\n-     * Encrypts a new M-Bus User key with the M-Bus Default key for use as M-Bus\n-     * Client Setup transfer_key parameter.\n-     * <p>\n-     * Note that the specifics of the encryption of the M-Bus User key depend on\n-     * the M-Bus version the devices support. This method should be appropriate\n-     * for use with DSMR 4 M-Bus devices.\n-     * <p>\n-     * The encryption is performed by applying an AES/CBC/NoPadding cipher\n-     * initialized for encryption with the given mbusDefaultKey and an\n-     * initialization vector of 16 zero-bytes to the given mbusUserKey.\n-     *\n-     * @return the properly wrapped User key for a DSMR 4 M-Bus User key change.\n-     */\n-    private byte[] encryptMbusUserKey(final byte[] mbusDefaultKey, final byte[] mbusUserKey)\n-            throws ProtocolAdapterException {\n-\n-        final Key secretkeySpec = new SecretKeySpec(mbusDefaultKey, \"AES\");\n-\n-        try {\n-\n-            final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n-\n-            final IvParameterSpec params = new IvParameterSpec(new byte[16]);\n-            cipher.init(Cipher.ENCRYPT_MODE, secretkeySpec, params);\n-\n-            return cipher.doFinal(mbusUserKey);\n-\n-        } catch (final NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {\n-            final String message = \"Error encrypting M-Bus User key with M-Bus Default key for transfer.\";\n-            LOGGER.error(message, e);\n-            throw new ProtocolAdapterException(message);\n-        }\n+  }\n+\n+  private MethodParameter getSetEncryptionKeyMethodParameter(\n+      final ObisCode obisCode, final byte[] encryptionKey) {\n+    final DataObject methodParameter = DataObject.newOctetStringData(encryptionKey);\n+    final MBusClientMethod method = MBusClientMethod.SET_ENCRYPTION_KEY;\n+    return new MethodParameter(\n+        method.getInterfaceClass().id(), obisCode, method.getMethodId(), methodParameter);\n+  }\n+\n+  /**\n+   * Encrypts a new M-Bus User key with the M-Bus Default key for use as M-Bus Client Setup\n+   * transfer_key parameter.\n+   *\n+   * <p>Note that the specifics of the encryption of the M-Bus User key depend on the M-Bus version\n+   * the devices support. This method should be appropriate for use with DSMR 4 M-Bus devices.\n+   *\n+   * <p>The encryption is performed by applying an AES/CBC/NoPadding cipher initialized for\n+   * encryption with the given mbusDefaultKey and an initialization vector of 16 zero-bytes to the\n+   * given mbusUserKey.\n+   *\n+   * @return the properly wrapped User key for a DSMR 4 M-Bus User key change.\n+   */\n+  private byte[] encryptMbusUserKey(final byte[] mbusDefaultKey, final byte[] mbusUserKey)\n+      throws ProtocolAdapterException {\n+\n+    final Key secretkeySpec = new SecretKeySpec(mbusDefaultKey, \"AES\");\n+\n+    try {\n+      final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+      final IvParameterSpec params = new IvParameterSpec(new byte[16]);\n+      cipher.init(Cipher.ENCRYPT_MODE, secretkeySpec, params);\n+      return cipher.doFinal(mbusUserKey);\n+\n+    } catch (final NoSuchAlgorithmException\n+        | NoSuchPaddingException\n+        | InvalidKeyException\n+        | InvalidAlgorithmParameterException\n+        | IllegalBlockSizeException\n+        | BadPaddingException e) {\n+      final String message = \"Error encrypting M-Bus User key with M-Bus Default key for transfer.\";\n+      LOGGER.error(message, e);\n+      throw new ProtocolAdapterException(message);\n     }\n+  }\n }\n", "next_change": {"commit": "aa058da7267fd0328be1818a50fcb14fcdfb2ab5", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetKeyOnGMeterCommandExecutor.java\nsimilarity index 72%\nrename from osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\nrename to osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetKeyOnGMeterCommandExecutor.java\nindex 38956f1406..f9fb3effca 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetEncryptionKeyExchangeOnGMeterCommandExecutor.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/SetKeyOnGMeterCommandExecutor.java\n", "chunk": "@@ -194,40 +199,4 @@ public class SetEncryptionKeyExchangeOnGMeterCommandExecutor\n     return new MethodParameter(\n         method.getInterfaceClass().id(), obisCode, method.getMethodId(), methodParameter);\n   }\n-\n-  /**\n-   * Encrypts a new M-Bus User key with the M-Bus Default key for use as M-Bus Client Setup\n-   * transfer_key parameter.\n-   *\n-   * <p>Note that the specifics of the encryption of the M-Bus User key depend on the M-Bus version\n-   * the devices support. This method should be appropriate for use with DSMR 4 M-Bus devices.\n-   *\n-   * <p>The encryption is performed by applying an AES/CBC/NoPadding cipher initialized for\n-   * encryption with the given mbusDefaultKey and an initialization vector of 16 zero-bytes to the\n-   * given mbusUserKey.\n-   *\n-   * @return the properly wrapped User key for a DSMR 4 M-Bus User key change.\n-   */\n-  private byte[] encryptMbusUserKey(final byte[] mbusDefaultKey, final byte[] mbusUserKey)\n-      throws ProtocolAdapterException {\n-\n-    final Key secretkeySpec = new SecretKeySpec(mbusDefaultKey, \"AES\");\n-\n-    try {\n-      final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n-      final IvParameterSpec params = new IvParameterSpec(new byte[16]);\n-      cipher.init(Cipher.ENCRYPT_MODE, secretkeySpec, params);\n-      return cipher.doFinal(mbusUserKey);\n-\n-    } catch (final NoSuchAlgorithmException\n-        | NoSuchPaddingException\n-        | InvalidKeyException\n-        | InvalidAlgorithmParameterException\n-        | IllegalBlockSizeException\n-        | BadPaddingException e) {\n-      final String message = \"Error encrypting M-Bus User key with M-Bus Default key for transfer.\";\n-      LOGGER.error(message, e);\n-      throw new ProtocolAdapterException(message);\n-    }\n-  }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc5OTUzOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450799539", "body": "@Slf4j", "bodyText": "@slf4j", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/slf4j/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/slf4j\">@slf4j</a></p>", "author": "coendamen", "createdAt": "2020-07-07T11:38:21Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient;\n+\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceTemplate;\n+\n+/**\n+ * SOAP Client for SecretManagement\n+ */\n+@Component\n+public class SecretManagementClient {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n+\n+    private final WebServiceTemplate webServiceTemplate;\n+\n+    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n+        this.webServiceTemplate = webServiceTemplate;\n+    }\n+\n+    public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n+\n+        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex d54079a3b2..362c5e30ff 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -26,7 +24,7 @@ public class SecretManagementClient {\n \n     public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+        log.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n \n         return (GetSecretsResponse) this.webServiceTemplate\n                 .marshalSendAndReceive(request);\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 362c5e30ff..a4ffa5e674 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -28,11 +40,36 @@ public class SecretManagementClient {\n \n         return (GetSecretsResponse) this.webServiceTemplate\n                 .marshalSendAndReceive(request);\n-\n     }\n \n     public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        throw new NotImplementedException();\n+        log.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+\n+        return (StoreSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n+\n+    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n+        log.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (ActivateSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n+\n+    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n+        log.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (HasNewSecretResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n     }\n \n+    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n+        log.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n }\n", "next_change": {"commit": "ee07b18fb34cda88d8e134059b2e2527c3dc5e84", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex a4ffa5e674..b2524e7e00 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -66,7 +77,7 @@ public class SecretManagementClient {\n     }\n \n     public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        log.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n                 request.getDeviceId());\n \n         return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex b2524e7e00..c8d3fb04ef 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -24,63 +25,65 @@ import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n import org.springframework.ws.client.core.WebServiceTemplate;\n \n-/**\n- * SOAP Client for SecretManagement\n- */\n+/** SOAP Client for SecretManagement */\n @Component\n public class SecretManagementClient {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n-    private final WebServiceTemplate webServiceTemplate;\n+  private final WebServiceTemplate webServiceTemplate;\n \n-    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n-        this.webServiceTemplate = webServiceTemplate;\n-    }\n+  SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n+    this.webServiceTemplate = webServiceTemplate;\n+  }\n \n-    public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n+  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GetNewSecretsResponse getNewSecretsRequest(GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetNewSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (StoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (ActivateSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (HasNewSecretResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n-                request.getDeviceId());\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n+      final GenerateAndStoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n }\n", "next_change": {"commit": "bae6f663b4100b43f076c7fe499728b5749dc28f", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex c8d3fb04ef..a2e70a7226 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -20,70 +23,102 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRe\n import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceMessageCallback;\n import org.springframework.ws.client.core.WebServiceTemplate;\n+import org.springframework.ws.soap.SoapHeader;\n+import org.springframework.ws.soap.SoapMessage;\n \n /** SOAP Client for SecretManagement */\n+@Slf4j\n @Component\n public class SecretManagementClient {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+  private static final String CORRELATION_UID = \"correlationUid\";\n   private final WebServiceTemplate webServiceTemplate;\n \n   SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n     this.webServiceTemplate = webServiceTemplate;\n   }\n \n-  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n+  private WebServiceMessageCallback createCorrelationHeaderCallback(\n+      final MessageMetadata messageMetadata) {\n+    return message -> {\n+      final SoapMessage soapMessage = (SoapMessage) message;\n+      final SoapHeader header = soapMessage.getSoapHeader();\n+      header\n+          .addHeaderElement(new QName(NAMESPACE_URI, CORRELATION_UID))\n+          .setText(messageMetadata.getCorrelationUid());\n+    };\n+  }\n+\n+  public GetSecretsResponse getSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetNewSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetNewSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n-    LOGGER.info(\n+  public StoreSecretsResponse storeSecretsRequest(\n+      final MessageMetadata messageMetadata, final StoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (StoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n-    LOGGER.info(\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      final MessageMetadata messageMetadata, final ActivateSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (ActivateSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n-    LOGGER.info(\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      final MessageMetadata messageMetadata, final HasNewSecretRequest request) {\n+    log.info(\n         \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (HasNewSecretResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n   public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n-      final GenerateAndStoreSecretsRequest request) {\n-    LOGGER.info(\n+      final MessageMetadata messageMetadata, final GenerateAndStoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GenerateAndStoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMDgyNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450800824", "body": "dit kom meerdere keren voor. dit moet allemaal veranderen in SecretManagementService injection, die qualifier kan weg", "bodyText": "dit kom meerdere keren voor. dit moet allemaal veranderen in SecretManagementService injection, die qualifier kan weg", "bodyHTML": "<p dir=\"auto\">dit kom meerdere keren voor. dit moet allemaal veranderen in SecretManagementService injection, die qualifier kan weg</p>", "author": "coendamen", "createdAt": "2020-07-07T11:40:42Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java", "diffHunk": "@@ -39,6 +40,7 @@\n     private InstallationMapper installationMapper;\n \n     @Autowired\n+    @Qualifier(\"secretManagementService\")\n     private SecurityKeyService securityKeyService;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe0089dac7cf66db3a9383f1198100cf4ef33395", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\nindex c3e94f9627..174b43626d 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n", "chunk": "@@ -40,7 +46,9 @@ public class InstallationService {\n     private InstallationMapper installationMapper;\n \n     @Autowired\n-    @Qualifier(\"secretManagementService\")\n+    private EncryptionService encryptionService;\n+\n+    @Autowired\n     private SecurityKeyService securityKeyService;\n \n     @Autowired\n", "next_change": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\nindex 174b43626d..83ec52caa5 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n", "chunk": "@@ -49,7 +49,7 @@ public class InstallationService {\n     private EncryptionService encryptionService;\n \n     @Autowired\n-    private SecurityKeyService securityKeyService;\n+    private SecretManagementService secretManagementService;\n \n     @Autowired\n     private CoupleMBusDeviceCommandExecutor coupleMBusDeviceCommandExecutor;\n", "next_change": {"commit": "8ba12210b740a8fa2ab40ca897b6716f96162146", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\nindex 83ec52caa5..62bf3b66c6 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n", "chunk": "@@ -46,7 +46,7 @@ public class InstallationService {\n     private InstallationMapper installationMapper;\n \n     @Autowired\n-    private EncryptionService encryptionService;\n+    private EncryptionHelperService encryptionService;\n \n     @Autowired\n     private SecretManagementService secretManagementService;\n", "next_change": {"commit": "102f9240c7b88b7117ab6b78e2c349e629251545", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\nindex 62bf3b66c6..573ebe41cb 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n", "chunk": "@@ -55,24 +61,70 @@ public class InstallationService {\n     private CoupleMBusDeviceCommandExecutor coupleMBusDeviceCommandExecutor;\n \n     @Autowired\n-    private DeCoupleMBusDeviceCommandExecutor deCoupleMBusDeviceCommandExecutor;\n+    private DecoupleMBusDeviceCommandExecutor decoupleMBusDeviceCommandExecutor;\n \n     @Autowired\n     private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n \n     public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        this.storeNewKeys(smartMeteringDevice);\n+        if (smartMeteringDevice.getDeviceIdentification() == null) {\n+            throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n+                    new IllegalArgumentException(\"Provided device does not contain device identification\"));\n+        }\n+        this.storeAndActivateKeys(smartMeteringDevice);\n         final DlmsDevice dlmsDevice = this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n         this.dlmsDeviceRepository.save(dlmsDevice);\n     }\n \n-    private void storeNewKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n-        Map<SecurityKeyType,byte[]> keysByType = new HashMap<>();\n-        keysByType.put(E_METER_MASTER,this.encryptionService.rsaDecrypt(deviceDto.getMasterKey()));\n-        keysByType.put(E_METER_AUTHENTICATION,this.encryptionService.rsaDecrypt(deviceDto.getAuthenticationKey()));\n-        keysByType.put(G_METER_ENCRYPTION,this.encryptionService.rsaDecrypt(deviceDto.getGlobalEncryptionUnicastKey()));\n-        keysByType.put(G_METER_MASTER,this.encryptionService.rsaDecrypt(deviceDto.getMbusDefaultKey()));\n+    private void storeAndActivateKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n+        final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+        final List<SecurityKeyType> keyTypesToStore = this.determineKeyTypesToStore(deviceDto);\n+        for (SecurityKeyType keyType : keyTypesToStore) {\n+            final byte[] key = this.getKeyFromDeviceDto(deviceDto, keyType);\n+            if (ArrayUtils.isNotEmpty(key)) {\n+                keysByType.put(keyType, this.encryptionService.rsaDecrypt(key));\n+            } else {\n+                Exception rootCause = new NoSuchElementException(keyType.name());\n+                throw new FunctionalException(FunctionalExceptionType.KEY_NOT_PRESENT, ComponentType.PROTOCOL_DLMS,\n+                        rootCause);\n+            }\n+        }\n         this.secretManagementService.storeNewKeys(deviceDto.getDeviceIdentification(), keysByType);\n+        this.secretManagementService.activateNewKeys(deviceDto.getDeviceIdentification(), keyTypesToStore);\n+    }\n+\n+    private List<SecurityKeyType> determineKeyTypesToStore(final SmartMeteringDeviceDto deviceDto)\n+            throws FunctionalException {\n+        if (this.getKeyFromDeviceDto(deviceDto, G_METER_MASTER) != null) {\n+            //device is a G-Meter\n+            if (this.getKeyFromDeviceDto(deviceDto, E_METER_MASTER) != null\n+                    || this.getKeyFromDeviceDto(deviceDto, E_METER_AUTHENTICATION) != null\n+                    || this.getKeyFromDeviceDto(deviceDto, E_METER_ENCRYPTION) != null) {\n+                final String msg = \"Provided device is considered a G-Meter (G_METER_MASTER is set)\"\n+                        + \", but contains E-Meter keys as well\";\n+                throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n+                        new IllegalArgumentException(msg));\n+            }\n+            return Arrays.asList(G_METER_MASTER);\n+        } else {\n+            //device is an E-meter\n+            return Arrays.asList(E_METER_MASTER, E_METER_AUTHENTICATION, E_METER_ENCRYPTION);\n+        }\n+    }\n+\n+    private byte[] getKeyFromDeviceDto(final SmartMeteringDeviceDto deviceDto, final SecurityKeyType keyType) {\n+        switch (keyType) {\n+        case E_METER_MASTER:\n+            return deviceDto.getMasterKey();\n+        case E_METER_AUTHENTICATION:\n+            return deviceDto.getAuthenticationKey();\n+        case E_METER_ENCRYPTION:\n+            return deviceDto.getGlobalEncryptionUnicastKey();\n+        case G_METER_MASTER:\n+            return deviceDto.getMbusDefaultKey();\n+        default:\n+            throw new IllegalArgumentException(\"Unknown type \" + keyType);\n+        }\n     }\n \n     public MbusChannelElementsResponseDto coupleMbusDevice(final DlmsConnectionManager conn, final DlmsDevice device,\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\nindex 573ebe41cb..dfcd480079 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n", "chunk": "@@ -45,101 +44,113 @@ import org.springframework.stereotype.Service;\n @Service(value = \"dlmsInstallationService\")\n public class InstallationService {\n \n-    @Autowired\n-    private DlmsDeviceRepository dlmsDeviceRepository;\n-\n-    @Autowired\n-    private InstallationMapper installationMapper;\n-\n-    @Autowired\n-    private EncryptionHelperService encryptionService;\n+  @Autowired private DlmsDeviceRepository dlmsDeviceRepository;\n \n-    @Autowired\n-    private SecretManagementService secretManagementService;\n+  @Autowired private InstallationMapper installationMapper;\n \n-    @Autowired\n-    private CoupleMBusDeviceCommandExecutor coupleMBusDeviceCommandExecutor;\n+  @Autowired private EncryptionHelperService encryptionService;\n \n-    @Autowired\n-    private DecoupleMBusDeviceCommandExecutor decoupleMBusDeviceCommandExecutor;\n+  @Autowired private SecretManagementService secretManagementService;\n \n-    @Autowired\n-    private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n-\n-    public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice) throws FunctionalException {\n-        if (smartMeteringDevice.getDeviceIdentification() == null) {\n-            throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n-                    new IllegalArgumentException(\"Provided device does not contain device identification\"));\n-        }\n-        this.storeAndActivateKeys(smartMeteringDevice);\n-        final DlmsDevice dlmsDevice = this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n-        this.dlmsDeviceRepository.save(dlmsDevice);\n-    }\n+  @Autowired private CoupleMBusDeviceCommandExecutor coupleMBusDeviceCommandExecutor;\n \n-    private void storeAndActivateKeys(final SmartMeteringDeviceDto deviceDto) throws FunctionalException {\n-        final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n-        final List<SecurityKeyType> keyTypesToStore = this.determineKeyTypesToStore(deviceDto);\n-        for (SecurityKeyType keyType : keyTypesToStore) {\n-            final byte[] key = this.getKeyFromDeviceDto(deviceDto, keyType);\n-            if (ArrayUtils.isNotEmpty(key)) {\n-                keysByType.put(keyType, this.encryptionService.rsaDecrypt(key));\n-            } else {\n-                Exception rootCause = new NoSuchElementException(keyType.name());\n-                throw new FunctionalException(FunctionalExceptionType.KEY_NOT_PRESENT, ComponentType.PROTOCOL_DLMS,\n-                        rootCause);\n-            }\n-        }\n-        this.secretManagementService.storeNewKeys(deviceDto.getDeviceIdentification(), keysByType);\n-        this.secretManagementService.activateNewKeys(deviceDto.getDeviceIdentification(), keyTypesToStore);\n-    }\n+  @Autowired private DecoupleMBusDeviceCommandExecutor decoupleMBusDeviceCommandExecutor;\n \n-    private List<SecurityKeyType> determineKeyTypesToStore(final SmartMeteringDeviceDto deviceDto)\n-            throws FunctionalException {\n-        if (this.getKeyFromDeviceDto(deviceDto, G_METER_MASTER) != null) {\n-            //device is a G-Meter\n-            if (this.getKeyFromDeviceDto(deviceDto, E_METER_MASTER) != null\n-                    || this.getKeyFromDeviceDto(deviceDto, E_METER_AUTHENTICATION) != null\n-                    || this.getKeyFromDeviceDto(deviceDto, E_METER_ENCRYPTION) != null) {\n-                final String msg = \"Provided device is considered a G-Meter (G_METER_MASTER is set)\"\n-                        + \", but contains E-Meter keys as well\";\n-                throw new FunctionalException(FunctionalExceptionType.VALIDATION_ERROR, ComponentType.PROTOCOL_DLMS,\n-                        new IllegalArgumentException(msg));\n-            }\n-            return Arrays.asList(G_METER_MASTER);\n-        } else {\n-            //device is an E-meter\n-            return Arrays.asList(E_METER_MASTER, E_METER_AUTHENTICATION, E_METER_ENCRYPTION);\n-        }\n-    }\n+  @Autowired\n+  private CoupleMbusDeviceByChannelCommandExecutor coupleMbusDeviceByChannelCommandExecutor;\n \n-    private byte[] getKeyFromDeviceDto(final SmartMeteringDeviceDto deviceDto, final SecurityKeyType keyType) {\n-        switch (keyType) {\n-        case E_METER_MASTER:\n-            return deviceDto.getMasterKey();\n-        case E_METER_AUTHENTICATION:\n-            return deviceDto.getAuthenticationKey();\n-        case E_METER_ENCRYPTION:\n-            return deviceDto.getGlobalEncryptionUnicastKey();\n-        case G_METER_MASTER:\n-            return deviceDto.getMbusDefaultKey();\n-        default:\n-            throw new IllegalArgumentException(\"Unknown type \" + keyType);\n-        }\n+  public void addMeter(final SmartMeteringDeviceDto smartMeteringDevice)\n+      throws FunctionalException {\n+    if (smartMeteringDevice.getDeviceIdentification() == null) {\n+      throw new FunctionalException(\n+          FunctionalExceptionType.VALIDATION_ERROR,\n+          ComponentType.PROTOCOL_DLMS,\n+          new IllegalArgumentException(\"Provided device does not contain device identification\"));\n     }\n-\n-    public MbusChannelElementsResponseDto coupleMbusDevice(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final MbusChannelElementsDto mbusChannelElements) throws ProtocolAdapterException {\n-        return this.coupleMBusDeviceCommandExecutor.execute(conn, device, mbusChannelElements);\n+    this.storeAndActivateKeys(smartMeteringDevice);\n+    final DlmsDevice dlmsDevice =\n+        this.installationMapper.map(smartMeteringDevice, DlmsDevice.class);\n+    this.dlmsDeviceRepository.save(dlmsDevice);\n+  }\n+\n+  private void storeAndActivateKeys(final SmartMeteringDeviceDto deviceDto)\n+      throws FunctionalException {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    final List<SecurityKeyType> keyTypesToStore = this.determineKeyTypesToStore(deviceDto);\n+    for (final SecurityKeyType keyType : keyTypesToStore) {\n+      final byte[] key = this.getKeyFromDeviceDto(deviceDto, keyType);\n+      if (ArrayUtils.isNotEmpty(key)) {\n+        keysByType.put(keyType, this.encryptionService.rsaDecrypt(key));\n+      } else {\n+        final Exception rootCause = new NoSuchElementException(keyType.name());\n+        throw new FunctionalException(\n+            FunctionalExceptionType.KEY_NOT_PRESENT, ComponentType.PROTOCOL_DLMS, rootCause);\n+      }\n     }\n-\n-    public CoupleMbusDeviceByChannelResponseDto coupleMbusDeviceByChannel(final DlmsConnectionManager conn,\n-            final DlmsDevice device, final CoupleMbusDeviceByChannelRequestDataDto requestDto)\n-            throws ProtocolAdapterException {\n-        return this.coupleMbusDeviceByChannelCommandExecutor.execute(conn, device, requestDto);\n+    this.secretManagementService.storeNewKeys(deviceDto.getDeviceIdentification(), keysByType);\n+    this.secretManagementService.activateNewKeys(\n+        deviceDto.getDeviceIdentification(), keyTypesToStore);\n+  }\n+\n+  private List<SecurityKeyType> determineKeyTypesToStore(final SmartMeteringDeviceDto deviceDto)\n+      throws FunctionalException {\n+    if (this.getKeyFromDeviceDto(deviceDto, G_METER_MASTER) != null) {\n+      // device is a G-Meter\n+      if (this.getKeyFromDeviceDto(deviceDto, E_METER_MASTER) != null\n+          || this.getKeyFromDeviceDto(deviceDto, E_METER_AUTHENTICATION) != null\n+          || this.getKeyFromDeviceDto(deviceDto, E_METER_ENCRYPTION) != null) {\n+        final String msg =\n+            \"Provided device is considered a G-Meter (G_METER_MASTER is set)\"\n+                + \", but contains E-Meter keys as well\";\n+        throw new FunctionalException(\n+            FunctionalExceptionType.VALIDATION_ERROR,\n+            ComponentType.PROTOCOL_DLMS,\n+            new IllegalArgumentException(msg));\n+      }\n+      return Arrays.asList(G_METER_MASTER);\n+    } else {\n+      // device is an E-meter\n+      return Arrays.asList(E_METER_MASTER, E_METER_AUTHENTICATION, E_METER_ENCRYPTION);\n     }\n-\n-    public DecoupleMbusDeviceResponseDto decoupleMbusDevice(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final DecoupleMbusDeviceDto decoupleMbusDeviceDto) throws ProtocolAdapterException {\n-        return this.decoupleMBusDeviceCommandExecutor.execute(conn, device, decoupleMbusDeviceDto);\n+  }\n+\n+  private byte[] getKeyFromDeviceDto(\n+      final SmartMeteringDeviceDto deviceDto, final SecurityKeyType keyType) {\n+    switch (keyType) {\n+      case E_METER_MASTER:\n+        return deviceDto.getMasterKey();\n+      case E_METER_AUTHENTICATION:\n+        return deviceDto.getAuthenticationKey();\n+      case E_METER_ENCRYPTION:\n+        return deviceDto.getGlobalEncryptionUnicastKey();\n+      case G_METER_MASTER:\n+        return deviceDto.getMbusDefaultKey();\n+      default:\n+        throw new IllegalArgumentException(\"Unknown type \" + keyType);\n     }\n+  }\n+\n+  public MbusChannelElementsResponseDto coupleMbusDevice(\n+      final DlmsConnectionManager conn,\n+      final DlmsDevice device,\n+      final MbusChannelElementsDto mbusChannelElements)\n+      throws ProtocolAdapterException {\n+    return this.coupleMBusDeviceCommandExecutor.execute(conn, device, mbusChannelElements);\n+  }\n+\n+  public CoupleMbusDeviceByChannelResponseDto coupleMbusDeviceByChannel(\n+      final DlmsConnectionManager conn,\n+      final DlmsDevice device,\n+      final CoupleMbusDeviceByChannelRequestDataDto requestDto)\n+      throws ProtocolAdapterException {\n+    return this.coupleMbusDeviceByChannelCommandExecutor.execute(conn, device, requestDto);\n+  }\n+\n+  public DecoupleMbusDeviceResponseDto decoupleMbusDevice(\n+      final DlmsConnectionManager conn,\n+      final DlmsDevice device,\n+      final DecoupleMbusDeviceDto decoupleMbusDeviceDto)\n+      throws ProtocolAdapterException {\n+    return this.decoupleMBusDeviceCommandExecutor.execute(conn, device, decoupleMbusDeviceDto);\n+  }\n }\n", "next_change": {"commit": "bae6f663b4100b43f076c7fe499728b5749dc28f", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\nindex dfcd480079..5617698109 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/InstallationService.java\n", "chunk": "@@ -133,24 +137,30 @@ public class InstallationService {\n   public MbusChannelElementsResponseDto coupleMbusDevice(\n       final DlmsConnectionManager conn,\n       final DlmsDevice device,\n-      final MbusChannelElementsDto mbusChannelElements)\n+      final MbusChannelElementsDto mbusChannelElements,\n+      final MessageMetadata messageMetadata)\n       throws ProtocolAdapterException {\n-    return this.coupleMBusDeviceCommandExecutor.execute(conn, device, mbusChannelElements);\n+    return this.coupleMBusDeviceCommandExecutor.execute(\n+        conn, device, mbusChannelElements, messageMetadata);\n   }\n \n   public CoupleMbusDeviceByChannelResponseDto coupleMbusDeviceByChannel(\n       final DlmsConnectionManager conn,\n       final DlmsDevice device,\n-      final CoupleMbusDeviceByChannelRequestDataDto requestDto)\n+      final CoupleMbusDeviceByChannelRequestDataDto requestDto,\n+      final MessageMetadata messageMetadata)\n       throws ProtocolAdapterException {\n-    return this.coupleMbusDeviceByChannelCommandExecutor.execute(conn, device, requestDto);\n+    return this.coupleMbusDeviceByChannelCommandExecutor.execute(\n+        conn, device, requestDto, messageMetadata);\n   }\n \n   public DecoupleMbusDeviceResponseDto decoupleMbusDevice(\n       final DlmsConnectionManager conn,\n       final DlmsDevice device,\n-      final DecoupleMbusDeviceDto decoupleMbusDeviceDto)\n+      final DecoupleMbusDeviceDto decoupleMbusDeviceDto,\n+      final MessageMetadata messageMetadata)\n       throws ProtocolAdapterException {\n-    return this.decoupleMBusDeviceCommandExecutor.execute(conn, device, decoupleMbusDeviceDto);\n+    return this.decoupleMBusDeviceCommandExecutor.execute(\n+        conn, device, decoupleMbusDeviceDto, messageMetadata);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTE4Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450801182", "body": "formatting not applied ?", "bodyText": "formatting not applied ?", "bodyHTML": "<p dir=\"auto\">formatting not applied ?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:41:20Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Service(value = \"secretManagementService\")\n+@Transactional\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n+    private SecretManagementClient secretManagementClient;\n+\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n+    {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTI3Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450801277", "body": "params kunnen final zijn", "bodyText": "params kunnen final zijn", "bodyHTML": "<p dir=\"auto\">params kunnen final zijn</p>", "author": "coendamen", "createdAt": "2020-07-07T11:41:29Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Service(value = \"secretManagementService\")\n+@Transactional\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n+    private SecretManagementClient secretManagementClient;\n+\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTMzMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450801331", "body": "final ?", "bodyText": "final ?", "bodyHTML": "<p dir=\"auto\">final ?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:41:35Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Service(value = \"secretManagementService\")\n+@Transactional\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private RsaEncryptionProvider rsaEncryptionProvider;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMTY0OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450801648", "body": "dit hoeft niet, de naam is al goed. het is al secretManagementService", "bodyText": "dit hoeft niet, de naam is al goed. het is al secretManagementService", "bodyHTML": "<p dir=\"auto\">dit hoeft niet, de naam is al goed. het is al secretManagementService</p>", "author": "coendamen", "createdAt": "2020-07-07T11:42:09Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Service(value = \"secretManagementService\")", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..b9d2db6aa3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,17 +9,18 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex b9d2db6aa3..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -26,16 +26,16 @@ import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMjQyNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450802426", "body": "use @Slf4j", "bodyText": "use @slf4j", "bodyHTML": "<p dir=\"auto\">use <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/slf4j/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/slf4j\">@slf4j</a></p>", "author": "coendamen", "createdAt": "2020-07-07T11:43:47Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Service(value = \"secretManagementService\")\n+@Transactional\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n+    private SecretManagementClient secretManagementClient;\n+\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n+    {\n+        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+        this.secretManagementClient = secretManagementClient;\n+    }\n+\n+    @Override\n+    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+\n+        try {\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_AUTHENTICATION_KEY);\n+\n+            return decryptSoapSecret(deviceIdentification,\n+                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        }\n+        catch(Exception e) {\n+            LOGGER.error(\"Error while retrieving authentication key\", e);\n+        }\n+        return new byte[0];\n+    }\n+\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+\n+        try {\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+\n+            return decryptSoapSecret(deviceIdentification,\n+                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        }\n+        catch(Exception e) {\n+            LOGGER.error(\"Error while retrieving encryption key\", e);", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -60,34 +61,35 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n \n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n+                    SecretType.E_METER_AUTHENTICATION_KEY);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_AUTHENTICATION_KEY);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n+                    SecretType.E_METER_AUTHENTICATION_KEY);\n \n-            return decryptSoapSecret(deviceIdentification,\n-                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        }\n-        catch(Exception e) {\n-            LOGGER.error(\"Error while retrieving authentication key\", e);\n+            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        } catch (Exception e) {\n+            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n         }\n-        return new byte[0];\n     }\n \n     @Override\n     public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n \n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n+                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n+                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n \n-            return decryptSoapSecret(deviceIdentification,\n-                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        }\n-        catch(Exception e) {\n+            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        } catch (Exception e) {\n             LOGGER.error(\"Error while retrieving encryption key\", e);\n         }\n         return new byte[0];\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..5af7af2f0b 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -87,8 +91,13 @@ public class SecretManagementService implements SecurityKeyService {\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n                     SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+\n+            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+\n+            return decryptedKey;\n+\n         } catch (Exception e) {\n             LOGGER.error(\"Error while retrieving encryption key\", e);\n         }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5af7af2f0b..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,83 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n+\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n+        try {\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    @Override\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwMzQxNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450803415", "body": "dit is obscuur IMO, je gooit de optional met een elseThrow mee als parameter. Ik zou dit iets explicieter maken door een ifPresent oid te schrijven", "bodyText": "dit is obscuur IMO, je gooit de optional met een elseThrow mee als parameter. Ik zou dit iets explicieter maken door een ifPresent oid te schrijven", "bodyHTML": "<p dir=\"auto\">dit is obscuur IMO, je gooit de optional met een elseThrow mee als parameter. Ik zou dit iets explicieter maken door een ifPresent oid te schrijven</p>", "author": "coendamen", "createdAt": "2020-07-07T11:45:44Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Service(value = \"secretManagementService\")\n+@Transactional\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n+    private SecretManagementClient secretManagementClient;\n+\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n+    {\n+        this.rsaEncryptionProvider = rsaEncryptionProvider;\n+        this.secretManagementClient = secretManagementClient;\n+    }\n+\n+    @Override\n+    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        throw new NotImplementedException();\n+    }\n+\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+\n+        try {\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_AUTHENTICATION_KEY);\n+\n+            return decryptSoapSecret(deviceIdentification,\n+                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..b9d2db6aa3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -60,7 +61,7 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n \n         try {\n             GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex b9d2db6aa3..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -64,14 +64,15 @@ public class SecretManagementService implements SecurityKeyService {\n     public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n \n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n+                    SecretType.E_METER_AUTHENTICATION_KEY);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_AUTHENTICATION_KEY);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n+                    SecretType.E_METER_AUTHENTICATION_KEY);\n \n-            return decryptSoapSecret(deviceIdentification,\n-                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        }\n-        catch(Exception e) {\n+            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        } catch (Exception e) {\n             throw new EncrypterException(\"Error while retrieving authentication key\", e);\n         }\n     }\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..5af7af2f0b 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -70,8 +70,12 @@ public class SecretManagementService implements SecurityKeyService {\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n                     SecretType.E_METER_AUTHENTICATION_KEY);\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+\n+            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+\n+            return decryptedKey;\n         } catch (Exception e) {\n             throw new EncrypterException(\"Error while retrieving authentication key\", e);\n         }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5af7af2f0b..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,83 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n+\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n+        try {\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    @Override\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 40ef0f7ee5..b9d2db6aa3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -71,9 +72,8 @@ public class SecretManagementService implements SecurityKeyService {\n                     optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n         }\n         catch(Exception e) {\n-            LOGGER.error(\"Error while retrieving authentication key\", e);\n+            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n         }\n-        return new byte[0];\n     }\n \n     @Override\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex b9d2db6aa3..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -64,14 +64,15 @@ public class SecretManagementService implements SecurityKeyService {\n     public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n \n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n+                    SecretType.E_METER_AUTHENTICATION_KEY);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_AUTHENTICATION_KEY);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n+                    SecretType.E_METER_AUTHENTICATION_KEY);\n \n-            return decryptSoapSecret(deviceIdentification,\n-                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        }\n-        catch(Exception e) {\n+            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        } catch (Exception e) {\n             throw new EncrypterException(\"Error while retrieving authentication key\", e);\n         }\n     }\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..5af7af2f0b 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -70,8 +70,12 @@ public class SecretManagementService implements SecurityKeyService {\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n                     SecretType.E_METER_AUTHENTICATION_KEY);\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+\n+            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+\n+            return decryptedKey;\n         } catch (Exception e) {\n             throw new EncrypterException(\"Error while retrieving authentication key\", e);\n         }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5af7af2f0b..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,83 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n+\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n+        try {\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    @Override\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex b9d2db6aa3..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -80,14 +81,15 @@ public class SecretManagementService implements SecurityKeyService {\n     public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n \n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n+                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n+                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n \n-            return decryptSoapSecret(deviceIdentification,\n-                    optionalTypedSecret.orElseThrow(()->new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        }\n-        catch(Exception e) {\n+            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+        } catch (Exception e) {\n             LOGGER.error(\"Error while retrieving encryption key\", e);\n         }\n         return new byte[0];\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..5af7af2f0b 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -87,8 +91,13 @@ public class SecretManagementService implements SecurityKeyService {\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n                     SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+\n+            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+\n+            return decryptedKey;\n+\n         } catch (Exception e) {\n             LOGGER.error(\"Error while retrieving encryption key\", e);\n         }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5af7af2f0b..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,83 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n+\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n+        try {\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n-\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            log.trace(\"DlmsAuthenticationKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n+    @Override\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-            return decryptedKey;\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n-        }\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n-\n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-\n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-\n-            log.trace(\"DlmsGlobalUnicastEncryptionKey for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwNTg4Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450805883", "body": "SOME_DEVICE zou constant kunnen zijn", "bodyText": "SOME_DEVICE zou constant kunnen zijn", "bodyHTML": "<p dir=\"auto\">SOME_DEVICE zou constant kunnen zijn</p>", "author": "coendamen", "createdAt": "2020-07-07T11:50:44Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.PageImpl;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class SecretManagementServiceTest {\n+    SecretManagementService service;\n+\n+    @Mock\n+    EncryptionDelegate encryptionDelegate;\n+    @Mock\n+    DbEncryptedSecretRepository secretRepository;\n+    @Mock\n+    DbEncryptionKeyRepository keyRepository;\n+\n+    @BeforeEach\n+    public void setHsmEncryption() {\n+        this.service = new SecretManagementService(this.encryptionDelegate, EncryptionProviderType.HSM,\n+                this.secretRepository, this.keyRepository);\n+    }\n+\n+    @Test\n+    public void retrieveSecrets() throws Exception {\n+        //GIVEN\n+        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+        final DbEncryptedSecret secret = new DbEncryptedSecret();\n+        secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+        secret.setEncryptionKeyReference(keyReference);\n+        final Secret decryptedSecret = new Secret(\"secret\".getBytes());\n+\n+        //WHEN\n+        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n+        when(this.secretRepository.findById(any())).thenReturn(Optional.of(secret));\n+        when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n+        final List<TypedSecret> typedSecrets = this.service.retrieveSecrets(\"SOME_DEVICE\",\n+                Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+\n+        //THEN\n+        assertThat(typedSecrets).isNotNull();\n+        assertThat(typedSecrets.size()).isEqualTo(1);\n+        final TypedSecret typedSecret = typedSecrets.get(0);\n+        assertThat(typedSecret.getSecret()).isEqualTo(HexUtils.toHexString(\"secret\".getBytes()));\n+        assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+    }\n+\n+    @Test\n+    public void retrieveSecrets_decryptionError() {\n+        //GIVEN\n+        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+        final DbEncryptedSecret secret = new DbEncryptedSecret();\n+        secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+        secret.setEncryptionKeyReference(keyReference);\n+\n+        //WHEN\n+        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n+        when(this.secretRepository.findById(1L)).thenReturn(Optional.of(secret));\n+        when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new RuntimeException(\"Decryption error\"));\n+\n+        //THEN\n+        assertThatIllegalStateException().isThrownBy(\n+                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+    }\n+\n+    @Test\n+    public void retrieveSecrets_secretWithoutKey() {\n+        final DbEncryptedSecret secret = new DbEncryptedSecret();\n+        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n+        when(this.secretRepository.findById(1L)).thenReturn(Optional.of(secret));\n+        assertThatIllegalStateException().isThrownBy(\n+                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+    }\n+\n+    @Test\n+    public void retrieveSecrets_noSecrets() {\n+        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n+        assertThatIllegalStateException().isThrownBy(\n+                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+    }\n+\n+    @Test\n+    public void storeSecrets() throws Exception {\n+        //GIVEN\n+        final TypedSecret typedSecret = new TypedSecret();\n+        typedSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+        typedSecret.setSecret(HexUtils.toHexString(\"$3cr3t\".getBytes()));\n+        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+        keyReference.setEncryptionProviderType(EncryptionProviderType.JRE);\n+        keyReference.setReference(\"keyReferenceString\");\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(EncryptionProviderType.JRE, \"$3cr3t\".getBytes());\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+\n+        //WHEN\n+        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n+        when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n+                new PageImpl<>(Arrays.asList(keyReference)));\n+        when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n+        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n+        //THEN\n+        final ArgumentCaptor<DbEncryptedSecret> secretArgumentCaptor = ArgumentCaptor.forClass(DbEncryptedSecret.class);\n+        verify(this.secretRepository).save(secretArgumentCaptor.capture());\n+        final DbEncryptedSecret savedSecret = secretArgumentCaptor.getValue();\n+        assertThat(savedSecret).isNotNull();\n+        assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e328835a21e6c66c94deee1559e102203c8a73af", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex baebb95835..725388e6db 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -131,11 +142,11 @@ public class SecretManagementServiceTest {\n         final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n \n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(null);\n+        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE)).thenReturn(0);\n         when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n                 new PageImpl<>(Arrays.asList(keyReference)));\n         when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n-        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n+        this.service.storeSecret(\"SOME_DEVICE\", typedSecret);\n         //THEN\n         final ArgumentCaptor<DbEncryptedSecret> secretArgumentCaptor = ArgumentCaptor.forClass(DbEncryptedSecret.class);\n         verify(this.secretRepository).save(secretArgumentCaptor.capture());\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 725388e6db..66515bcf93 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -146,7 +142,7 @@ public class SecretManagementServiceTest {\n         when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n                 new PageImpl<>(Arrays.asList(keyReference)));\n         when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n-        this.service.storeSecret(\"SOME_DEVICE\", typedSecret);\n+        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n         //THEN\n         final ArgumentCaptor<DbEncryptedSecret> secretArgumentCaptor = ArgumentCaptor.forClass(DbEncryptedSecret.class);\n         verify(this.secretRepository).save(secretArgumentCaptor.capture());\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 66515bcf93..d82d8cea7c 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -138,7 +133,7 @@ public class SecretManagementServiceTest {\n         final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n \n         //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE)).thenReturn(0);\n+        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW)).thenReturn(0);\n         when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n                 new PageImpl<>(Arrays.asList(keyReference)));\n         when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n", "next_change": {"commit": "2159e9a08463bd3a0175cc18eb0487988b3f1769", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex d82d8cea7c..65ec503a3a 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -133,7 +137,8 @@ public class SecretManagementServiceTest {\n         final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n \n         //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW)).thenReturn(0);\n+        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY,\n+                SecretStatus.NEW)).thenReturn(0);\n         when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n                 new PageImpl<>(Arrays.asList(keyReference)));\n         when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 65ec503a3a..342aa9ee5f 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -112,42 +121,47 @@ public class SecretManagementServiceTest {\n     public void retrieveSecrets_secretWithoutKey() {\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n         final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY,\n-                SecretStatus.ACTIVE)).thenReturn(secretList);\n+        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+                .thenReturn(secretList);\n         assertThatIllegalStateException().isThrownBy(\n                 () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n     }\n \n     @Test\n     public void retrieveSecrets_noSecrets() {\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+        List<SecretType> secretTypes = Arrays.asList(SecretType.E_METER_MASTER_KEY);\n+        List<TypedSecret> result = this.service.retrieveSecrets(\"SOME_DEVICE\", secretTypes);\n+        assertThat(result).isNotNull();\n+        assertThat(result.size()).isEqualTo(secretTypes.size());\n+        assertThat(result.get(0)).isNotNull();\n+        assertThat(result.get(0).getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+        assertThat(result.get(0).getSecret()).isNull();\n     }\n \n     @Test\n     public void storeSecrets() throws Exception {\n         //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret();\n-        typedSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        typedSecret.setSecret(HexUtils.toHexString(\"$3cr3t\".getBytes()));\n+        final TypedSecret typedSecret = new TypedSecret(\"rsaSecret\".getBytes(), SecretType.E_METER_MASTER_KEY);\n         final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(EncryptionProviderType.JRE);\n-        keyReference.setReference(\"keyReferenceString\");\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(EncryptionProviderType.JRE, \"$3cr3t\".getBytes());\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+        keyReference.setReference(\"1\");\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"aesSecret\".getBytes());\n \n         //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY,\n-                SecretStatus.NEW)).thenReturn(0);\n-        when(this.keyRepository.findByTypeAndValid(any(), any(), any())).thenReturn(\n-                new PageImpl<>(Arrays.asList(keyReference)));\n+        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+                .thenReturn(0);\n+        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n+        when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\")).thenReturn(keyReference);\n         when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n         this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n         //THEN\n-        final ArgumentCaptor<DbEncryptedSecret> secretArgumentCaptor = ArgumentCaptor.forClass(DbEncryptedSecret.class);\n-        verify(this.secretRepository).save(secretArgumentCaptor.capture());\n-        final DbEncryptedSecret savedSecret = secretArgumentCaptor.getValue();\n-        assertThat(savedSecret).isNotNull();\n+        final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n+                ArgumentCaptor.forClass(List.class);\n+        verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n+        final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n+        assertThat(savedSecrets).isNotNull();\n+        assertThat(savedSecrets.size()).isEqualTo(1);\n+        DbEncryptedSecret savedSecret = savedSecrets.get(0);\n         assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n         assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n         assertThat(savedSecret.getEncodedSecret()).isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "9949e261418959bfc6a3635533e00fca3f04ccc8", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 342aa9ee5f..871071ba88 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -170,16 +171,13 @@ public class SecretManagementServiceTest {\n     }\n \n     @Test\n-    public void storeSecrets_newKeyAlreadyStored() throws Exception {\n+    public void storeSecretsNewKeyAlreadyStored() throws Exception {\n         //GIVEN\n         final TypedSecret typedSecret = new TypedSecret(new byte[16], SecretType.E_METER_MASTER_KEY);\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"aesSecret\".getBytes());\n         final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n         keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n         keyReference.setReference(\"1\");\n         //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n         when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n                 .thenReturn(1);\n         //THEN\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 871071ba88..079735cf6a 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -45,317 +44,355 @@ import org.opensmartgridplatform.shared.security.RsaEncrypter;\n @ExtendWith(MockitoExtension.class)\n public class SecretManagementServiceTest {\n \n-    private static final String SOME_DEVICE = \"SOME_DEVICE\";\n-    private static final EncryptionProviderType ENCRYPTION_PROVIDER_TYPE = EncryptionProviderType.HSM;\n-\n-    private SecretManagementService service;\n-\n-    @Mock\n-    private EncryptionDelegate encryptionDelegate;\n-    @Mock\n-    private DbEncryptedSecretRepository secretRepository;\n-    @Mock\n-    private DbEncryptionKeyRepository keyRepository;\n-    @Mock\n-    private RsaEncrypter rsaEncrypter;\n-\n-    @BeforeEach\n-    public void setHsmEncryption() {\n-        this.service = new SecretManagementService(this.encryptionDelegate, ENCRYPTION_PROVIDER_TYPE,\n-                this.secretRepository, this.keyRepository, this.rsaEncrypter);\n-    }\n-\n-    @Test\n-    public void retrieveSecrets() throws Exception {\n-        //GIVEN\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        secret.setEncryptionKeyReference(keyReference);\n-        secret.setEncodedSecret(\"ABCDEF01234567890123456789ABCDEF\");\n-        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n-        final byte[] decryptedSecret = \"secret0000000001\".getBytes();\n-        final byte[] rsaSecret = \"1000000000terces\".getBytes();\n-\n-        //WHEN\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(secretList);\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n-        when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n-        final List<TypedSecret> typedSecrets = this.service\n-                .retrieveSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_MASTER_KEY));\n-\n-        //THEN\n-        assertThat(typedSecrets).isNotNull();\n-        assertThat(typedSecrets.size()).isEqualTo(1);\n-        final TypedSecret typedSecret = typedSecrets.get(0);\n-        assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n-        assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n-    }\n-\n-    @Test\n-    public void retrieveSecretsDecryptionError() throws EncrypterException {\n-        //GIVEN\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        secret.setEncryptionKeyReference(keyReference);\n-        secret.setEncodedSecret(\"0123456789ABCDEF0123456789ABCDEF\");\n-        final List<DbEncryptedSecret> secretPage = Arrays.asList(secret);\n-\n-        //WHEN\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(secretPage);\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new EncrypterException(\"Decryption error\"));\n-\n-        //THEN\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n-    }\n-\n-    @Test\n-    public void retrieveSecretsSecretWithoutKey() {\n-        final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(secretList);\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n-    }\n-\n-    @Test\n-    public void retrieveSecretsNoSecrets() {\n-        List<SecretType> secretTypes = Arrays.asList(SecretType.E_METER_MASTER_KEY);\n-        List<TypedSecret> result = this.service.retrieveSecrets(\"SOME_DEVICE\", secretTypes);\n-        assertThat(result).isNotNull();\n-        assertThat(result.size()).isEqualTo(secretTypes.size());\n-        assertThat(result.get(0)).isNotNull();\n-        assertThat(result.get(0).getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n-        assertThat(result.get(0).getSecret()).isNull();\n-    }\n-\n-    @Test\n-    public void storeSecrets() throws Exception {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"rsaSecret00000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE,\n-                \"aesSecret0000001\".getBytes());\n-\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\")).thenReturn(keyReference);\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n-        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n-        //THEN\n-        final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n-                ArgumentCaptor.forClass(List.class);\n-        verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n-        final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n-        assertThat(savedSecrets).isNotNull();\n-        assertThat(savedSecrets.size()).isEqualTo(1);\n-        DbEncryptedSecret savedSecret = savedSecrets.get(0);\n-        assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n-        assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n-        assertThat(savedSecret.getEncodedSecret()).isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n-        assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n-        assertThat(savedSecret.getCreationTime()).isNotNull();\n-    }\n-\n-    @Test\n-    public void storeSecretsNewKeyAlreadyStored() throws Exception {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(new byte[16], SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        //THEN\n-        assertThatIllegalStateException()\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-    }\n-\n-    @Test\n-    public void storeSecretsNoKey() {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList());\n-        //THEN\n-        assertThatExceptionOfType(NoSuchElementException.class)\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-\n-    }\n-\n-    @Test\n-    public void storeSecretsMultipleKeys() {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any()))\n-                .thenReturn(Arrays.asList(new DbEncryptionKeyReference(), new DbEncryptionKeyReference()));\n-        //THEN\n-        assertThatIllegalStateException()\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-    }\n-\n-    @Test\n-    public void storeSecretsEncryptionError() throws EncrypterException {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"keyReferenceString\");\n-\n-        //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n-                .thenThrow(new EncrypterException(\"Encryption error\"));\n-        //THEN\n-        assertThatIllegalStateException()\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-\n-    }\n-\n-    @Test\n-    public void storeSecretsExistingSecret() throws Exception {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"n3w$3cr3t0000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE,\n-                \"n3w$3cr3t0000001\".getBytes());\n-        final DbEncryptedSecret existingDbSecret = new DbEncryptedSecret();\n-        existingDbSecret.setCreationTime(new Date());\n-        existingDbSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        existingDbSecret.setEncodedSecret(\"1234567890ABCDEF\");\n-        existingDbSecret.setDeviceIdentification(\"SOME_DEVICE\");\n-        existingDbSecret.setEncryptionKeyReference(keyReference);\n-\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\")).thenReturn(keyReference);\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n-                .thenReturn(encryptedSecret);   //encrypt new DB secret\n-        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n-        //THEN\n-        final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n-                ArgumentCaptor.forClass(List.class);\n-        verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n-        final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n-        assertThat(savedSecrets).isNotNull();\n-        assertThat(savedSecrets.size()).isEqualTo(1);\n-        DbEncryptedSecret savedSecret = savedSecrets.get(0);\n-        assertThat(savedSecret).isNotNull();\n-        assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n-        assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n-        assertThat(savedSecret.getEncodedSecret()).isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n-        assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n-        assertThat(savedSecret.getCreationTime()).isNotNull();\n-    }\n-\n-    @Test\n-    public void activateSecretsNoCurrentActiveSecret() {\n-        //GIVEN\n-        final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n-        newSecret.setId(1L);\n-        newSecret.setSecretStatus(SecretStatus.NEW);\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(new ArrayList<>());\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(Arrays.asList(newSecret));\n-        when(this.secretRepository.saveAll(Arrays.asList(newSecret))).thenReturn(Arrays.asList(newSecret));\n-        this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n-        //THEN\n-        assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n-    }\n-\n-    @Test\n-    public void activateSecretsWithCurrentActiveSecret() {\n-        //GIVEN\n-        final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n-        newSecret.setId(1L);\n-        newSecret.setSecretStatus(SecretStatus.NEW);\n-        final DbEncryptedSecret activeSecret = new DbEncryptedSecret();\n-        newSecret.setId(2L);\n-        newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(Arrays.asList(activeSecret));\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(Arrays.asList(newSecret));\n-        when(this.secretRepository.saveAll(any())).thenReturn(Arrays.asList(newSecret\n-                ,activeSecret));\n-        this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n-        //THEN\n-        assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n-        assertThat(activeSecret.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-    }\n-\n-    @Test\n-    public void activateSecretsNoNewSecret() {\n-        //GIVEN\n-        final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n-        newSecret.setId(1L);\n-        newSecret.setSecretStatus(SecretStatus.NEW);\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n-    }\n-\n-    @Test\n-    public void hasNewSecret() {\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        boolean result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n-        assertThat(result).isTrue();\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n-        assertThat(result).isFalse();\n-    }\n-\n-    @Test\n-    public void generateAndStoreSecrets() throws EncrypterException {\n-        final Date now = new Date();\n-        final String reference = \"1\";\n-        byte[] aesSecret = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n-        byte[] secret = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n-        byte[] rsaSecret = { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };\n-        DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setReference(reference);\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setValidFrom(now);\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n-                .thenReturn(aesSecret);\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n-        when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n-        List<TypedSecret> secrets = this.service\n-                .generateAndStoreSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n-        assertThat(secrets.size()).isEqualTo(1);\n-        TypedSecret typedSecret = secrets.get(0);\n-        assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n-        assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n-    }\n-}\n\\ No newline at end of file\n+  private static final String SOME_DEVICE = \"SOME_DEVICE\";\n+  private static final EncryptionProviderType ENCRYPTION_PROVIDER_TYPE = EncryptionProviderType.HSM;\n+\n+  private SecretManagementService service;\n+\n+  @Mock private EncryptionDelegate encryptionDelegate;\n+  @Mock private DbEncryptedSecretRepository secretRepository;\n+  @Mock private DbEncryptionKeyRepository keyRepository;\n+  @Mock private RsaEncrypter rsaEncrypter;\n+\n+  @BeforeEach\n+  public void setHsmEncryption() {\n+    this.service =\n+        new SecretManagementService(\n+            this.encryptionDelegate,\n+            ENCRYPTION_PROVIDER_TYPE,\n+            this.secretRepository,\n+            this.keyRepository,\n+            this.rsaEncrypter);\n+  }\n+\n+  @Test\n+  public void retrieveSecrets() throws Exception {\n+    // GIVEN\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final DbEncryptedSecret secret = new DbEncryptedSecret();\n+    secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+    secret.setEncryptionKeyReference(keyReference);\n+    secret.setEncodedSecret(\"ABCDEF01234567890123456789ABCDEF\");\n+    final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+    final byte[] decryptedSecret = \"secret0000000001\".getBytes();\n+    final byte[] rsaSecret = \"1000000000terces\".getBytes();\n+\n+    // WHEN\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(secretList);\n+    when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n+    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n+    final List<TypedSecret> typedSecrets =\n+        this.service.retrieveSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+\n+    // THEN\n+    assertThat(typedSecrets).isNotNull();\n+    assertThat(typedSecrets.size()).isEqualTo(1);\n+    final TypedSecret typedSecret = typedSecrets.get(0);\n+    assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n+    assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+  }\n+\n+  @Test\n+  public void retrieveSecretsDecryptionError() throws EncrypterException {\n+    // GIVEN\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final DbEncryptedSecret secret = new DbEncryptedSecret();\n+    secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+    secret.setEncryptionKeyReference(keyReference);\n+    secret.setEncodedSecret(\"0123456789ABCDEF0123456789ABCDEF\");\n+    final List<DbEncryptedSecret> secretPage = Arrays.asList(secret);\n+\n+    // WHEN\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(secretPage);\n+    when(this.encryptionDelegate.decrypt(any(), any()))\n+        .thenThrow(new EncrypterException(\"Decryption error\"));\n+\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(\n+            () ->\n+                this.service.retrieveSecrets(\n+                    \"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+  }\n+\n+  @Test\n+  public void retrieveSecretsSecretWithoutKey() {\n+    final DbEncryptedSecret secret = new DbEncryptedSecret();\n+    final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(secretList);\n+    assertThatIllegalStateException()\n+        .isThrownBy(\n+            () ->\n+                this.service.retrieveSecrets(\n+                    \"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+  }\n+\n+  @Test\n+  public void retrieveSecretsNoSecrets() {\n+    final List<SecretType> secretTypes = Arrays.asList(SecretType.E_METER_MASTER_KEY);\n+    final List<TypedSecret> result = this.service.retrieveSecrets(\"SOME_DEVICE\", secretTypes);\n+    assertThat(result).isNotNull();\n+    assertThat(result.size()).isEqualTo(secretTypes.size());\n+    assertThat(result.get(0)).isNotNull();\n+    assertThat(result.get(0).getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+    assertThat(result.get(0).getSecret()).isNull();\n+  }\n+\n+  @Test\n+  public void storeSecrets() throws Exception {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"rsaSecret00000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final EncryptedSecret encryptedSecret =\n+        new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"aesSecret0000001\".getBytes());\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\"))\n+        .thenReturn(keyReference);\n+    when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n+    this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n+    // THEN\n+    final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n+        ArgumentCaptor.forClass(List.class);\n+    verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n+    final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n+    assertThat(savedSecrets).isNotNull();\n+    assertThat(savedSecrets.size()).isEqualTo(1);\n+    final DbEncryptedSecret savedSecret = savedSecrets.get(0);\n+    assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n+    assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n+    assertThat(savedSecret.getEncodedSecret())\n+        .isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n+    assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n+    assertThat(savedSecret.getCreationTime()).isNotNull();\n+  }\n+\n+  @Test\n+  public void storeSecretsNewKeyAlreadyStored() throws Exception {\n+    // GIVEN\n+    final TypedSecret typedSecret = new TypedSecret(new byte[16], SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsNoKey() {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    // WHEN\n+    when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList());\n+    // THEN\n+    assertThatExceptionOfType(NoSuchElementException.class)\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsMultipleKeys() {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    // WHEN\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(new DbEncryptionKeyReference(), new DbEncryptionKeyReference()));\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsEncryptionError() throws EncrypterException {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"keyReferenceString\");\n+\n+    // WHEN\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n+        .thenThrow(new EncrypterException(\"Encryption error\"));\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsExistingSecret() throws Exception {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"n3w$3cr3t0000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final EncryptedSecret encryptedSecret =\n+        new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"n3w$3cr3t0000001\".getBytes());\n+    final DbEncryptedSecret existingDbSecret = new DbEncryptedSecret();\n+    existingDbSecret.setCreationTime(new Date());\n+    existingDbSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+    existingDbSecret.setEncodedSecret(\"1234567890ABCDEF\");\n+    existingDbSecret.setDeviceIdentification(\"SOME_DEVICE\");\n+    existingDbSecret.setEncryptionKeyReference(keyReference);\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\"))\n+        .thenReturn(keyReference);\n+    when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n+        .thenReturn(encryptedSecret); // encrypt new DB secret\n+    this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n+    // THEN\n+    final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n+        ArgumentCaptor.forClass(List.class);\n+    verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n+    final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n+    assertThat(savedSecrets).isNotNull();\n+    assertThat(savedSecrets.size()).isEqualTo(1);\n+    final DbEncryptedSecret savedSecret = savedSecrets.get(0);\n+    assertThat(savedSecret).isNotNull();\n+    assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n+    assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n+    assertThat(savedSecret.getEncodedSecret())\n+        .isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n+    assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n+    assertThat(savedSecret.getCreationTime()).isNotNull();\n+  }\n+\n+  @Test\n+  public void activateSecretsNoCurrentActiveSecret() {\n+    // GIVEN\n+    final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n+    newSecret.setId(1L);\n+    newSecret.setSecretStatus(SecretStatus.NEW);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(new ArrayList<>());\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(newSecret));\n+    when(this.secretRepository.saveAll(Arrays.asList(newSecret)))\n+        .thenReturn(Arrays.asList(newSecret));\n+    this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+    // THEN\n+    assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n+  }\n+\n+  @Test\n+  public void activateSecretsWithCurrentActiveSecret() {\n+    // GIVEN\n+    final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n+    newSecret.setId(1L);\n+    newSecret.setSecretStatus(SecretStatus.NEW);\n+    final DbEncryptedSecret activeSecret = new DbEncryptedSecret();\n+    newSecret.setId(2L);\n+    newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(Arrays.asList(activeSecret));\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(newSecret));\n+    when(this.secretRepository.saveAll(any())).thenReturn(Arrays.asList(newSecret, activeSecret));\n+    this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+    // THEN\n+    assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n+    assertThat(activeSecret.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+  }\n+\n+  @Test\n+  public void activateSecretsNoNewSecret() {\n+    // GIVEN\n+    final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n+    newSecret.setId(1L);\n+    newSecret.setSecretStatus(SecretStatus.NEW);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    assertThatIllegalStateException()\n+        .isThrownBy(\n+            () ->\n+                this.service.activateNewSecrets(\n+                    \"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+  }\n+\n+  @Test\n+  public void hasNewSecret() {\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    boolean result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n+    assertThat(result).isTrue();\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n+    assertThat(result).isFalse();\n+  }\n+\n+  @Test\n+  public void generateAndStoreSecrets() throws EncrypterException {\n+    final Date now = new Date();\n+    final String reference = \"1\";\n+    final byte[] aesSecret = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+    final byte[] secret = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n+    final byte[] rsaSecret = {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setReference(reference);\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setValidFrom(now);\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n+        .thenReturn(aesSecret);\n+    when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n+    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n+    final List<TypedSecret> secrets =\n+        this.service.generateAndStoreSecrets(\n+            SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n+    assertThat(secrets.size()).isEqualTo(1);\n+    final TypedSecret typedSecret = secrets.get(0);\n+    assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n+    assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n+  }\n+}\n", "next_change": {"commit": "9a24991a5099b52f1f6402b2dbc487219a6dc070", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 079735cf6a..76813117ae 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -388,11 +486,96 @@ public class SecretManagementServiceTest {\n     when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n     when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n     final List<TypedSecret> secrets =\n-        this.service.generateAndStoreSecrets(\n+        this.service.generateAndStoreOrResetNewSecrets(\n             SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n     assertThat(secrets.size()).isEqualTo(1);\n     final TypedSecret typedSecret = secrets.get(0);\n     assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n     assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n   }\n+\n+  @Test\n+  public void generateAndStoreNewSecretWhenOlderNewSecretAlreadyExists() throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secret = this.getNewEncryptionSecret(100);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secret));\n+\n+    final SecretType secretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    this.service.generateAndStoreOrResetNewSecrets(SOME_DEVICE, Arrays.asList(secretType));\n+\n+    // THEN\n+    final List<DbEncryptedSecret> foundSecrets =\n+        this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW);\n+    assertThat(foundSecrets).hasSize(1);\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secret));\n+    assertThat(secret.getCreationTime()).isCloseTo(new Date(), 10);\n+    assertThat(secret.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+  }\n+\n+  @Test\n+  public void generateAndStoreNewSecretsWhenOneRecentAndOlderNewSecretAlreadyExists()\n+      throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secretOldEncryption = this.getNewEncryptionSecret(100);\n+    final DbEncryptedSecret secretOlderEncryption = this.getNewEncryptionSecret(1000);\n+    final DbEncryptedSecret secretOldAuthen = this.getNewAuthenticationSecret(100);\n+    final DbEncryptedSecret secretOlderAuthen = this.getNewAuthenticationSecret(1000);\n+    final Date olderCreationTime = secretOlderEncryption.getCreationTime();\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldEncryption, secretOlderEncryption));\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldAuthen, secretOlderAuthen));\n+\n+    final SecretType encryptionSecretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    final SecretType authenSecretType = SecretType.E_METER_AUTHENTICATION_KEY;\n+\n+    this.service.generateAndStoreOrResetNewSecrets(\n+        SOME_DEVICE, Arrays.asList(encryptionSecretType, authenSecretType));\n+\n+    // THEN\n+    final String logMessage =\n+        \"During (GenerateOr)Replace Key Process multiple keys with status NEW\";\n+    verify(this.mockAppender, times(2))\n+        .doAppend(\n+            argThat(\n+                argument -> {\n+                  assertThat(argument.getMessage()).startsWith(logMessage);\n+                  assertThat(argument.getLevel()).isEqualTo(Level.WARN);\n+                  return true;\n+                }));\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n+    verify(this.secretRepository, never())\n+        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n+\n+    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 10);\n+    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 10);\n+    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOlderEncryption.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderAuthen.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 76813117ae..6b5a77c2a4 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -484,98 +394,13 @@ public class SecretManagementServiceTest {\n     when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n         .thenReturn(aesSecret);\n     when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n-    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n+    when(this.encrypterForSecretManagementClient.encrypt(any())).thenReturn(rsaSecret);\n     final List<TypedSecret> secrets =\n-        this.service.generateAndStoreOrResetNewSecrets(\n+        this.service.generateAndStoreSecrets(\n             SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n     assertThat(secrets.size()).isEqualTo(1);\n     final TypedSecret typedSecret = secrets.get(0);\n     assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n     assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n   }\n-\n-  @Test\n-  public void generateAndStoreNewSecretWhenOlderNewSecretAlreadyExists() throws Exception {\n-    // GIVEN\n-    final DbEncryptedSecret secret = this.getNewEncryptionSecret(100);\n-    // WHEN\n-    when(this.secretRepository.getSecretCount(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(1);\n-    when(this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(Arrays.asList(secret));\n-\n-    final SecretType secretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-    this.service.generateAndStoreOrResetNewSecrets(SOME_DEVICE, Arrays.asList(secretType));\n-\n-    // THEN\n-    final List<DbEncryptedSecret> foundSecrets =\n-        this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW);\n-    assertThat(foundSecrets).hasSize(1);\n-\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secret));\n-    assertThat(secret.getCreationTime()).isCloseTo(new Date(), 10);\n-    assertThat(secret.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-  }\n-\n-  @Test\n-  public void generateAndStoreNewSecretsWhenOneRecentAndOlderNewSecretAlreadyExists()\n-      throws Exception {\n-    // GIVEN\n-    final DbEncryptedSecret secretOldEncryption = this.getNewEncryptionSecret(100);\n-    final DbEncryptedSecret secretOlderEncryption = this.getNewEncryptionSecret(1000);\n-    final DbEncryptedSecret secretOldAuthen = this.getNewAuthenticationSecret(100);\n-    final DbEncryptedSecret secretOlderAuthen = this.getNewAuthenticationSecret(1000);\n-    final Date olderCreationTime = secretOlderEncryption.getCreationTime();\n-\n-    // WHEN\n-    when(this.secretRepository.getSecretCount(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(2);\n-    when(this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(Arrays.asList(secretOldEncryption, secretOlderEncryption));\n-    when(this.secretRepository.getSecretCount(\n-            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n-        .thenReturn(2);\n-    when(this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n-        .thenReturn(Arrays.asList(secretOldAuthen, secretOlderAuthen));\n-\n-    final SecretType encryptionSecretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-    final SecretType authenSecretType = SecretType.E_METER_AUTHENTICATION_KEY;\n-\n-    this.service.generateAndStoreOrResetNewSecrets(\n-        SOME_DEVICE, Arrays.asList(encryptionSecretType, authenSecretType));\n-\n-    // THEN\n-    final String logMessage =\n-        \"During (GenerateOr)Replace Key Process multiple keys with status NEW\";\n-    verify(this.mockAppender, times(2))\n-        .doAppend(\n-            argThat(\n-                argument -> {\n-                  assertThat(argument.getMessage()).startsWith(logMessage);\n-                  assertThat(argument.getLevel()).isEqualTo(Level.WARN);\n-                  return true;\n-                }));\n-\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n-    verify(this.secretRepository, never())\n-        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n-\n-    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 10);\n-    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 10);\n-    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOlderEncryption.getCreationTime().getTime())\n-        .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderAuthen.getCreationTime().getTime())\n-        .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-  }\n }\n", "next_change": {"commit": "195ff84150abd28386026335f39673dd69390f56", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 6b5a77c2a4..c4ec3f73ac 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -394,13 +501,98 @@ public class SecretManagementServiceTest {\n     when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n         .thenReturn(aesSecret);\n     when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n-    when(this.encrypterForSecretManagementClient.encrypt(any())).thenReturn(rsaSecret);\n+    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n     final List<TypedSecret> secrets =\n-        this.service.generateAndStoreSecrets(\n+        this.service.generateAndStoreOrResetNewSecrets(\n             SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n     assertThat(secrets.size()).isEqualTo(1);\n     final TypedSecret typedSecret = secrets.get(0);\n     assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n     assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n   }\n+\n+  @Test\n+  public void generateAndStoreNewSecretWhenOlderNewSecretAlreadyExists() throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secret = this.getNewEncryptionSecret(100);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secret));\n+\n+    final SecretType secretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    this.service.generateAndStoreOrResetNewSecrets(SOME_DEVICE, Arrays.asList(secretType));\n+\n+    // THEN\n+    final List<DbEncryptedSecret> foundSecrets =\n+        this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW);\n+    assertThat(foundSecrets).hasSize(1);\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secret));\n+    assertThat(secret.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secret.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+  }\n+\n+  @Test\n+  public void generateAndStoreNewSecretsWhenOneRecentAndOlderNewSecretAlreadyExists()\n+      throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secretOldEncryption = this.getNewEncryptionSecret(100);\n+    final DbEncryptedSecret secretOlderEncryption = this.getNewEncryptionSecret(1000);\n+    final DbEncryptedSecret secretOldAuthen = this.getNewAuthenticationSecret(100);\n+    final DbEncryptedSecret secretOlderAuthen = this.getNewAuthenticationSecret(1000);\n+    final Date olderCreationTime = secretOlderEncryption.getCreationTime();\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldEncryption, secretOlderEncryption));\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldAuthen, secretOlderAuthen));\n+\n+    final SecretType encryptionSecretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    final SecretType authenSecretType = SecretType.E_METER_AUTHENTICATION_KEY;\n+\n+    this.service.generateAndStoreOrResetNewSecrets(\n+        SOME_DEVICE, Arrays.asList(encryptionSecretType, authenSecretType));\n+\n+    // THEN\n+    final String logMessage =\n+        \"During (GenerateOr)Replace Key Process multiple keys with status NEW\";\n+    verify(this.mockAppender, times(2))\n+        .doAppend(\n+            argThat(\n+                argument -> {\n+                  assertThat(argument.getMessage()).startsWith(logMessage);\n+                  assertThat(argument.getLevel()).isEqualTo(Level.WARN);\n+                  return true;\n+                }));\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n+    verify(this.secretRepository, never())\n+        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n+\n+    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOlderEncryption.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderAuthen.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+  }\n }\n", "next_change": {"commit": "d1565558084b533c091c8310911a50d6766fde49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex c4ec3f73ac..63d4126596 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -584,15 +610,17 @@ public class SecretManagementServiceTest {\n     verify(this.secretRepository, never())\n         .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n \n-    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 100);\n-    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secretOldEncryption.getCreationTime())\n+        .isEqualTo(originalCreationTimeEncryptionSecret);\n+    assertThat(secretOldAuthen.getCreationTime())\n+        .isEqualTo(originalCreationTimeAuthenticationSecret);\n     assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n     assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n     assertThat(secretOlderEncryption.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n     assertThat(secretOlderAuthen.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n+    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n   }\n }\n", "next_change": {"commit": "b7947c76093303a1f50869f7dc20ed80aed4c154", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 63d4126596..93e0329e30 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -606,21 +602,21 @@ public class SecretManagementServiceTest {\n                 }));\n \n     verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthentication));\n     verify(this.secretRepository, never())\n-        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n+        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthentication));\n \n     assertThat(secretOldEncryption.getCreationTime())\n         .isEqualTo(originalCreationTimeEncryptionSecret);\n-    assertThat(secretOldAuthen.getCreationTime())\n+    assertThat(secretOldAuthentication.getCreationTime())\n         .isEqualTo(originalCreationTimeAuthenticationSecret);\n     assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldAuthentication.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n     assertThat(secretOlderEncryption.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderAuthen.getCreationTime().getTime())\n+    assertThat(secretOlderAuthentication.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n     assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n-    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n+    assertThat(secretOlderAuthentication.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n   }\n }\n", "next_change": {"commit": "b30685e826bc285c9c0b44607ffa549b6d82b821", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 93e0329e30..12b6e95072 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -602,21 +571,13 @@ public class SecretManagementServiceTest {\n                 }));\n \n     verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthentication));\n-    verify(this.secretRepository, never())\n-        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthentication));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n \n     assertThat(secretOldEncryption.getCreationTime())\n         .isEqualTo(originalCreationTimeEncryptionSecret);\n-    assertThat(secretOldAuthentication.getCreationTime())\n-        .isEqualTo(originalCreationTimeAuthenticationSecret);\n-    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOldAuthentication.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n     assertThat(secretOlderEncryption.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderAuthentication.getCreationTime().getTime())\n-        .isEqualTo(olderCreationTime.getTime());\n     assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n-    assertThat(secretOlderAuthentication.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwNjY1Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450806657", "body": "minor: could all be private", "bodyText": "minor: could all be private", "bodyHTML": "<p dir=\"auto\">minor: could all be private</p>", "author": "coendamen", "createdAt": "2020-07-07T11:52:06Z", "path": "osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.assertThatIllegalStateException;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.PageImpl;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class SecretManagementServiceTest {\n+    SecretManagementService service;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex baebb95835..09585139d8 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -45,14 +45,17 @@ import org.springframework.data.domain.PageImpl;\n \n @ExtendWith(MockitoExtension.class)\n public class SecretManagementServiceTest {\n-    SecretManagementService service;\n+\n+    private static final String SOME_DEVICE = \"SOME_DEVICE\";\n+\n+    private SecretManagementService service;\n \n     @Mock\n-    EncryptionDelegate encryptionDelegate;\n+    private EncryptionDelegate encryptionDelegate;\n     @Mock\n-    DbEncryptedSecretRepository secretRepository;\n+    private DbEncryptedSecretRepository secretRepository;\n     @Mock\n-    DbEncryptionKeyRepository keyRepository;\n+    private DbEncryptionKeyRepository keyRepository;\n \n     @BeforeEach\n     public void setHsmEncryption() {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 09585139d8..342aa9ee5f 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -56,49 +56,61 @@ public class SecretManagementServiceTest {\n     private DbEncryptedSecretRepository secretRepository;\n     @Mock\n     private DbEncryptionKeyRepository keyRepository;\n+    @Mock\n+    private RsaEncrypter rsaEncryptionProvider;\n \n     @BeforeEach\n     public void setHsmEncryption() {\n-        this.service = new SecretManagementService(this.encryptionDelegate, EncryptionProviderType.HSM,\n-                this.secretRepository, this.keyRepository);\n+        this.service = new SecretManagementService(this.encryptionDelegate, ENCRYPTION_PROVIDER_TYPE,\n+                this.secretRepository, this.keyRepository, this.rsaEncryptionProvider);\n     }\n \n     @Test\n     public void retrieveSecrets() throws Exception {\n         //GIVEN\n         final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+        keyReference.setReference(\"1\");\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n         secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n         secret.setEncryptionKeyReference(keyReference);\n-        final Secret decryptedSecret = new Secret(\"secret\".getBytes());\n+        secret.setEncodedSecret(\"ABCDEF0123456789\");\n+        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+        final byte[] decryptedSecret = \"secret\".getBytes();\n+        final byte[] rsaSecret = \"terces\".getBytes();\n \n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n-        when(this.secretRepository.findById(any())).thenReturn(Optional.of(secret));\n+        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+                .thenReturn(secretList);\n         when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n-        final List<TypedSecret> typedSecrets = this.service.retrieveSecrets(SOME_DEVICE,\n-                Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+        when(this.rsaEncryptionProvider.encrypt(any())).thenReturn(rsaSecret);\n+        final List<TypedSecret> typedSecrets = this.service\n+                .retrieveSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_MASTER_KEY));\n \n         //THEN\n         assertThat(typedSecrets).isNotNull();\n         assertThat(typedSecrets.size()).isEqualTo(1);\n         final TypedSecret typedSecret = typedSecrets.get(0);\n-        assertThat(typedSecret.getSecret()).isEqualTo(HexUtils.toHexString(\"secret\".getBytes()));\n+        assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n         assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n     }\n \n     @Test\n-    public void retrieveSecrets_decryptionError() {\n+    public void retrieveSecrets_decryptionError() throws EncrypterException {\n         //GIVEN\n         final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+        keyReference.setReference(\"1\");\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n         secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n         secret.setEncryptionKeyReference(keyReference);\n+        secret.setEncodedSecret(\"0123456789ABCDEF\");\n+        final List<DbEncryptedSecret> secretPage = Arrays.asList(secret);\n \n         //WHEN\n-        when(this.secretRepository.findIdOfValidMostRecent(any(), any(), any())).thenReturn(1L);\n-        when(this.secretRepository.findById(1L)).thenReturn(Optional.of(secret));\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new RuntimeException(\"Decryption error\"));\n+        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+                .thenReturn(secretPage);\n+        when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new EncrypterException(\"Decryption error\"));\n \n         //THEN\n         assertThatIllegalStateException().isThrownBy(\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 342aa9ee5f..bf5c90a732 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -104,12 +105,13 @@ public class SecretManagementServiceTest {\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n         secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n         secret.setEncryptionKeyReference(keyReference);\n-        secret.setEncodedSecret(\"0123456789ABCDEF\");\n+        secret.setEncodedSecret(\"0123456789ABCDEF0123456789ABCDEF\");\n         final List<DbEncryptedSecret> secretPage = Arrays.asList(secret);\n \n         //WHEN\n         when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n                 .thenReturn(secretPage);\n+        //when(this.encryptionDelegate.getSecretByteLength(any())).thenReturn(16);\n         when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new EncrypterException(\"Decryption error\"));\n \n         //THEN\n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex bf5c90a732..a0c2d341ef 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -111,7 +110,6 @@ public class SecretManagementServiceTest {\n         //WHEN\n         when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n                 .thenReturn(secretPage);\n-        //when(this.encryptionDelegate.getSecretByteLength(any())).thenReturn(16);\n         when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new EncrypterException(\"Decryption error\"));\n \n         //THEN\n", "next_change": {"commit": "9949e261418959bfc6a3635533e00fca3f04ccc8", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex a0c2d341ef..871071ba88 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -118,7 +118,7 @@ public class SecretManagementServiceTest {\n     }\n \n     @Test\n-    public void retrieveSecrets_secretWithoutKey() {\n+    public void retrieveSecretsSecretWithoutKey() {\n         final DbEncryptedSecret secret = new DbEncryptedSecret();\n         final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n         when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 871071ba88..079735cf6a 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -45,317 +44,355 @@ import org.opensmartgridplatform.shared.security.RsaEncrypter;\n @ExtendWith(MockitoExtension.class)\n public class SecretManagementServiceTest {\n \n-    private static final String SOME_DEVICE = \"SOME_DEVICE\";\n-    private static final EncryptionProviderType ENCRYPTION_PROVIDER_TYPE = EncryptionProviderType.HSM;\n-\n-    private SecretManagementService service;\n-\n-    @Mock\n-    private EncryptionDelegate encryptionDelegate;\n-    @Mock\n-    private DbEncryptedSecretRepository secretRepository;\n-    @Mock\n-    private DbEncryptionKeyRepository keyRepository;\n-    @Mock\n-    private RsaEncrypter rsaEncrypter;\n-\n-    @BeforeEach\n-    public void setHsmEncryption() {\n-        this.service = new SecretManagementService(this.encryptionDelegate, ENCRYPTION_PROVIDER_TYPE,\n-                this.secretRepository, this.keyRepository, this.rsaEncrypter);\n-    }\n-\n-    @Test\n-    public void retrieveSecrets() throws Exception {\n-        //GIVEN\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        secret.setEncryptionKeyReference(keyReference);\n-        secret.setEncodedSecret(\"ABCDEF01234567890123456789ABCDEF\");\n-        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n-        final byte[] decryptedSecret = \"secret0000000001\".getBytes();\n-        final byte[] rsaSecret = \"1000000000terces\".getBytes();\n-\n-        //WHEN\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(secretList);\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n-        when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n-        final List<TypedSecret> typedSecrets = this.service\n-                .retrieveSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_MASTER_KEY));\n-\n-        //THEN\n-        assertThat(typedSecrets).isNotNull();\n-        assertThat(typedSecrets.size()).isEqualTo(1);\n-        final TypedSecret typedSecret = typedSecrets.get(0);\n-        assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n-        assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n-    }\n-\n-    @Test\n-    public void retrieveSecretsDecryptionError() throws EncrypterException {\n-        //GIVEN\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        secret.setEncryptionKeyReference(keyReference);\n-        secret.setEncodedSecret(\"0123456789ABCDEF0123456789ABCDEF\");\n-        final List<DbEncryptedSecret> secretPage = Arrays.asList(secret);\n-\n-        //WHEN\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(secretPage);\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenThrow(new EncrypterException(\"Decryption error\"));\n-\n-        //THEN\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n-    }\n-\n-    @Test\n-    public void retrieveSecretsSecretWithoutKey() {\n-        final DbEncryptedSecret secret = new DbEncryptedSecret();\n-        final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(secretList);\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.retrieveSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n-    }\n-\n-    @Test\n-    public void retrieveSecretsNoSecrets() {\n-        List<SecretType> secretTypes = Arrays.asList(SecretType.E_METER_MASTER_KEY);\n-        List<TypedSecret> result = this.service.retrieveSecrets(\"SOME_DEVICE\", secretTypes);\n-        assertThat(result).isNotNull();\n-        assertThat(result.size()).isEqualTo(secretTypes.size());\n-        assertThat(result.get(0)).isNotNull();\n-        assertThat(result.get(0).getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n-        assertThat(result.get(0).getSecret()).isNull();\n-    }\n-\n-    @Test\n-    public void storeSecrets() throws Exception {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"rsaSecret00000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE,\n-                \"aesSecret0000001\".getBytes());\n-\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\")).thenReturn(keyReference);\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n-        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n-        //THEN\n-        final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n-                ArgumentCaptor.forClass(List.class);\n-        verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n-        final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n-        assertThat(savedSecrets).isNotNull();\n-        assertThat(savedSecrets.size()).isEqualTo(1);\n-        DbEncryptedSecret savedSecret = savedSecrets.get(0);\n-        assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n-        assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n-        assertThat(savedSecret.getEncodedSecret()).isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n-        assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n-        assertThat(savedSecret.getCreationTime()).isNotNull();\n-    }\n-\n-    @Test\n-    public void storeSecretsNewKeyAlreadyStored() throws Exception {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(new byte[16], SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        //THEN\n-        assertThatIllegalStateException()\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-    }\n-\n-    @Test\n-    public void storeSecretsNoKey() {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList());\n-        //THEN\n-        assertThatExceptionOfType(NoSuchElementException.class)\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-\n-    }\n-\n-    @Test\n-    public void storeSecretsMultipleKeys() {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any()))\n-                .thenReturn(Arrays.asList(new DbEncryptionKeyReference(), new DbEncryptionKeyReference()));\n-        //THEN\n-        assertThatIllegalStateException()\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-    }\n-\n-    @Test\n-    public void storeSecretsEncryptionError() throws EncrypterException {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"keyReferenceString\");\n-\n-        //WHEN\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n-                .thenThrow(new EncrypterException(\"Encryption error\"));\n-        //THEN\n-        assertThatIllegalStateException()\n-                .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n-\n-    }\n-\n-    @Test\n-    public void storeSecretsExistingSecret() throws Exception {\n-        //GIVEN\n-        final TypedSecret typedSecret = new TypedSecret(\"n3w$3cr3t0000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n-        final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setReference(\"1\");\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE,\n-                \"n3w$3cr3t0000001\".getBytes());\n-        final DbEncryptedSecret existingDbSecret = new DbEncryptedSecret();\n-        existingDbSecret.setCreationTime(new Date());\n-        existingDbSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n-        existingDbSecret.setEncodedSecret(\"1234567890ABCDEF\");\n-        existingDbSecret.setDeviceIdentification(\"SOME_DEVICE\");\n-        existingDbSecret.setEncryptionKeyReference(keyReference);\n-\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\")).thenReturn(keyReference);\n-        when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n-                .thenReturn(encryptedSecret);   //encrypt new DB secret\n-        this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n-        //THEN\n-        final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n-                ArgumentCaptor.forClass(List.class);\n-        verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n-        final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n-        assertThat(savedSecrets).isNotNull();\n-        assertThat(savedSecrets.size()).isEqualTo(1);\n-        DbEncryptedSecret savedSecret = savedSecrets.get(0);\n-        assertThat(savedSecret).isNotNull();\n-        assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n-        assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n-        assertThat(savedSecret.getEncodedSecret()).isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n-        assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n-        assertThat(savedSecret.getCreationTime()).isNotNull();\n-    }\n-\n-    @Test\n-    public void activateSecretsNoCurrentActiveSecret() {\n-        //GIVEN\n-        final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n-        newSecret.setId(1L);\n-        newSecret.setSecretStatus(SecretStatus.NEW);\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(new ArrayList<>());\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(Arrays.asList(newSecret));\n-        when(this.secretRepository.saveAll(Arrays.asList(newSecret))).thenReturn(Arrays.asList(newSecret));\n-        this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n-        //THEN\n-        assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n-    }\n-\n-    @Test\n-    public void activateSecretsWithCurrentActiveSecret() {\n-        //GIVEN\n-        final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n-        newSecret.setId(1L);\n-        newSecret.setSecretStatus(SecretStatus.NEW);\n-        final DbEncryptedSecret activeSecret = new DbEncryptedSecret();\n-        newSecret.setId(2L);\n-        newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n-                .thenReturn(Arrays.asList(activeSecret));\n-        when(this.secretRepository.findSecrets(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(Arrays.asList(newSecret));\n-        when(this.secretRepository.saveAll(any())).thenReturn(Arrays.asList(newSecret\n-                ,activeSecret));\n-        this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n-        //THEN\n-        assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n-        assertThat(activeSecret.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-    }\n-\n-    @Test\n-    public void activateSecretsNoNewSecret() {\n-        //GIVEN\n-        final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n-        newSecret.setId(1L);\n-        newSecret.setSecretStatus(SecretStatus.NEW);\n-        //WHEN\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        assertThatIllegalStateException().isThrownBy(\n-                () -> this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n-    }\n-\n-    @Test\n-    public void hasNewSecret() {\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(1);\n-        boolean result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n-        assertThat(result).isTrue();\n-        when(this.secretRepository.getSecretCount(SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n-                .thenReturn(0);\n-        result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n-        assertThat(result).isFalse();\n-    }\n-\n-    @Test\n-    public void generateAndStoreSecrets() throws EncrypterException {\n-        final Date now = new Date();\n-        final String reference = \"1\";\n-        byte[] aesSecret = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n-        byte[] secret = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n-        byte[] rsaSecret = { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };\n-        DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n-        keyReference.setReference(reference);\n-        keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n-        keyReference.setValidFrom(now);\n-        when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList(keyReference));\n-        when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n-                .thenReturn(aesSecret);\n-        when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n-        when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n-        List<TypedSecret> secrets = this.service\n-                .generateAndStoreSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n-        assertThat(secrets.size()).isEqualTo(1);\n-        TypedSecret typedSecret = secrets.get(0);\n-        assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n-        assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n-    }\n-}\n\\ No newline at end of file\n+  private static final String SOME_DEVICE = \"SOME_DEVICE\";\n+  private static final EncryptionProviderType ENCRYPTION_PROVIDER_TYPE = EncryptionProviderType.HSM;\n+\n+  private SecretManagementService service;\n+\n+  @Mock private EncryptionDelegate encryptionDelegate;\n+  @Mock private DbEncryptedSecretRepository secretRepository;\n+  @Mock private DbEncryptionKeyRepository keyRepository;\n+  @Mock private RsaEncrypter rsaEncrypter;\n+\n+  @BeforeEach\n+  public void setHsmEncryption() {\n+    this.service =\n+        new SecretManagementService(\n+            this.encryptionDelegate,\n+            ENCRYPTION_PROVIDER_TYPE,\n+            this.secretRepository,\n+            this.keyRepository,\n+            this.rsaEncrypter);\n+  }\n+\n+  @Test\n+  public void retrieveSecrets() throws Exception {\n+    // GIVEN\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final DbEncryptedSecret secret = new DbEncryptedSecret();\n+    secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+    secret.setEncryptionKeyReference(keyReference);\n+    secret.setEncodedSecret(\"ABCDEF01234567890123456789ABCDEF\");\n+    final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+    final byte[] decryptedSecret = \"secret0000000001\".getBytes();\n+    final byte[] rsaSecret = \"1000000000terces\".getBytes();\n+\n+    // WHEN\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(secretList);\n+    when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(decryptedSecret);\n+    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n+    final List<TypedSecret> typedSecrets =\n+        this.service.retrieveSecrets(SOME_DEVICE, Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+\n+    // THEN\n+    assertThat(typedSecrets).isNotNull();\n+    assertThat(typedSecrets.size()).isEqualTo(1);\n+    final TypedSecret typedSecret = typedSecrets.get(0);\n+    assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n+    assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+  }\n+\n+  @Test\n+  public void retrieveSecretsDecryptionError() throws EncrypterException {\n+    // GIVEN\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final DbEncryptedSecret secret = new DbEncryptedSecret();\n+    secret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+    secret.setEncryptionKeyReference(keyReference);\n+    secret.setEncodedSecret(\"0123456789ABCDEF0123456789ABCDEF\");\n+    final List<DbEncryptedSecret> secretPage = Arrays.asList(secret);\n+\n+    // WHEN\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(secretPage);\n+    when(this.encryptionDelegate.decrypt(any(), any()))\n+        .thenThrow(new EncrypterException(\"Decryption error\"));\n+\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(\n+            () ->\n+                this.service.retrieveSecrets(\n+                    \"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+  }\n+\n+  @Test\n+  public void retrieveSecretsSecretWithoutKey() {\n+    final DbEncryptedSecret secret = new DbEncryptedSecret();\n+    final List<DbEncryptedSecret> secretList = Arrays.asList(secret);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(secretList);\n+    assertThatIllegalStateException()\n+        .isThrownBy(\n+            () ->\n+                this.service.retrieveSecrets(\n+                    \"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+  }\n+\n+  @Test\n+  public void retrieveSecretsNoSecrets() {\n+    final List<SecretType> secretTypes = Arrays.asList(SecretType.E_METER_MASTER_KEY);\n+    final List<TypedSecret> result = this.service.retrieveSecrets(\"SOME_DEVICE\", secretTypes);\n+    assertThat(result).isNotNull();\n+    assertThat(result.size()).isEqualTo(secretTypes.size());\n+    assertThat(result.get(0)).isNotNull();\n+    assertThat(result.get(0).getSecretType()).isEqualTo(SecretType.E_METER_MASTER_KEY);\n+    assertThat(result.get(0).getSecret()).isNull();\n+  }\n+\n+  @Test\n+  public void storeSecrets() throws Exception {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"rsaSecret00000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final EncryptedSecret encryptedSecret =\n+        new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"aesSecret0000001\".getBytes());\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\"))\n+        .thenReturn(keyReference);\n+    when(this.encryptionDelegate.encrypt(any(), any(), anyString())).thenReturn(encryptedSecret);\n+    this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n+    // THEN\n+    final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n+        ArgumentCaptor.forClass(List.class);\n+    verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n+    final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n+    assertThat(savedSecrets).isNotNull();\n+    assertThat(savedSecrets.size()).isEqualTo(1);\n+    final DbEncryptedSecret savedSecret = savedSecrets.get(0);\n+    assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n+    assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n+    assertThat(savedSecret.getEncodedSecret())\n+        .isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n+    assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n+    assertThat(savedSecret.getCreationTime()).isNotNull();\n+  }\n+\n+  @Test\n+  public void storeSecretsNewKeyAlreadyStored() throws Exception {\n+    // GIVEN\n+    final TypedSecret typedSecret = new TypedSecret(new byte[16], SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsNoKey() {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    // WHEN\n+    when(this.keyRepository.findByTypeAndValid(any(), any())).thenReturn(Arrays.asList());\n+    // THEN\n+    assertThatExceptionOfType(NoSuchElementException.class)\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsMultipleKeys() {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    // WHEN\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(new DbEncryptionKeyReference(), new DbEncryptionKeyReference()));\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsEncryptionError() throws EncrypterException {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"$3cr3t\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"keyReferenceString\");\n+\n+    // WHEN\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n+        .thenThrow(new EncrypterException(\"Encryption error\"));\n+    // THEN\n+    assertThatIllegalStateException()\n+        .isThrownBy(() -> this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret)));\n+  }\n+\n+  @Test\n+  public void storeSecretsExistingSecret() throws Exception {\n+    // GIVEN\n+    final TypedSecret typedSecret =\n+        new TypedSecret(\"n3w$3cr3t0000001\".getBytes(), SecretType.E_METER_MASTER_KEY);\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setReference(\"1\");\n+    final EncryptedSecret encryptedSecret =\n+        new EncryptedSecret(ENCRYPTION_PROVIDER_TYPE, \"n3w$3cr3t0000001\".getBytes());\n+    final DbEncryptedSecret existingDbSecret = new DbEncryptedSecret();\n+    existingDbSecret.setCreationTime(new Date());\n+    existingDbSecret.setSecretType(SecretType.E_METER_MASTER_KEY);\n+    existingDbSecret.setEncodedSecret(\"1234567890ABCDEF\");\n+    existingDbSecret.setDeviceIdentification(\"SOME_DEVICE\");\n+    existingDbSecret.setEncryptionKeyReference(keyReference);\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.keyRepository.findByTypeAndReference(ENCRYPTION_PROVIDER_TYPE, \"1\"))\n+        .thenReturn(keyReference);\n+    when(this.encryptionDelegate.encrypt(any(), any(), anyString()))\n+        .thenReturn(encryptedSecret); // encrypt new DB secret\n+    this.service.storeSecrets(\"SOME_DEVICE\", Arrays.asList(typedSecret));\n+    // THEN\n+    final ArgumentCaptor<List<DbEncryptedSecret>> secretListArgumentCaptor =\n+        ArgumentCaptor.forClass(List.class);\n+    verify(this.secretRepository).saveAll(secretListArgumentCaptor.capture());\n+    final List<DbEncryptedSecret> savedSecrets = secretListArgumentCaptor.getValue();\n+    assertThat(savedSecrets).isNotNull();\n+    assertThat(savedSecrets.size()).isEqualTo(1);\n+    final DbEncryptedSecret savedSecret = savedSecrets.get(0);\n+    assertThat(savedSecret).isNotNull();\n+    assertThat(savedSecret.getDeviceIdentification()).isEqualTo(\"SOME_DEVICE\");\n+    assertThat(savedSecret.getSecretType()).isEqualTo(typedSecret.getSecretType());\n+    assertThat(savedSecret.getEncodedSecret())\n+        .isEqualTo(HexUtils.toHexString(encryptedSecret.getSecret()));\n+    assertThat(savedSecret.getEncryptionKeyReference()).isEqualTo(keyReference);\n+    assertThat(savedSecret.getCreationTime()).isNotNull();\n+  }\n+\n+  @Test\n+  public void activateSecretsNoCurrentActiveSecret() {\n+    // GIVEN\n+    final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n+    newSecret.setId(1L);\n+    newSecret.setSecretStatus(SecretStatus.NEW);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(new ArrayList<>());\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(newSecret));\n+    when(this.secretRepository.saveAll(Arrays.asList(newSecret)))\n+        .thenReturn(Arrays.asList(newSecret));\n+    this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+    // THEN\n+    assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n+  }\n+\n+  @Test\n+  public void activateSecretsWithCurrentActiveSecret() {\n+    // GIVEN\n+    final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n+    newSecret.setId(1L);\n+    newSecret.setSecretStatus(SecretStatus.NEW);\n+    final DbEncryptedSecret activeSecret = new DbEncryptedSecret();\n+    newSecret.setId(2L);\n+    newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.ACTIVE))\n+        .thenReturn(Arrays.asList(activeSecret));\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(newSecret));\n+    when(this.secretRepository.saveAll(any())).thenReturn(Arrays.asList(newSecret, activeSecret));\n+    this.service.activateNewSecrets(\"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY));\n+    // THEN\n+    assertThat(newSecret.getSecretStatus()).isEqualTo(SecretStatus.ACTIVE);\n+    assertThat(activeSecret.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+  }\n+\n+  @Test\n+  public void activateSecretsNoNewSecret() {\n+    // GIVEN\n+    final DbEncryptedSecret newSecret = new DbEncryptedSecret();\n+    newSecret.setId(1L);\n+    newSecret.setSecretStatus(SecretStatus.NEW);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    assertThatIllegalStateException()\n+        .isThrownBy(\n+            () ->\n+                this.service.activateNewSecrets(\n+                    \"SOME_DEVICE\", Arrays.asList(SecretType.E_METER_MASTER_KEY)));\n+  }\n+\n+  @Test\n+  public void hasNewSecret() {\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(1);\n+    boolean result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n+    assertThat(result).isTrue();\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_MASTER_KEY, SecretStatus.NEW))\n+        .thenReturn(0);\n+    result = this.service.hasNewSecret(SOME_DEVICE, SecretType.E_METER_MASTER_KEY);\n+    assertThat(result).isFalse();\n+  }\n+\n+  @Test\n+  public void generateAndStoreSecrets() throws EncrypterException {\n+    final Date now = new Date();\n+    final String reference = \"1\";\n+    final byte[] aesSecret = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+    final byte[] secret = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n+    final byte[] rsaSecret = {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n+    final DbEncryptionKeyReference keyReference = new DbEncryptionKeyReference();\n+    keyReference.setReference(reference);\n+    keyReference.setEncryptionProviderType(ENCRYPTION_PROVIDER_TYPE);\n+    keyReference.setValidFrom(now);\n+    when(this.keyRepository.findByTypeAndValid(any(), any()))\n+        .thenReturn(Arrays.asList(keyReference));\n+    when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n+        .thenReturn(aesSecret);\n+    when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n+    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n+    final List<TypedSecret> secrets =\n+        this.service.generateAndStoreSecrets(\n+            SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n+    assertThat(secrets.size()).isEqualTo(1);\n+    final TypedSecret typedSecret = secrets.get(0);\n+    assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n+    assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n+  }\n+}\n", "next_change": {"commit": "9a24991a5099b52f1f6402b2dbc487219a6dc070", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 079735cf6a..76813117ae 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -388,11 +486,96 @@ public class SecretManagementServiceTest {\n     when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n     when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n     final List<TypedSecret> secrets =\n-        this.service.generateAndStoreSecrets(\n+        this.service.generateAndStoreOrResetNewSecrets(\n             SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n     assertThat(secrets.size()).isEqualTo(1);\n     final TypedSecret typedSecret = secrets.get(0);\n     assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n     assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n   }\n+\n+  @Test\n+  public void generateAndStoreNewSecretWhenOlderNewSecretAlreadyExists() throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secret = this.getNewEncryptionSecret(100);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secret));\n+\n+    final SecretType secretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    this.service.generateAndStoreOrResetNewSecrets(SOME_DEVICE, Arrays.asList(secretType));\n+\n+    // THEN\n+    final List<DbEncryptedSecret> foundSecrets =\n+        this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW);\n+    assertThat(foundSecrets).hasSize(1);\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secret));\n+    assertThat(secret.getCreationTime()).isCloseTo(new Date(), 10);\n+    assertThat(secret.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+  }\n+\n+  @Test\n+  public void generateAndStoreNewSecretsWhenOneRecentAndOlderNewSecretAlreadyExists()\n+      throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secretOldEncryption = this.getNewEncryptionSecret(100);\n+    final DbEncryptedSecret secretOlderEncryption = this.getNewEncryptionSecret(1000);\n+    final DbEncryptedSecret secretOldAuthen = this.getNewAuthenticationSecret(100);\n+    final DbEncryptedSecret secretOlderAuthen = this.getNewAuthenticationSecret(1000);\n+    final Date olderCreationTime = secretOlderEncryption.getCreationTime();\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldEncryption, secretOlderEncryption));\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldAuthen, secretOlderAuthen));\n+\n+    final SecretType encryptionSecretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    final SecretType authenSecretType = SecretType.E_METER_AUTHENTICATION_KEY;\n+\n+    this.service.generateAndStoreOrResetNewSecrets(\n+        SOME_DEVICE, Arrays.asList(encryptionSecretType, authenSecretType));\n+\n+    // THEN\n+    final String logMessage =\n+        \"During (GenerateOr)Replace Key Process multiple keys with status NEW\";\n+    verify(this.mockAppender, times(2))\n+        .doAppend(\n+            argThat(\n+                argument -> {\n+                  assertThat(argument.getMessage()).startsWith(logMessage);\n+                  assertThat(argument.getLevel()).isEqualTo(Level.WARN);\n+                  return true;\n+                }));\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n+    verify(this.secretRepository, never())\n+        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n+\n+    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 10);\n+    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 10);\n+    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOlderEncryption.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderAuthen.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 76813117ae..6b5a77c2a4 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -484,98 +394,13 @@ public class SecretManagementServiceTest {\n     when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n         .thenReturn(aesSecret);\n     when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n-    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n+    when(this.encrypterForSecretManagementClient.encrypt(any())).thenReturn(rsaSecret);\n     final List<TypedSecret> secrets =\n-        this.service.generateAndStoreOrResetNewSecrets(\n+        this.service.generateAndStoreSecrets(\n             SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n     assertThat(secrets.size()).isEqualTo(1);\n     final TypedSecret typedSecret = secrets.get(0);\n     assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n     assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n   }\n-\n-  @Test\n-  public void generateAndStoreNewSecretWhenOlderNewSecretAlreadyExists() throws Exception {\n-    // GIVEN\n-    final DbEncryptedSecret secret = this.getNewEncryptionSecret(100);\n-    // WHEN\n-    when(this.secretRepository.getSecretCount(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(1);\n-    when(this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(Arrays.asList(secret));\n-\n-    final SecretType secretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-    this.service.generateAndStoreOrResetNewSecrets(SOME_DEVICE, Arrays.asList(secretType));\n-\n-    // THEN\n-    final List<DbEncryptedSecret> foundSecrets =\n-        this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW);\n-    assertThat(foundSecrets).hasSize(1);\n-\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secret));\n-    assertThat(secret.getCreationTime()).isCloseTo(new Date(), 10);\n-    assertThat(secret.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-  }\n-\n-  @Test\n-  public void generateAndStoreNewSecretsWhenOneRecentAndOlderNewSecretAlreadyExists()\n-      throws Exception {\n-    // GIVEN\n-    final DbEncryptedSecret secretOldEncryption = this.getNewEncryptionSecret(100);\n-    final DbEncryptedSecret secretOlderEncryption = this.getNewEncryptionSecret(1000);\n-    final DbEncryptedSecret secretOldAuthen = this.getNewAuthenticationSecret(100);\n-    final DbEncryptedSecret secretOlderAuthen = this.getNewAuthenticationSecret(1000);\n-    final Date olderCreationTime = secretOlderEncryption.getCreationTime();\n-\n-    // WHEN\n-    when(this.secretRepository.getSecretCount(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(2);\n-    when(this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n-        .thenReturn(Arrays.asList(secretOldEncryption, secretOlderEncryption));\n-    when(this.secretRepository.getSecretCount(\n-            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n-        .thenReturn(2);\n-    when(this.secretRepository.findSecrets(\n-            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n-        .thenReturn(Arrays.asList(secretOldAuthen, secretOlderAuthen));\n-\n-    final SecretType encryptionSecretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-    final SecretType authenSecretType = SecretType.E_METER_AUTHENTICATION_KEY;\n-\n-    this.service.generateAndStoreOrResetNewSecrets(\n-        SOME_DEVICE, Arrays.asList(encryptionSecretType, authenSecretType));\n-\n-    // THEN\n-    final String logMessage =\n-        \"During (GenerateOr)Replace Key Process multiple keys with status NEW\";\n-    verify(this.mockAppender, times(2))\n-        .doAppend(\n-            argThat(\n-                argument -> {\n-                  assertThat(argument.getMessage()).startsWith(logMessage);\n-                  assertThat(argument.getLevel()).isEqualTo(Level.WARN);\n-                  return true;\n-                }));\n-\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n-    verify(this.secretRepository, never())\n-        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n-\n-    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 10);\n-    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 10);\n-    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOlderEncryption.getCreationTime().getTime())\n-        .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderAuthen.getCreationTime().getTime())\n-        .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-  }\n }\n", "next_change": {"commit": "195ff84150abd28386026335f39673dd69390f56", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 6b5a77c2a4..c4ec3f73ac 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -394,13 +501,98 @@ public class SecretManagementServiceTest {\n     when(this.encryptionDelegate.generateAes128BitsSecret(ENCRYPTION_PROVIDER_TYPE, reference))\n         .thenReturn(aesSecret);\n     when(this.encryptionDelegate.decrypt(any(), any())).thenReturn(secret);\n-    when(this.encrypterForSecretManagementClient.encrypt(any())).thenReturn(rsaSecret);\n+    when(this.rsaEncrypter.encrypt(any())).thenReturn(rsaSecret);\n     final List<TypedSecret> secrets =\n-        this.service.generateAndStoreSecrets(\n+        this.service.generateAndStoreOrResetNewSecrets(\n             SOME_DEVICE, Arrays.asList(SecretType.E_METER_AUTHENTICATION_KEY));\n     assertThat(secrets.size()).isEqualTo(1);\n     final TypedSecret typedSecret = secrets.get(0);\n     assertThat(typedSecret.getSecretType()).isEqualTo(SecretType.E_METER_AUTHENTICATION_KEY);\n     assertThat(typedSecret.getSecret()).isEqualTo(rsaSecret);\n   }\n+\n+  @Test\n+  public void generateAndStoreNewSecretWhenOlderNewSecretAlreadyExists() throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secret = this.getNewEncryptionSecret(100);\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(1);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secret));\n+\n+    final SecretType secretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    this.service.generateAndStoreOrResetNewSecrets(SOME_DEVICE, Arrays.asList(secretType));\n+\n+    // THEN\n+    final List<DbEncryptedSecret> foundSecrets =\n+        this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW);\n+    assertThat(foundSecrets).hasSize(1);\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secret));\n+    assertThat(secret.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secret.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+  }\n+\n+  @Test\n+  public void generateAndStoreNewSecretsWhenOneRecentAndOlderNewSecretAlreadyExists()\n+      throws Exception {\n+    // GIVEN\n+    final DbEncryptedSecret secretOldEncryption = this.getNewEncryptionSecret(100);\n+    final DbEncryptedSecret secretOlderEncryption = this.getNewEncryptionSecret(1000);\n+    final DbEncryptedSecret secretOldAuthen = this.getNewAuthenticationSecret(100);\n+    final DbEncryptedSecret secretOlderAuthen = this.getNewAuthenticationSecret(1000);\n+    final Date olderCreationTime = secretOlderEncryption.getCreationTime();\n+\n+    // WHEN\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_ENCRYPTION_KEY_UNICAST, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldEncryption, secretOlderEncryption));\n+    when(this.secretRepository.getSecretCount(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(2);\n+    when(this.secretRepository.findSecrets(\n+            SOME_DEVICE, SecretType.E_METER_AUTHENTICATION_KEY, SecretStatus.NEW))\n+        .thenReturn(Arrays.asList(secretOldAuthen, secretOlderAuthen));\n+\n+    final SecretType encryptionSecretType = SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+    final SecretType authenSecretType = SecretType.E_METER_AUTHENTICATION_KEY;\n+\n+    this.service.generateAndStoreOrResetNewSecrets(\n+        SOME_DEVICE, Arrays.asList(encryptionSecretType, authenSecretType));\n+\n+    // THEN\n+    final String logMessage =\n+        \"During (GenerateOr)Replace Key Process multiple keys with status NEW\";\n+    verify(this.mockAppender, times(2))\n+        .doAppend(\n+            argThat(\n+                argument -> {\n+                  assertThat(argument.getMessage()).startsWith(logMessage);\n+                  assertThat(argument.getLevel()).isEqualTo(Level.WARN);\n+                  return true;\n+                }));\n+\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n+    verify(this.secretRepository, never())\n+        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n+\n+    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOlderEncryption.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderAuthen.getCreationTime().getTime())\n+        .isEqualTo(olderCreationTime.getTime());\n+    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+  }\n }\n", "next_change": {"commit": "d1565558084b533c091c8310911a50d6766fde49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex c4ec3f73ac..63d4126596 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -584,15 +610,17 @@ public class SecretManagementServiceTest {\n     verify(this.secretRepository, never())\n         .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n \n-    assertThat(secretOldEncryption.getCreationTime()).isCloseTo(new Date(), 100);\n-    assertThat(secretOldAuthen.getCreationTime()).isCloseTo(new Date(), 100);\n+    assertThat(secretOldEncryption.getCreationTime())\n+        .isEqualTo(originalCreationTimeEncryptionSecret);\n+    assertThat(secretOldAuthen.getCreationTime())\n+        .isEqualTo(originalCreationTimeAuthenticationSecret);\n     assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n     assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n     assertThat(secretOlderEncryption.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n     assertThat(secretOlderAuthen.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n-    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.EXPIRED);\n+    assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n+    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n   }\n }\n", "next_change": {"commit": "b7947c76093303a1f50869f7dc20ed80aed4c154", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 63d4126596..93e0329e30 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -606,21 +602,21 @@ public class SecretManagementServiceTest {\n                 }));\n \n     verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthen));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthentication));\n     verify(this.secretRepository, never())\n-        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthen));\n+        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthentication));\n \n     assertThat(secretOldEncryption.getCreationTime())\n         .isEqualTo(originalCreationTimeEncryptionSecret);\n-    assertThat(secretOldAuthen.getCreationTime())\n+    assertThat(secretOldAuthentication.getCreationTime())\n         .isEqualTo(originalCreationTimeAuthenticationSecret);\n     assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOldAuthen.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldAuthentication.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n     assertThat(secretOlderEncryption.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderAuthen.getCreationTime().getTime())\n+    assertThat(secretOlderAuthentication.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n     assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n-    assertThat(secretOlderAuthen.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n+    assertThat(secretOlderAuthentication.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n   }\n }\n", "next_change": {"commit": "b30685e826bc285c9c0b44607ffa549b6d82b821", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\nindex 93e0329e30..12b6e95072 100644\n--- a/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n+++ b/osgp/platform/osgp-secret-management/src/test/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementServiceTest.java\n", "chunk": "@@ -602,21 +571,13 @@ public class SecretManagementServiceTest {\n                 }));\n \n     verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n-    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldAuthentication));\n-    verify(this.secretRepository, never())\n-        .saveAll(Arrays.asList(secretOldEncryption, secretOldAuthentication));\n+    verify(this.secretRepository, never()).saveAll(Arrays.asList(secretOldEncryption));\n \n     assertThat(secretOldEncryption.getCreationTime())\n         .isEqualTo(originalCreationTimeEncryptionSecret);\n-    assertThat(secretOldAuthentication.getCreationTime())\n-        .isEqualTo(originalCreationTimeAuthenticationSecret);\n-    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n-    assertThat(secretOldAuthentication.getSecretStatus()).isEqualTo(SecretStatus.NEW);\n+    assertThat(secretOldEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n     assertThat(secretOlderEncryption.getCreationTime().getTime())\n         .isEqualTo(olderCreationTime.getTime());\n-    assertThat(secretOlderAuthentication.getCreationTime().getTime())\n-        .isEqualTo(olderCreationTime.getTime());\n     assertThat(secretOlderEncryption.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n-    assertThat(secretOlderAuthentication.getSecretStatus()).isEqualTo(SecretStatus.WITHDRAWN);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwOTYyNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450809625", "body": "what could go wrong here?", "bodyText": "what could go wrong here?", "bodyHTML": "<p dir=\"auto\">what could go wrong here?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:58:01Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;\n+        }\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n+            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n+            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+            dbEncryptedSecret.setCreationTime(new Date());\n+            return dbEncryptedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n+        }\n+    }\n+\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n+            throws Exception {\n+        try {\n+            //@formatter:off\n+            return secretTypes.stream()\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .collect(Collectors.toList());\n+            //@formatter:on\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -118,6 +112,7 @@ public class SecretManagementService {\n             //@formatter:off\n             return secretTypes.stream()\n                     .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n         } catch (final Exception exc) {\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -106,12 +106,11 @@ public class SecretManagementService {\n         }\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n-            throws Exception {\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         try {\n             //@formatter:off\n             return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n                     .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -110,7 +106,7 @@ public class SecretManagementService {\n         try {\n             //@formatter:off\n             return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n+                    .map(secretType -> this.retrieveCurrentSecret(deviceIdentification, secretType))\n                     .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..d38c5f1060 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -106,7 +104,7 @@ public class SecretManagementService {\n         try {\n             //@formatter:off\n             return secretTypes.stream()\n-                    .map(secretType -> this.retrieveCurrentSecret(deviceIdentification, secretType))\n+                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n                     .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex d38c5f1060..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,186 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification,\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n             final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n-    }\n-\n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream().map(s->s.getSecretType()).forEach(t-> this.checkNrNewSecretsOfType(deviceIdentification, t, 0));\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n         }\n     }\n \n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        final DbEncryptionKeyReference keyReference = this.getKey();\n-        //TODO get key (KEK) from HSM and use it to generate AES 128-bits secret\n-        return null;\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -126,27 +121,28 @@ public class SecretManagementService {\n         }\n     }\n \n-    @java.lang.SuppressWarnings(\"squid:S3655\")\n-    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n         final Date now = new Date();\n         final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n                 now);\n         if (secretId == null) {\n-            throw new NoSuchElementException(\"No secret found with a valid key\");\n+            return Optional.empty();\n         }\n-        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n+        return Optional.of(typedSecret);\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        if (dbEncryptedSecret != null) {\n-            final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n+        if (dbEncryptedSecret.isPresent()) {\n+            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n+            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n             if (keyReference == null) {\n                 throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n             }\n-            final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n             final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n                     secretBytes);\n-            return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n         } else {    //Should never happen because of stream mapping in retrieveSecrets()\n             throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n         }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,7 +148,7 @@ public class SecretManagementService {\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -120,35 +116,38 @@ public class SecretManagementService {\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    public Optional<TypedSecret> retrieveCurrentSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n+                secretType, SecretStatus.ACTIVE);\n+        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n+\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final Page<DbEncryptedSecret> secretsPage = this.secretRepository.findSecrets(deviceIdentification, secretType,\n+                secretStatus, Pageable.unpaged());\n+        if (secretsPage.getTotalElements() == 0) {\n             return Optional.empty();\n+        } else if (secretsPage.getTotalElements() > 1) {\n+            throw new IllegalStateException(); //TODO set proper msg\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsPage.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+        if (keyReference == null) {\n+            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n         }\n+        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n+                secretBytes);\n+        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,10 +152,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -152,10 +150,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -150,10 +148,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwOTkwMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450809902", "body": "could be rewritten with Optional? ", "bodyText": "could be rewritten with Optional?", "bodyHTML": "<p dir=\"auto\">could be rewritten with Optional?</p>", "author": "coendamen", "createdAt": "2020-07-07T11:58:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;\n+        }\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n+            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n+            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+            dbEncryptedSecret.setCreationTime(new Date());\n+            return dbEncryptedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n+        }\n+    }\n+\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n+            throws Exception {\n+        try {\n+            //@formatter:off\n+            return secretTypes.stream()\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .collect(Collectors.toList());\n+            //@formatter:on\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\n+                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+        }\n+    }\n+\n+    @java.lang.SuppressWarnings(\"squid:S3655\")\n+    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Date now = new Date();\n+        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n+                now);\n+        if (secretId == null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -126,27 +121,28 @@ public class SecretManagementService {\n         }\n     }\n \n-    @java.lang.SuppressWarnings(\"squid:S3655\")\n-    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n         final Date now = new Date();\n         final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n                 now);\n         if (secretId == null) {\n-            throw new NoSuchElementException(\"No secret found with a valid key\");\n+            return Optional.empty();\n         }\n-        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n+        return Optional.of(typedSecret);\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        if (dbEncryptedSecret != null) {\n-            final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n+        if (dbEncryptedSecret.isPresent()) {\n+            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n+            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n             if (keyReference == null) {\n                 throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n             }\n-            final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n             final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n                     secretBytes);\n-            return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n         } else {    //Should never happen because of stream mapping in retrieveSecrets()\n             throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n         }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,7 +148,7 @@ public class SecretManagementService {\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -120,35 +116,38 @@ public class SecretManagementService {\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    public Optional<TypedSecret> retrieveCurrentSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n+                secretType, SecretStatus.ACTIVE);\n+        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n+\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final Page<DbEncryptedSecret> secretsPage = this.secretRepository.findSecrets(deviceIdentification, secretType,\n+                secretStatus, Pageable.unpaged());\n+        if (secretsPage.getTotalElements() == 0) {\n             return Optional.empty();\n+        } else if (secretsPage.getTotalElements() > 1) {\n+            throw new IllegalStateException(); //TODO set proper msg\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsPage.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+        if (keyReference == null) {\n+            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n         }\n+        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n+                secretBytes);\n+        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,10 +152,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -152,10 +150,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -150,10 +148,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMDM2Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450810363", "body": "this seems strange, why do a null check here? \r\n\r\nconsider doing the null check in the caller, that is much clearer.", "bodyText": "this seems strange, why do a null check here?\nconsider doing the null check in the caller, that is much clearer.", "bodyHTML": "<p dir=\"auto\">this seems strange, why do a null check here?</p>\n<p dir=\"auto\">consider doing the null check in the caller, that is much clearer.</p>", "author": "coendamen", "createdAt": "2020-07-07T11:59:33Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;\n+        }\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n+            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n+            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+            dbEncryptedSecret.setCreationTime(new Date());\n+            return dbEncryptedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n+        }\n+    }\n+\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n+            throws Exception {\n+        try {\n+            //@formatter:off\n+            return secretTypes.stream()\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .collect(Collectors.toList());\n+            //@formatter:on\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\n+                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+        }\n+    }\n+\n+    @java.lang.SuppressWarnings(\"squid:S3655\")\n+    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Date now = new Date();\n+        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n+                now);\n+        if (secretId == null) {\n+            throw new NoSuchElementException(\"No secret found with a valid key\");\n+        }\n+        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+    }\n+\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        if (dbEncryptedSecret != null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -126,27 +121,28 @@ public class SecretManagementService {\n         }\n     }\n \n-    @java.lang.SuppressWarnings(\"squid:S3655\")\n-    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n         final Date now = new Date();\n         final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n                 now);\n         if (secretId == null) {\n-            throw new NoSuchElementException(\"No secret found with a valid key\");\n+            return Optional.empty();\n         }\n-        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n+        return Optional.of(typedSecret);\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        if (dbEncryptedSecret != null) {\n-            final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n+        if (dbEncryptedSecret.isPresent()) {\n+            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n+            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n             if (keyReference == null) {\n                 throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n             }\n-            final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n             final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n                     secretBytes);\n-            return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n         } else {    //Should never happen because of stream mapping in retrieveSecrets()\n             throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n         }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,7 +148,7 @@ public class SecretManagementService {\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -120,35 +116,38 @@ public class SecretManagementService {\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    public Optional<TypedSecret> retrieveCurrentSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n+                secretType, SecretStatus.ACTIVE);\n+        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n+\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final Page<DbEncryptedSecret> secretsPage = this.secretRepository.findSecrets(deviceIdentification, secretType,\n+                secretStatus, Pageable.unpaged());\n+        if (secretsPage.getTotalElements() == 0) {\n             return Optional.empty();\n+        } else if (secretsPage.getTotalElements() > 1) {\n+            throw new IllegalStateException(); //TODO set proper msg\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsPage.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+        if (keyReference == null) {\n+            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n         }\n+        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n+                secretBytes);\n+        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,10 +152,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -152,10 +150,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -150,10 +148,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMTExNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450811116", "body": "and another null check?\r\n\r\nconsider validating the DbEncryptedSecret  first before calling this method", "bodyText": "and another null check?\nconsider validating the DbEncryptedSecret  first before calling this method", "bodyHTML": "<p dir=\"auto\">and another null check?</p>\n<p dir=\"auto\">consider validating the DbEncryptedSecret  first before calling this method</p>", "author": "coendamen", "createdAt": "2020-07-07T12:00:53Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;\n+        }\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n+            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n+            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+            dbEncryptedSecret.setCreationTime(new Date());\n+            return dbEncryptedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n+        }\n+    }\n+\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n+            throws Exception {\n+        try {\n+            //@formatter:off\n+            return secretTypes.stream()\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .collect(Collectors.toList());\n+            //@formatter:on\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\n+                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+        }\n+    }\n+\n+    @java.lang.SuppressWarnings(\"squid:S3655\")\n+    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Date now = new Date();\n+        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n+                now);\n+        if (secretId == null) {\n+            throw new NoSuchElementException(\"No secret found with a valid key\");\n+        }\n+        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+    }\n+\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        if (dbEncryptedSecret != null) {\n+            final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+            if (keyReference == null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -126,27 +121,28 @@ public class SecretManagementService {\n         }\n     }\n \n-    @java.lang.SuppressWarnings(\"squid:S3655\")\n-    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n         final Date now = new Date();\n         final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n                 now);\n         if (secretId == null) {\n-            throw new NoSuchElementException(\"No secret found with a valid key\");\n+            return Optional.empty();\n         }\n-        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n+        return Optional.of(typedSecret);\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        if (dbEncryptedSecret != null) {\n-            final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n+        if (dbEncryptedSecret.isPresent()) {\n+            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n+            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n             if (keyReference == null) {\n                 throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n             }\n-            final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n             final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n                     secretBytes);\n-            return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n         } else {    //Should never happen because of stream mapping in retrieveSecrets()\n             throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n         }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,7 +148,7 @@ public class SecretManagementService {\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -120,35 +116,38 @@ public class SecretManagementService {\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    public Optional<TypedSecret> retrieveCurrentSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n+                secretType, SecretStatus.ACTIVE);\n+        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n+\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final Page<DbEncryptedSecret> secretsPage = this.secretRepository.findSecrets(deviceIdentification, secretType,\n+                secretStatus, Pageable.unpaged());\n+        if (secretsPage.getTotalElements() == 0) {\n             return Optional.empty();\n+        } else if (secretsPage.getTotalElements() > 1) {\n+            throw new IllegalStateException(); //TODO set proper msg\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsPage.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+        if (keyReference == null) {\n+            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n         }\n+        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n+                secretBytes);\n+        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n     }\n \n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-                                          final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n             final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -149,10 +152,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -152,10 +150,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -150,10 +148,10 @@ public class SecretManagementService {\n     private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n             final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n                     keyReference.getReference());\n             final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n             typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n             return typedSecret;\n         } catch (final Exception exc) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMjYyNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450812627", "body": "I see many IllegalStateExceptions, although it is easy/handy to throw just a RuntimeException I would suggest to make a proper Checked Exception to make it more explicit where it can go wrong and improved exception handling.", "bodyText": "I see many IllegalStateExceptions, although it is easy/handy to throw just a RuntimeException I would suggest to make a proper Checked Exception to make it more explicit where it can go wrong and improved exception handling.", "bodyHTML": "<p dir=\"auto\">I see many IllegalStateExceptions, although it is easy/handy to throw just a RuntimeException I would suggest to make a proper Checked Exception to make it more explicit where it can go wrong and improved exception handling.</p>", "author": "coendamen", "createdAt": "2020-07-07T12:03:37Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;\n+        }\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n+            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n+            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+            dbEncryptedSecret.setCreationTime(new Date());\n+            return dbEncryptedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n+        }\n+    }\n+\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n+            throws Exception {\n+        try {\n+            //@formatter:off\n+            return secretTypes.stream()\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .collect(Collectors.toList());\n+            //@formatter:on\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\n+                    String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n+        }\n+    }\n+\n+    @java.lang.SuppressWarnings(\"squid:S3655\")\n+    public TypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Date now = new Date();\n+        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n+                now);\n+        if (secretId == null) {\n+            throw new NoSuchElementException(\"No secret found with a valid key\");\n+        }\n+        return this.getTypedSecret(this.secretRepository.findById(secretId).get());\n+    }\n+\n+    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n+        if (dbEncryptedSecret != null) {\n+            final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n+            if (keyReference == null) {\n+                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n+            }\n+            final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n+                    secretBytes);\n+            return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n+            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+        }\n+    }\n+\n+    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n+            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+        try {\n+            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n+                    keyReference.getReference());\n+            final TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n+            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n+            return typedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -165,4 +159,44 @@ public class SecretManagementService {\n             throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n         }\n     }\n+\n+    public synchronized Long storeSecret(final String deviceIdentification, final TypedSecret typedSecret)\n+            throws IOException {\n+        final Date now = new Date(); //TODO check creation & time zone\n+        final SecretType secretType = typedSecret.getSecretType();\n+        if (this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0) {\n+            final String errorMsg = \"Cannot store new secret: a new secret of type %s is already present\";\n+            throw new IllegalStateException(String.format(errorMsg, secretType.name()));\n+        }\n+        this.validateSecret(deviceIdentification, typedSecret);\n+        DbEncryptedSecret encryptedSecret = this.createEncrypted(deviceIdentification, typedSecret, this.getKey());\n+        try {\n+            encryptedSecret = this.secretRepository.save(encryptedSecret);\n+            return encryptedSecret.getId();\n+        } catch (final DataAccessException dae) {\n+            throw new IOException(\"Could not store new key in database\", dae);\n+        }\n+    }\n+\n+    public synchronized void activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Date now = new Date(); //TODO check creation & time zone\n+        final int nrNewSecrets = this.secretRepository.getSecretCount(deviceIdentification, secretType,\n+                SecretStatus.NEW);\n+        if (nrNewSecrets == 0) {\n+            throw new IllegalStateException(\"Cannot activate new secret: no new secret is present\");\n+        } else if (nrNewSecrets > 1) { //should not be possible\n+            throw new IllegalStateException(\"Cannot activate new secret: multiple new secrets are present\");\n+        }\n+        final Optional<DbEncryptedSecret> currentSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n+                secretType, SecretStatus.ACTIVE);\n+        if (currentSecretOptional.isPresent()) {\n+            final DbEncryptedSecret currentSecret = currentSecretOptional.get();\n+            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+            this.secretRepository.save(currentSecret);\n+        }\n+        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n+                SecretStatus.NEW).get(); //We have checked nr of new secrets already\n+        newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+        this.secretRepository.save(newSecret);\n+    }\n }\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..d38c5f1060 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -160,43 +159,50 @@ public class SecretManagementService {\n         }\n     }\n \n-    public synchronized Long storeSecret(final String deviceIdentification, final TypedSecret typedSecret)\n-            throws IOException {\n-        final Date now = new Date(); //TODO check creation & time zone\n-        final SecretType secretType = typedSecret.getSecretType();\n-        if (this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0) {\n-            final String errorMsg = \"Cannot store new secret: a new secret of type %s is already present\";\n-            throw new IllegalStateException(String.format(errorMsg, secretType.name()));\n-        }\n-        this.validateSecret(deviceIdentification, typedSecret);\n-        DbEncryptedSecret encryptedSecret = this.createEncrypted(deviceIdentification, typedSecret, this.getKey());\n-        try {\n-            encryptedSecret = this.secretRepository.save(encryptedSecret);\n-            return encryptedSecret.getId();\n-        } catch (final DataAccessException dae) {\n-            throw new IOException(\"Could not store new key in database\", dae);\n-        }\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        //@formatter:off\n+        secrets.stream().map(s->s.getSecretType()).forEach(t-> this.checkNrNewSecretsOfType(deviceIdentification, t, 0));\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n     }\n \n-    public synchronized void activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date(); //TODO check creation & time zone\n-        final int nrNewSecrets = this.secretRepository.getSecretCount(deviceIdentification, secretType,\n-                SecretStatus.NEW);\n-        if (nrNewSecrets == 0) {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret is present\");\n-        } else if (nrNewSecrets > 1) { //should not be possible\n-            throw new IllegalStateException(\"Cannot activate new secret: multiple new secrets are present\");\n-        }\n-        final Optional<DbEncryptedSecret> currentSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n+    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+    }\n+\n+    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+    }\n+\n+    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n                 secretType, SecretStatus.ACTIVE);\n-        if (currentSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = currentSecretOptional.get();\n+        if (activeSecretOptional.isPresent()) {\n+            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n             this.secretRepository.save(currentSecret);\n         }\n         final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already\n+                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        this.secretRepository.save(newSecret);\n+        return this.secretRepository.save(newSecret).getId();\n+    }\n+\n+    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n+        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+        if (nrNewSecretsOfType != expectedNr) {\n+            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        final DbEncryptionKeyReference keyReference = this.getKey();\n+        //TODO get key (KEK) from HSM and use it to generate AES 128-bits secret\n+        return null;\n     }\n }\n", "next_change": {"commit": "2159e9a08463bd3a0175cc18eb0487988b3f1769", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex d38c5f1060..cb3599c4ab 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -202,7 +207,24 @@ public class SecretManagementService {\n \n     public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n         final DbEncryptionKeyReference keyReference = this.getKey();\n-        //TODO get key (KEK) from HSM and use it to generate AES 128-bits secret\n+        //TODO get key (KEK) from HSM and use it to encrypt generated AES 128-bits secret\n+        //Old implementation:\n+        try {\n+            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n+            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n+            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n+            //encrypt with KEK\n+        } catch(final NoSuchAlgorithmException nsae) {\n+            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n+        }\n+\n+        //EvB:\n+        // Dit is hoe je een secret kunt genereren\n+        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n+        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n+        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n+        // HSM wordt gegenereerd.\n+        // Ik zal een link naar documentatie sturen.\n         return null;\n     }\n }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cb3599c4ab..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -26,205 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification,\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n             final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n-    }\n-\n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n         }\n     }\n \n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        final DbEncryptionKeyReference keyReference = this.getKey();\n-        //TODO get key (KEK) from HSM and use it to encrypt generated AES 128-bits secret\n-        //Old implementation:\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-            //encrypt with KEK\n-        } catch(final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMzk4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450813987", "body": "I would rewrite this into a constructor to make data immutable.\r\n\r\nalso it is much less lines. just return new DbEncryptedSecret(value1, value2) etc", "bodyText": "I would rewrite this into a constructor to make data immutable.\nalso it is much less lines. just return new DbEncryptedSecret(value1, value2) etc", "bodyHTML": "<p dir=\"auto\">I would rewrite this into a constructor to make data immutable.</p>\n<p dir=\"auto\">also it is much less lines. just return new DbEncryptedSecret(value1, value2) etc</p>", "author": "coendamen", "createdAt": "2020-07-07T12:06:11Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;\n+        }\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -83,17 +82,12 @@ public class SecretManagementService {\n     }\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        try {\n-            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-            return current.getSecret().equals(secret.getSecret());\n-        } catch (final NoSuchElementException nsee) {\n-            //there is no current secret\n-            return false;\n-        }\n+        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-            final DbEncryptionKeyReference keyReference) {\n+                                              final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n         final Secret secret = new Secret(secretBytes);\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -82,15 +76,16 @@ public class SecretManagementService {\n     }\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        final Optional<TypedSecret> current = this.retrieveCurrentSecret(deviceIdentification, secret.getSecretType());\n         return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-                                              final DbEncryptionKeyReference keyReference) {\n+            final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n         final Secret secret = new Secret(secretBytes);\n+        final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n                     keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -75,20 +78,19 @@ public class SecretManagementService {\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveCurrentSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n+    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n+        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n+        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -87,10 +85,11 @@ public class SecretManagementService {\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -85,11 +84,10 @@ public class SecretManagementService {\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxNTYwOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450815608", "body": "where is the NoSuchElementException exception thrown? ", "bodyText": "where is the NoSuchElementException exception thrown?", "bodyHTML": "<p dir=\"auto\">where is the NoSuchElementException exception thrown?</p>", "author": "coendamen", "createdAt": "2020-07-07T12:09:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -83,13 +82,8 @@ public class SecretManagementService {\n     }\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        try {\n-            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-            return current.getSecret().equals(secret.getSecret());\n-        } catch (final NoSuchElementException nsee) {\n-            //there is no current secret\n-            return false;\n-        }\n+        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        return current.isPresent() ? current.get().getSecret().equals(secret.getSecret()) : false;\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -83,11 +83,11 @@ public class SecretManagementService {\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n         final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() ? current.get().getSecret().equals(secret.getSecret()) : false;\n+        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-            final DbEncryptionKeyReference keyReference) {\n+                                              final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n         final Secret secret = new Secret(secretBytes);\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -82,15 +76,16 @@ public class SecretManagementService {\n     }\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        final Optional<TypedSecret> current = this.retrieveCurrentSecret(deviceIdentification, secret.getSecretType());\n         return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-                                              final DbEncryptionKeyReference keyReference) {\n+            final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n         final Secret secret = new Secret(secretBytes);\n+        final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n                     keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -75,20 +78,19 @@ public class SecretManagementService {\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveCurrentSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n+    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n+        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n+        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -87,10 +85,11 @@ public class SecretManagementService {\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -85,11 +84,10 @@ public class SecretManagementService {\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxNjIyMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450816220", "body": "I would rewrite this to make it clearer", "bodyText": "I would rewrite this to make it clearer", "bodyHTML": "<p dir=\"auto\">I would rewrite this to make it clearer</p>", "author": "coendamen", "createdAt": "2020-07-07T12:10:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        try {\n+            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+            return current.getSecret().equals(secret.getSecret());\n+        } catch (final NoSuchElementException nsee) {\n+            //there is no current secret\n+            return false;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -83,13 +82,8 @@ public class SecretManagementService {\n     }\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        try {\n-            final TypedSecret current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-            return current.getSecret().equals(secret.getSecret());\n-        } catch (final NoSuchElementException nsee) {\n-            //there is no current secret\n-            return false;\n-        }\n+        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        return current.isPresent() ? current.get().getSecret().equals(secret.getSecret()) : false;\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -83,11 +83,11 @@ public class SecretManagementService {\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n         final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() ? current.get().getSecret().equals(secret.getSecret()) : false;\n+        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-            final DbEncryptionKeyReference keyReference) {\n+                                              final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n         final Secret secret = new Secret(secretBytes);\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -82,15 +76,16 @@ public class SecretManagementService {\n     }\n \n     private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        final Optional<TypedSecret> current = this.retrieveCurrentSecret(deviceIdentification, secret.getSecretType());\n         return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-                                              final DbEncryptionKeyReference keyReference) {\n+            final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n         final Secret secret = new Secret(secretBytes);\n+        final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n                     keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n", "next_change": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..371b1bfd48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -75,20 +78,19 @@ public class SecretManagementService {\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveCurrentSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() && current.get().getSecret().equals(secret.getSecret());\n+    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n+        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n+        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n     }\n \n     private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 371b1bfd48..3273f1e073 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -87,10 +85,11 @@ public class SecretManagementService {\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "212af20585d65ae4da3d321b7ccdaa46fb275bc0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 3273f1e073..ea0ddea1e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -85,11 +84,10 @@ public class SecretManagementService {\n             final DbEncryptionKeyReference keyReference) {\n         final String secretString = typedSecret.getSecret();\n         final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n         final Date now = new Date(); //TODO check creation & time zone\n         try {\n             final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n             final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n             dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n             dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ea0ddea1e7..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,199 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n-    public static final int AES_GMC_128_KEY_SIZE = 128;\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n \n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secretBytes, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n-    }\n-\n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final byte[] decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n-        }\n-    }\n-\n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        //Old implementation:\n-        /*try {\n-            final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\",\"\"); //.getInstance(\"AES\");\n-            keyGenerator.init(AES_GMC_128_KEY_SIZE);\n-            final byte[] encodedSecret = keyGenerator.generateKey().getEncoded();\n-        } catch (final NoSuchAlgorithmException nsae) {\n-            throw new IllegalStateException(\"Secret configuration incorrect\", nsae);\n-        }*/\n-\n-        //EvB:\n-        // Dit is hoe je een secret kunt genereren\n-        // Die moet vervolgens bij het opslaan encrypted worden met een KEK\n-        // Het lijkt me dat het zo werkt, maar ik weet dat niet zeker. ik heb dat niet uitgezocht.\n-        // Het idee is wanneer je ervoor zorgt dat de KeyGenerator provided wordt door NCipher, dat de key dan in de\n-        // HSM wordt gegenereerd.\n-        // Ik zal een link naar documentatie sturen.\n-        return null;\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxNjk3Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450816977", "body": "this annotation is not needed", "bodyText": "this annotation is not needed", "bodyHTML": "<p dir=\"auto\">this annotation is not needed</p>", "author": "coendamen", "createdAt": "2020-07-07T12:11:58Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..618e001b7d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -38,7 +38,6 @@ public class SecretManagementService {\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n \n-    @Autowired\n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -18,147 +23,285 @@ import java.util.stream.Collectors;\n import org.apache.tomcat.util.buf.HexUtils;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n+    }\n+\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n-        if (secret.getSecret() == null) {\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n-        return current.isPresent() ? current.get().getSecret().equals(secret.getSecret()) : false;\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(new Date());\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n-            throws Exception {\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    public Optional<TypedSecret> retrieveSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Date now = new Date();\n-        final Long secretId = this.secretRepository.findIdOfValidMostRecent(deviceIdentification, secretType.name(),\n-                now);\n-        if (secretId == null) {\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n+            final SecretType secretType) {\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n+    }\n+\n+    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n+            final SecretType secretType, final SecretStatus secretStatus) {\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+        if (secretsList.size() == 0) {\n             return Optional.empty();\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n-        final TypedSecret typedSecret = this.getTypedSecret(this.secretRepository.findById(secretId));\n-        return Optional.of(typedSecret);\n+        return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final Optional<DbEncryptedSecret> dbEncryptedSecret) {\n-        if (dbEncryptedSecret.isPresent()) {\n-            final DbEncryptedSecret secret = dbEncryptedSecret.get();\n-            final DbEncryptionKeyReference keyReference = secret.getEncryptionKeyReference();\n-            if (keyReference == null) {\n-                throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-            }\n-            final byte[] secretBytes = HexUtils.fromHexString(secret.getEncodedSecret());\n-            final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                    secretBytes);\n-            return this.createTypedSecret(secret, keyReference, encryptedSecret);\n-        } else {    //Should never happen because of stream mapping in retrieveSecrets()\n-            throw new IllegalStateException(\"Could not create typed secret for NULL secret\");\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+    }\n+\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+        secrets.stream()\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    }\n+\n+    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    }\n+\n+    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+    }\n+\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (activeSecretOptional.isPresent()) {\n+            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+            updatedSecrets.add(currentSecret);\n+        }\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n+        newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n+    }\n+\n+    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n+        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+        if (nrNewSecretsOfType != expectedNr) {\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n         }\n     }\n \n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n         try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n+        }\n+    }\n+\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n         }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxNzcyMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450817722", "body": "possible NPE's here?", "bodyText": "possible NPE's here?", "bodyHTML": "<p dir=\"auto\">possible NPE's here?</p>", "author": "coendamen", "createdAt": "2020-07-07T12:13:07Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {\n+            TechnicalFault technicalFault = convert((TechnicalException) ex);\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) {\n+                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n+            }\n+            if (technicalFault.getComponent() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n+            }\n+            if (technicalFault.getInnerMessage() != null) {\n+                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n+            }\n+            if (technicalFault.getInnerException() != null) {\n+                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            }\n+        }\n+    }\n+\n+    private TechnicalFault convert(final TechnicalException ex) {\n+        if (ex == null) {\n+            return null;\n+        }\n+        final TechnicalFault destination = new TechnicalFault();\n+        destination.setComponent(ex.getComponentType().name());\n+        destination.setMessage(ex.getMessage());\n+        if (ex.getCause() != null) {\n+            destination.setInnerException(ex.getCause().getClass().getName());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxODkzMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450818930", "body": "you could use Stream().map() here", "bodyText": "you could use Stream().map() here", "bodyHTML": "<p dir=\"auto\">you could use Stream().map() here</p>", "author": "coendamen", "createdAt": "2020-07-07T12:15:15Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {\n+\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+    private EncryptionDelegate encryptionDelegate;\n+\n+    public SoapEndpointDataTypeConverter(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+    }\n+\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n+\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n+                soapSecretTypes.getSecretType();\n+        List<SecretType> secretTypeList = new ArrayList<>();\n+\n+        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..5c81e0d9e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,10 +38,6 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n-        }\n-\n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n                 soapSecretTypes.getSecretType();\n         List<SecretType> secretTypeList = new ArrayList<>();\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 5c81e0d9e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,17 +38,10 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        List<SecretType> secretTypeList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n-                soapSecretTypeList) {\n-            SecretType secretType = convertToSecretType(soapSecretType);\n-            secretTypeList.add(secretType);\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return secretTypeList;\n+        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+                Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,11 +36,11 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n \n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxOTI2Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450819267", "body": "could use Stream().map()", "bodyText": "could use Stream().map()", "bodyHTML": "<p dir=\"auto\">could use Stream().map()</p>", "author": "coendamen", "createdAt": "2020-07-07T12:15:46Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {\n+\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+    private EncryptionDelegate encryptionDelegate;\n+\n+    public SoapEndpointDataTypeConverter(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+    }\n+\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n+\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n+                soapSecretTypes.getSecretType();\n+        List<SecretType> secretTypeList = new ArrayList<>();\n+\n+        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n+                soapSecretTypeList) {\n+            SecretType secretType = convertToSecretType(soapSecretType);\n+            secretTypeList.add(secretType);\n+        }\n+\n+        return secretTypeList;\n+    }\n+\n+    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+\n+        if (soapTypedSecrets == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList\n+                = soapTypedSecrets.getTypedSecret();\n+        List<TypedSecret> typedSecretList = new ArrayList<>();\n+\n+        for (org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret :", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -61,16 +50,11 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList\n-                = soapTypedSecrets.getTypedSecret();\n-        List<TypedSecret> typedSecretList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret :\n-                soapTypedSecretsList) {\n-            typedSecretList.add(decryptAndConvertSoapTypedSecret(soapTypedSecret));\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+                soapTypedSecrets.getTypedSecret();\n \n-        return typedSecretList;\n+        return soapTypedSecretsList.stream().map(\n+                (soapTypedSecret) -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -54,7 +54,7 @@ public class SoapEndpointDataTypeConverter {\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                (soapTypedSecret) -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyMDA2Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450820066", "body": "I would keep the endpoint as thin as possible and move away the \"secrets\"code to the service.", "bodyText": "I would keep the endpoint as thin as possible and move away the \"secrets\"code to the service.", "bodyHTML": "<p dir=\"auto\">I would keep the endpoint as thin as possible and move away the \"secrets\"code to the service.</p>", "author": "coendamen", "createdAt": "2020-07-07T12:17:15Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.util.List;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.services.SecretManagementService;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+@Endpoint\n+@Slf4j\n+public class SecretManagementEndpoint {\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement/2020/05\";\n+\n+    private final SecretManagementService secretManagementService;\n+    private final SoapEndpointDataTypeConverter converter;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n+            SoapEndpointDataTypeConverter converter) {\n+        this.secretManagementService = secretManagementService;\n+        this.converter = converter;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n+\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        log.trace(request.toString());\n+\n+        try {\n+            GetSecretsResponse response = new GetSecretsResponse();\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(request.getSecretTypes());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex d0deee67d7..db9aab1d6d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -48,9 +51,9 @@ public class SecretManagementEndpoint {\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n \n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        logger.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        log.trace(request.toString());\n+        logger.trace(request.toString());\n \n         try {\n             GetSecretsResponse response = new GetSecretsResponse();\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex db9aab1d6d..76ac969a62 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -51,14 +49,20 @@ public class SecretManagementEndpoint {\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n \n-        logger.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        logger.trace(request.toString());\n+        log.trace(request.toString());\n \n         try {\n             GetSecretsResponse response = new GetSecretsResponse();\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(request.getSecretTypes());\n+            SecretTypes soapSecretTypes = request.getSecretTypes();\n+\n+            if (soapSecretTypes == null) {\n+                throw new TechnicalException(\"Missing input: secret types\");\n+            }\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n             List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n                     secretTypeList);\n \n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 76ac969a62..6fd1c521f7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -51,32 +55,30 @@ public class SecretManagementEndpoint {\n \n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        log.trace(request.toString());\n+        if (log.isDebugEnabled()) {\n+            log.debug(getSecretsRequestToString(request));\n+        }\n \n-        try {\n-            GetSecretsResponse response = new GetSecretsResponse();\n+        GetSecretsResponse response = new GetSecretsResponse();\n \n-            SecretTypes soapSecretTypes = request.getSecretTypes();\n+        SecretTypes soapSecretTypes = request.getSecretTypes();\n \n-            if (soapSecretTypes == null) {\n-                throw new TechnicalException(\"Missing input: secret types\");\n-            }\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                    secretTypeList);\n+        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                secretTypeList);\n \n-            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n \n-            response.setTypedSecrets(soapTypedSecrets);\n-            response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n \n-            log.trace(response.toString());\n+        log.trace(response.toString());\n \n-            return response;\n-        } catch (Exception e) {\n-            throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n-        }\n+        return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 6fd1c521f7..533a69c1fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,23 +86,21 @@ public class SecretManagementEndpoint {\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n+    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n \n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n \n-        StoreSecretsResponse response = new StoreSecretsResponse();\n+        final StoreSecretResponse response = new StoreSecretResponse();\n \n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n \n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+        try {\n+            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n+        } catch(final IOException ioe) {\n+            //TODO process/rethrow exception\n         }\n \n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n         response.setResult(OsgpResultType.OK);\n \n         log.trace(response.toString());\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 533a69c1fd..b2d3841c1d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -55,56 +59,60 @@ public class SecretManagementEndpoint {\n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n             log.debug(this.getSecretsRequestToString(request));\n         }\n-\n         final GetSecretsResponse response = new GetSecretsResponse();\n-\n         final SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n         if (soapSecretTypes == null) {\n             throw new TechnicalException(\"Missing input: secret types\");\n         }\n-\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n         final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n         final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n-\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        final StoreSecretResponse response = new StoreSecretResponse();\n-\n-        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n-\n-        try {\n-            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n-        } catch(final IOException ioe) {\n-            //TODO process/rethrow exception\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        if (soapTypedSecrets == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n+                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex b2d3841c1d..516b919866 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -112,6 +112,7 @@ public class SecretManagementEndpoint {\n                 t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n         this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n         return response;\n     }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 516b919866..63f7ec46d2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -108,9 +107,8 @@ public class SecretManagementEndpoint {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n-                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n         response.setResult(OsgpResultType.OK);\n         response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n", "next_change": {"commit": "fbdb92d61e267dcd963e7490941e8b628efeb594", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 63f7ec46d2..9285957e4a 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -115,10 +139,10 @@ public class SecretManagementEndpoint {\n         return response;\n     }\n \n-    private String getSecretsRequestToString(final GetSecretsRequest request) {\n+    private <T> String requestToString(final T request) {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            final JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n             final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 9285957e4a..e78b2429cf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -147,7 +155,8 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\", e);\n+            String logFormat = \"Could not serialize request of type %s\";\n+            log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n     }\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e78b2429cf..4b8396680c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -155,7 +150,7 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            String logFormat = \"Could not serialize request of type %s\";\n+            final String logFormat = \"Could not serialize request of type %s\";\n             log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 4b8396680c..991145a3a5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -45,153 +43,166 @@ import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI =\n-            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n-    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n-    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+  private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+  private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n-    private final SecretManagementService secretManagementService;\n-    private final SoapEndpointDataTypeConverter converter;\n+  private final SecretManagementService secretManagementService;\n+  private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n-            final SoapEndpointDataTypeConverter converter) {\n-        this.secretManagementService = secretManagementService;\n-        this.converter = converter;\n-    }\n+  public SecretManagementEndpoint(\n+      final SecretManagementService secretManagementService,\n+      final SoapEndpointDataTypeConverter converter) {\n+    this.secretManagementService = secretManagementService;\n+    this.converter = converter;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n-    @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetSecretsResponse response = new GetSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+  @ResponsePayload\n+  public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final GetSecretsResponse response = new GetSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n-    @ResponsePayload\n-    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+  @ResponsePayload\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      @RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveNewSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n-    @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final StoreSecretsResponse response = new StoreSecretsResponse();\n-        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n-        }\n-        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+  @ResponsePayload\n+  public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'storeSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final StoreSecretsResponse response = new StoreSecretsResponse();\n+    final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n+    }\n+    final List<TypedSecret> typedSecretList =\n+        this.converter.convertToTypedSecrets(soapTypedSecrets);\n+    this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n-    @ResponsePayload\n-    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n-            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n-                request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        response.setResult(OsgpResultType.OK);\n-        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+  @ResponsePayload\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+      @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecretList =\n+        this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(), secretTypeList);\n+    response.setResult(OsgpResultType.OK);\n+    response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+    return response;\n+  }\n \n-    private <T> String requestToString(final T request) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try {\n-            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n-            final Marshaller marshaller = ctx.createMarshaller();\n-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-            marshaller.marshal(request, baos);\n-        } catch (final JAXBException e) {\n-            final String logFormat = \"Could not serialize request of type %s\";\n-            log.error(String.format(logFormat,request.getClass()), e);\n-        }\n-        return baos.toString();\n+  private <T> String requestToString(final T request) {\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    try {\n+      final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+      final Marshaller marshaller = ctx.createMarshaller();\n+      marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+      marshaller.marshal(request, baos);\n+    } catch (final JAXBException e) {\n+      final String logFormat = \"Could not serialize request of type %s\";\n+      log.error(String.format(logFormat, request.getClass()), e);\n     }\n+    return baos.toString();\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n-    @ResponsePayload\n-    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        try {\n-            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n-                    this.converter.convertToSecretTypes(soapSecretTypes));\n-            response.setResult(OsgpResultType.OK);\n-        } catch (final RuntimeException rte) {\n-            log.error(\"Could not activate new secrets: \"+rte.toString());\n-            throw new TechnicalException(\"Could not activate new secrets\",rte);\n-        }\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+  @ResponsePayload\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    try {\n+      this.secretManagementService.activateNewSecrets(\n+          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n+      response.setResult(OsgpResultType.OK);\n+    } catch (final RuntimeException rte) {\n+      log.error(\"Could not activate new secrets: \" + rte.toString());\n+      throw new TechnicalException(\"Could not activate new secrets\", rte);\n     }\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n-    @ResponsePayload\n-    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final HasNewSecretResponse response = new HasNewSecretResponse();\n-        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-        response.setHasNewSecret(result);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+  @ResponsePayload\n+  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final HasNewSecretResponse response = new HasNewSecretResponse();\n+    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+    response.setHasNewSecret(result);\n+    return response;\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 991145a3a5..a710cf5252 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -166,43 +250,46 @@ public class SecretManagementEndpoint {\n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n   @ResponsePayload\n   public ActivateSecretsResponse activateSecretsRequest(\n-      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n-    }\n-    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-    final SecretTypes soapSecretTypes = request.getSecretTypes();\n-    if (soapSecretTypes == null) {\n-      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-    }\n-    try {\n-      this.secretManagementService.activateNewSecrets(\n-          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n-      response.setResult(OsgpResultType.OK);\n-    } catch (final RuntimeException rte) {\n-      log.error(\"Could not activate new secrets: \" + rte.toString());\n-      throw new TechnicalException(\"Could not activate new secrets\", rte);\n-    }\n-    return response;\n+      @RequestPayload final ActivateSecretsRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::activateSecrets,\n+        header,\n+        messageContext,\n+        this.nameList(request.getSecretTypes()));\n   }\n \n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n   @ResponsePayload\n-  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-      throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      @RequestPayload final HasNewSecretRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::hasNewSecret,\n+        header,\n+        messageContext,\n+        Arrays.asList(request.getSecretType().name()));\n+  }\n+\n+  private List<String> nameList(final SecretTypes secretTypes) {\n+    if (secretTypes == null) {\n+      return Collections.emptyList();\n     }\n-    final HasNewSecretResponse response = new HasNewSecretResponse();\n-    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-    response.setHasNewSecret(result);\n-    return response;\n+    return secretTypes.getSecretType().stream().map(st -> st.name()).collect(Collectors.toList());\n+  }\n+\n+  private List<String> nameList(final TypedSecrets typedSecrets) {\n+    if (typedSecrets == null) {\n+      return Collections.emptyList();\n+    }\n+    return typedSecrets.getTypedSecret().stream()\n+        .map(ts -> ts.getType().name())\n+        .collect(Collectors.toList());\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyMTIxOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450821218", "body": "why is this class prepended with Db (I understand why, but it is not standard to the rest of the app).\r\n\r\nConsider changing to EncryptionKeyReference, then you also do not need the name attribute of @Table", "bodyText": "why is this class prepended with Db (I understand why, but it is not standard to the rest of the app).\nConsider changing to EncryptionKeyReference, then you also do not need the name attribute of @table", "bodyHTML": "<p dir=\"auto\">why is this class prepended with Db (I understand why, but it is not standard to the rest of the app).</p>\n<p dir=\"auto\">Consider changing to EncryptionKeyReference, then you also do not need the name attribute of <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/table/hovercard\" href=\"https://github.com/table\">@table</a></p>", "author": "coendamen", "createdAt": "2020-07-07T12:19:30Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+import java.util.Date;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+@Entity\n+@Table(name = \"encryption_key_reference\")\n+@Getter\n+@Setter\n+public class DbEncryptionKeyReference {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\nindex 9fe4dff042..ace84bf792 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n", "chunk": "@@ -32,14 +32,14 @@ public class DbEncryptionKeyReference {\n     @SequenceGenerator(name = \"encryption_key_seq_gen\", sequenceName = \"encryption_key_reference_id_seq\",\n             allocationSize = 1)\n     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n-    Long id;\n-    Date creationTime;\n-    Date modificationTime;\n-    Long version; //for optimistic locking\n+    private Long id;\n+    private Date creationTime;\n+    private Date modificationTime;\n+    private Long version; //for optimistic locking\n     @Enumerated(EnumType.STRING)\n-    EncryptionProviderType encryptionProviderType;\n-    String reference;\n-    Date validFrom;\n-    Date validTo;\n-    String modifiedBy;\n+    private EncryptionProviderType encryptionProviderType;\n+    private String reference;\n+    private Date validFrom;\n+    private Date validTo;\n+    private String modifiedBy;\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\nindex ace84bf792..57dbcf8273 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n", "chunk": "@@ -28,18 +26,23 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n @Getter\n @Setter\n public class DbEncryptionKeyReference {\n-    @Id\n-    @SequenceGenerator(name = \"encryption_key_seq_gen\", sequenceName = \"encryption_key_reference_id_seq\",\n-            allocationSize = 1)\n-    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n-    private Long id;\n-    private Date creationTime;\n-    private Date modificationTime;\n-    private Long version; //for optimistic locking\n-    @Enumerated(EnumType.STRING)\n-    private EncryptionProviderType encryptionProviderType;\n-    private String reference;\n-    private Date validFrom;\n-    private Date validTo;\n-    private String modifiedBy;\n+  @Id\n+  @SequenceGenerator(\n+      name = \"encryption_key_seq_gen\",\n+      sequenceName = \"encryption_key_reference_id_seq\",\n+      allocationSize = 1)\n+  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n+  private Long id;\n+\n+  private Date creationTime;\n+  private Date modificationTime;\n+  private Long version; // for optimistic locking\n+\n+  @Enumerated(EnumType.STRING)\n+  private EncryptionProviderType encryptionProviderType;\n+\n+  private String reference;\n+  private Date validFrom;\n+  private Date validTo;\n+  private String modifiedBy;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyMTc3NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450821774", "body": "remove the Db and name attributes from the annotation", "bodyText": "remove the Db and name attributes from the annotation", "bodyHTML": "<p dir=\"auto\">remove the Db and name attributes from the annotation</p>", "author": "coendamen", "createdAt": "2020-07-07T12:20:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+import java.util.Date;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+/**\n+ * Encrypted secret, which should not be mutated, because modifications should result in a new version (record in the\n+ * DB). Historic entries remain in the DB table and the current secret should be determined via a query on creationTime.\n+ */\n+@Entity\n+@Table(name = \"encrypted_secret\")\n+@Getter\n+@Setter\n+public class DbEncryptedSecret {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\nindex 6cb8e5873d..489e2459d7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n", "chunk": "@@ -35,12 +35,12 @@ public class DbEncryptedSecret {\n     @Id\n     @SequenceGenerator(name = \"encrypted_secret_seq_gen\", sequenceName = \"encrypted_secret_id_seq\", allocationSize = 1)\n     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n-    Long id;\n-    Date creationTime;\n-    String deviceIdentification;\n+    private Long id;\n+    private Date creationTime;\n+    private String deviceIdentification;\n     @Enumerated(EnumType.STRING)\n-    SecretType secretType;\n-    String encodedSecret;\n+    private SecretType secretType;\n+    private String encodedSecret;\n     @ManyToOne\n-    DbEncryptionKeyReference encryptionKeyReference;\n+    private DbEncryptionKeyReference encryptionKeyReference;\n }\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\nindex 489e2459d7..412147da79 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n", "chunk": "@@ -40,6 +40,8 @@ public class DbEncryptedSecret {\n     private String deviceIdentification;\n     @Enumerated(EnumType.STRING)\n     private SecretType secretType;\n+    @Enumerated(EnumType.STRING)\n+    private SecretStatus secretStatus;\n     private String encodedSecret;\n     @ManyToOne\n     private DbEncryptionKeyReference encryptionKeyReference;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\nindex 412147da79..48eea2b36c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n", "chunk": "@@ -19,30 +18,36 @@ import javax.persistence.Id;\n import javax.persistence.ManyToOne;\n import javax.persistence.SequenceGenerator;\n import javax.persistence.Table;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n /**\n- * Encrypted secret, which should not be mutated, because modifications should result in a new version (record in the\n- * DB). Historic entries remain in the DB table and the current secret should be determined via a query on creationTime.\n+ * Encrypted secret, which should not be mutated, because modifications should result in a new\n+ * version (record in the DB). Historic entries remain in the DB table and the current secret should\n+ * be determined via a query on creationTime.\n  */\n @Entity\n @Table(name = \"encrypted_secret\")\n @Getter\n @Setter\n public class DbEncryptedSecret {\n-    @Id\n-    @SequenceGenerator(name = \"encrypted_secret_seq_gen\", sequenceName = \"encrypted_secret_id_seq\", allocationSize = 1)\n-    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n-    private Long id;\n-    private Date creationTime;\n-    private String deviceIdentification;\n-    @Enumerated(EnumType.STRING)\n-    private SecretType secretType;\n-    @Enumerated(EnumType.STRING)\n-    private SecretStatus secretStatus;\n-    private String encodedSecret;\n-    @ManyToOne\n-    private DbEncryptionKeyReference encryptionKeyReference;\n+  @Id\n+  @SequenceGenerator(\n+      name = \"encrypted_secret_seq_gen\",\n+      sequenceName = \"encrypted_secret_id_seq\",\n+      allocationSize = 1)\n+  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n+  private Long id;\n+\n+  private Date creationTime;\n+  private String deviceIdentification;\n+\n+  @Enumerated(EnumType.STRING)\n+  private SecretType secretType;\n+\n+  @Enumerated(EnumType.STRING)\n+  private SecretStatus secretStatus;\n+\n+  private String encodedSecret;\n+  @ManyToOne private DbEncryptionKeyReference encryptionKeyReference;\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyMzIyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450823228", "body": "is this possible? for RSA you need both the public key and the private key, They should never be able to be null.\r\n\r\nI would rewrite this to fail the deployment / startup when any of the keys is null. Or not create this Provider at all if the provider can be absent", "bodyText": "is this possible? for RSA you need both the public key and the private key, They should never be able to be null.\nI would rewrite this to fail the deployment / startup when any of the keys is null. Or not create this Provider at all if the provider can be absent", "bodyHTML": "<p dir=\"auto\">is this possible? for RSA you need both the public key and the private key, They should never be able to be null.</p>\n<p dir=\"auto\">I would rewrite this to fail the deployment / startup when any of the keys is null. Or not create this Provider at all if the provider can be absent</p>", "author": "coendamen", "createdAt": "2020-07-07T12:23:21Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.config;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.opensmartgridplatform.shared.security.DefaultEncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.providers.EncryptionProvider;\n+import org.opensmartgridplatform.shared.security.providers.HsmEncryptionProvider;\n+import org.opensmartgridplatform.shared.security.providers.JreEncryptionProvider;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.Resource;\n+\n+@Configuration\n+public class SecurityConfig {\n+\n+    @Value(\"${soap.public.key.resource:#{null}}\")\n+    private Optional<Resource> soapPublicKeyResource;\n+\n+    @Value(\"${soap.private.key.resource:#{null}}\")\n+    private Optional<Resource> soapPrivateKeyResource;\n+\n+    @Value(\"${database.secret.resource}\")\n+    private Resource databaseSecretResource;\n+\n+    @Value(\"${hsm.keystore.resource:#{null}}\")\n+    private Optional<Resource> hsmKeystoreResource;\n+\n+    @Value(\"${encryption.provider.type}\")\n+    private String encryptionProviderTypeName;\n+\n+    @Bean(\"DefaultEncryptionDelegate\")\n+    public DefaultEncryptionDelegate getEncryptionDelegate() {\n+        return new DefaultEncryptionDelegate(getDefaultEncryptionProviders());\n+    }\n+\n+    private EncryptionProvider[] getDefaultEncryptionProviders() {\n+\n+        List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n+\n+        try {\n+            JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n+                    this.databaseSecretResource.getFile());\n+\n+            encryptionProviderList.add(jreEncryptionProvider);\n+\n+            File privateKeyStoreFile = this.soapPrivateKeyResource.isPresent() ?\n+                    this.soapPrivateKeyResource.get().getFile() : null;\n+            File publicKeyStoreFile = this.soapPublicKeyResource.isPresent() ?\n+                    this.soapPublicKeyResource.get().getFile() : null;\n+\n+            RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider(privateKeyStoreFile,", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\nindex c50ecb4ced..4fa93eac61 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n", "chunk": "@@ -48,23 +49,36 @@ public class SecurityConfig {\n         return new DefaultEncryptionDelegate(getDefaultEncryptionProviders());\n     }\n \n-    private EncryptionProvider[] getDefaultEncryptionProviders() {\n+    @Bean\n+    public List<EncryptionProvider> getDefaultEncryptionProviders() {\n \n         List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n \n         try {\n             JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n-                    this.databaseSecretResource.getFile());\n+                    this.jreEncryptionKeyResource.getFile());\n \n             encryptionProviderList.add(jreEncryptionProvider);\n \n-            File privateKeyStoreFile = this.soapPrivateKeyResource.isPresent() ?\n-                    this.soapPrivateKeyResource.get().getFile() : null;\n-            File publicKeyStoreFile = this.soapPublicKeyResource.isPresent() ?\n-                    this.soapPublicKeyResource.get().getFile() : null;\n-\n-            RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider(privateKeyStoreFile,\n-                    publicKeyStoreFile);\n+            RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider();\n+\n+            this.soapPrivateKeyResource.ifPresent((res)-> {\n+                try {\n+                    rsaEncryptionProvider.setPrivateKeyStore(res.getFile());\n+                }\n+                catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {\n+                    throw new IllegalStateException(\"Could not load private key resource.\", e);\n+                }\n+            });\n+\n+            this.soapPublicKeyResource.ifPresent((res)-> {\n+                try {\n+                    rsaEncryptionProvider.setPublicKeyStore(res.getFile());\n+                }\n+                catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {\n+                    throw new IllegalStateException(\"Could not load public key resource.\", e);\n+                }\n+            });\n \n             encryptionProviderList.add(rsaEncryptionProvider);\n \n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\nindex 4fa93eac61..378c8c5a54 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n", "chunk": "@@ -75,7 +75,7 @@ public class SecurityConfig {\n                 try {\n                     rsaEncryptionProvider.setPublicKeyStore(res.getFile());\n                 }\n-                catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {\n+                catch (IOException e) {\n                     throw new IllegalStateException(\"Could not load public key resource.\", e);\n                 }\n             });\n", "next_change": {"commit": "fb6248e8bf029e15394e1e0fa0cbc2968af22e33", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\nindex 378c8c5a54..2e32893f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n", "chunk": "@@ -62,16 +60,16 @@ public class SecurityConfig {\n \n             RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider();\n \n-            this.soapPrivateKeyResource.ifPresent((res)-> {\n+            this.soapPrivateKeyResource.ifPresent(res-> {\n                 try {\n                     rsaEncryptionProvider.setPrivateKeyStore(res.getFile());\n                 }\n-                catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {\n+                catch (IOException e) {\n                     throw new IllegalStateException(\"Could not load private key resource.\", e);\n                 }\n             });\n \n-            this.soapPublicKeyResource.ifPresent((res)-> {\n+            this.soapPublicKeyResource.ifPresent(res-> {\n                 try {\n                     rsaEncryptionProvider.setPublicKeyStore(res.getFile());\n                 }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\nindex 2e32893f87..fbd5932b3f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n", "chunk": "@@ -44,42 +45,17 @@ public class SecurityConfig {\n \n     @Bean(\"DefaultEncryptionDelegate\")\n     public DefaultEncryptionDelegate getEncryptionDelegate() {\n-        return new DefaultEncryptionDelegate(getDefaultEncryptionProviders());\n+        return new DefaultEncryptionDelegate(this.getDefaultEncryptionProviders());\n     }\n \n-    @Bean\n-    public List<EncryptionProvider> getDefaultEncryptionProviders() {\n-\n+    private List<EncryptionProvider> getDefaultEncryptionProviders() {\n         List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n \n         try {\n             JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n                     this.jreEncryptionKeyResource.getFile());\n-\n             encryptionProviderList.add(jreEncryptionProvider);\n \n-            RsaEncryptionProvider rsaEncryptionProvider = new RsaEncryptionProvider();\n-\n-            this.soapPrivateKeyResource.ifPresent(res-> {\n-                try {\n-                    rsaEncryptionProvider.setPrivateKeyStore(res.getFile());\n-                }\n-                catch (IOException e) {\n-                    throw new IllegalStateException(\"Could not load private key resource.\", e);\n-                }\n-            });\n-\n-            this.soapPublicKeyResource.ifPresent(res-> {\n-                try {\n-                    rsaEncryptionProvider.setPublicKeyStore(res.getFile());\n-                }\n-                catch (IOException e) {\n-                    throw new IllegalStateException(\"Could not load public key resource.\", e);\n-                }\n-            });\n-\n-            encryptionProviderList.add(rsaEncryptionProvider);\n-\n             if (this.hsmKeystoreResource.isPresent()) {\n                 HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider(\n                         this.hsmKeystoreResource.get().getFile());\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\nindex fbd5932b3f..2aefa31992 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n", "chunk": "@@ -49,10 +49,10 @@ public class SecurityConfig {\n     }\n \n     private List<EncryptionProvider> getDefaultEncryptionProviders() {\n-        List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n+        final List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n \n         try {\n-            JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n+            final JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n                     this.jreEncryptionKeyResource.getFile());\n             encryptionProviderList.add(jreEncryptionProvider);\n \n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\nindex 2aefa31992..47c2fac3c8 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecurityConfig.java\n", "chunk": "@@ -28,64 +27,64 @@ import org.springframework.core.io.Resource;\n @Configuration\n public class SecurityConfig {\n \n-    @Value(\"${soap.public.key.resource:#{null}}\")\n-    private Optional<Resource> soapPublicKeyResource;\n+  @Value(\"${soap.public.key.resource:#{null}}\")\n+  private Optional<Resource> soapPublicKeyResource;\n \n-    @Value(\"${soap.private.key.resource:#{null}}\")\n-    private Optional<Resource> soapPrivateKeyResource;\n+  @Value(\"${soap.private.key.resource:#{null}}\")\n+  private Optional<Resource> soapPrivateKeyResource;\n \n-    @Value(\"${jre.encryption.key.resource}\")\n-    private Resource jreEncryptionKeyResource;\n+  @Value(\"${jre.encryption.key.resource}\")\n+  private Resource jreEncryptionKeyResource;\n \n-    @Value(\"${hsm.keystore.resource:#{null}}\")\n-    private Optional<Resource> hsmKeystoreResource;\n+  @Value(\"${hsm.keystore.resource:#{null}}\")\n+  private Optional<Resource> hsmKeystoreResource;\n \n-    @Value(\"${encryption.provider.type}\")\n-    private String encryptionProviderTypeName;\n+  @Value(\"${encryption.provider.type}\")\n+  private String encryptionProviderTypeName;\n \n-    @Bean(\"DefaultEncryptionDelegate\")\n-    public DefaultEncryptionDelegate getEncryptionDelegate() {\n-        return new DefaultEncryptionDelegate(this.getDefaultEncryptionProviders());\n-    }\n+  @Bean(\"DefaultEncryptionDelegate\")\n+  public DefaultEncryptionDelegate getEncryptionDelegate() {\n+    return new DefaultEncryptionDelegate(this.getDefaultEncryptionProviders());\n+  }\n \n-    private List<EncryptionProvider> getDefaultEncryptionProviders() {\n-        final List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n+  private List<EncryptionProvider> getDefaultEncryptionProviders() {\n+    final List<EncryptionProvider> encryptionProviderList = new ArrayList<>();\n \n-        try {\n-            final JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider(\n-                    this.jreEncryptionKeyResource.getFile());\n-            encryptionProviderList.add(jreEncryptionProvider);\n+    try {\n+      final JreEncryptionProvider jreEncryptionProvider =\n+          new JreEncryptionProvider(this.jreEncryptionKeyResource.getFile());\n+      encryptionProviderList.add(jreEncryptionProvider);\n \n-            if (this.hsmKeystoreResource.isPresent()) {\n-                HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider(\n-                        this.hsmKeystoreResource.get().getFile());\n-                encryptionProviderList.add(hsmEncryptionProvider);\n-            }\n+      if (this.hsmKeystoreResource.isPresent()) {\n+        final HsmEncryptionProvider hsmEncryptionProvider =\n+            new HsmEncryptionProvider(this.hsmKeystoreResource.get().getFile());\n+        encryptionProviderList.add(hsmEncryptionProvider);\n+      }\n \n-            return encryptionProviderList;\n-        } catch (IOException | EncrypterException e) {\n-            throw new IllegalStateException(\"Error creating default encryption providers\", e);\n-        }\n+      return encryptionProviderList;\n+    } catch (IOException | EncrypterException e) {\n+      throw new IllegalStateException(\"Error creating default encryption providers\", e);\n     }\n+  }\n \n-    @Bean\n-    public RsaEncrypter getSoapEncrypter() {\n-        try {\n-            final RsaEncrypter rsaEncryptionProvider = new RsaEncrypter();\n-            if (this.soapPrivateKeyResource.isPresent()) {\n-                rsaEncryptionProvider.setPrivateKeyStore(this.soapPrivateKeyResource.get().getFile());\n-            }\n-            if (this.soapPublicKeyResource.isPresent()) {\n-                rsaEncryptionProvider.setPublicKeyStore(this.soapPublicKeyResource.get().getFile());\n-            }\n-            return rsaEncryptionProvider;\n-        } catch (IOException | EncrypterException e) {\n-            throw new IllegalStateException(\"Error creating default encryption providers\", e);\n-        }\n+  @Bean\n+  public RsaEncrypter getSoapEncrypter() {\n+    try {\n+      final RsaEncrypter rsaEncryptionProvider = new RsaEncrypter();\n+      if (this.soapPrivateKeyResource.isPresent()) {\n+        rsaEncryptionProvider.setPrivateKeyStore(this.soapPrivateKeyResource.get().getFile());\n+      }\n+      if (this.soapPublicKeyResource.isPresent()) {\n+        rsaEncryptionProvider.setPublicKeyStore(this.soapPublicKeyResource.get().getFile());\n+      }\n+      return rsaEncryptionProvider;\n+    } catch (IOException | EncrypterException e) {\n+      throw new IllegalStateException(\"Error creating default encryption providers\", e);\n     }\n+  }\n \n-    @Bean\n-    public EncryptionProviderType getEncryptionProviderType() {\n-        return EncryptionProviderType.valueOf(this.encryptionProviderTypeName);\n-    }\n-}\n\\ No newline at end of file\n+  @Bean\n+  public EncryptionProviderType getEncryptionProviderType() {\n+    return EncryptionProviderType.valueOf(this.encryptionProviderTypeName);\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyNTYyMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450825621", "body": "can you explain why is this class needed? either the logback.xml from the classpath is loaded or one is provided via the context.xml.\r\n\r\nIs there a reason we use JDNI here? is the log file neede by JMX ?\r\n\r\n", "bodyText": "can you explain why is this class needed? either the logback.xml from the classpath is loaded or one is provided via the context.xml.\nIs there a reason we use JDNI here? is the log file neede by JMX ?", "bodyHTML": "<p dir=\"auto\">can you explain why is this class needed? either the logback.xml from the classpath is loaded or one is provided via the context.xml.</p>\n<p dir=\"auto\">Is there a reason we use JDNI here? is the log file neede by JMX ?</p>", "author": "coendamen", "createdAt": "2020-07-07T12:27:43Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/SecretManagementInitializer.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.config;\n+\n+import ch.qos.logback.core.joran.spi.JoranException;\n+import ch.qos.logback.ext.spring.LogbackConfigurer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.web.WebApplicationInitializer;\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+\n+public class SecretManagementInitializer implements WebApplicationInitializer {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyNjA5Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450826093", "body": "this is a constant, is there a reason why it is a Spring @Value ?", "bodyText": "this is a constant, is there a reason why it is a Spring @value ?", "bodyHTML": "<p dir=\"auto\">this is a constant, is there a reason why it is a Spring <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/value/hovercard\" href=\"https://github.com/value\">@value</a> ?</p>", "author": "coendamen", "createdAt": "2020-07-07T12:28:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/ApplicationConfig.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n+\n+@Configuration\n+@PropertySource(\"classpath:osgp-secret-management.properties\")\n+@PropertySource(value = \"file:${osgp/Global/config}\", ignoreResourceNotFound = true)\n+@PropertySource(value = \"file:${osgp/SecretManagement/config}\", ignoreResourceNotFound = true)\n+public class ApplicationConfig {\n+    @Value(\"${component.name}\")", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMDM2MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450830360", "body": "Global variables", "bodyText": "Global variables", "bodyHTML": "<p dir=\"auto\">Global variables</p>", "author": "jboon", "createdAt": "2020-07-07T12:36:24Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.config;\n+\n+import org.opensmartgridplatform.secretmanagement.application.exception.DetailSoapFaultMappingExceptionResolver;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.springframework.boot.web.servlet.ServletRegistrationBean;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.ws.config.annotation.EnableWs;\n+import org.springframework.ws.config.annotation.WsConfigurerAdapter;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultDefinition;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+import org.springframework.ws.transport.http.MessageDispatcherServlet;\n+import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;\n+import org.springframework.xml.xsd.XsdSchemaCollection;\n+import org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection;\n+\n+import java.util.Properties;\n+\n+@EnableWs\n+@Configuration\n+public class WebServiceConfig extends WsConfigurerAdapter {\n+\n+    public static final String SECRET_MANAGEMENT_WS_BASE_PATH = \"/ws/SecretManagement/*\";\n+    public static final String SECRET_MANAGEMENT_PORT = \"SecretManagementPort\";\n+    public static final String SECRET_MANAGEMENT_URI = \"/ws/SecretManagement\";\n+    public static final String SECRET_MANAGEMENT_NS = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement/2020/05\";\n+    public static final String SECRET_MANAGEMENT_SCHEMA_LOC = \"schemas/secret-management.xsd\";", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\nindex 40c1761c49..f1f05fc7a3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\n", "chunk": "@@ -30,12 +30,12 @@ import java.util.Properties;\n @Configuration\n public class WebServiceConfig extends WsConfigurerAdapter {\n \n-    public static final String SECRET_MANAGEMENT_WS_BASE_PATH = \"/ws/SecretManagement/*\";\n-    public static final String SECRET_MANAGEMENT_PORT = \"SecretManagementPort\";\n-    public static final String SECRET_MANAGEMENT_URI = \"/ws/SecretManagement\";\n-    public static final String SECRET_MANAGEMENT_NS = \"http://www.opensmartgridplatform\"\n+    private static final String SECRET_MANAGEMENT_WS_BASE_PATH = \"/ws/SecretManagement/*\";\n+    private static final String SECRET_MANAGEMENT_PORT = \"SecretManagementPort\";\n+    private static final String SECRET_MANAGEMENT_URI = \"/ws/SecretManagement\";\n+    private static final String SECRET_MANAGEMENT_NS = \"http://www.opensmartgridplatform\"\n             + \".org/schemas/security/secretmanagement/2020/05\";\n-    public static final String SECRET_MANAGEMENT_SCHEMA_LOC = \"schemas/secret-management.xsd\";\n+    private static final String SECRET_MANAGEMENT_SCHEMA_LOC = \"schemas/secret-management.xsd\";\n \n     @Bean\n     public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\nindex f1f05fc7a3..6a3da653f2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\n", "chunk": "@@ -34,7 +34,7 @@ public class WebServiceConfig extends WsConfigurerAdapter {\n     private static final String SECRET_MANAGEMENT_PORT = \"SecretManagementPort\";\n     private static final String SECRET_MANAGEMENT_URI = \"/ws/SecretManagement\";\n     private static final String SECRET_MANAGEMENT_NS = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement/2020/05\";\n+            + \".org/schemas/security/secretmanagement\";\n     private static final String SECRET_MANAGEMENT_SCHEMA_LOC = \"schemas/secret-management.xsd\";\n \n     @Bean\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\nindex 6a3da653f2..9977a5bbda 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/WebServiceConfig.java\n", "chunk": "@@ -24,65 +25,65 @@ import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;\n import org.springframework.xml.xsd.XsdSchemaCollection;\n import org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection;\n \n-import java.util.Properties;\n-\n @EnableWs\n @Configuration\n public class WebServiceConfig extends WsConfigurerAdapter {\n \n-    private static final String SECRET_MANAGEMENT_WS_BASE_PATH = \"/ws/SecretManagement/*\";\n-    private static final String SECRET_MANAGEMENT_PORT = \"SecretManagementPort\";\n-    private static final String SECRET_MANAGEMENT_URI = \"/ws/SecretManagement\";\n-    private static final String SECRET_MANAGEMENT_NS = \"http://www.opensmartgridplatform\"\n-            + \".org/schemas/security/secretmanagement\";\n-    private static final String SECRET_MANAGEMENT_SCHEMA_LOC = \"schemas/secret-management.xsd\";\n+  private static final String SECRET_MANAGEMENT_WS_BASE_PATH = \"/ws/SecretManagement/*\";\n+  private static final String SECRET_MANAGEMENT_PORT = \"SecretManagementPort\";\n+  private static final String SECRET_MANAGEMENT_URI = \"/ws/SecretManagement\";\n+  private static final String SECRET_MANAGEMENT_NS =\n+      \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+  private static final String SECRET_MANAGEMENT_SCHEMA_LOC = \"schemas/secret-management.xsd\";\n \n-    @Bean\n-    public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(\n-            ApplicationContext applicationContext) {\n-        MessageDispatcherServlet servlet = new MessageDispatcherServlet();\n-        servlet.setApplicationContext(applicationContext);\n-        servlet.setTransformWsdlLocations(true);\n-        return new ServletRegistrationBean<>(servlet, SECRET_MANAGEMENT_WS_BASE_PATH);\n-    }\n+  @Bean\n+  public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(\n+      final ApplicationContext applicationContext) {\n+    final MessageDispatcherServlet servlet = new MessageDispatcherServlet();\n+    servlet.setApplicationContext(applicationContext);\n+    servlet.setTransformWsdlLocations(true);\n+    return new ServletRegistrationBean<>(servlet, SECRET_MANAGEMENT_WS_BASE_PATH);\n+  }\n \n-    /**\n-     * url of the WSDL by this definition is:\n-     *\n-     * http://localhost:8080/ws/SecretManagement/secretManagement.wsdl\n-     */\n-    @Bean(name = \"secretManagement\")\n-    public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchemaCollection secretManagementSchemas) {\n-        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();\n-        wsdl11Definition.setPortTypeName(SECRET_MANAGEMENT_PORT);\n-        wsdl11Definition.setLocationUri(SECRET_MANAGEMENT_URI);\n-        wsdl11Definition.setTargetNamespace(SECRET_MANAGEMENT_NS);\n-        wsdl11Definition.setSchemaCollection(secretManagementSchemas);\n-        return wsdl11Definition;\n-    }\n+  /**\n+   * url of the WSDL by this definition is:\n+   *\n+   * <p>http://localhost:8080/ws/SecretManagement/secretManagement.wsdl\n+   */\n+  @Bean(name = \"secretManagement\")\n+  public DefaultWsdl11Definition defaultWsdl11Definition(\n+      final XsdSchemaCollection secretManagementSchemas) {\n+    final DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();\n+    wsdl11Definition.setPortTypeName(SECRET_MANAGEMENT_PORT);\n+    wsdl11Definition.setLocationUri(SECRET_MANAGEMENT_URI);\n+    wsdl11Definition.setTargetNamespace(SECRET_MANAGEMENT_NS);\n+    wsdl11Definition.setSchemaCollection(secretManagementSchemas);\n+    return wsdl11Definition;\n+  }\n \n-    @Bean\n-    public XsdSchemaCollection secretManagementSchemas() {\n-        CommonsXsdSchemaCollection sc = new CommonsXsdSchemaCollection();\n-        sc.setXsds(new ClassPathResource(SECRET_MANAGEMENT_SCHEMA_LOC));\n-        return sc;\n-    }\n+  @Bean\n+  public XsdSchemaCollection secretManagementSchemas() {\n+    final CommonsXsdSchemaCollection sc = new CommonsXsdSchemaCollection();\n+    sc.setXsds(new ClassPathResource(SECRET_MANAGEMENT_SCHEMA_LOC));\n+    return sc;\n+  }\n \n-    @Bean\n-    public SoapFaultMappingExceptionResolver exceptionResolver() {\n-        SoapFaultMappingExceptionResolver exceptionResolver = new DetailSoapFaultMappingExceptionResolver();\n+  @Bean\n+  public SoapFaultMappingExceptionResolver exceptionResolver() {\n+    final SoapFaultMappingExceptionResolver exceptionResolver =\n+        new DetailSoapFaultMappingExceptionResolver();\n \n-        SoapFaultDefinition faultDefinition = new SoapFaultDefinition();\n-        faultDefinition.setFaultCode(SoapFaultDefinition.SERVER);\n-        exceptionResolver.setDefaultFault(faultDefinition);\n+    final SoapFaultDefinition faultDefinition = new SoapFaultDefinition();\n+    faultDefinition.setFaultCode(SoapFaultDefinition.SERVER);\n+    exceptionResolver.setDefaultFault(faultDefinition);\n \n-        Properties errorMappings = new Properties();\n-        errorMappings.setProperty(Exception.class.getName(), SoapFaultDefinition.SERVER.toString());\n-        errorMappings.setProperty(TechnicalException.class.getName(),\n-                SoapFaultDefinition.SERVER.toString());\n-        exceptionResolver.setExceptionMappings(errorMappings);\n-        exceptionResolver.setOrder(1);\n+    final Properties errorMappings = new Properties();\n+    errorMappings.setProperty(Exception.class.getName(), SoapFaultDefinition.SERVER.toString());\n+    errorMappings.setProperty(\n+        TechnicalException.class.getName(), SoapFaultDefinition.SERVER.toString());\n+    exceptionResolver.setExceptionMappings(errorMappings);\n+    exceptionResolver.setOrder(1);\n \n-        return exceptionResolver;\n-    }\n-}\n\\ No newline at end of file\n+    return exceptionResolver;\n+  }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMTI0MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450831241", "body": "Add private access modifiers", "bodyText": "Add private access modifiers", "bodyHTML": "<p dir=\"auto\">Add private access modifiers</p>", "author": "jboon", "createdAt": "2020-07-07T12:37:58Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+import java.util.Date;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+/**\n+ * Encrypted secret, which should not be mutated, because modifications should result in a new version (record in the\n+ * DB). Historic entries remain in the DB table and the current secret should be determined via a query on creationTime.\n+ */\n+@Entity\n+@Table(name = \"encrypted_secret\")\n+@Getter\n+@Setter\n+public class DbEncryptedSecret {\n+    @Id\n+    @SequenceGenerator(name = \"encrypted_secret_seq_gen\", sequenceName = \"encrypted_secret_id_seq\", allocationSize = 1)\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n+    Long id;\n+    Date creationTime;\n+    String deviceIdentification;\n+    @Enumerated(EnumType.STRING)\n+    SecretType secretType;\n+    String encodedSecret;\n+    @ManyToOne\n+    DbEncryptionKeyReference encryptionKeyReference;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\nindex 6cb8e5873d..489e2459d7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n", "chunk": "@@ -35,12 +35,12 @@ public class DbEncryptedSecret {\n     @Id\n     @SequenceGenerator(name = \"encrypted_secret_seq_gen\", sequenceName = \"encrypted_secret_id_seq\", allocationSize = 1)\n     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n-    Long id;\n-    Date creationTime;\n-    String deviceIdentification;\n+    private Long id;\n+    private Date creationTime;\n+    private String deviceIdentification;\n     @Enumerated(EnumType.STRING)\n-    SecretType secretType;\n-    String encodedSecret;\n+    private SecretType secretType;\n+    private String encodedSecret;\n     @ManyToOne\n-    DbEncryptionKeyReference encryptionKeyReference;\n+    private DbEncryptionKeyReference encryptionKeyReference;\n }\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\nindex 489e2459d7..412147da79 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n", "chunk": "@@ -40,6 +40,8 @@ public class DbEncryptedSecret {\n     private String deviceIdentification;\n     @Enumerated(EnumType.STRING)\n     private SecretType secretType;\n+    @Enumerated(EnumType.STRING)\n+    private SecretStatus secretStatus;\n     private String encodedSecret;\n     @ManyToOne\n     private DbEncryptionKeyReference encryptionKeyReference;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\nindex 412147da79..48eea2b36c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptedSecret.java\n", "chunk": "@@ -19,30 +18,36 @@ import javax.persistence.Id;\n import javax.persistence.ManyToOne;\n import javax.persistence.SequenceGenerator;\n import javax.persistence.Table;\n-\n import lombok.Getter;\n import lombok.Setter;\n \n /**\n- * Encrypted secret, which should not be mutated, because modifications should result in a new version (record in the\n- * DB). Historic entries remain in the DB table and the current secret should be determined via a query on creationTime.\n+ * Encrypted secret, which should not be mutated, because modifications should result in a new\n+ * version (record in the DB). Historic entries remain in the DB table and the current secret should\n+ * be determined via a query on creationTime.\n  */\n @Entity\n @Table(name = \"encrypted_secret\")\n @Getter\n @Setter\n public class DbEncryptedSecret {\n-    @Id\n-    @SequenceGenerator(name = \"encrypted_secret_seq_gen\", sequenceName = \"encrypted_secret_id_seq\", allocationSize = 1)\n-    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n-    private Long id;\n-    private Date creationTime;\n-    private String deviceIdentification;\n-    @Enumerated(EnumType.STRING)\n-    private SecretType secretType;\n-    @Enumerated(EnumType.STRING)\n-    private SecretStatus secretStatus;\n-    private String encodedSecret;\n-    @ManyToOne\n-    private DbEncryptionKeyReference encryptionKeyReference;\n+  @Id\n+  @SequenceGenerator(\n+      name = \"encrypted_secret_seq_gen\",\n+      sequenceName = \"encrypted_secret_id_seq\",\n+      allocationSize = 1)\n+  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encrypted_secret_seq_gen\")\n+  private Long id;\n+\n+  private Date creationTime;\n+  private String deviceIdentification;\n+\n+  @Enumerated(EnumType.STRING)\n+  private SecretType secretType;\n+\n+  @Enumerated(EnumType.STRING)\n+  private SecretStatus secretStatus;\n+\n+  private String encodedSecret;\n+  @ManyToOne private DbEncryptionKeyReference encryptionKeyReference;\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMTU4Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450831586", "body": "Add private access modifiers", "bodyText": "Add private access modifiers", "bodyHTML": "<p dir=\"auto\">Add private access modifiers</p>", "author": "jboon", "createdAt": "2020-07-07T12:38:35Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+import java.util.Date;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+@Entity\n+@Table(name = \"encryption_key_reference\")\n+@Getter\n+@Setter\n+public class DbEncryptionKeyReference {\n+    @Id\n+    @SequenceGenerator(name = \"encryption_key_seq_gen\", sequenceName = \"encryption_key_reference_id_seq\",\n+            allocationSize = 1)\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n+    Long id;\n+    Date creationTime;\n+    Date modificationTime;\n+    Long version; //for optimistic locking\n+    @Enumerated(EnumType.STRING)\n+    EncryptionProviderType encryptionProviderType;\n+    String reference;\n+    Date validFrom;\n+    Date validTo;\n+    String modifiedBy;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\nindex 9fe4dff042..ace84bf792 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n", "chunk": "@@ -32,14 +32,14 @@ public class DbEncryptionKeyReference {\n     @SequenceGenerator(name = \"encryption_key_seq_gen\", sequenceName = \"encryption_key_reference_id_seq\",\n             allocationSize = 1)\n     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n-    Long id;\n-    Date creationTime;\n-    Date modificationTime;\n-    Long version; //for optimistic locking\n+    private Long id;\n+    private Date creationTime;\n+    private Date modificationTime;\n+    private Long version; //for optimistic locking\n     @Enumerated(EnumType.STRING)\n-    EncryptionProviderType encryptionProviderType;\n-    String reference;\n-    Date validFrom;\n-    Date validTo;\n-    String modifiedBy;\n+    private EncryptionProviderType encryptionProviderType;\n+    private String reference;\n+    private Date validFrom;\n+    private Date validTo;\n+    private String modifiedBy;\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\nindex ace84bf792..57dbcf8273 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/DbEncryptionKeyReference.java\n", "chunk": "@@ -28,18 +26,23 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n @Getter\n @Setter\n public class DbEncryptionKeyReference {\n-    @Id\n-    @SequenceGenerator(name = \"encryption_key_seq_gen\", sequenceName = \"encryption_key_reference_id_seq\",\n-            allocationSize = 1)\n-    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n-    private Long id;\n-    private Date creationTime;\n-    private Date modificationTime;\n-    private Long version; //for optimistic locking\n-    @Enumerated(EnumType.STRING)\n-    private EncryptionProviderType encryptionProviderType;\n-    private String reference;\n-    private Date validFrom;\n-    private Date validTo;\n-    private String modifiedBy;\n+  @Id\n+  @SequenceGenerator(\n+      name = \"encryption_key_seq_gen\",\n+      sequenceName = \"encryption_key_reference_id_seq\",\n+      allocationSize = 1)\n+  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"encryption_key_seq_gen\")\n+  private Long id;\n+\n+  private Date creationTime;\n+  private Date modificationTime;\n+  private Long version; // for optimistic locking\n+\n+  @Enumerated(EnumType.STRING)\n+  private EncryptionProviderType encryptionProviderType;\n+\n+  private String reference;\n+  private Date validFrom;\n+  private Date validTo;\n+  private String modifiedBy;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMTgxNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450831815", "body": "Add private access modifiers", "bodyText": "Add private access modifiers", "bodyHTML": "<p dir=\"auto\">Add private access modifiers</p>", "author": "jboon", "createdAt": "2020-07-07T12:39:00Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+/**\n+ * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n+ */\n+public class TypedSecret {\n+    SecretType secretType;\n+    String secret;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 73dbb615c6..1fe3bcb6c3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -12,22 +12,22 @@ package org.opensmartgridplatform.secretmanagement.application.domain;\n  * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n  */\n public class TypedSecret {\n-    SecretType secretType;\n-    String secret;\n+    private SecretType secretType;\n+    private String secret;\n \n     public String getSecret() {\n-        return secret;\n+        return this.secret;\n     }\n \n     public SecretType getSecretType() {\n-        return secretType;\n+        return this.secretType;\n     }\n \n-    public void setSecret(String secret) {\n+    public void setSecret(final String secret) {\n         this.secret = secret;\n     }\n \n-    public void setSecretType(SecretType secretType) {\n+    public void setSecretType(final SecretType secretType) {\n         this.secretType = secretType;\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 1fe3bcb6c3..4c2f14eba6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -8,29 +8,20 @@\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n+import lombok.Getter;\n+\n /**\n  * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n  */\n+@Getter\n public class TypedSecret {\n-    private SecretType secretType;\n-    private String secret;\n-\n-    public String getSecret() {\n-        return this.secret;\n-    }\n-\n-    public SecretType getSecretType() {\n-        return this.secretType;\n-    }\n+    private final SecretType secretType;\n+    private final byte[] secret;\n \n-    public void setSecret(final String secret) {\n+    public TypedSecret(final byte[] secret, final SecretType secretType) {\n         this.secret = secret;\n-    }\n-\n-    public void setSecretType(final SecretType secretType) {\n         this.secretType = secretType;\n     }\n-\n }\n \n \n", "next_change": {"commit": "9949e261418959bfc6a3635533e00fca3f04ccc8", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 4c2f14eba6..6522073575 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -19,8 +21,16 @@ public class TypedSecret {\n     private final byte[] secret;\n \n     public TypedSecret(final byte[] secret, final SecretType secretType) {\n-        this.secret = secret;\n-        this.secretType = secretType;\n+        this.secret = Arrays.copyOf(secret, secret.length);\n+        if(secretType!=null) {\n+            this.secretType = secretType;\n+        } else {\n+            throw new IllegalArgumentException(\"Secret type can not be NULL\");\n+        }\n+    }\n+\n+    public byte[] getSecret() {\n+        return Arrays.copyOf(this.secret, this.secret.length);\n     }\n }\n \n", "next_change": {"commit": "2ad102dc23f1887d7e8309251500ff3e4ce8b28f", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 6522073575..7793f8ede4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -30,7 +30,7 @@ public class TypedSecret {\n     }\n \n     public byte[] getSecret() {\n-        return Arrays.copyOf(this.secret, this.secret.length);\n+        return this.secret == null ? null : Arrays.copyOf(this.secret, this.secret.length);\n     }\n }\n \n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 7793f8ede4..a2b9a4bb65 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -1,37 +1,32 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n import java.util.Arrays;\n-\n import lombok.Getter;\n \n-/**\n- * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n- */\n+/** TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type. */\n @Getter\n public class TypedSecret {\n-    private final SecretType secretType;\n-    private final byte[] secret;\n+  private final SecretType secretType;\n+  private final byte[] secret;\n \n-    public TypedSecret(final byte[] secret, final SecretType secretType) {\n-        this.secret = secret == null ? null : Arrays.copyOf(secret, secret.length);\n-        if (secretType != null) {\n-            this.secretType = secretType;\n-        } else {\n-            throw new IllegalArgumentException(\"Secret type can not be NULL\");\n-        }\n+  public TypedSecret(final byte[] secret, final SecretType secretType) {\n+    this.secret = secret == null ? null : Arrays.copyOf(secret, secret.length);\n+    if (secretType != null) {\n+      this.secretType = secretType;\n+    } else {\n+      throw new IllegalArgumentException(\"Secret type can not be NULL\");\n     }\n+  }\n \n-    public byte[] getSecret() {\n-        return this.secret == null ? null : Arrays.copyOf(this.secret, this.secret.length);\n-    }\n+  public byte[] getSecret() {\n+    return this.secret == null ? null : Arrays.copyOf(this.secret, this.secret.length);\n+  }\n }\n-\n-\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzNjM2Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450836366", "body": "Any exception will be translated to a TechnicalException. Is this intended?\r\nMaybe return a SOAP Fault to communicate the problem to the caller?", "bodyText": "Any exception will be translated to a TechnicalException. Is this intended?\nMaybe return a SOAP Fault to communicate the problem to the caller?", "bodyHTML": "<p dir=\"auto\">Any exception will be translated to a TechnicalException. Is this intended?<br>\nMaybe return a SOAP Fault to communicate the problem to the caller?</p>", "author": "jboon", "createdAt": "2020-07-07T12:46:16Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.util.List;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.services.SecretManagementService;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+@Endpoint\n+@Slf4j\n+public class SecretManagementEndpoint {\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement/2020/05\";\n+\n+    private final SecretManagementService secretManagementService;\n+    private final SoapEndpointDataTypeConverter converter;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n+            SoapEndpointDataTypeConverter converter) {\n+        this.secretManagementService = secretManagementService;\n+        this.converter = converter;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n+\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        log.trace(request.toString());\n+\n+        try {\n+            GetSecretsResponse response = new GetSecretsResponse();\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(request.getSecretTypes());\n+            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                    secretTypeList);\n+\n+            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+\n+            response.setTypedSecrets(soapTypedSecrets);\n+            response.setResult(OsgpResultType.OK);\n+\n+            log.trace(response.toString());\n+\n+            return response;\n+        } catch (Exception e) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex d0deee67d7..db9aab1d6d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -64,7 +67,7 @@ public class SecretManagementEndpoint {\n             response.setTypedSecrets(soapTypedSecrets);\n             response.setResult(OsgpResultType.OK);\n \n-            log.trace(response.toString());\n+            logger.trace(response.toString());\n \n             return response;\n         } catch (Exception e) {\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex db9aab1d6d..76ac969a62 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -67,7 +71,7 @@ public class SecretManagementEndpoint {\n             response.setTypedSecrets(soapTypedSecrets);\n             response.setResult(OsgpResultType.OK);\n \n-            logger.trace(response.toString());\n+            log.trace(response.toString());\n \n             return response;\n         } catch (Exception e) {\n", "next_change": {"commit": "1b6e76f1ae90d21483a8cb6700ced390ece6ddde", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 76ac969a62..0f65e309a7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -74,6 +81,7 @@ public class SecretManagementEndpoint {\n             log.trace(response.toString());\n \n             return response;\n+\n         } catch (Exception e) {\n             throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n         }\n", "next_change": {"commit": "960d7b310d52105a83162bf24bef337b063bda42", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 0f65e309a7..7eb42b6e8a 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,6 +83,9 @@ public class SecretManagementEndpoint {\n             return response;\n \n         } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                e.printStackTrace();\n+            }\n             throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n         }\n     }\n", "next_change": {"commit": "44a3bcbb103c55ae89dcb931f229d8fda5d2bd2a", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 7eb42b6e8a..e7d9328893 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,7 +83,7 @@ public class SecretManagementEndpoint {\n             return response;\n \n         } catch (Exception e) {\n-            if (log.isDebugEnabled()) {\n+            if (log.isTraceEnabled()) {\n                 e.printStackTrace();\n             }\n             throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e7d9328893..6fd1c521f7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -60,34 +59,26 @@ public class SecretManagementEndpoint {\n             log.debug(getSecretsRequestToString(request));\n         }\n \n-        try {\n-            GetSecretsResponse response = new GetSecretsResponse();\n-\n-            SecretTypes soapSecretTypes = request.getSecretTypes();\n+        GetSecretsResponse response = new GetSecretsResponse();\n \n-            if (soapSecretTypes == null) {\n-                throw new TechnicalException(\"Missing input: secret types\");\n-            }\n+        SecretTypes soapSecretTypes = request.getSecretTypes();\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                    secretTypeList);\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n \n-            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                secretTypeList);\n \n-            response.setTypedSecrets(soapTypedSecrets);\n-            response.setResult(OsgpResultType.OK);\n+        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n \n-            log.trace(response.toString());\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n \n-            return response;\n+        log.trace(response.toString());\n \n-        } catch (Exception e) {\n-            if (log.isTraceEnabled()) {\n-                e.printStackTrace();\n-            }\n-            throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n-        }\n+        return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 6fd1c521f7..533a69c1fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,23 +86,21 @@ public class SecretManagementEndpoint {\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n+    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n \n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n \n-        StoreSecretsResponse response = new StoreSecretsResponse();\n+        final StoreSecretResponse response = new StoreSecretResponse();\n \n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n \n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+        try {\n+            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n+        } catch(final IOException ioe) {\n+            //TODO process/rethrow exception\n         }\n \n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n         response.setResult(OsgpResultType.OK);\n \n         log.trace(response.toString());\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 533a69c1fd..b2d3841c1d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -55,56 +59,60 @@ public class SecretManagementEndpoint {\n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n             log.debug(this.getSecretsRequestToString(request));\n         }\n-\n         final GetSecretsResponse response = new GetSecretsResponse();\n-\n         final SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n         if (soapSecretTypes == null) {\n             throw new TechnicalException(\"Missing input: secret types\");\n         }\n-\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n         final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n         final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n-\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        final StoreSecretResponse response = new StoreSecretResponse();\n-\n-        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n-\n-        try {\n-            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n-        } catch(final IOException ioe) {\n-            //TODO process/rethrow exception\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        if (soapTypedSecrets == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n+                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex b2d3841c1d..516b919866 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -112,6 +112,7 @@ public class SecretManagementEndpoint {\n                 t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n         this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n         return response;\n     }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 516b919866..63f7ec46d2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -108,9 +107,8 @@ public class SecretManagementEndpoint {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n-                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n         response.setResult(OsgpResultType.OK);\n         response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n", "next_change": {"commit": "fbdb92d61e267dcd963e7490941e8b628efeb594", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 63f7ec46d2..9285957e4a 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -115,10 +139,10 @@ public class SecretManagementEndpoint {\n         return response;\n     }\n \n-    private String getSecretsRequestToString(final GetSecretsRequest request) {\n+    private <T> String requestToString(final T request) {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            final JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n             final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 9285957e4a..e78b2429cf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -147,7 +155,8 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\", e);\n+            String logFormat = \"Could not serialize request of type %s\";\n+            log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n     }\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e78b2429cf..4b8396680c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -155,7 +150,7 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            String logFormat = \"Could not serialize request of type %s\";\n+            final String logFormat = \"Could not serialize request of type %s\";\n             log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 4b8396680c..991145a3a5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -45,153 +43,166 @@ import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI =\n-            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n-    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n-    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+  private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+  private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n-    private final SecretManagementService secretManagementService;\n-    private final SoapEndpointDataTypeConverter converter;\n+  private final SecretManagementService secretManagementService;\n+  private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n-            final SoapEndpointDataTypeConverter converter) {\n-        this.secretManagementService = secretManagementService;\n-        this.converter = converter;\n-    }\n+  public SecretManagementEndpoint(\n+      final SecretManagementService secretManagementService,\n+      final SoapEndpointDataTypeConverter converter) {\n+    this.secretManagementService = secretManagementService;\n+    this.converter = converter;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n-    @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetSecretsResponse response = new GetSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+  @ResponsePayload\n+  public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final GetSecretsResponse response = new GetSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n-    @ResponsePayload\n-    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+  @ResponsePayload\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      @RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveNewSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n-    @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final StoreSecretsResponse response = new StoreSecretsResponse();\n-        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n-        }\n-        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+  @ResponsePayload\n+  public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'storeSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final StoreSecretsResponse response = new StoreSecretsResponse();\n+    final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n+    }\n+    final List<TypedSecret> typedSecretList =\n+        this.converter.convertToTypedSecrets(soapTypedSecrets);\n+    this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n-    @ResponsePayload\n-    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n-            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n-                request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        response.setResult(OsgpResultType.OK);\n-        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+  @ResponsePayload\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+      @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecretList =\n+        this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(), secretTypeList);\n+    response.setResult(OsgpResultType.OK);\n+    response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+    return response;\n+  }\n \n-    private <T> String requestToString(final T request) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try {\n-            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n-            final Marshaller marshaller = ctx.createMarshaller();\n-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-            marshaller.marshal(request, baos);\n-        } catch (final JAXBException e) {\n-            final String logFormat = \"Could not serialize request of type %s\";\n-            log.error(String.format(logFormat,request.getClass()), e);\n-        }\n-        return baos.toString();\n+  private <T> String requestToString(final T request) {\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    try {\n+      final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+      final Marshaller marshaller = ctx.createMarshaller();\n+      marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+      marshaller.marshal(request, baos);\n+    } catch (final JAXBException e) {\n+      final String logFormat = \"Could not serialize request of type %s\";\n+      log.error(String.format(logFormat, request.getClass()), e);\n     }\n+    return baos.toString();\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n-    @ResponsePayload\n-    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        try {\n-            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n-                    this.converter.convertToSecretTypes(soapSecretTypes));\n-            response.setResult(OsgpResultType.OK);\n-        } catch (final RuntimeException rte) {\n-            log.error(\"Could not activate new secrets: \"+rte.toString());\n-            throw new TechnicalException(\"Could not activate new secrets\",rte);\n-        }\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+  @ResponsePayload\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    try {\n+      this.secretManagementService.activateNewSecrets(\n+          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n+      response.setResult(OsgpResultType.OK);\n+    } catch (final RuntimeException rte) {\n+      log.error(\"Could not activate new secrets: \" + rte.toString());\n+      throw new TechnicalException(\"Could not activate new secrets\", rte);\n     }\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n-    @ResponsePayload\n-    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final HasNewSecretResponse response = new HasNewSecretResponse();\n-        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-        response.setHasNewSecret(result);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+  @ResponsePayload\n+  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final HasNewSecretResponse response = new HasNewSecretResponse();\n+    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+    response.setHasNewSecret(result);\n+    return response;\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 991145a3a5..a710cf5252 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -166,43 +250,46 @@ public class SecretManagementEndpoint {\n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n   @ResponsePayload\n   public ActivateSecretsResponse activateSecretsRequest(\n-      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n-    }\n-    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-    final SecretTypes soapSecretTypes = request.getSecretTypes();\n-    if (soapSecretTypes == null) {\n-      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-    }\n-    try {\n-      this.secretManagementService.activateNewSecrets(\n-          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n-      response.setResult(OsgpResultType.OK);\n-    } catch (final RuntimeException rte) {\n-      log.error(\"Could not activate new secrets: \" + rte.toString());\n-      throw new TechnicalException(\"Could not activate new secrets\", rte);\n-    }\n-    return response;\n+      @RequestPayload final ActivateSecretsRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::activateSecrets,\n+        header,\n+        messageContext,\n+        this.nameList(request.getSecretTypes()));\n   }\n \n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n   @ResponsePayload\n-  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-      throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      @RequestPayload final HasNewSecretRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::hasNewSecret,\n+        header,\n+        messageContext,\n+        Arrays.asList(request.getSecretType().name()));\n+  }\n+\n+  private List<String> nameList(final SecretTypes secretTypes) {\n+    if (secretTypes == null) {\n+      return Collections.emptyList();\n     }\n-    final HasNewSecretResponse response = new HasNewSecretResponse();\n-    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-    response.setHasNewSecret(result);\n-    return response;\n+    return secretTypes.getSecretType().stream().map(st -> st.name()).collect(Collectors.toList());\n+  }\n+\n+  private List<String> nameList(final TypedSecrets typedSecrets) {\n+    if (typedSecrets == null) {\n+      return Collections.emptyList();\n+    }\n+    return typedSecrets.getTypedSecret().stream()\n+        .map(ts -> ts.getType().name())\n+        .collect(Collectors.toList());\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzNjU0OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450836548", "body": "See comment above", "bodyText": "See comment above", "bodyHTML": "<p dir=\"auto\">See comment above</p>", "author": "jboon", "createdAt": "2020-07-07T12:46:34Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.util.List;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.services.SecretManagementService;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+@Endpoint\n+@Slf4j\n+public class SecretManagementEndpoint {\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement/2020/05\";\n+\n+    private final SecretManagementService secretManagementService;\n+    private final SoapEndpointDataTypeConverter converter;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n+            SoapEndpointDataTypeConverter converter) {\n+        this.secretManagementService = secretManagementService;\n+        this.converter = converter;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n+\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        log.trace(request.toString());\n+\n+        try {\n+            GetSecretsResponse response = new GetSecretsResponse();\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(request.getSecretTypes());\n+            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                    secretTypeList);\n+\n+            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+\n+            response.setTypedSecrets(soapTypedSecrets);\n+            response.setResult(OsgpResultType.OK);\n+\n+            log.trace(response.toString());\n+\n+            return response;\n+        } catch (Exception e) {\n+            throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n+        }\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+    @ResponsePayload\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n+\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+\n+        StoreSecretsResponse response = new StoreSecretsResponse();\n+\n+        try {\n+            List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n+\n+            secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+\n+            response.setResult(OsgpResultType.OK);\n+\n+            log.trace(response.toString());\n+\n+            return response;\n+        } catch (Exception e) {\n+            throw new TechnicalException(ComponentType.SHARED, e.getMessage());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex d0deee67d7..db9aab1d6d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -88,7 +91,7 @@ public class SecretManagementEndpoint {\n \n             response.setResult(OsgpResultType.OK);\n \n-            log.trace(response.toString());\n+            logger.trace(response.toString());\n \n             return response;\n         } catch (Exception e) {\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex db9aab1d6d..76ac969a62 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -79,19 +83,25 @@ public class SecretManagementEndpoint {\n     @ResponsePayload\n     public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n \n-        logger.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        logger.trace(request.toString());\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n \n         StoreSecretsResponse response = new StoreSecretsResponse();\n \n         try {\n+            TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+\n+            if (soapTypedSecrets == null) {\n+                throw new TechnicalException(\"Missing input: typed secrets\");\n+            }\n+\n             List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n \n             secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n \n             response.setResult(OsgpResultType.OK);\n \n-            logger.trace(response.toString());\n+            log.trace(response.toString());\n \n             return response;\n         } catch (Exception e) {\n", "next_change": {"commit": "1b6e76f1ae90d21483a8cb6700ced390ece6ddde", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 76ac969a62..0f65e309a7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -109,4 +117,19 @@ public class SecretManagementEndpoint {\n         }\n     }\n \n+    private String getSecretsRequestToString(GetSecretsRequest request) {\n+        try {\n+            JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            Marshaller marshaller = ctx.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            marshaller.marshal(request, baos);\n+\n+            return baos.toString();\n+        }\n+        catch(JAXBException e) {\n+            throw new IllegalStateException(\"Could not serialize GetSecretsRequest\");\n+        }\n+    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 0f65e309a7..6fd1c521f7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -127,8 +117,7 @@ public class SecretManagementEndpoint {\n             marshaller.marshal(request, baos);\n \n             return baos.toString();\n-        }\n-        catch(JAXBException e) {\n+        } catch (JAXBException e) {\n             throw new IllegalStateException(\"Could not serialize GetSecretsRequest\");\n         }\n     }\n", "next_change": {"commit": "bd58ee80242d67262adf062325925d9bcfa90694", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 6fd1c521f7..87a9903d82 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -108,17 +108,15 @@ public class SecretManagementEndpoint {\n     }\n \n     private String getSecretsRequestToString(GetSecretsRequest request) {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n             JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n             Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             marshaller.marshal(request, baos);\n-\n-            return baos.toString();\n         } catch (JAXBException e) {\n-            throw new IllegalStateException(\"Could not serialize GetSecretsRequest\");\n+            log.error(\"Could not serialize GetSecretsRequest\");\n         }\n+        return baos.toString();\n     }\n }\n", "next_change": {"commit": "1a5975cc121f6272044cb1608e7ea345b97dd06b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 87a9903d82..56af4cd2ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -115,7 +115,7 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\");\n+            log.error(\"Could not serialize GetSecretsRequest\", e);\n         }\n         return baos.toString();\n     }\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 56af4cd2ea..533a69c1fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -107,16 +108,33 @@ public class SecretManagementEndpoint {\n         return response;\n     }\n \n-    private String getSecretsRequestToString(GetSecretsRequest request) {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private String getSecretsRequestToString(final GetSecretsRequest request) {\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n-            Marshaller marshaller = ctx.createMarshaller();\n+            final JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n-        } catch (JAXBException e) {\n+        } catch (final JAXBException e) {\n             log.error(\"Could not serialize GetSecretsRequest\", e);\n         }\n         return baos.toString();\n     }\n+\n+    public ActivateSecretResponse activateSecretRequest(@RequestPayload final ActivateSecretRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+\n+        final ActivateSecretResponse response = new ActivateSecretResponse();\n+        try{\n+            this.secretManagementService.activateNewSecret(request.getDeviceId(),\n+                    this.converter.convertToSecretType(request.getType()));\n+            response.setResult(OsgpResultType.OK);\n+        } catch(final RuntimeException rte) {\n+            //TODO process/rethrow exception\n+        }\n+        log.trace(response.toString());\n+\n+        return response;\n+    }\n }\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 533a69c1fd..b2d3841c1d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -121,20 +129,43 @@ public class SecretManagementEndpoint {\n         return baos.toString();\n     }\n \n-    public ActivateSecretResponse activateSecretRequest(@RequestPayload final ActivateSecretRequest request) throws OsgpException {\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+    @ResponsePayload\n+    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        final ActivateSecretResponse response = new ActivateSecretResponse();\n-        try{\n-            this.secretManagementService.activateNewSecret(request.getDeviceId(),\n-                    this.converter.convertToSecretType(request.getType()));\n+        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+        try {\n+            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n+                    this.converter.convertToSecretTypes(soapSecretTypes));\n             response.setResult(OsgpResultType.OK);\n-        } catch(final RuntimeException rte) {\n+        } catch (final RuntimeException rte) {\n             //TODO process/rethrow exception\n         }\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+    @ResponsePayload\n+    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+            throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+        final HasNewSecretResponse response = new HasNewSecretResponse();\n+        try {\n+            final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(),\n+                    this.converter.convertToSecretType(request.getSecretType()));\n+            response.setHasNewSecret(result);\n+        } catch (final RuntimeException rte) {\n+            //TODO process/rethrow exception\n+        }\n+        log.trace(response.toString());\n         return response;\n     }\n }\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex b2d3841c1d..cb2377d0d1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -158,13 +158,9 @@ public class SecretManagementEndpoint {\n         log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n         final HasNewSecretResponse response = new HasNewSecretResponse();\n-        try {\n-            final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(),\n-                    this.converter.convertToSecretType(request.getSecretType()));\n-            response.setHasNewSecret(result);\n-        } catch (final RuntimeException rte) {\n-            //TODO process/rethrow exception\n-        }\n+        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+        response.setHasNewSecret(result);\n         log.trace(response.toString());\n         return response;\n     }\n", "next_change": {"commit": "3d3b7013f5cab8f90b335382a83ae97db9ddcee8", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex cb2377d0d1..c41f018684 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -156,7 +187,9 @@ public class SecretManagementEndpoint {\n     public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n             throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        log.trace(request.toString());\n+        if (log.isDebugEnabled()) {\n+            log.debug(this.requestToString(request));\n+        }\n         final HasNewSecretResponse response = new HasNewSecretResponse();\n         final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n         final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n", "next_change": {"commit": "9949e261418959bfc6a3635533e00fca3f04ccc8", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex c41f018684..73ed333dcd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -194,7 +192,6 @@ public class SecretManagementEndpoint {\n         final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n         final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n         response.setHasNewSecret(result);\n-        log.trace(response.toString());\n         return response;\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 73ed333dcd..991145a3a5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -45,153 +43,166 @@ import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI =\n-            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n-    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n-    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+  private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+  private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n-    private final SecretManagementService secretManagementService;\n-    private final SoapEndpointDataTypeConverter converter;\n+  private final SecretManagementService secretManagementService;\n+  private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n-            final SoapEndpointDataTypeConverter converter) {\n-        this.secretManagementService = secretManagementService;\n-        this.converter = converter;\n-    }\n+  public SecretManagementEndpoint(\n+      final SecretManagementService secretManagementService,\n+      final SoapEndpointDataTypeConverter converter) {\n+    this.secretManagementService = secretManagementService;\n+    this.converter = converter;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n-    @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetSecretsResponse response = new GetSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+  @ResponsePayload\n+  public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final GetSecretsResponse response = new GetSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n-    @ResponsePayload\n-    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+  @ResponsePayload\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      @RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveNewSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n-    @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final StoreSecretsResponse response = new StoreSecretsResponse();\n-        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n-        }\n-        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+  @ResponsePayload\n+  public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'storeSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final StoreSecretsResponse response = new StoreSecretsResponse();\n+    final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n+    }\n+    final List<TypedSecret> typedSecretList =\n+        this.converter.convertToTypedSecrets(soapTypedSecrets);\n+    this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n-    @ResponsePayload\n-    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n-            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n-                request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        response.setResult(OsgpResultType.OK);\n-        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+  @ResponsePayload\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+      @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecretList =\n+        this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(), secretTypeList);\n+    response.setResult(OsgpResultType.OK);\n+    response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+    return response;\n+  }\n \n-    private <T> String requestToString(final T request) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try {\n-            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n-            final Marshaller marshaller = ctx.createMarshaller();\n-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-            marshaller.marshal(request, baos);\n-        } catch (final JAXBException e) {\n-            String logFormat = \"Could not serialize request of type %s\";\n-            log.error(String.format(logFormat,request.getClass()), e);\n-        }\n-        return baos.toString();\n+  private <T> String requestToString(final T request) {\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    try {\n+      final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+      final Marshaller marshaller = ctx.createMarshaller();\n+      marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+      marshaller.marshal(request, baos);\n+    } catch (final JAXBException e) {\n+      final String logFormat = \"Could not serialize request of type %s\";\n+      log.error(String.format(logFormat, request.getClass()), e);\n     }\n+    return baos.toString();\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n-    @ResponsePayload\n-    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        try {\n-            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n-                    this.converter.convertToSecretTypes(soapSecretTypes));\n-            response.setResult(OsgpResultType.OK);\n-        } catch (final RuntimeException rte) {\n-            log.error(\"Could not activate new secrets: \"+rte.toString());\n-            throw new TechnicalException(\"Could not activate new secrets\",rte);\n-        }\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+  @ResponsePayload\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    try {\n+      this.secretManagementService.activateNewSecrets(\n+          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n+      response.setResult(OsgpResultType.OK);\n+    } catch (final RuntimeException rte) {\n+      log.error(\"Could not activate new secrets: \" + rte.toString());\n+      throw new TechnicalException(\"Could not activate new secrets\", rte);\n     }\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n-    @ResponsePayload\n-    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final HasNewSecretResponse response = new HasNewSecretResponse();\n-        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-        response.setHasNewSecret(result);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+  @ResponsePayload\n+  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final HasNewSecretResponse response = new HasNewSecretResponse();\n+    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+    response.setHasNewSecret(result);\n+    return response;\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 991145a3a5..a710cf5252 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -166,43 +250,46 @@ public class SecretManagementEndpoint {\n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n   @ResponsePayload\n   public ActivateSecretsResponse activateSecretsRequest(\n-      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n-    }\n-    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-    final SecretTypes soapSecretTypes = request.getSecretTypes();\n-    if (soapSecretTypes == null) {\n-      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-    }\n-    try {\n-      this.secretManagementService.activateNewSecrets(\n-          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n-      response.setResult(OsgpResultType.OK);\n-    } catch (final RuntimeException rte) {\n-      log.error(\"Could not activate new secrets: \" + rte.toString());\n-      throw new TechnicalException(\"Could not activate new secrets\", rte);\n-    }\n-    return response;\n+      @RequestPayload final ActivateSecretsRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::activateSecrets,\n+        header,\n+        messageContext,\n+        this.nameList(request.getSecretTypes()));\n   }\n \n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n   @ResponsePayload\n-  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-      throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      @RequestPayload final HasNewSecretRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::hasNewSecret,\n+        header,\n+        messageContext,\n+        Arrays.asList(request.getSecretType().name()));\n+  }\n+\n+  private List<String> nameList(final SecretTypes secretTypes) {\n+    if (secretTypes == null) {\n+      return Collections.emptyList();\n     }\n-    final HasNewSecretResponse response = new HasNewSecretResponse();\n-    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-    response.setHasNewSecret(result);\n-    return response;\n+    return secretTypes.getSecretType().stream().map(st -> st.name()).collect(Collectors.toList());\n+  }\n+\n+  private List<String> nameList(final TypedSecrets typedSecrets) {\n+    if (typedSecrets == null) {\n+      return Collections.emptyList();\n+    }\n+    return typedSecrets.getTypedSecret().stream()\n+        .map(ts -> ts.getType().name())\n+        .collect(Collectors.toList());\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzODQwNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450838407", "body": "Make this field final", "bodyText": "Make this field final", "bodyHTML": "<p dir=\"auto\">Make this field final</p>", "author": "jboon", "createdAt": "2020-07-07T12:49:43Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {\n+\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+    private EncryptionDelegate encryptionDelegate;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..5c81e0d9e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -29,7 +29,7 @@ import java.util.List;\n public class SoapEndpointDataTypeConverter {\n \n     private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private EncryptionDelegate encryptionDelegate;\n+    private final EncryptionDelegate encryptionDelegate;\n \n     public SoapEndpointDataTypeConverter(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 5c81e0d9e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,17 +38,10 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        List<SecretType> secretTypeList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n-                soapSecretTypeList) {\n-            SecretType secretType = convertToSecretType(soapSecretType);\n-            secretTypeList.add(secretType);\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return secretTypeList;\n+        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+                Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,11 +36,11 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n \n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzOTMyNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450839327", "body": "You could validate this in the caller and assume valid input.", "bodyText": "You could validate this in the caller and assume valid input.", "bodyHTML": "<p dir=\"auto\">You could validate this in the caller and assume valid input.</p>", "author": "jboon", "createdAt": "2020-07-07T12:51:14Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {\n+\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+    private EncryptionDelegate encryptionDelegate;\n+\n+    public SoapEndpointDataTypeConverter(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+    }\n+\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+\n+        if (soapSecretTypes == null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..5c81e0d9e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,10 +38,6 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n-        }\n-\n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n                 soapSecretTypes.getSecretType();\n         List<SecretType> secretTypeList = new ArrayList<>();\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 5c81e0d9e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,17 +38,10 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        List<SecretType> secretTypeList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n-                soapSecretTypeList) {\n-            SecretType secretType = convertToSecretType(soapSecretType);\n-            secretTypeList.add(secretType);\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return secretTypeList;\n+        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+                Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,11 +36,11 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n \n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzOTg5OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450839899", "body": "Validate input", "bodyText": "Validate input", "bodyHTML": "<p dir=\"auto\">Validate input</p>", "author": "jboon", "createdAt": "2020-07-07T12:52:08Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.util.List;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.services.SecretManagementService;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+@Endpoint\n+@Slf4j\n+public class SecretManagementEndpoint {\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement/2020/05\";\n+\n+    private final SecretManagementService secretManagementService;\n+    private final SoapEndpointDataTypeConverter converter;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n+            SoapEndpointDataTypeConverter converter) {\n+        this.secretManagementService = secretManagementService;\n+        this.converter = converter;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n+\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        log.trace(request.toString());\n+\n+        try {\n+            GetSecretsResponse response = new GetSecretsResponse();\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(request.getSecretTypes());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex d0deee67d7..db9aab1d6d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -48,9 +51,9 @@ public class SecretManagementEndpoint {\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n \n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        logger.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        log.trace(request.toString());\n+        logger.trace(request.toString());\n \n         try {\n             GetSecretsResponse response = new GetSecretsResponse();\n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex db9aab1d6d..76ac969a62 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -51,14 +49,20 @@ public class SecretManagementEndpoint {\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n \n-        logger.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        logger.trace(request.toString());\n+        log.trace(request.toString());\n \n         try {\n             GetSecretsResponse response = new GetSecretsResponse();\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(request.getSecretTypes());\n+            SecretTypes soapSecretTypes = request.getSecretTypes();\n+\n+            if (soapSecretTypes == null) {\n+                throw new TechnicalException(\"Missing input: secret types\");\n+            }\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n             List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n                     secretTypeList);\n \n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 76ac969a62..6fd1c521f7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -51,32 +55,30 @@ public class SecretManagementEndpoint {\n \n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        log.trace(request.toString());\n+        if (log.isDebugEnabled()) {\n+            log.debug(getSecretsRequestToString(request));\n+        }\n \n-        try {\n-            GetSecretsResponse response = new GetSecretsResponse();\n+        GetSecretsResponse response = new GetSecretsResponse();\n \n-            SecretTypes soapSecretTypes = request.getSecretTypes();\n+        SecretTypes soapSecretTypes = request.getSecretTypes();\n \n-            if (soapSecretTypes == null) {\n-                throw new TechnicalException(\"Missing input: secret types\");\n-            }\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                    secretTypeList);\n+        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                secretTypeList);\n \n-            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n \n-            response.setTypedSecrets(soapTypedSecrets);\n-            response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n \n-            log.trace(response.toString());\n+        log.trace(response.toString());\n \n-            return response;\n-        } catch (Exception e) {\n-            throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n-        }\n+        return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 6fd1c521f7..533a69c1fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,23 +86,21 @@ public class SecretManagementEndpoint {\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n+    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n \n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n \n-        StoreSecretsResponse response = new StoreSecretsResponse();\n+        final StoreSecretResponse response = new StoreSecretResponse();\n \n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n \n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+        try {\n+            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n+        } catch(final IOException ioe) {\n+            //TODO process/rethrow exception\n         }\n \n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n         response.setResult(OsgpResultType.OK);\n \n         log.trace(response.toString());\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 533a69c1fd..b2d3841c1d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -55,56 +59,60 @@ public class SecretManagementEndpoint {\n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n             log.debug(this.getSecretsRequestToString(request));\n         }\n-\n         final GetSecretsResponse response = new GetSecretsResponse();\n-\n         final SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n         if (soapSecretTypes == null) {\n             throw new TechnicalException(\"Missing input: secret types\");\n         }\n-\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n         final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n         final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n-\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        final StoreSecretResponse response = new StoreSecretResponse();\n-\n-        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n-\n-        try {\n-            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n-        } catch(final IOException ioe) {\n-            //TODO process/rethrow exception\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        if (soapTypedSecrets == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n+                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex b2d3841c1d..516b919866 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -112,6 +112,7 @@ public class SecretManagementEndpoint {\n                 t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n         this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n         return response;\n     }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 516b919866..63f7ec46d2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -108,9 +107,8 @@ public class SecretManagementEndpoint {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n-                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n         response.setResult(OsgpResultType.OK);\n         response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n", "next_change": {"commit": "fbdb92d61e267dcd963e7490941e8b628efeb594", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 63f7ec46d2..9285957e4a 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -115,10 +139,10 @@ public class SecretManagementEndpoint {\n         return response;\n     }\n \n-    private String getSecretsRequestToString(final GetSecretsRequest request) {\n+    private <T> String requestToString(final T request) {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            final JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n             final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 9285957e4a..e78b2429cf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -147,7 +155,8 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\", e);\n+            String logFormat = \"Could not serialize request of type %s\";\n+            log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n     }\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e78b2429cf..4b8396680c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -155,7 +150,7 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            String logFormat = \"Could not serialize request of type %s\";\n+            final String logFormat = \"Could not serialize request of type %s\";\n             log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 4b8396680c..991145a3a5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -45,153 +43,166 @@ import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI =\n-            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n-    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n-    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+  private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+  private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n-    private final SecretManagementService secretManagementService;\n-    private final SoapEndpointDataTypeConverter converter;\n+  private final SecretManagementService secretManagementService;\n+  private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n-            final SoapEndpointDataTypeConverter converter) {\n-        this.secretManagementService = secretManagementService;\n-        this.converter = converter;\n-    }\n+  public SecretManagementEndpoint(\n+      final SecretManagementService secretManagementService,\n+      final SoapEndpointDataTypeConverter converter) {\n+    this.secretManagementService = secretManagementService;\n+    this.converter = converter;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n-    @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetSecretsResponse response = new GetSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+  @ResponsePayload\n+  public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final GetSecretsResponse response = new GetSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n-    @ResponsePayload\n-    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+  @ResponsePayload\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      @RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveNewSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n-    @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final StoreSecretsResponse response = new StoreSecretsResponse();\n-        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n-        }\n-        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+  @ResponsePayload\n+  public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'storeSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final StoreSecretsResponse response = new StoreSecretsResponse();\n+    final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n+    }\n+    final List<TypedSecret> typedSecretList =\n+        this.converter.convertToTypedSecrets(soapTypedSecrets);\n+    this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n-    @ResponsePayload\n-    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n-            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n-                request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        response.setResult(OsgpResultType.OK);\n-        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+  @ResponsePayload\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+      @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecretList =\n+        this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(), secretTypeList);\n+    response.setResult(OsgpResultType.OK);\n+    response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+    return response;\n+  }\n \n-    private <T> String requestToString(final T request) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try {\n-            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n-            final Marshaller marshaller = ctx.createMarshaller();\n-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-            marshaller.marshal(request, baos);\n-        } catch (final JAXBException e) {\n-            final String logFormat = \"Could not serialize request of type %s\";\n-            log.error(String.format(logFormat,request.getClass()), e);\n-        }\n-        return baos.toString();\n+  private <T> String requestToString(final T request) {\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    try {\n+      final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+      final Marshaller marshaller = ctx.createMarshaller();\n+      marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+      marshaller.marshal(request, baos);\n+    } catch (final JAXBException e) {\n+      final String logFormat = \"Could not serialize request of type %s\";\n+      log.error(String.format(logFormat, request.getClass()), e);\n     }\n+    return baos.toString();\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n-    @ResponsePayload\n-    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        try {\n-            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n-                    this.converter.convertToSecretTypes(soapSecretTypes));\n-            response.setResult(OsgpResultType.OK);\n-        } catch (final RuntimeException rte) {\n-            log.error(\"Could not activate new secrets: \"+rte.toString());\n-            throw new TechnicalException(\"Could not activate new secrets\",rte);\n-        }\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+  @ResponsePayload\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    try {\n+      this.secretManagementService.activateNewSecrets(\n+          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n+      response.setResult(OsgpResultType.OK);\n+    } catch (final RuntimeException rte) {\n+      log.error(\"Could not activate new secrets: \" + rte.toString());\n+      throw new TechnicalException(\"Could not activate new secrets\", rte);\n     }\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n-    @ResponsePayload\n-    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final HasNewSecretResponse response = new HasNewSecretResponse();\n-        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-        response.setHasNewSecret(result);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+  @ResponsePayload\n+  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final HasNewSecretResponse response = new HasNewSecretResponse();\n+    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+    response.setHasNewSecret(result);\n+    return response;\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 991145a3a5..a710cf5252 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -166,43 +250,46 @@ public class SecretManagementEndpoint {\n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n   @ResponsePayload\n   public ActivateSecretsResponse activateSecretsRequest(\n-      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n-    }\n-    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-    final SecretTypes soapSecretTypes = request.getSecretTypes();\n-    if (soapSecretTypes == null) {\n-      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-    }\n-    try {\n-      this.secretManagementService.activateNewSecrets(\n-          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n-      response.setResult(OsgpResultType.OK);\n-    } catch (final RuntimeException rte) {\n-      log.error(\"Could not activate new secrets: \" + rte.toString());\n-      throw new TechnicalException(\"Could not activate new secrets\", rte);\n-    }\n-    return response;\n+      @RequestPayload final ActivateSecretsRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::activateSecrets,\n+        header,\n+        messageContext,\n+        this.nameList(request.getSecretTypes()));\n   }\n \n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n   @ResponsePayload\n-  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-      throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      @RequestPayload final HasNewSecretRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::hasNewSecret,\n+        header,\n+        messageContext,\n+        Arrays.asList(request.getSecretType().name()));\n+  }\n+\n+  private List<String> nameList(final SecretTypes secretTypes) {\n+    if (secretTypes == null) {\n+      return Collections.emptyList();\n     }\n-    final HasNewSecretResponse response = new HasNewSecretResponse();\n-    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-    response.setHasNewSecret(result);\n-    return response;\n+    return secretTypes.getSecretType().stream().map(st -> st.name()).collect(Collectors.toList());\n+  }\n+\n+  private List<String> nameList(final TypedSecrets typedSecrets) {\n+    if (typedSecrets == null) {\n+      return Collections.emptyList();\n+    }\n+    return typedSecrets.getTypedSecret().stream()\n+        .map(ts -> ts.getType().name())\n+        .collect(Collectors.toList());\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0MTI3OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450841279", "body": "This could be done beautifully with the Streams API ;-)", "bodyText": "This could be done beautifully with the Streams API ;-)", "bodyHTML": "<p dir=\"auto\">This could be done beautifully with the Streams API ;-)</p>", "author": "jboon", "createdAt": "2020-07-07T12:54:26Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {\n+\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+    private EncryptionDelegate encryptionDelegate;\n+\n+    public SoapEndpointDataTypeConverter(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+    }\n+\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n+\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n+                soapSecretTypes.getSecretType();\n+        List<SecretType> secretTypeList = new ArrayList<>();\n+\n+        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..5c81e0d9e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,10 +38,6 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n-        }\n-\n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n                 soapSecretTypes.getSecretType();\n         List<SecretType> secretTypeList = new ArrayList<>();\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 5c81e0d9e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,17 +38,10 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        List<SecretType> secretTypeList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n-                soapSecretTypeList) {\n-            SecretType secretType = convertToSecretType(soapSecretType);\n-            secretTypeList.add(secretType);\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return secretTypeList;\n+        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+                Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,11 +36,11 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n \n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0MjA5Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450842096", "body": "See comments above", "bodyText": "See comments above", "bodyHTML": "<p dir=\"auto\">See comments above</p>", "author": "jboon", "createdAt": "2020-07-07T12:55:40Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {\n+\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+    private EncryptionDelegate encryptionDelegate;\n+\n+    public SoapEndpointDataTypeConverter(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+    }\n+\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n+\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n+                soapSecretTypes.getSecretType();\n+        List<SecretType> secretTypeList = new ArrayList<>();\n+\n+        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n+                soapSecretTypeList) {\n+            SecretType secretType = convertToSecretType(soapSecretType);\n+            secretTypeList.add(secretType);\n+        }\n+\n+        return secretTypeList;\n+    }\n+\n+    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+\n+        if (soapTypedSecrets == null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -38,21 +38,10 @@ public class SoapEndpointDataTypeConverter {\n \n     public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n \n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(\"Missing input: secret types\");\n-        }\n-\n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        List<SecretType> secretTypeList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType :\n-                soapSecretTypeList) {\n-            SecretType secretType = convertToSecretType(soapSecretType);\n-            secretTypeList.add(secretType);\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return secretTypeList;\n+        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+                Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,11 +36,11 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) throws OsgpException {\n+    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n \n         List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map((soapSecretType) -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b97dbaa3e9..2920305149 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -61,16 +50,11 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList\n-                = soapTypedSecrets.getTypedSecret();\n-        List<TypedSecret> typedSecretList = new ArrayList<>();\n-\n-        for (org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret :\n-                soapTypedSecretsList) {\n-            typedSecretList.add(decryptAndConvertSoapTypedSecret(soapTypedSecret));\n-        }\n+        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+                soapTypedSecrets.getTypedSecret();\n \n-        return typedSecretList;\n+        return soapTypedSecretsList.stream().map(\n+                (soapTypedSecret) -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n", "next_change": {"commit": "9927d20221b3a973c6afbac6deb042424d94bbcc", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..eba4f67467 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -54,7 +54,7 @@ public class SoapEndpointDataTypeConverter {\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                (soapTypedSecret) -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex eba4f67467..f8ec24df19 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -36,36 +36,35 @@ public class SoapEndpointDataTypeConverter {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n     }\n \n-    public List<SecretType> convertToSecretTypes(SecretTypes soapSecretTypes) {\n+    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n \n-        return soapSecretTypeList.stream().map(soapSecretType -> convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n                 Collectors.toList());\n     }\n \n-    public List<TypedSecret> convertToTypedSecrets(TypedSecrets soapTypedSecrets) throws OsgpException {\n+    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n \n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n \n         return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n-    public TypedSecrets convertToSoapTypedSecrets(List<TypedSecret> typedSecrets) {\n-        TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n \n-        List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n+        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n \n-        for (TypedSecret typedSecret : typedSecrets) {\n-            org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                    encryptAndConvertSoapTypedSecret(\n+        for (final TypedSecret typedSecret : typedSecrets) {\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex f8ec24df19..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,59 +16,37 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0NTM1NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450845355", "body": "This will never be null due to the instance of check  in the above code fragment", "bodyText": "This will never be null due to the instance of check  in the above code fragment", "bodyHTML": "<p dir=\"auto\">This will never be null due to the instance of check  in the above code fragment</p>", "author": "jboon", "createdAt": "2020-07-07T13:00:55Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {\n+            TechnicalFault technicalFault = convert((TechnicalException) ex);\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) {\n+                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n+            }\n+            if (technicalFault.getComponent() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n+            }\n+            if (technicalFault.getInnerMessage() != null) {\n+                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n+            }\n+            if (technicalFault.getInnerException() != null) {\n+                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            }\n+        }\n+    }\n+\n+    private TechnicalFault convert(final TechnicalException ex) {\n+        if (ex == null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0ODEwOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450848109", "body": "+1 for the exception translation", "bodyText": "+1 for the exception translation", "bodyHTML": "<p dir=\"auto\">+1 for the exception translation</p>", "author": "jboon", "createdAt": "2020-07-07T13:05:25Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0ODkzNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450848935", "body": "Is there only a generic exception? ", "bodyText": "Is there only a generic exception?", "bodyHTML": "<p dir=\"auto\">Is there only a generic exception?</p>", "author": "jboon", "createdAt": "2020-07-07T13:06:50Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0OTU1NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450849554", "body": "I have only seen Component.SHARED be set. What is the relevance of this field?", "bodyText": "I have only seen Component.SHARED be set. What is the relevance of this field?", "bodyHTML": "<p dir=\"auto\">I have only seen Component.SHARED be set. What is the relevance of this field?</p>", "author": "jboon", "createdAt": "2020-07-07T13:07:44Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {\n+            TechnicalFault technicalFault = convert((TechnicalException) ex);\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) {\n+                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n+            }\n+            if (technicalFault.getComponent() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg0OTg2MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450849861", "body": "Is this relevant for the caller?", "bodyText": "Is this relevant for the caller?", "bodyHTML": "<p dir=\"auto\">Is this relevant for the caller?</p>", "author": "jboon", "createdAt": "2020-07-07T13:08:12Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {\n+            TechnicalFault technicalFault = convert((TechnicalException) ex);\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) {\n+                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n+            }\n+            if (technicalFault.getComponent() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n+            }\n+            if (technicalFault.getInnerMessage() != null) {\n+                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MDA2Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450850063", "body": "Is this something you want to expose?", "bodyText": "Is this something you want to expose?", "bodyHTML": "<p dir=\"auto\">Is this something you want to expose?</p>", "author": "jboon", "createdAt": "2020-07-07T13:08:30Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {\n+            TechnicalFault technicalFault = convert((TechnicalException) ex);\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) {\n+                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n+            }\n+            if (technicalFault.getComponent() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n+            }\n+            if (technicalFault.getInnerMessage() != null) {\n+                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n+            }\n+            if (technicalFault.getInnerException() != null) {\n+                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MDkyNg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450850926", "body": "I would not expose the cause. Translate exceptions to application specific ones.", "bodyText": "I would not expose the cause. Translate exceptions to application specific ones.", "bodyHTML": "<p dir=\"auto\">I would not expose the cause. Translate exceptions to application specific ones.</p>", "author": "jboon", "createdAt": "2020-07-07T13:09:43Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.exception;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalException) {\n+            TechnicalFault technicalFault = convert((TechnicalException) ex);\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) {\n+                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n+            }\n+            if (technicalFault.getComponent() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n+            }\n+            if (technicalFault.getInnerMessage() != null) {\n+                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n+            }\n+            if (technicalFault.getInnerException() != null) {\n+                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            }\n+        }\n+    }\n+\n+    private TechnicalFault convert(final TechnicalException ex) {\n+        if (ex == null) {\n+            return null;\n+        }\n+        final TechnicalFault destination = new TechnicalFault();\n+        destination.setComponent(ex.getComponentType().name());\n+        destination.setMessage(ex.getMessage());\n+        if (ex.getCause() != null) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex ad9aaef645..9c7bf34058 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -20,41 +20,20 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n \n     private static final QName MESSAGE = new QName(\"Message\");\n     private static final QName COMPONENT = new QName(\"Component\");\n-    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n-    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n \n     @Override\n     protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        SoapFaultDetail detail = fault.addFaultDetail();\n+\n+        if (ex.getMessage() != null) {\n+            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+        }\n+\n         if (ex instanceof TechnicalException) {\n-            TechnicalFault technicalFault = convert((TechnicalException) ex);\n-            SoapFaultDetail detail = fault.addFaultDetail();\n-            if (technicalFault.getMessage() != null) {\n-                detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());\n-            }\n-            if (technicalFault.getComponent() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(technicalFault.getComponent());\n-            }\n-            if (technicalFault.getInnerMessage() != null) {\n-                detail.addFaultDetailElement(INNER_MESSAGE).addText(technicalFault.getInnerMessage());\n-            }\n-            if (technicalFault.getInnerException() != null) {\n-                detail.addFaultDetailElement(INNER_EXCEPTION).addText(technicalFault.getInnerException());\n+            if (((TechnicalException) ex).getComponentType().name() != null) {\n+                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n             }\n         }\n     }\n \n-    private TechnicalFault convert(final TechnicalException ex) {\n-        if (ex == null) {\n-            return null;\n-        }\n-        final TechnicalFault destination = new TechnicalFault();\n-        destination.setComponent(ex.getComponentType().name());\n-        destination.setMessage(ex.getMessage());\n-        if (ex.getCause() != null) {\n-            destination.setInnerException(ex.getCause().getClass().getName());\n-            destination.setInnerMessage(ex.getCause().getMessage());\n-        }\n-\n-        return destination;\n-    }\n }\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 9c7bf34058..1d67112bc3 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -30,9 +29,7 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         }\n \n         if (ex instanceof TechnicalException) {\n-            if (((TechnicalException) ex).getComponentType().name() != null) {\n-                detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-            }\n+            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n         }\n     }\n \n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 1d67112bc3..6d597a87ea 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -25,7 +25,11 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n         SoapFaultDetail detail = fault.addFaultDetail();\n \n         if (ex.getMessage() != null) {\n-            detail.addFaultDetailElement(MESSAGE).addText(ex.getMessage());\n+            String messageText = ex.getMessage();\n+            if (ex.getCause() != null) {\n+                messageText += \": \" + ex.getCause().toString();\n+            }\n+            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n         }\n \n         if (ex instanceof TechnicalException) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 6d597a87ea..04b67f43b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -1,40 +1,47 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n- * <p>\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.exception;\n \n import javax.xml.namespace.QName;\n-\n+import lombok.extern.slf4j.Slf4j;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.springframework.ws.soap.SoapFault;\n import org.springframework.ws.soap.SoapFaultDetail;\n import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n \n+@Slf4j\n public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n \n-    private static final QName MESSAGE = new QName(\"Message\");\n-    private static final QName COMPONENT = new QName(\"Component\");\n-\n-    @Override\n-    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n-        SoapFaultDetail detail = fault.addFaultDetail();\n+  private static final QName MESSAGE = new QName(\"Message\");\n+  private static final QName COMPONENT = new QName(\"Component\");\n \n-        if (ex.getMessage() != null) {\n-            String messageText = ex.getMessage();\n-            if (ex.getCause() != null) {\n-                messageText += \": \" + ex.getCause().toString();\n-            }\n-            detail.addFaultDetailElement(MESSAGE).addText(messageText);\n-        }\n+  @Override\n+  protected void customizeFault(final Object endpoint, final Exception ex, final SoapFault fault) {\n+    log.error(\"Exception occured during SOAP request processing\", ex);\n+    final SoapFaultDetail detail = fault.addFaultDetail();\n+    if (ex instanceof ExceptionWrapper) {\n+      this.customizeFault(endpoint, (Exception) ex.getCause(), fault);\n+      return;\n+    }\n \n-        if (ex instanceof TechnicalException) {\n-            detail.addFaultDetailElement(COMPONENT).addText(((TechnicalException) ex).getComponentType().name());\n-        }\n+    if (ex.getMessage() != null) {\n+      String messageText = ex.getMessage();\n+      if (ex.getCause() != null) {\n+        messageText += \": \" + ex.getCause().toString();\n+      }\n+      detail.addFaultDetailElement(MESSAGE).addText(messageText);\n     }\n \n+    if (ex instanceof TechnicalException) {\n+      detail\n+          .addFaultDetailElement(COMPONENT)\n+          .addText(((TechnicalException) ex).getComponentType().name());\n+    }\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 04b67f43b5..598b72189e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -44,4 +48,19 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n           .addText(((TechnicalException) ex).getComponentType().name());\n     }\n   }\n+\n+  @Override\n+  protected void logException(final Exception ex, final MessageContext messageContext) {\n+    log.error(\n+        \"[{}] Exception occurred during SOAP request processing\",\n+        this.getCorrelationUid(messageContext),\n+        ex);\n+  }\n+\n+  private String getCorrelationUid(final MessageContext messageContext) {\n+    final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n+    final Iterator<SoapHeaderElement> iter =\n+        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+    return iter.hasNext() ? iter.next().getText() : null;\n+  }\n }\n", "next_change": {"commit": "b064588409753e0bb74bfe6e68f2ba6a5e005ed4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\nindex 598b72189e..3d12ed7192 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/exception/DetailSoapFaultMappingExceptionResolver.java\n", "chunk": "@@ -60,7 +63,10 @@ public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExc\n   private String getCorrelationUid(final MessageContext messageContext) {\n     final SaajSoapMessage request = (SaajSoapMessage) messageContext.getRequest();\n     final Iterator<SoapHeaderElement> iter =\n-        request.getEnvelope().getHeader().examineHeaderElements(new QName(\"correlationUid\"));\n+        request\n+            .getEnvelope()\n+            .getHeader()\n+            .examineHeaderElements(new QName(NAMESPACE_URI, CORRELATION_UID));\n     return iter.hasNext() ? iter.next().getText() : null;\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1Mjc2MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450852760", "body": "+1 for using the Stream API", "bodyText": "+1 for using the Stream API", "bodyHTML": "<p dir=\"auto\">+1 for using the Stream API</p>", "author": "jboon", "createdAt": "2020-07-07T13:12:24Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 7f3861aaaf..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -49,7 +48,7 @@ public class SecretManagementService {\n         this.keyRepository = keyRepository;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n         //@formatter:off\n         secrets.stream()\n                 .map(t -> this.validateSecret(deviceIdentification, t))\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -48,19 +51,10 @@ public class SecretManagementService {\n         this.keyRepository = keyRepository;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n     private DbEncryptionKeyReference getKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n+                this.encryptionProviderType, now, Pageable.unpaged());\n         if (keyRefsPage.getSize() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n         }\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..b749f99b63 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -62,12 +60,13 @@ public class SecretManagementService {\n                 () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n         if (secret.getSecret() == null) {\n             throw new IllegalArgumentException(\"No secret string set\");\n         } else if (secret.getSecretType() == null) {\n             throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n             throw new IllegalArgumentException(\n                     String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n                             secret.getSecretType().name()));\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex b749f99b63..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,186 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification,\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n             final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n-    }\n-\n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n         }\n     }\n \n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        final DbEncryptionKeyReference keyReference = this.getKey();\n-        //TODO get key (KEK) from HSM and use it to generate AES 128-bits secret\n-        return null;\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1MzkzOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450853939", "body": "Global variables", "bodyText": "Global variables", "bodyHTML": "<p dir=\"auto\">Global variables</p>", "author": "jboon", "createdAt": "2020-07-07T13:14:19Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -16,31 +18,25 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String ALG = \"RSA\";\n-    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n \n     private Key publicKey;\n     private Key privateKey;\n \n-    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n-        try {\n-            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+    public void setPrivateKeyStore(File privateKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        super.setKeyFile(privateKeyStoreFile);\n+    }\n \n-            if (privateKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-                privateKey = keyFactory.generatePrivate(privateKeySpec);\n-                super.setKeyFile(privateKeyStoreFile);\n-            }\n-            if (publicKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-                publicKey = keyFactory.generatePublic(publicKeySpec);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Something went wrong during construction of \"\n-                    + \"RsaEncryptionProvider\", e);\n-        }\n+    public void setPublicKeyStore(File publicKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n     }\n \n     protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NDA0NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450854045", "body": "Make final", "bodyText": "Make final", "bodyHTML": "<p dir=\"auto\">Make final</p>", "author": "jboon", "createdAt": "2020-07-07T13:14:27Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -16,31 +18,25 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String ALG = \"RSA\";\n-    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n \n     private Key publicKey;\n     private Key privateKey;\n \n-    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n-        try {\n-            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+    public void setPrivateKeyStore(File privateKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        super.setKeyFile(privateKeyStoreFile);\n+    }\n \n-            if (privateKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-                privateKey = keyFactory.generatePrivate(privateKeySpec);\n-                super.setKeyFile(privateKeyStoreFile);\n-            }\n-            if (publicKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-                publicKey = keyFactory.generatePublic(publicKeySpec);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Something went wrong during construction of \"\n-                    + \"RsaEncryptionProvider\", e);\n-        }\n+    public void setPublicKeyStore(File publicKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n     }\n \n     protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NTM2Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450855363", "body": "I think I wouldn't do this in the constructor. You could create beans and inject the Key objects in here", "bodyText": "I think I wouldn't do this in the constructor. You could create beans and inject the Key objects in here", "bodyHTML": "<p dir=\"auto\">I think I wouldn't do this in the constructor. You could create beans and inject the Key objects in here</p>", "author": "jboon", "createdAt": "2020-07-07T13:16:25Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n+        try {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -16,31 +18,25 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String ALG = \"RSA\";\n-    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+    private static final String ALG = \"RSA\";\n+    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n \n     private Key publicKey;\n     private Key privateKey;\n \n-    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n-        try {\n-            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+    public void setPrivateKeyStore(File privateKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n+        super.setKeyFile(privateKeyStoreFile);\n+    }\n \n-            if (privateKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-                privateKey = keyFactory.generatePrivate(privateKeySpec);\n-                super.setKeyFile(privateKeyStoreFile);\n-            }\n-            if (publicKeyStoreFile != null) {\n-                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-                publicKey = keyFactory.generatePublic(publicKeySpec);\n-            }\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Something went wrong during construction of \"\n-                    + \"RsaEncryptionProvider\", e);\n-        }\n+    public void setPublicKeyStore(File publicKeyStoreFile)\n+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n     }\n \n     protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzAyMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450857020", "body": "?", "bodyText": "?", "bodyHTML": "<p dir=\"auto\">?</p>", "author": "jboon", "createdAt": "2020-07-07T13:19:02Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.Cipher;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"RSA\";\n+    public static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n+\n+    private Key publicKey;\n+    private Key privateKey;\n+\n+    public RsaEncryptionProvider(File privateKeyStoreFile, File publicKeyStoreFile) {\n+        try {\n+            KeyFactory keyFactory = KeyFactory.getInstance(ALG);\n+\n+            if (privateKeyStoreFile != null) {\n+                byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n+                PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n+                privateKey = keyFactory.generatePrivate(privateKeySpec);\n+                super.setKeyFile(privateKeyStoreFile);\n+            }\n+            if (publicKeyStoreFile != null) {\n+                byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+                X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+                publicKey = keyFactory.generatePublic(publicKeySpec);\n+            }\n+        } catch (Exception e) {\n+            throw new EncrypterException(\"Something went wrong during construction of \"\n+                    + \"RsaEncryptionProvider\", e);\n+        }\n+    }\n+\n+    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n+        return Cipher.getInstance(ALGORITHM);\n+    }\n+\n+    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n+        if (cipherMode == Cipher.ENCRYPT_MODE) {\n+            if (publicKey == null) {\n+                throw new EncrypterException(\"Cannot RSA encrypt because no public key is defined.\");\n+            }\n+            return publicKey;\n+        } else if (cipherMode == Cipher.DECRYPT_MODE) {\n+            if (privateKey == null) {\n+                throw new EncrypterException(\"Cannot RSA encrypt because no private key is defined.\");\n+            }\n+            return privateKey;\n+        }\n+        throw new EncrypterException(\"Invalid cipher mode specified.\");\n+    }\n+\n+    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+        return null;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex c8edb0a8f9..494ce3546c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -48,18 +44,7 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        if (cipherMode == Cipher.ENCRYPT_MODE) {\n-            if (publicKey == null) {\n-                throw new EncrypterException(\"Cannot RSA encrypt because no public key is defined.\");\n-            }\n-            return publicKey;\n-        } else if (cipherMode == Cipher.DECRYPT_MODE) {\n-            if (privateKey == null) {\n-                throw new EncrypterException(\"Cannot RSA encrypt because no private key is defined.\");\n-            }\n-            return privateKey;\n-        }\n-        throw new EncrypterException(\"Invalid cipher mode specified.\");\n+        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n     }\n \n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 494ce3546c..d6a3864758 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -32,15 +33,23 @@ public class RsaEncryptionProvider extends AbstractEncryptionProvider implements\n         super.setKeyFile(privateKeyStoreFile);\n     }\n \n-    public void setPublicKeyStore(File publicKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-        publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n+        try {\n+            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n+            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n+            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n+        }\n+        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            throw new EncrypterException(\"Could not set public keystore\", e);\n+        }\n     }\n \n-    protected Cipher getCipher() throws javax.crypto.NoSuchPaddingException, NoSuchAlgorithmException {\n-        return Cipher.getInstance(ALGORITHM);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String key, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex d6a3864758..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,67 +0,0 @@\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile)\n-            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) throws EncrypterException {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzY2Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450857667", "body": "Global variables", "bodyText": "Global variables", "bodyHTML": "<p dir=\"auto\">Global variables</p>", "author": "jboon", "createdAt": "2020-07-07T13:20:06Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    public static final String ALG = \"AES\";\n+    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    public static final String PROVIDER = \"SunJCE\";\n+    public static final String FORMAT = \"RAW\";", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex eb9e9df8d0..6268a9fb92 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -27,28 +27,28 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    public static final String ALG = \"AES\";\n-    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    public static final String PROVIDER = \"SunJCE\";\n-    public static final String FORMAT = \"RAW\";\n+    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    private static final String ALG = \"AES\";\n+    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    private static final String PROVIDER = \"SunJCE\";\n+    private static final String FORMAT = \"RAW\";\n     private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n \n-    private byte[] key;\n-\n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n-    }\n+    private final byte[] key;\n \n     public JreEncryptionProvider(File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n         } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\");\n+            throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 6268a9fb92..a6a0ea3bc2 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -45,8 +45,12 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM, PROVIDER);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a6a0ea3bc2..877b3ded42 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -53,13 +55,16 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n             throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n         }\n \n         return new SecretKey() {\n+            private static final long serialVersionUID = 4555243342661334965L;\n+\n             @Override\n             public String getAlgorithm() {\n                 return ALG;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 877b3ded42..a379c98f07 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -16,90 +16,94 @@ import java.security.Key;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n import java.security.spec.AlgorithmParameterSpec;\n-\n import javax.crypto.Cipher;\n import javax.crypto.KeyGenerator;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.SecretKey;\n import javax.crypto.spec.IvParameterSpec;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n-public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class JreEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    private static final String ALG = \"AES\";\n-    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    private static final String PROVIDER = \"SunJCE\";\n-    private static final String FORMAT = \"RAW\";\n-    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+  private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+  private static final String ALG = \"AES\";\n+  private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+  private static final String PROVIDER = \"SunJCE\";\n+  private static final String FORMAT = \"RAW\";\n+  private static final byte[] IV = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+  private static final int KEY_LENGTH = 16;\n \n-    private final byte[] key;\n+  private final byte[] key;\n \n-    public JreEncryptionProvider(File keyStoreFile) throws EncrypterException {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n-        } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public JreEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n+    } catch (final IOException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n-\n-    @Override\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  }\n+\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    @Override\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n-\n-        if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n-            throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n-        }\n-\n-        return new SecretKey() {\n-            private static final long serialVersionUID = 4555243342661334965L;\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n \n-            @Override\n-            public String getAlgorithm() {\n-                return ALG;\n-            }\n-\n-            @Override\n-            public String getFormat() {\n-                return FORMAT;\n-            }\n-\n-            @Override\n-            public byte[] getEncoded() {\n-                return JreEncryptionProvider.this.key;\n-            }\n-        };\n+    if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n+      throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n     }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n+    return new SecretKey() {\n+      private static final long serialVersionUID = 4555243342661334965L;\n+\n+      @Override\n+      public String getAlgorithm() {\n+        return ALG;\n+      }\n+\n+      @Override\n+      public String getFormat() {\n+        return FORMAT;\n+      }\n+\n+      @Override\n+      public byte[] getEncoded() {\n+        return JreEncryptionProvider.this.key;\n+      }\n+    };\n+  }\n+\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n+      keyGenerator.init(KEY_LENGTH * 8);\n+      return this.encrypt(keyGenerator.generateKey().getEncoded(), keyReference).getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n-        try {\n-            KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n-            keyGenerator.init(128);\n-            return this.encrypt(keyGenerator.generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n-    }\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.JRE;\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.JRE;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n }\n", "next_change": {"commit": "fc313d9098483fe1fecab5e9fadb92a1db5d471e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a379c98f07..7bc14faf63 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -106,4 +103,52 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider {\n   public int getSecretByteLength() {\n     return KEY_LENGTH;\n   }\n+\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+\n+      final byte[] iv = new byte[GCM_IV_LENGTH]; // NEVER REUSE THIS IV WITH SAME KEY\n+      this.secureRandom.nextBytes(iv);\n+\n+      final GCMParameterSpec parameterSpec = new GCMParameterSpec(KEY_LENGTH * 8, iv);\n+\n+      cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference), parameterSpec);\n+\n+      final byte[] bytes = cipher.doFinal(secret);\n+      final ByteBuffer byteBuffer = ByteBuffer.allocate(GCM_IV_LENGTH + bytes.length);\n+      byteBuffer.put(iv);\n+      byteBuffer.put(bytes);\n+\n+      return new EncryptedSecret(this.getType(), byteBuffer.array());\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n+\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          String.format(\n+              \"EncryptionProvider for type %s cannot decrypt secrets of type %s\",\n+              this.getType().name(), secret.getType().name()));\n+    }\n+\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      final AlgorithmParameterSpec gcmIv =\n+          new GCMParameterSpec(KEY_LENGTH * 8, secret.getSecret(), 0, GCM_IV_LENGTH);\n+      cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference), gcmIv);\n+\n+      return cipher.doFinal(\n+          secret.getSecret(), GCM_IV_LENGTH, secret.getSecret().length - GCM_IV_LENGTH);\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1ODA2Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450858062", "body": "Make final", "bodyText": "Make final", "bodyHTML": "<p dir=\"auto\">Make final</p>", "author": "jboon", "createdAt": "2020-07-07T13:20:36Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    public static final String ALG = \"AES\";\n+    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    public static final String PROVIDER = \"SunJCE\";\n+    public static final String FORMAT = \"RAW\";\n+    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+\n+    private byte[] key;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex eb9e9df8d0..6268a9fb92 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -27,28 +27,28 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n-    public static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    public static final String ALG = \"AES\";\n-    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    public static final String PROVIDER = \"SunJCE\";\n-    public static final String FORMAT = \"RAW\";\n+    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+    private static final String ALG = \"AES\";\n+    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    private static final String PROVIDER = \"SunJCE\";\n+    private static final String FORMAT = \"RAW\";\n     private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n \n-    private byte[] key;\n-\n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n-    }\n+    private final byte[] key;\n \n     public JreEncryptionProvider(File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n         } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\");\n+            throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 6268a9fb92..a6a0ea3bc2 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -45,8 +45,12 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM, PROVIDER);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a6a0ea3bc2..877b3ded42 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -53,13 +55,16 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n \n         if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n             throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n         }\n \n         return new SecretKey() {\n+            private static final long serialVersionUID = 4555243342661334965L;\n+\n             @Override\n             public String getAlgorithm() {\n                 return ALG;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex 877b3ded42..a379c98f07 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -16,90 +16,94 @@ import java.security.Key;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n import java.security.spec.AlgorithmParameterSpec;\n-\n import javax.crypto.Cipher;\n import javax.crypto.KeyGenerator;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.SecretKey;\n import javax.crypto.spec.IvParameterSpec;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n-public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class JreEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n-    private static final String ALG = \"AES\";\n-    private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n-    private static final String PROVIDER = \"SunJCE\";\n-    private static final String FORMAT = \"RAW\";\n-    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+  private static final String DEFAULT_SINGLE_KEY_REFERENCE = \"1\";\n+  private static final String ALG = \"AES\";\n+  private static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+  private static final String PROVIDER = \"SunJCE\";\n+  private static final String FORMAT = \"RAW\";\n+  private static final byte[] IV = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+  private static final int KEY_LENGTH = 16;\n \n-    private final byte[] key;\n+  private final byte[] key;\n \n-    public JreEncryptionProvider(File keyStoreFile) throws EncrypterException {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n-        } catch (IOException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public JreEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n+    } catch (final IOException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n-\n-    @Override\n-    protected Cipher getCipher() throws EncrypterException {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  }\n+\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    @Override\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) throws EncrypterException {\n-\n-        if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n-            throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n-        }\n-\n-        return new SecretKey() {\n-            private static final long serialVersionUID = 4555243342661334965L;\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n \n-            @Override\n-            public String getAlgorithm() {\n-                return ALG;\n-            }\n-\n-            @Override\n-            public String getFormat() {\n-                return FORMAT;\n-            }\n-\n-            @Override\n-            public byte[] getEncoded() {\n-                return JreEncryptionProvider.this.key;\n-            }\n-        };\n+    if (!keyReference.equals(DEFAULT_SINGLE_KEY_REFERENCE)) {\n+      throw new EncrypterException(\"Only keyReference '1' is valid in this implementation.\");\n     }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n+    return new SecretKey() {\n+      private static final long serialVersionUID = 4555243342661334965L;\n+\n+      @Override\n+      public String getAlgorithm() {\n+        return ALG;\n+      }\n+\n+      @Override\n+      public String getFormat() {\n+        return FORMAT;\n+      }\n+\n+      @Override\n+      public byte[] getEncoded() {\n+        return JreEncryptionProvider.this.key;\n+      }\n+    };\n+  }\n+\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      final KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n+      keyGenerator.init(KEY_LENGTH * 8);\n+      return this.encrypt(keyGenerator.generateKey().getEncoded(), keyReference).getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n-        try {\n-            KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n-            keyGenerator.init(128);\n-            return this.encrypt(keyGenerator.generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n-    }\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.JRE;\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.JRE;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n }\n", "next_change": {"commit": "fc313d9098483fe1fecab5e9fadb92a1db5d471e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\nindex a379c98f07..7bc14faf63 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/JreEncryptionProvider.java\n", "chunk": "@@ -106,4 +103,52 @@ public class JreEncryptionProvider extends AbstractEncryptionProvider {\n   public int getSecretByteLength() {\n     return KEY_LENGTH;\n   }\n+\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+\n+      final byte[] iv = new byte[GCM_IV_LENGTH]; // NEVER REUSE THIS IV WITH SAME KEY\n+      this.secureRandom.nextBytes(iv);\n+\n+      final GCMParameterSpec parameterSpec = new GCMParameterSpec(KEY_LENGTH * 8, iv);\n+\n+      cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference), parameterSpec);\n+\n+      final byte[] bytes = cipher.doFinal(secret);\n+      final ByteBuffer byteBuffer = ByteBuffer.allocate(GCM_IV_LENGTH + bytes.length);\n+      byteBuffer.put(iv);\n+      byteBuffer.put(bytes);\n+\n+      return new EncryptedSecret(this.getType(), byteBuffer.array());\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n+\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          String.format(\n+              \"EncryptionProvider for type %s cannot decrypt secrets of type %s\",\n+              this.getType().name(), secret.getType().name()));\n+    }\n+\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      final AlgorithmParameterSpec gcmIv =\n+          new GCMParameterSpec(KEY_LENGTH * 8, secret.getSecret(), 0, GCM_IV_LENGTH);\n+      cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference), gcmIv);\n+\n+      return cipher.doFinal(\n+          secret.getSecret(), GCM_IV_LENGTH, secret.getSecret().length - GCM_IV_LENGTH);\n+\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n+    }\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1OTg5MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450859891", "body": "Make this private, add getter if needed.", "bodyText": "Make this private, add getter if needed.", "bodyHTML": "<p dir=\"auto\">Make this private, add getter if needed.</p>", "author": "jboon", "createdAt": "2020-07-07T13:23:09Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final int BLOCK_SIZE=16;\n+\n+    protected File keyFile;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 57084c5361..4c7378d2c8 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -31,14 +31,13 @@ public abstract class AbstractEncryptionProvider {\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher()\n-            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException;\n+    protected abstract Cipher getCipher() throws EncrypterException;\n \n     protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n     protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    public void setKeyFile(File keyFile) {\n+    protected void setKeyFile(File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 4c7378d2c8..44d5754d51 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -31,28 +28,28 @@ public abstract class AbstractEncryptionProvider {\n \n     public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher() throws EncrypterException;\n+    protected abstract Cipher getCipher();\n \n     protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n     protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(File keyFile) {\n+        protected void setKeyFile(final File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n-    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+    public EncryptedSecret encrypt(final Secret secret, final String keyReference) {\n         try {\n             final Cipher cipher = this.getCipher();\n             cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 44d5754d51..c7fcdc6c7e 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -34,22 +33,22 @@ public abstract class AbstractEncryptionProvider {\n \n     protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-        protected void setKeyFile(final File keyFile) {\n+    protected void setKeyFile(final File keyFile) {\n         this.keyFile = keyFile;\n     }\n \n-    public EncryptedSecret encrypt(final Secret secret, final String keyReference) {\n+    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n         try {\n             final Cipher cipher = this.getCipher();\n             cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n         } catch (final Exception e) {\n             throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n \n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex c7fcdc6c7e..6271d01916 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -48,7 +48,7 @@ public abstract class AbstractEncryptionProvider {\n         }\n     }\n \n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 6271d01916..bb4fd7da47 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -48,7 +48,7 @@ public abstract class AbstractEncryptionProvider {\n         }\n     }\n \n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n", "next_change": {"commit": "9a8abb71dec97e80e9a47cee6e2ee07652250e83", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex bb4fd7da47..252623e5f9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -48,12 +50,13 @@ public abstract class AbstractEncryptionProvider {\n         }\n     }\n \n+    @Override\n     public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         if (secret.getType() != this.getType()) {\n             throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \"\n-                            + secret.getType().name());\n+                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \" + secret\n+                            .getType().name());\n         }\n \n         try {\n", "next_change": {"commit": "4b1676dc8f0cc9eff0bcb9e20a3bd14ca54e6e1d", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 252623e5f9..948316b6b4 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -64,11 +64,6 @@ public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n             cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (decryptedData.length != this.getSecretByteLength()) {\n-                throw new EncrypterException(\n-                        String.format(\"Incorrect key byte length: expected %s, but was %s\", this.getSecretByteLength(),\n-                                decryptedData.length));\n-            }\n             if (this.checkNullBytesPrepended(decryptedData)) {\n                 return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 948316b6b4..d3c3874cfb 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -12,77 +12,81 @@ import java.io.File;\n import java.security.Key;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n \n-    private static final int BLOCK_SIZE = 16;\n+  private static final int BLOCK_SIZE = 16;\n \n-    protected File keyFile;\n+  protected File keyFile;\n \n-    @Override\n-    public abstract EncryptionProviderType getType();\n+  @Override\n+  public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+  protected abstract Cipher getCipher();\n \n-    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+  protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+  protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(final File keyFile) {\n-        this.keyFile = keyFile;\n-    }\n+  protected void setKeyFile(final File keyFile) {\n+    this.keyFile = keyFile;\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n-        }\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.ENCRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        if (secret.getType() != this.getType()) {\n-            throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \" + secret\n-                            .getType().name());\n-        }\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          \"EncryptionProvider for type \"\n+              + this.getType().name()\n+              + \" cannot decrypt secrets of type \"\n+              + secret.getType().name());\n+    }\n \n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (this.checkNullBytesPrepended(decryptedData)) {\n-                return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n-            } else {\n-                return decryptedData;\n-            }\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n-        }\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.DECRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+      if (this.checkNullBytesPrepended(decryptedData)) {\n+        return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n+      } else {\n+        return decryptedData;\n+      }\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    private boolean checkNullBytesPrepended(final byte[] bytes) {\n-        if (bytes.length > BLOCK_SIZE) {\n-            for (short s = 0; s < BLOCK_SIZE; s++) {\n-                if (bytes[s] != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+  private boolean checkNullBytesPrepended(final byte[] bytes) {\n+    if (bytes.length > BLOCK_SIZE) {\n+      for (short s = 0; s < BLOCK_SIZE; s++) {\n+        if (bytes[s] != 0) {\n+          return false;\n         }\n-        return false;\n+      }\n+      return true;\n     }\n+    return false;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3MTE3NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450871175", "body": "return \r\n    bytes.length > BLOCK_SIZE \r\n    && \r\n    Arrays.stream(Arrays.copyOfRange(bytes, 0, BLOCK_SIZE)).allMatch(b -> b == 0);\r\n\r\nSomething like this?", "bodyText": "return\nbytes.length > BLOCK_SIZE\n&&\nArrays.stream(Arrays.copyOfRange(bytes, 0, BLOCK_SIZE)).allMatch(b -> b == 0);\nSomething like this?", "bodyHTML": "<p dir=\"auto\">return<br>\nbytes.length &gt; BLOCK_SIZE<br>\n&amp;&amp;<br>\nArrays.stream(Arrays.copyOfRange(bytes, 0, BLOCK_SIZE)).allMatch(b -&gt; b == 0);</p>\n<p dir=\"auto\">Something like this?</p>", "author": "jboon", "createdAt": "2020-07-07T13:38:52Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final int BLOCK_SIZE=16;\n+\n+    protected File keyFile;\n+\n+    public abstract EncryptionProviderType getType();\n+\n+    protected abstract Cipher getCipher()\n+            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException;\n+\n+    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+\n+    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+\n+    public void setKeyFile(File keyFile) {\n+        this.keyFile = keyFile;\n+    }\n+\n+    public EncryptedSecret encrypt(Secret secret, String keyReference) {\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n+            // InvalidAlgorithmParameterException |\n+            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n+            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n+        }\n+    }\n+\n+    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+\n+        if (secret.getType() != this.getType()) {\n+            throw new EncrypterException(\n+                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \"\n+                            + secret.getType().name());\n+        }\n+\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+                    this.getAlgorithmParameterSpec());\n+            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+\n+            if (this.checkNullBytesPrepended(decryptedData)) {\n+                return new Secret(Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length));\n+            } else {\n+                return new Secret(decryptedData);\n+            }\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n+            // InvalidAlgorithmParameterException |\n+            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n+            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n+        }\n+    }\n+\n+    private boolean checkNullBytesPrepended(final byte[] bytes) {", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 57084c5361..4c7378d2c8 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -76,9 +72,6 @@ public abstract class AbstractEncryptionProvider {\n                 return new Secret(decryptedData);\n             }\n         } catch (Exception e) {\n-            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException |\n-            // InvalidAlgorithmParameterException |\n-            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n             throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 4c7378d2c8..44d5754d51 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -71,7 +68,7 @@ public abstract class AbstractEncryptionProvider {\n             } else {\n                 return new Secret(decryptedData);\n             }\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n         }\n     }\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 44d5754d51..c7fcdc6c7e 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -64,9 +63,9 @@ public abstract class AbstractEncryptionProvider {\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n \n             if (this.checkNullBytesPrepended(decryptedData)) {\n-                return new Secret(Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length));\n+                return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n-                return new Secret(decryptedData);\n+                return decryptedData;\n             }\n         } catch (final Exception e) {\n             throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n", "next_change": {"commit": "9a8abb71dec97e80e9a47cee6e2ee07652250e83", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex c7fcdc6c7e..252623e5f9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -61,7 +64,11 @@ public abstract class AbstractEncryptionProvider {\n             cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-\n+            if (decryptedData.length != this.getSecretByteLength()) {\n+                throw new EncrypterException(\n+                        String.format(\"Incorrect key byte length: expected %s, but was %s\", this.getSecretByteLength(),\n+                                decryptedData.length));\n+            }\n             if (this.checkNullBytesPrepended(decryptedData)) {\n                 return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n", "next_change": {"commit": "4b1676dc8f0cc9eff0bcb9e20a3bd14ca54e6e1d", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 252623e5f9..948316b6b4 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -64,11 +64,6 @@ public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n             cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n                     this.getAlgorithmParameterSpec());\n             final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (decryptedData.length != this.getSecretByteLength()) {\n-                throw new EncrypterException(\n-                        String.format(\"Incorrect key byte length: expected %s, but was %s\", this.getSecretByteLength(),\n-                                decryptedData.length));\n-            }\n             if (this.checkNullBytesPrepended(decryptedData)) {\n                 return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n             } else {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\nindex 948316b6b4..d3c3874cfb 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/AbstractEncryptionProvider.java\n", "chunk": "@@ -12,77 +12,81 @@ import java.io.File;\n import java.security.Key;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n-\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n \n public abstract class AbstractEncryptionProvider implements EncryptionProvider {\n \n-    private static final int BLOCK_SIZE = 16;\n+  private static final int BLOCK_SIZE = 16;\n \n-    protected File keyFile;\n+  protected File keyFile;\n \n-    @Override\n-    public abstract EncryptionProviderType getType();\n+  @Override\n+  public abstract EncryptionProviderType getType();\n \n-    protected abstract Cipher getCipher();\n+  protected abstract Cipher getCipher();\n \n-    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+  protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n \n-    protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n+  protected abstract Key getSecretEncryptionKey(String keyReference, int cipherMode);\n \n-    protected void setKeyFile(final File keyFile) {\n-        this.keyFile = keyFile;\n-    }\n+  protected void setKeyFile(final File keyFile) {\n+    this.keyFile = keyFile;\n+  }\n \n-    @Override\n-    public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n-        }\n+  @Override\n+  public EncryptedSecret encrypt(final byte[] secret, final String keyReference) {\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.ENCRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.ENCRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      return new EncryptedSecret(this.getType(), cipher.doFinal(secret));\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not encrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        if (secret.getType() != this.getType()) {\n-            throw new EncrypterException(\n-                    \"EncryptionProvider for type \" + this.getType().name() + \" cannot decrypt secrets of type \" + secret\n-                            .getType().name());\n-        }\n+    if (secret.getType() != this.getType()) {\n+      throw new EncrypterException(\n+          \"EncryptionProvider for type \"\n+              + this.getType().name()\n+              + \" cannot decrypt secrets of type \"\n+              + secret.getType().name());\n+    }\n \n-        try {\n-            final Cipher cipher = this.getCipher();\n-            cipher.init(Cipher.DECRYPT_MODE, this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n-                    this.getAlgorithmParameterSpec());\n-            final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n-            if (this.checkNullBytesPrepended(decryptedData)) {\n-                return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n-            } else {\n-                return decryptedData;\n-            }\n-        } catch (final Exception e) {\n-            throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n-        }\n+    try {\n+      final Cipher cipher = this.getCipher();\n+      cipher.init(\n+          Cipher.DECRYPT_MODE,\n+          this.getSecretEncryptionKey(keyReference, Cipher.DECRYPT_MODE),\n+          this.getAlgorithmParameterSpec());\n+      final byte[] decryptedData = cipher.doFinal(secret.getSecret());\n+      if (this.checkNullBytesPrepended(decryptedData)) {\n+        return Arrays.copyOfRange(decryptedData, BLOCK_SIZE, decryptedData.length);\n+      } else {\n+        return decryptedData;\n+      }\n+    } catch (final Exception e) {\n+      throw new EncrypterException(\"Could not decrypt secret with keyReference \" + keyReference, e);\n     }\n+  }\n \n-    private boolean checkNullBytesPrepended(final byte[] bytes) {\n-        if (bytes.length > BLOCK_SIZE) {\n-            for (short s = 0; s < BLOCK_SIZE; s++) {\n-                if (bytes[s] != 0) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+  private boolean checkNullBytesPrepended(final byte[] bytes) {\n+    if (bytes.length > BLOCK_SIZE) {\n+      for (short s = 0; s < BLOCK_SIZE; s++) {\n+        if (bytes[s] != 0) {\n+          return false;\n         }\n-        return false;\n+      }\n+      return true;\n     }\n+    return false;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3MTYyMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450871620", "body": "final", "bodyText": "final", "bodyHTML": "<p dir=\"auto\">final</p>", "author": "jboon", "createdAt": "2020-07-07T13:39:31Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.shared.security.providers;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+    private static final String PROVIDER = \"nCipherKM\";\n+    private static final String TYPE = \"ncipher.sworld\";\n+    private static final byte[] IV = new byte[16];\n+\n+    private KeyStore keyStore;", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex b07f1cdd7b..50b47ff5d4 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -34,7 +34,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     private static final String TYPE = \"ncipher.sworld\";\n     private static final byte[] IV = new byte[16];\n \n-    private KeyStore keyStore;\n+    private final KeyStore keyStore;\n \n     public HsmEncryptionProvider(File keyStoreFile) {\n         try {\n", "next_change": {"commit": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 50b47ff5d4..0e72e615b9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -19,20 +19,29 @@ import java.security.NoSuchProviderException;\n import java.security.UnrecoverableKeyException;\n import java.security.cert.CertificateException;\n import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n \n import javax.crypto.Cipher;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.spec.IvParameterSpec;\n \n+import org.apache.commons.codec.binary.Hex;\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+\n+    private static final int KEY_LENGTH = 16;\n     private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n     private static final String PROVIDER = \"nCipherKM\";\n     private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[16];\n+    private static final byte[] IV = new byte[KEY_LENGTH];\n \n     private final KeyStore keyStore;\n \n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 0e72e615b9..18615dbf1f 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -45,27 +45,28 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n \n     private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(File keyStoreFile) {\n+    public HsmEncryptionProvider(final File keyStoreFile) {\n         try {\n             super.setKeyFile(keyStoreFile);\n             this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            FileInputStream fIn = new FileInputStream(keyStoreFile);\n+            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n-        } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n+        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+    @Override\n+    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n \n         Secret decryptedSecret = super.decrypt(secret, keyReference);\n \n-        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n+        final byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n \n         if (decryptedSecretBytes.length > KEY_LENGTH) {\n \n-            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes,\n-                    decryptedSecretBytes.length-16, decryptedSecretBytes.length);\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n+                    decryptedSecretBytes.length-16);\n \n             LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 18615dbf1f..5736344a37 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -57,21 +56,19 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n+    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n \n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n+        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n \n-        final byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n+        if (decryptedSecret.length > KEY_LENGTH) {\n \n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n+            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n+                    decryptedSecret.length-16);\n \n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n \n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+            return truncatedDecryptedSecretBytes;\n         }\n \n         return decryptedSecret;\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 5736344a37..6af1bab88c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -75,7 +76,19 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     @Override\n-    protected Cipher getCipher() {\n+    public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n+        //byte[] newSecret = new byte[128/8];\n+        try {\n+            //SecureRandom.getInstance(\"SHA1PRNG\",PROVIDER).nextBytes(newSecret);\n+            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n+        } catch (NoSuchAlgorithmException exc) {\n+            throw new EncrypterException(\"Could not generate secret\", exc);\n+        }\n+        //return newSecret;\n+    }\n+\n+    @Override\n+    protected Cipher getCipher() throws EncrypterException {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n         } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n", "next_change": {"commit": "db4ef46ae5ce0bac840ce7df1675cc1e247fc807", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 6af1bab88c..af000b83c9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -58,33 +58,24 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n \n     @Override\n     public byte[] decrypt(final EncryptedSecret secret, final String keyReference) throws EncrypterException {\n-\n         byte[] decryptedSecret = super.decrypt(secret, keyReference);\n-\n         if (decryptedSecret.length > KEY_LENGTH) {\n-\n             final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n                     decryptedSecret.length-16);\n-\n             LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n                             Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n             return truncatedDecryptedSecretBytes;\n         }\n-\n         return decryptedSecret;\n     }\n \n     @Override\n     public byte[] generateAes128BitsSecret(String keyReference) throws EncrypterException {\n-        //byte[] newSecret = new byte[128/8];\n         try {\n-            //SecureRandom.getInstance(\"SHA1PRNG\",PROVIDER).nextBytes(newSecret);\n             return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n         } catch (NoSuchAlgorithmException exc) {\n             throw new EncrypterException(\"Could not generate secret\", exc);\n         }\n-        //return newSecret;\n     }\n \n     @Override\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex af000b83c9..9bdf890046 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -78,6 +78,11 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n         }\n     }\n \n+    @Override\n+    public int getSecretByteLength() {\n+        return KEY_LENGTH;\n+    }\n+\n     @Override\n     protected Cipher getCipher() throws EncrypterException {\n         try {\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 9bdf890046..cd2a57088b 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -84,7 +84,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     @Override\n-    protected Cipher getCipher() throws EncrypterException {\n+    protected Cipher getCipher() {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n         } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex cd2a57088b..5717cc229a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -33,86 +31,97 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n \n-    private static final int KEY_LENGTH = 16;\n-    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n-    private static final String PROVIDER = \"nCipherKM\";\n-    private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[KEY_LENGTH];\n+  private static final int KEY_LENGTH = 16;\n+  private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+  private static final String PROVIDER = \"nCipherKM\";\n+  private static final String TYPE = \"ncipher.sworld\";\n+  private static final byte[] IV = new byte[KEY_LENGTH];\n \n-    private final KeyStore keyStore;\n+  private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(final File keyStoreFile) {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n-            this.keyStore.load(fIn, null);\n-        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public HsmEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n+      final FileInputStream fIn = new FileInputStream(keyStoreFile);\n+      this.keyStore.load(fIn, null);\n+    } catch (final CertificateException\n+        | NoSuchAlgorithmException\n+        | NoSuchProviderException\n+        | IOException\n+        | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n-        if (decryptedSecret.length > KEY_LENGTH) {\n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n-                    decryptedSecret.length-16);\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n-                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-            return truncatedDecryptedSecretBytes;\n-        }\n-        return decryptedSecret;\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    final byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+    if (decryptedSecret.length > KEY_LENGTH) {\n+      // This provider uses NoPadding, but since decrypted byte size is bigger than key byte size,\n+      // the secrets were apparently encrypted using padding of some kind; truncate the padded\n+      // bytes.\n+      final byte[] truncatedDecryptedSecretBytes =\n+          Arrays.copyOfRange(decryptedSecret, 0, KEY_LENGTH);\n+      LOGGER.trace(\n+          \"Truncating decrypted key from \"\n+              + Hex.encodeHexString(decryptedSecret)\n+              + \" to \"\n+              + Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+      return truncatedDecryptedSecretBytes;\n     }\n+    return decryptedSecret;\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) {\n-        try {\n-            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(), keyReference)\n+          .getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public int getSecretByteLength() {\n-        return KEY_LENGTH;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n \n-    @Override\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    /**\n-     * This method reads the encryption key specified by keyReference from the Hsm.\n-     *\n-     * @return the key that must be used for encryption/decryption\n-     */\n-    @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n-        try {\n-            return this.keyStore.getKey(keyReference, null);\n-        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not get keystore from key\", e);\n-        }\n+  /**\n+   * This method reads the encryption key specified by keyReference from the Hsm.\n+   *\n+   * @return the key that must be used for encryption/decryption\n+   */\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    try {\n+      return this.keyStore.getKey(keyReference, null);\n+    } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not get keystore from key\", e);\n     }\n+  }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n-    }\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.HSM;\n-    }\n-}\n\\ No newline at end of file\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.HSM;\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 50b47ff5d4..0e72e615b9 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -43,12 +52,36 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n             FileInputStream fIn = new FileInputStream(keyStoreFile);\n             this.keyStore.load(fIn, null);\n         } catch (CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\");\n+            throw new EncrypterException(\"Could not read keystore\", e);\n         }\n     }\n \n-    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n-        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    public Secret decrypt(EncryptedSecret secret, String keyReference) {\n+\n+        Secret decryptedSecret = super.decrypt(secret, keyReference);\n+\n+        byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n+\n+        if (decryptedSecretBytes.length > KEY_LENGTH) {\n+\n+            byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes,\n+                    decryptedSecretBytes.length-16, decryptedSecretBytes.length);\n+\n+            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n+                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+\n+            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n+        }\n+\n+        return decryptedSecret;\n+    }\n+\n+    protected Cipher getCipher() throws EncrypterException {\n+        try {\n+            return Cipher.getInstance(ALGORITHM, PROVIDER);\n+        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new EncrypterException(\"Could not get cipher\", e);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 0e72e615b9..18615dbf1f 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -76,10 +77,11 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n         return decryptedSecret;\n     }\n \n-    protected Cipher getCipher() throws EncrypterException {\n+    @Override\n+    protected Cipher getCipher() {\n         try {\n             return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n             throw new EncrypterException(\"Could not get cipher\", e);\n         }\n     }\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 18615dbf1f..5736344a37 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -87,8 +84,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n     }\n \n     /**\n-     * This method reads the 'actual' encryption key (from the database).\n-     * Normally this is the key start isValidFrom(now) and isValidUntil(now).\n+     * This method reads the encryption key specified by keyReference from the Hsm.\n      *\n      * @return the key that must be used for encryption/decryption\n      */\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 5736344a37..6af1bab88c 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -89,7 +102,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n      * @return the key that must be used for encryption/decryption\n      */\n     @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) throws EncrypterException {\n         try {\n             return this.keyStore.getKey(keyReference, null);\n         } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 6af1bab88c..cd2a57088b 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -102,7 +98,7 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n      * @return the key that must be used for encryption/decryption\n      */\n     @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) throws EncrypterException {\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n         try {\n             return this.keyStore.getKey(keyReference, null);\n         } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex cd2a57088b..5717cc229a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -33,86 +31,97 @@ import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n \n-    private static final int KEY_LENGTH = 16;\n-    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n-    private static final String PROVIDER = \"nCipherKM\";\n-    private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[KEY_LENGTH];\n+  private static final int KEY_LENGTH = 16;\n+  private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+  private static final String PROVIDER = \"nCipherKM\";\n+  private static final String TYPE = \"ncipher.sworld\";\n+  private static final byte[] IV = new byte[KEY_LENGTH];\n \n-    private final KeyStore keyStore;\n+  private final KeyStore keyStore;\n \n-    public HsmEncryptionProvider(final File keyStoreFile) {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n-            this.keyStore.load(fIn, null);\n-        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+  public HsmEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n+      final FileInputStream fIn = new FileInputStream(keyStoreFile);\n+      this.keyStore.load(fIn, null);\n+    } catch (final CertificateException\n+        | NoSuchAlgorithmException\n+        | NoSuchProviderException\n+        | IOException\n+        | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n+  }\n \n-    @Override\n-    public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n-        byte[] decryptedSecret = super.decrypt(secret, keyReference);\n-        if (decryptedSecret.length > KEY_LENGTH) {\n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecret, 0,\n-                    decryptedSecret.length-16);\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecret) + \" to \" +\n-                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-            return truncatedDecryptedSecretBytes;\n-        }\n-        return decryptedSecret;\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    final byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+    if (decryptedSecret.length > KEY_LENGTH) {\n+      // This provider uses NoPadding, but since decrypted byte size is bigger than key byte size,\n+      // the secrets were apparently encrypted using padding of some kind; truncate the padded\n+      // bytes.\n+      final byte[] truncatedDecryptedSecretBytes =\n+          Arrays.copyOfRange(decryptedSecret, 0, KEY_LENGTH);\n+      LOGGER.trace(\n+          \"Truncating decrypted key from \"\n+              + Hex.encodeHexString(decryptedSecret)\n+              + \" to \"\n+              + Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+      return truncatedDecryptedSecretBytes;\n     }\n+    return decryptedSecret;\n+  }\n \n-    @Override\n-    public byte[] generateAes128BitsSecret(String keyReference) {\n-        try {\n-            return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(),keyReference).getSecret();\n-        } catch (NoSuchAlgorithmException exc) {\n-            throw new EncrypterException(\"Could not generate secret\", exc);\n-        }\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(), keyReference)\n+          .getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n+  }\n \n-    @Override\n-    public int getSecretByteLength() {\n-        return KEY_LENGTH;\n-    }\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n \n-    @Override\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n+  }\n \n-    /**\n-     * This method reads the encryption key specified by keyReference from the Hsm.\n-     *\n-     * @return the key that must be used for encryption/decryption\n-     */\n-    @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n-        try {\n-            return this.keyStore.getKey(keyReference, null);\n-        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not get keystore from key\", e);\n-        }\n+  /**\n+   * This method reads the encryption key specified by keyReference from the Hsm.\n+   *\n+   * @return the key that must be used for encryption/decryption\n+   */\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    try {\n+      return this.keyStore.getKey(keyReference, null);\n+    } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not get keystore from key\", e);\n     }\n+  }\n \n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n-    }\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n \n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.HSM;\n-    }\n-}\n\\ No newline at end of file\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.HSM;\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 0e72e615b9..18615dbf1f 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -90,18 +92,21 @@ public class HsmEncryptionProvider extends AbstractEncryptionProvider implements\n      *\n      * @return the key that must be used for encryption/decryption\n      */\n-    protected Key getSecretEncryptionKey(String keyReference, int cipherMode) {\n+    @Override\n+    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n         try {\n             return this.keyStore.getKey(keyReference, null);\n-        } catch (UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n             throw new EncrypterException(\"Could not get keystore from key\", e);\n         }\n     }\n \n+    @Override\n     protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n         return new IvParameterSpec(IV);\n     }\n \n+    @Override\n     public EncryptionProviderType getType() {\n         return EncryptionProviderType.HSM;\n     }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\nindex 18615dbf1f..5717cc229a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/HsmEncryptionProvider.java\n", "chunk": "@@ -20,94 +20,108 @@ import java.security.UnrecoverableKeyException;\n import java.security.cert.CertificateException;\n import java.security.spec.AlgorithmParameterSpec;\n import java.util.Arrays;\n-\n import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n import javax.crypto.NoSuchPaddingException;\n import javax.crypto.spec.IvParameterSpec;\n-\n import org.apache.commons.codec.binary.Hex;\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n-\n-    private static final int KEY_LENGTH = 16;\n-    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n-    private static final String PROVIDER = \"nCipherKM\";\n-    private static final String TYPE = \"ncipher.sworld\";\n-    private static final byte[] IV = new byte[KEY_LENGTH];\n-\n-    private final KeyStore keyStore;\n-\n-    public HsmEncryptionProvider(final File keyStoreFile) {\n-        try {\n-            super.setKeyFile(keyStoreFile);\n-            this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n-            final FileInputStream fIn = new FileInputStream(keyStoreFile);\n-            this.keyStore.load(fIn, null);\n-        } catch (final CertificateException | NoSuchAlgorithmException | NoSuchProviderException | IOException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not read keystore\", e);\n-        }\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(HsmEncryptionProvider.class);\n+\n+  private static final int KEY_LENGTH = 16;\n+  private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+  private static final String PROVIDER = \"nCipherKM\";\n+  private static final String TYPE = \"ncipher.sworld\";\n+  private static final byte[] IV = new byte[KEY_LENGTH];\n+\n+  private final KeyStore keyStore;\n+\n+  public HsmEncryptionProvider(final File keyStoreFile) {\n+    try {\n+      super.setKeyFile(keyStoreFile);\n+      this.keyStore = KeyStore.getInstance(TYPE, PROVIDER);\n+      final FileInputStream fIn = new FileInputStream(keyStoreFile);\n+      this.keyStore.load(fIn, null);\n+    } catch (final CertificateException\n+        | NoSuchAlgorithmException\n+        | NoSuchProviderException\n+        | IOException\n+        | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not read keystore\", e);\n     }\n-\n-    @Override\n-    public Secret decrypt(final EncryptedSecret secret, final String keyReference) {\n-\n-        Secret decryptedSecret = super.decrypt(secret, keyReference);\n-\n-        final byte[] decryptedSecretBytes = decryptedSecret.getSecret();\n-\n-        if (decryptedSecretBytes.length > KEY_LENGTH) {\n-\n-            final byte[] truncatedDecryptedSecretBytes = Arrays.copyOfRange(decryptedSecretBytes, 0,\n-                    decryptedSecretBytes.length-16);\n-\n-            LOGGER.trace(\"Truncating decrypted key from \" + Hex.encodeHexString(decryptedSecretBytes) + \" to \" +\n-                            Hex.encodeHexString(truncatedDecryptedSecretBytes));\n-\n-            decryptedSecret = new Secret(truncatedDecryptedSecretBytes);\n-        }\n-\n-        return decryptedSecret;\n+  }\n+\n+  @Override\n+  public byte[] decrypt(final EncryptedSecret secret, final String keyReference) {\n+    final byte[] decryptedSecret = super.decrypt(secret, keyReference);\n+    if (decryptedSecret.length > KEY_LENGTH) {\n+      // This provider uses NoPadding, but since decrypted byte size is bigger than key byte size,\n+      // the secrets were apparently encrypted using padding of some kind; truncate the padded\n+      // bytes.\n+      final byte[] truncatedDecryptedSecretBytes =\n+          Arrays.copyOfRange(decryptedSecret, 0, KEY_LENGTH);\n+      LOGGER.trace(\n+          \"Truncating decrypted key from \"\n+              + Hex.encodeHexString(decryptedSecret)\n+              + \" to \"\n+              + Hex.encodeHexString(truncatedDecryptedSecretBytes));\n+      return truncatedDecryptedSecretBytes;\n     }\n-\n-    @Override\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM, PROVIDER);\n-        } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n+    return decryptedSecret;\n+  }\n+\n+  @Override\n+  public byte[] generateAes128BitsSecret(final String keyReference) {\n+    try {\n+      return this.encrypt(KeyGenerator.getInstance(\"AES\").generateKey().getEncoded(), keyReference)\n+          .getSecret();\n+    } catch (final NoSuchAlgorithmException exc) {\n+      throw new EncrypterException(\"Could not generate secret\", exc);\n     }\n-\n-    /**\n-     * This method reads the 'actual' encryption key (from the database).\n-     * Normally this is the key start isValidFrom(now) and isValidUntil(now).\n-     *\n-     * @return the key that must be used for encryption/decryption\n-     */\n-    @Override\n-    protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n-        try {\n-            return this.keyStore.getKey(keyReference, null);\n-        } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n-            throw new EncrypterException(\"Could not get keystore from key\", e);\n-        }\n-    }\n-\n-    @Override\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public int getSecretByteLength() {\n+    return KEY_LENGTH;\n+  }\n+\n+  @Override\n+  protected Cipher getCipher() {\n+    try {\n+      return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    } catch (final NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException e) {\n+      throw new EncrypterException(\"Could not get cipher\", e);\n     }\n-\n-    @Override\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.HSM;\n+  }\n+\n+  /**\n+   * This method reads the encryption key specified by keyReference from the Hsm.\n+   *\n+   * @return the key that must be used for encryption/decryption\n+   */\n+  @Override\n+  protected Key getSecretEncryptionKey(final String keyReference, final int cipherMode) {\n+    try {\n+      return this.keyStore.getKey(keyReference, null);\n+    } catch (final UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {\n+      throw new EncrypterException(\"Could not get keystore from key\", e);\n     }\n-}\n\\ No newline at end of file\n+  }\n+\n+  @Override\n+  protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n+    return new IvParameterSpec(IV);\n+  }\n+\n+  @Override\n+  public EncryptionProviderType getType() {\n+    return EncryptionProviderType.HSM;\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"oid": "862ff45f0dad78e58c81214be6c772adec3d3ee6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/862ff45f0dad78e58c81214be6c772adec3d3ee6", "message": "SLIM-2077-excluded-spring-security", "committedDate": "2020-07-07T13:54:15Z", "type": "commit"}, {"oid": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "message": "SLIM-2077-review-comments", "committedDate": "2020-07-08T12:28:23Z", "type": "commit"}, {"oid": "ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ae1f1686574dd3072ce1307d9629ab84b0d6e95d", "message": "PR review changes", "committedDate": "2020-07-08T12:35:48Z", "type": "commit"}, {"oid": "452499e17c6886bd78c880364ea1e177605b885d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/452499e17c6886bd78c880364ea1e177605b885d", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-07-08T12:35:57Z", "type": "commit"}, {"oid": "90464396df4c09f1a59c8fcb11cb619705914cc4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/90464396df4c09f1a59c8fcb11cb619705914cc4", "message": "mvn POM property fixed", "committedDate": "2020-07-13T12:48:52Z", "type": "commit"}, {"oid": "1ef03c7e069dcb1f9f69e10a827e10314b9dd873", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1ef03c7e069dcb1f9f69e10a827e10314b9dd873", "message": "fixed non-running tests during Maven build", "committedDate": "2020-07-13T13:08:19Z", "type": "commit"}, {"oid": "3f6c276ffa1696b0ad2975e65974e05c77658bd0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3f6c276ffa1696b0ad2975e65974e05c77658bd0", "message": "SLIM-2077-review-comments", "committedDate": "2020-07-13T16:50:42Z", "type": "commit"}, {"oid": "1b6e76f1ae90d21483a8cb6700ced390ece6ddde", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1b6e76f1ae90d21483a8cb6700ced390ece6ddde", "message": "SLIM-2077-additional-trace-level-logging-for-test", "committedDate": "2020-07-14T12:37:29Z", "type": "commit"}, {"oid": "960d7b310d52105a83162bf24bef337b063bda42", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/960d7b310d52105a83162bf24bef337b063bda42", "message": "SLIM-2077-added-debug-level-logging", "committedDate": "2020-07-14T15:37:17Z", "type": "commit"}, {"oid": "a1bad9a2d6d8054d346efca7d9600467e429b62c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a1bad9a2d6d8054d346efca7d9600467e429b62c", "message": "SLIM-2077-added-debug-level-logging-and-logging-initializer", "committedDate": "2020-07-15T08:44:24Z", "type": "commit"}, {"oid": "3acde2e6b4750f309034f6cc5cbd0d221a0baf8e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3acde2e6b4750f309034f6cc5cbd0d221a0baf8e", "message": "SLIM-2077-adjusted-to-warn-levels", "committedDate": "2020-07-15T09:02:08Z", "type": "commit"}, {"oid": "4f568126891b2741b21365035117542af21a2a5b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4f568126891b2741b21365035117542af21a2a5b", "message": "SLIM-2077-added-debug-level-logging", "committedDate": "2020-07-15T10:33:16Z", "type": "commit"}, {"oid": "27e8524ee4835a63fc556e033e0a2213932c401f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/27e8524ee4835a63fc556e033e0a2213932c401f", "message": "SLIM-2077-moved-main-for-log-initialization", "committedDate": "2020-07-15T11:57:29Z", "type": "commit"}, {"oid": "44a3bcbb103c55ae89dcb931f229d8fda5d2bd2a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/44a3bcbb103c55ae89dcb931f229d8fda5d2bd2a", "message": "SLIM-2077-exception-now-at-max-level-max-trace", "committedDate": "2020-07-15T15:46:13Z", "type": "commit"}, {"oid": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "message": "SLIM-2077-moved-main-for-log-initialization", "committedDate": "2020-07-16T12:19:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAzMjU1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r456032552", "body": "Header is missing for this file.", "bodyText": "Header is missing for this file.", "bodyHTML": "<p dir=\"auto\">Header is missing for this file.</p>", "author": "kevinsmeets", "createdAt": "2020-07-16T19:42:07Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.config;", "originalCommit": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76c4b6da598e77347a129c0bc9fe636040c6c64c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 3666984daa..3a2efdff21 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -2,7 +2,6 @@ package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n \n import java.io.File;\n import java.io.IOException;\n-import java.security.NoSuchAlgorithmException;\n import java.security.spec.InvalidKeySpecException;\n \n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n", "next_change": {"commit": "bd58ee80242d67262adf062325925d9bcfa90694", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 3a2efdff21..ca8988b552 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -2,7 +2,6 @@ package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n \n import java.io.File;\n import java.io.IOException;\n-import java.security.spec.InvalidKeySpecException;\n \n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.springframework.beans.factory.annotation.Value;\n", "next_change": {"commit": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex ca8988b552..de794897ed 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -1,7 +1,16 @@\n+/**\n+ * Copyright 2016 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n \n import java.io.File;\n import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n \n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.springframework.beans.factory.annotation.Value;\n", "next_change": {"commit": "ed14ef97bad42284b11ab8117d86d7268281ed11", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex de794897ed..39722b9199 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -9,8 +9,6 @@ package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n \n import java.io.File;\n import java.io.IOException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.InvalidKeySpecException;\n \n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.springframework.beans.factory.annotation.Value;\n", "next_change": {"commit": "d74e3b3f5af25bee0f9ceec7e7ed907f82c15def", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 39722b9199..02a8e498f5 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -10,6 +10,7 @@ package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n import java.io.File;\n import java.io.IOException;\n \n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.springframework.beans.factory.annotation.Value;\n import org.springframework.context.annotation.Bean;\n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 02a8e498f5..d6ffd650ad 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -11,7 +11,7 @@ import java.io.File;\n import java.io.IOException;\n \n import org.apache.http.conn.ssl.NoopHostnameVerifier;\n-import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Value;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex d6ffd650ad..389c0fd67e 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -1,15 +1,15 @@\n-/**\n+/*\n  * Copyright 2016 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n  *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n+ * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n \n import java.io.File;\n import java.io.IOException;\n-\n import org.apache.http.conn.ssl.NoopHostnameVerifier;\n import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Value;\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAzMjcyMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r456032723", "body": "Header is missing for this file.", "bodyText": "Header is missing for this file.", "bodyHTML": "<p dir=\"auto\">Header is missing for this file.</p>", "author": "kevinsmeets", "createdAt": "2020-07-16T19:42:20Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;", "originalCommit": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5af7af2f0b..cab6259172 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -1,3 +1,10 @@\n+/**\n+ * Copyright 2016 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n \n import java.util.List;\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex cab6259172..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -12,25 +12,33 @@ import java.util.Optional;\n \n import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.codec.binary.Hex;\n-import org.apache.commons.lang3.NotImplementedException;\n import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n-import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalExceptionType;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.opensmartgridplatform.shared.security.RsaEncryptionService;\n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -46,7 +44,7 @@ import org.springframework.stereotype.Service;\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncryptionProvider soapSecretsRsaEncryptionProvider;\n+    private final RsaEncrypter soapSecretsRsaEncryptionProvider;\n     private final SecretManagementClient secretManagementClient;\n \n     @Autowired\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -44,7 +51,7 @@ import org.springframework.stereotype.Service;\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapSecretsRsaEncryptionProvider;\n+    private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n     @Autowired\n", "next_change": {"commit": "fe0089dac7cf66db3a9383f1198100cf4ef33395", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..6023363883 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -54,106 +50,15 @@ public class SecretManagementService implements SecurityKeyService {\n     private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n \n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n+    //@Autowired\n+    //private EncryptionService aesEncryptionService;\n \n     public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n         this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n-    }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n-    }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n-    }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n-    }\n-\n     @Override\n     public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n         LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n", "next_change": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 6023363883..8dc6ff1b8f 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -59,13 +63,33 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    //@Override\n     public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n         LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n         return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n+    /**\n+     * Retrieves the active keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    //@Override\n     public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n         GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n         GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8dc6ff1b8f..dcd861224d 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -89,7 +85,6 @@ public class SecretManagementService { //implements SecurityKeyService {\n      *\n      * @return the requested keys in a map by key type, with value NULL if not present\n      */\n-    //@Override\n     public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n         GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n         GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex dcd861224d..2a68eece74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -85,9 +83,10 @@ public class SecretManagementService {\n      *\n      * @return the requested keys in a map by key type, with value NULL if not present\n      */\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    public Map<SecurityKeyType, byte[]> getKeys(final String deviceIdentification,\n+            final List<SecurityKeyType> keyTypes) {\n+        final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n         this.validateGetResponse(keyTypes, response);\n         return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2a68eece74..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -43,321 +42,336 @@ import org.springframework.stereotype.Service;\n \n @Service\n /**\n- * Service for storing, activating and retrieving device keys.\n- * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n- */ public class SecretManagementService {\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n \n-    /**\n-     * Retrieve an active key of a certain type for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyType\n-     *         the requested key type\n-     *\n-     * @return the key or NULL if not present\n-     */\n-    public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        if (LOGGER.isInfoEnabled()) {\n-            LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        }\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n \n-    /**\n-     * Retrieves the active keys of requested types for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyTypes\n-     *         the requested key types\n-     *\n-     * @return the requested keys in a map by key type, with value NULL if not present\n-     */\n-    public Map<SecurityKeyType, byte[]> getKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n-    }\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n \n-    /**\n-     * Retrieve a new (not yet activated) key of a certain type for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyType\n-     *         the requested key type\n-     *\n-     * @return the key or NULL if not present\n-     */\n-    public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        if (LOGGER.isInfoEnabled()) {\n-            LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n-        }\n-        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n \n-    /**\n-     * Retrieves the new (not yet activated) keys of requested types for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyTypes\n-     *         the requested key types\n-     *\n-     * @return the requested keys in a map by key type, with value NULL if not present\n-     */\n-    public Map<SecurityKeyType, byte[]> getNewKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n-        final GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n-        this.validateGetNewResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n-    }\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n \n-    private void validateGetResponse(final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n-        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n-                response.getTypedSecrets(), keyTypes.size());\n-    }\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n \n-    private void validateGetNewResponse(final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n-        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n-                response.getTypedSecrets(), keyTypes.size());\n-    }\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n \n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(final List<TypedSecret> soapSecrets) {\n-        final Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n-        final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n-        soapSecrets.forEach(ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n-        return decryptedKeysByType;\n-    }\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n \n-    private GetSecretsRequest createGetSecretsRequest(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n \n-    private GetNewSecretsRequest createGetNewSecretsRequest(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetNewSecretsRequest request = new GetNewSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n \n-    /**\n-     * Store new key\n-     * <p>\n-     * A new key is a security key with a device which status NEW.\n-     * This status is used when the new key is known, but not yet set on the device.\n-     * <p>\n-     * <strong>CAUTION:</strong> Only call this method when a successful\n-     * connection with the device has been set up (that is: a valid\n-     * communication key that works is known), and you are sure any existing new\n-     * key data that is not activated yet (for instance a new key stored earlier in an\n-     * attempt to replace the communication key that got aborted).<br>\n-     * <p>\n-     * The moment the new key is known to be transferred to the device, make\n-     * sure to activate it by calling\n-     * {@link #activateNewKey(String, SecurityKeyType)}.\n-     *\n-     * @param deviceIdentification\n-     *         DLMS device id\n-     * @param key\n-     *         key to store, unencrypted\n-     * @param keyType\n-     *         type of key\n-     *\n-     * @see #activateNewKey(String, SecurityKeyType)\n-     */\n-    public void storeNewKey(final String deviceIdentification, final SecurityKeyType keyType, byte[] key) {\n-        final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n-        keysByType.put(keyType, key);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n \n-    public void storeNewKeys(final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n-        this.validateKeys(keysByType);\n-        final TypedSecrets typedSecrets = new TypedSecrets();\n-        final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(entry.getKey().toSecretType());\n-            ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n-            typedSecretList.add(ts);\n-        }\n-        final StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        StoreSecretsResponse response = null;\n-        try {\n-            response = this.secretManagementClient.storeSecretsRequest(request);\n-        } catch (RuntimeException exc) {\n-            throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n-        }\n-        if (response == null) {\n-            throw new IllegalStateException(\"Could not store keys: NULL response\");\n-        } else if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    String.format(\"Could not store keys: result=%s; fault=%s\", response.getResult(),\n-                            response.getTechnicalFault()));\n-        }\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n-        final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n-        if (nrNulls > 0) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(final String deviceIdentification,\n-            final TypedSecrets typedSecrets) {\n-        final StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    /**\n-     * Updates the state of a new key from 'new' to 'active'\n-     * <p>\n-     * This method should be called to activate a new key stored with\n-     * {@link #storeNewKeys(String, Map)} after it has\n-     * been confirmed to be set on the device.\n-     *\n-     * @param deviceIdentification\n-     *         DLMS device id\n-     * @param keyType\n-     *         type of key\n-     *\n-     * @see #storeNewKeys(String, Map)\n-     */\n-    public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n+  }\n \n-    public void activateNewKeys(final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n-        final ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        this.secretManagementClient.activateSecretsRequest(request);\n-    }\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n \n-    public boolean hasNewSecretOfType(final String deviceIdentification, final SecurityKeyType keyType) {\n-        final HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n \n-    public byte[] generate128BitsKeyAndStoreAsNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n-    }\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n \n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final SecretTypes secretTypes = new SecretTypes();\n-        final GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n \n-        final GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        final TypedSecrets typedSecrets = response.getTypedSecrets();\n-        final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n-    }\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n \n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(final String deviceIdentification,\n-            final SecretTypes secretTypes) {\n-        final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n-    private void validateGenerateAndStoreResponse(final List<SecurityKeyType> keyTypes,\n-            final GenerateAndStoreSecretsResponse response, final List<TypedSecret> typedSecretList) {\n-        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n-                response.getTypedSecrets(), keyTypes.size());\n-        typedSecretList.forEach(ts -> {\n-            if (ts.getSecret() == null) {\n-                throw new IllegalStateException(String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n-            }\n-        });\n-    }\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n \n-    private void validateOsgpResultAndTypedSecrets(final OsgpResultType result, final Object fault,\n-            final TypedSecrets typedSecrets, final int expectedNrKeys) {\n-        if (!OsgpResultType.OK.equals(result)) {\n-            throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n-        } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n-            throw new IllegalStateException(\"No secrets in response\");\n-        } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    String.format(\"Unexpected number of secrets in response: expected %s but found %s\", expectedNrKeys,\n-                            typedSecrets.getTypedSecret().size()));\n-        }\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n+  }\n \n-    private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n-        boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n-        if (exceptionOnNull && nullValue) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n-        } else if (!exceptionOnNull && nullValue) {\n-            return null;\n-        }\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n+    }\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n+  }\n \n-    private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n-        boolean nullValue = secret == null || secret.length == 0;\n-        if (exceptionOnNull && nullValue) {\n-            throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n-        } else if (!exceptionOnNull && nullValue) {\n-            return null;\n-        }\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n+    }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -53,9 +60,8 @@ public class SecretManagementService implements SecurityKeyService {\n     @Autowired\n     private EncryptionService aesEncryptionService;\n \n-    public SecretManagementService(RsaEncrypter soapSecretsRsaEncryptionProvider,\n-            SecretManagementClient secretManagementClient) {\n-        this.soapSecretsRsaEncryptionProvider = soapSecretsRsaEncryptionProvider;\n+    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n+        this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n", "next_change": {"commit": "b66ad7da974da5fb9e814d3d24b293b6cb899084", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..72a55789a5 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -65,92 +67,13 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n-    }\n-\n     @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n+    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) throws FunctionalException {\n         try {\n             return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n         } catch (final Exception e) {\n             LOGGER.error(\"Unexpected exception during decryption\", e);\n             throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n-    }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n-    }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n         }\n     }\n \n", "next_change": {"commit": "fe0089dac7cf66db3a9383f1198100cf4ef33395", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 72a55789a5..6023363883 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -56,27 +50,15 @@ public class SecretManagementService implements SecurityKeyService {\n     private final RsaEncrypter soapRsaEncrypter;\n     private final SecretManagementClient secretManagementClient;\n \n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n \n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n+    //@Autowired\n+    //private EncryptionService aesEncryptionService;\n \n     public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n         this.soapRsaEncrypter = soapRsaEncrypter;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) throws FunctionalException {\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n-    }\n-\n     @Override\n     public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n         LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n", "next_change": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 6023363883..8dc6ff1b8f 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -59,13 +63,33 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n+    /**\n+     * Retrieve an active key of a certain type for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyType\n+     *         the requested key type\n+     *\n+     * @return the key or NULL if not present\n+     */\n+    //@Override\n     public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n         LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n         return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n     }\n \n-    @Override\n+    /**\n+     * Retrieves the active keys of requested types for a specified device\n+     *\n+     * @param deviceIdentification\n+     *         the device identification string of the device\n+     * @param keyTypes\n+     *         the requested key types\n+     *\n+     * @return the requested keys in a map by key type, with value NULL if not present\n+     */\n+    //@Override\n     public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n         GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n         GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8dc6ff1b8f..dcd861224d 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -89,7 +85,6 @@ public class SecretManagementService { //implements SecurityKeyService {\n      *\n      * @return the requested keys in a map by key type, with value NULL if not present\n      */\n-    //@Override\n     public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n         GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n         GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex dcd861224d..2a68eece74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -85,9 +83,10 @@ public class SecretManagementService {\n      *\n      * @return the requested keys in a map by key type, with value NULL if not present\n      */\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    public Map<SecurityKeyType, byte[]> getKeys(final String deviceIdentification,\n+            final List<SecurityKeyType> keyTypes) {\n+        final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+        final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n         this.validateGetResponse(keyTypes, response);\n         return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n     }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2a68eece74..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -43,321 +42,336 @@ import org.springframework.stereotype.Service;\n \n @Service\n /**\n- * Service for storing, activating and retrieving device keys.\n- * Also performs RSA encryption/decryption operations for SOAP messaging purposes.\n- */ public class SecretManagementService {\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n \n-    /**\n-     * Retrieve an active key of a certain type for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyType\n-     *         the requested key type\n-     *\n-     * @return the key or NULL if not present\n-     */\n-    public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        if (LOGGER.isInfoEnabled()) {\n-            LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        }\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n \n-    /**\n-     * Retrieves the active keys of requested types for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyTypes\n-     *         the requested key types\n-     *\n-     * @return the requested keys in a map by key type, with value NULL if not present\n-     */\n-    public Map<SecurityKeyType, byte[]> getKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n-    }\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n \n-    /**\n-     * Retrieve a new (not yet activated) key of a certain type for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyType\n-     *         the requested key type\n-     *\n-     * @return the key or NULL if not present\n-     */\n-    public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        if (LOGGER.isInfoEnabled()) {\n-            LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n-        }\n-        return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n \n-    /**\n-     * Retrieves the new (not yet activated) keys of requested types for a specified device\n-     *\n-     * @param deviceIdentification\n-     *         the device identification string of the device\n-     * @param keyTypes\n-     *         the requested key types\n-     *\n-     * @return the requested keys in a map by key type, with value NULL if not present\n-     */\n-    public Map<SecurityKeyType, byte[]> getNewKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetNewSecretsRequest request = this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n-        final GetNewSecretsResponse response = this.secretManagementClient.getNewSecretsRequest(request);\n-        this.validateGetNewResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n-    }\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n \n-    private void validateGetResponse(final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n-        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n-                response.getTypedSecrets(), keyTypes.size());\n-    }\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n \n-    private void validateGetNewResponse(final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n-        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n-                response.getTypedSecrets(), keyTypes.size());\n-    }\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n \n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(final List<TypedSecret> soapSecrets) {\n-        final Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n-        final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n-        soapSecrets.forEach(ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n-        return decryptedKeysByType;\n-    }\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n \n-    private GetSecretsRequest createGetSecretsRequest(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n \n-    private GetNewSecretsRequest createGetNewSecretsRequest(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final GetNewSecretsRequest request = new GetNewSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n \n-    /**\n-     * Store new key\n-     * <p>\n-     * A new key is a security key with a device which status NEW.\n-     * This status is used when the new key is known, but not yet set on the device.\n-     * <p>\n-     * <strong>CAUTION:</strong> Only call this method when a successful\n-     * connection with the device has been set up (that is: a valid\n-     * communication key that works is known), and you are sure any existing new\n-     * key data that is not activated yet (for instance a new key stored earlier in an\n-     * attempt to replace the communication key that got aborted).<br>\n-     * <p>\n-     * The moment the new key is known to be transferred to the device, make\n-     * sure to activate it by calling\n-     * {@link #activateNewKey(String, SecurityKeyType)}.\n-     *\n-     * @param deviceIdentification\n-     *         DLMS device id\n-     * @param key\n-     *         key to store, unencrypted\n-     * @param keyType\n-     *         type of key\n-     *\n-     * @see #activateNewKey(String, SecurityKeyType)\n-     */\n-    public void storeNewKey(final String deviceIdentification, final SecurityKeyType keyType, byte[] key) {\n-        final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n-        keysByType.put(keyType, key);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n \n-    public void storeNewKeys(final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n-        this.validateKeys(keysByType);\n-        final TypedSecrets typedSecrets = new TypedSecrets();\n-        final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(entry.getKey().toSecretType());\n-            ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n-            typedSecretList.add(ts);\n-        }\n-        final StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        StoreSecretsResponse response = null;\n-        try {\n-            response = this.secretManagementClient.storeSecretsRequest(request);\n-        } catch (RuntimeException exc) {\n-            throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n-        }\n-        if (response == null) {\n-            throw new IllegalStateException(\"Could not store keys: NULL response\");\n-        } else if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    String.format(\"Could not store keys: result=%s; fault=%s\", response.getResult(),\n-                            response.getTechnicalFault()));\n-        }\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n-        final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n-        if (nrNulls > 0) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(final String deviceIdentification,\n-            final TypedSecrets typedSecrets) {\n-        final StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    /**\n-     * Updates the state of a new key from 'new' to 'active'\n-     * <p>\n-     * This method should be called to activate a new key stored with\n-     * {@link #storeNewKeys(String, Map)} after it has\n-     * been confirmed to be set on the device.\n-     *\n-     * @param deviceIdentification\n-     *         DLMS device id\n-     * @param keyType\n-     *         type of key\n-     *\n-     * @see #storeNewKeys(String, Map)\n-     */\n-    public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n+  }\n \n-    public void activateNewKeys(final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n-        final ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        this.secretManagementClient.activateSecretsRequest(request);\n-    }\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n \n-    public boolean hasNewSecretOfType(final String deviceIdentification, final SecurityKeyType keyType) {\n-        final HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n \n-    public byte[] generate128BitsKeyAndStoreAsNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n-    }\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n \n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes) {\n-        final SecretTypes secretTypes = new SecretTypes();\n-        final GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n \n-        final GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        final TypedSecrets typedSecrets = response.getTypedSecrets();\n-        final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n-    }\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n \n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(final String deviceIdentification,\n-            final SecretTypes secretTypes) {\n-        final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n-    private void validateGenerateAndStoreResponse(final List<SecurityKeyType> keyTypes,\n-            final GenerateAndStoreSecretsResponse response, final List<TypedSecret> typedSecretList) {\n-        this.validateOsgpResultAndTypedSecrets(response.getResult(), response.getTechnicalFault(),\n-                response.getTypedSecrets(), keyTypes.size());\n-        typedSecretList.forEach(ts -> {\n-            if (ts.getSecret() == null) {\n-                throw new IllegalStateException(String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n-            }\n-        });\n-    }\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n \n-    private void validateOsgpResultAndTypedSecrets(final OsgpResultType result, final Object fault,\n-            final TypedSecrets typedSecrets, final int expectedNrKeys) {\n-        if (!OsgpResultType.OK.equals(result)) {\n-            throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n-        } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n-            throw new IllegalStateException(\"No secrets in response\");\n-        } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    String.format(\"Unexpected number of secrets in response: expected %s but found %s\", expectedNrKeys,\n-                            typedSecrets.getTypedSecret().size()));\n-        }\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n+  }\n \n-    private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n-        boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n-        if (exceptionOnNull && nullValue) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n-        } else if (!exceptionOnNull && nullValue) {\n-            return null;\n-        }\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n+    }\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n+  }\n \n-    private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n-        boolean nullValue = secret == null || secret.length == 0;\n-        if (exceptionOnNull && nullValue) {\n-            throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n-        } else if (!exceptionOnNull && nullValue) {\n-            return null;\n-        }\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n+    }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAzMjk1Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r456032953", "body": "Header is missing for this file.", "bodyText": "Header is missing for this file.", "bodyHTML": "<p dir=\"auto\">Header is missing for this file.</p>", "author": "kevinsmeets", "createdAt": "2020-07-16T19:42:35Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient;", "originalCommit": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 362c5e30ff..811d1c0cc2 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -1,3 +1,10 @@\n+/**\n+ * Copyright 2016 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient;\n \n import lombok.extern.slf4j.Slf4j;\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 811d1c0cc2..a4ffa5e674 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -8,9 +8,14 @@\n package org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient;\n \n import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.springframework.stereotype.Component;\n", "next_change": {"commit": "fbdb92d61e267dcd963e7490941e8b628efeb594", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex a4ffa5e674..9ee257a467 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -12,6 +12,8 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecret\n import org.opensmartgridplatform.ws.schema.core.secret.management.ActivateSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GenerateAndStoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetNewSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRequest;\n", "next_change": {"commit": "ee07b18fb34cda88d8e134059b2e2527c3dc5e84", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 9ee257a467..b2524e7e00 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -20,6 +19,8 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRe\n import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n import org.springframework.ws.client.core.WebServiceTemplate;\n \n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex b2524e7e00..c8d3fb04ef 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -24,63 +25,65 @@ import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n import org.springframework.ws.client.core.WebServiceTemplate;\n \n-/**\n- * SOAP Client for SecretManagement\n- */\n+/** SOAP Client for SecretManagement */\n @Component\n public class SecretManagementClient {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n-    private final WebServiceTemplate webServiceTemplate;\n+  private final WebServiceTemplate webServiceTemplate;\n \n-    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n-        this.webServiceTemplate = webServiceTemplate;\n-    }\n+  SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n+    this.webServiceTemplate = webServiceTemplate;\n+  }\n \n-    public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n+  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GetNewSecretsResponse getNewSecretsRequest(GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetNewSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (StoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (ActivateSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (HasNewSecretResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n-                request.getDeviceId());\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n+      final GenerateAndStoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n }\n", "next_change": {"commit": "bae6f663b4100b43f076c7fe499728b5749dc28f", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex c8d3fb04ef..a2e70a7226 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -20,70 +23,102 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRe\n import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceMessageCallback;\n import org.springframework.ws.client.core.WebServiceTemplate;\n+import org.springframework.ws.soap.SoapHeader;\n+import org.springframework.ws.soap.SoapMessage;\n \n /** SOAP Client for SecretManagement */\n+@Slf4j\n @Component\n public class SecretManagementClient {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+  private static final String CORRELATION_UID = \"correlationUid\";\n   private final WebServiceTemplate webServiceTemplate;\n \n   SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n     this.webServiceTemplate = webServiceTemplate;\n   }\n \n-  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n+  private WebServiceMessageCallback createCorrelationHeaderCallback(\n+      final MessageMetadata messageMetadata) {\n+    return message -> {\n+      final SoapMessage soapMessage = (SoapMessage) message;\n+      final SoapHeader header = soapMessage.getSoapHeader();\n+      header\n+          .addHeaderElement(new QName(NAMESPACE_URI, CORRELATION_UID))\n+          .setText(messageMetadata.getCorrelationUid());\n+    };\n+  }\n+\n+  public GetSecretsResponse getSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetNewSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetNewSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n-    LOGGER.info(\n+  public StoreSecretsResponse storeSecretsRequest(\n+      final MessageMetadata messageMetadata, final StoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (StoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n-    LOGGER.info(\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      final MessageMetadata messageMetadata, final ActivateSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (ActivateSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n-    LOGGER.info(\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      final MessageMetadata messageMetadata, final HasNewSecretRequest request) {\n+    log.info(\n         \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (HasNewSecretResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n   public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n-      final GenerateAndStoreSecretsRequest request) {\n-    LOGGER.info(\n+      final MessageMetadata messageMetadata, final GenerateAndStoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GenerateAndStoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAzMzY3Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r456033677", "body": "Header is missing for this file.", "bodyText": "Header is missing for this file.", "bodyHTML": "<p dir=\"auto\">Header is missing for this file.</p>", "author": "kevinsmeets", "createdAt": "2020-07-16T19:43:32Z", "path": "osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opensmartgridplatform.shared.security.providers;", "originalCommit": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex d6a3864758..591396bf8b 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -1,5 +1,10 @@\n package org.opensmartgridplatform.shared.security.providers;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.Files;\n", "next_change": {"commit": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 591396bf8b..505f35615a 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -1,10 +1,13 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n package org.opensmartgridplatform.shared.security.providers;\n \n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.Files;\n", "next_change": {"commit": "ed14ef97bad42284b11ab8117d86d7268281ed11", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\nindex 505f35615a..a16a8a50c2 100644\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n", "chunk": "@@ -8,6 +8,11 @@\n  */\n package org.opensmartgridplatform.shared.security.providers;\n \n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.Files;\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java b/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\ndeleted file mode 100644\nindex a16a8a50c2..0000000000\n--- a/osgp/shared/shared/src/main/java/org/opensmartgridplatform/shared/security/providers/RsaEncryptionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,77 +0,0 @@\n-/**\n- * Copyright 2020 Smart Society Services B.V.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- */\n-package org.opensmartgridplatform.shared.security.providers;\n-\n-import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.NoSuchPaddingException;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.security.spec.InvalidKeySpecException;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.spec.X509EncodedKeySpec;\n-\n-public class RsaEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n-\n-    private static final String ALG = \"RSA\";\n-    private static final String ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n-\n-    private Key publicKey;\n-    private Key privateKey;\n-\n-    public void setPrivateKeyStore(File privateKeyStoreFile) {\n-        try {\n-        byte[] keyData = Files.readAllBytes(privateKeyStoreFile.toPath());\n-        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyData);\n-        privateKey = KeyFactory.getInstance(ALG).generatePrivate(privateKeySpec);\n-        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-        super.setKeyFile(privateKeyStoreFile);\n-    }\n-\n-    public void setPublicKeyStore(File publicKeyStoreFile) {\n-        try {\n-            byte[] keyData = Files.readAllBytes(publicKeyStoreFile.toPath());\n-            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyData);\n-            publicKey = KeyFactory.getInstance(ALG).generatePublic(publicKeySpec);\n-        }\n-        catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n-            throw new EncrypterException(\"Could not set public keystore\", e);\n-        }\n-    }\n-\n-    protected Cipher getCipher() {\n-        try {\n-            return Cipher.getInstance(ALGORITHM);\n-        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {\n-            throw new EncrypterException(\"Could not get cipher\", e);\n-        }\n-    }\n-\n-    protected Key getSecretEncryptionKey(String key, int cipherMode) {\n-        return cipherMode == Cipher.ENCRYPT_MODE ? publicKey : privateKey;\n-    }\n-\n-    protected AlgorithmParameterSpec getAlgorithmParameterSpec() {\n-        return null;\n-    }\n-\n-    public EncryptionProviderType getType() {\n-        return EncryptionProviderType.RSA;\n-    }\n-}\n-\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAzNDQ3NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r456034475", "body": "Header is missing for this file.", "bodyText": "Header is missing for this file.", "bodyHTML": "<p dir=\"auto\">Header is missing for this file.</p>", "author": "kevinsmeets", "createdAt": "2020-07-16T19:44:48Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java", "diffHunk": "@@ -1,503 +1,23 @@\n-/**\n- * Copyright 2017 Smart Society Services B.V.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.services;", "originalCommit": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\nindex 54f6b6b3ff..abff08c1c8 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n", "chunk": "@@ -1,3 +1,10 @@\n+/**\n+ * Copyright 2016 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n \n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n", "next_change": {"commit": "29332318c26597d383f0866d6fcb516519277d71", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\nindex abff08c1c8..4e7ab18f9c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n", "chunk": "@@ -13,18 +13,120 @@ import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapte\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n \n public interface SecurityKeyService {\n-    byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n-    byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException;\n-    byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException;\n+\n+    //get decrypted keys\n     byte[] getDlmsMasterKey(final String deviceIdentification);\n     byte[] getDlmsAuthenticationKey(final String deviceIdentification);\n     byte[] getDlmsGlobalUnicastEncryptionKey(final String deviceIdentification);\n-    byte[] getMbusDefaultKey(final String mbusDeviceIdentification);\n-    byte[] getMbusUserKey(final String mbusDeviceIdentification);\n-    byte[] getDlmsPassword(final String deviceIdentification);\n+    byte[] getMbusDefaultKey(final String mbusDeviceIdentification); //G_MASTER key\n+    byte[] getDlmsPassword(final String deviceIdentification); //PPP_PASSWORD\n+    byte[] getMbusUserKey(final String mbusDeviceIdentification); //G_METER_ENCRYPTION_KEY, currently not used\n+\n+    /**\n+     * Store new key\n+     * <p>\n+     * A new key is a security key with a device that does not have a valid from\n+     * date. This situation occurs in the process of updating a key, when the\n+     * new key is known, but not yet set on the device.\n+     * <p>\n+     * <strong>CAUTION:</strong> Only call this method when a successful\n+     * connection with the device has been set up (that is: a valid\n+     * communication key that works is known), and you are sure any existing new\n+     * key data is NOT VALID (for instance a new key stored earlier in an\n+     * attempt to replace the communication key that got aborted).<br>\n+     * <strong>This method will throw away any earlier stored new key and\n+     * replace it.</strong>\n+     * <p>\n+     * The moment the new key is known to be transferred to the device, make\n+     * sure to update its status from a new key to a valid key (and invalidating\n+     * any previous key) by calling\n+     * {@link #validateNewKey(DlmsDevice, SecurityKeyType)}.\n+     *\n+     * @param device\n+     *         DLMS device\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @return saved device, with a new key of the given type\n+     *\n+     * @see #validateNewKey(DlmsDevice, SecurityKeyType)\n+     */\n     DlmsDevice storeNewKey(final DlmsDevice device, final byte[] encryptedKey, final SecurityKeyType keyType);\n+\n+    /**\n+     * Updates the state of a new key (having valid from date {@code null}) to\n+     * be considered valid (setting valid from to now).<br>\n+     * This invalidates any previous valid key (setting valid of the previous\n+     * key to now).\n+     * <p>\n+     * This method should be called to validate a new key stored with\n+     * {@link #storeNewKey(DlmsDevice, byte[], SecurityKeyType)} after it has\n+     * been confirmed to be set on the device.\n+     *\n+     * @param device\n+     *         DLMS device\n+     * @param keyType\n+     *         type of key\n+     *\n+     * @return saved device, with a new security key that has become valid, and\n+     *         any previously valid security key marked as no longer valid\n+     *\n+     * @throws ProtocolAdapterException\n+     *         if no new key is stored with the given device\n+     * @see #storeNewKey(DlmsDevice, byte[], SecurityKeyType)\n+     */\n     DlmsDevice validateNewKey(final DlmsDevice device, final SecurityKeyType keyType) throws ProtocolAdapterException;\n+\n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 16-byte AES key.\n+     */\n     byte[] generateKey();\n+\n+    /**\n+     * Convenience method to generate a new key that does not need to be used\n+     * immediately, and return it appropriately encrypted (AES) with the secret key\n+     * for the DLMS protocol adapter.\n+     *\n+     * @return a new encrypted key.\n+     *\n+     * @see #generateKey()\n+     */\n     byte[] generateAndEncryptKey();\n-    byte[] encryptMbusUserKey(final byte[] mbusDefaultKey, final byte[] mbusUserKey) throws ProtocolAdapterException;\n+\n+    //RSA decrypt key (from incoming requests) and encrypt with AES (for in memory storage)\n+    byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n+\n+    //AES decrypt (decrypt memory storage for actual use of key)\n+    byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException;\n+\n+    //AES encrypt (encrypt for safe memory storage)\n+    byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException;\n+\n+    //Note this method is moved to the appropriate command since it seems to be DSMR specific\n+    /**\n+     * Encrypts a new M-Bus User key with the M-Bus Default key for use as M-Bus\n+     * Client Setup transfer_key parameter.\n+     * <p>\n+     * Note that the specifics of the encryption of the M-Bus User key depend on\n+     * the M-Bus version the devices support. This method should be appropriate\n+     * for use with DSMR 4 M-Bus devices.\n+     * <p>\n+     * The encryption is performed by applying an AES/CBC/NoPadding cipher\n+     * initialized for encryption with the given mbusDefaultKey and an\n+     * initialization vector of 16 zero-bytes to the given mbusUserKey.\n+     *\n+     * @return the properly wrapped User key for a DSMR 4 M-Bus User key change.\n+     *\n+    public byte[] encryptMbusUserKey(final byte[] mbusDefaultKey, final byte[] mbusUserKey)\n+            throws ProtocolAdapterException {}\n+    */\n }\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\nindex 4e7ab18f9c..7f696e9b10 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n", "chunk": "@@ -88,45 +89,21 @@ public interface SecurityKeyService {\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n      * @return a new 16-byte AES key.\n-     */\n-    byte[] generateKey();\n-\n-    /**\n-     * Convenience method to generate a new key that does not need to be used\n-     * immediately, and return it appropriately encrypted (AES) with the secret key\n-     * for the DLMS protocol adapter.\n-     *\n-     * @return a new encrypted key.\n      *\n-     * @see #generateKey()\n-     */\n-    byte[] generateAndEncryptKey();\n+    byte[] generateAES128BitsKey();*/\n+\n+    byte[][] generateAES128BitsKeysAndStoreAsNewKeys(final String deviceIdentification,\n+            final SecurityKeyType[] keyTypes);\n \n     //RSA decrypt key (from incoming requests) and encrypt with AES (for in memory storage)\n     byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n \n+    byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n+\n     //AES decrypt (decrypt memory storage for actual use of key)\n-    byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException;\n+    byte[] aesDecryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n \n     //AES encrypt (encrypt for safe memory storage)\n-    byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException;\n+    byte[] aesEncryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws FunctionalException;\n \n-    //Note this method is moved to the appropriate command since it seems to be DSMR specific\n-    /**\n-     * Encrypts a new M-Bus User key with the M-Bus Default key for use as M-Bus\n-     * Client Setup transfer_key parameter.\n-     * <p>\n-     * Note that the specifics of the encryption of the M-Bus User key depend on\n-     * the M-Bus version the devices support. This method should be appropriate\n-     * for use with DSMR 4 M-Bus devices.\n-     * <p>\n-     * The encryption is performed by applying an AES/CBC/NoPadding cipher\n-     * initialized for encryption with the given mbusDefaultKey and an\n-     * initialization vector of 16 zero-bytes to the given mbusUserKey.\n-     *\n-     * @return the properly wrapped User key for a DSMR 4 M-Bus User key change.\n-     *\n-    public byte[] encryptMbusUserKey(final byte[] mbusDefaultKey, final byte[] mbusUserKey)\n-            throws ProtocolAdapterException {}\n-    */\n }\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\nindex 7f696e9b10..3a1ca518a4 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n", "chunk": "@@ -77,33 +71,26 @@ public interface SecurityKeyService {\n      *\n      * @throws ProtocolAdapterException\n      *         if no new key is stored with the given device\n-     * @see #storeNewKeys(String, SecurityKeyType[], byte[][])\n+     * @see #storeNewKeys(String, Map)\n      */\n-    void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) throws ProtocolAdapterException;\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 16-byte AES key.\n-     *\n-    byte[] generateAES128BitsKey();*/\n+    void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType)\n+            throws ProtocolAdapterException;\n \n-    byte[][] generateAES128BitsKeysAndStoreAsNewKeys(final String deviceIdentification,\n-            final SecurityKeyType[] keyTypes);\n+    byte[] generate128BitsKeyAndStoreAsNewKey(final String deviceIdentification, final SecurityKeyType keyType);\n+    Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(final String deviceIdentification,\n+            final List<SecurityKeyType> keyTypes);\n \n     //RSA decrypt key (from incoming requests) and encrypt with AES (for in memory storage)\n-    byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n+    byte[] reEncryptKey(final byte[] externallyEncryptedKey) throws\n+            FunctionalException;\n \n-    byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n+    //decrypt OSGP provided RSA key\n+    byte[] rsaDecrypt(final byte[] externallyEncryptedKey) throws FunctionalException;\n \n     //AES decrypt (decrypt memory storage for actual use of key)\n-    byte[] aesDecryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws FunctionalException;\n+    byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException;\n \n     //AES encrypt (encrypt for safe memory storage)\n-    byte[] aesEncryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws FunctionalException;\n+    //byte[] aesEncryptKey(final byte[] plainKey/*, final SecurityKeyType keyType*/) throws FunctionalException;\n \n }\n", "next_change": {"commit": "1bfc9d37938969b827ee32c6f16610e78c38383d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\nindex 3a1ca518a4..d8c3e8808c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n", "chunk": "@@ -91,6 +96,6 @@ public interface SecurityKeyService {\n     byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException;\n \n     //AES encrypt (encrypt for safe memory storage)\n-    //byte[] aesEncryptKey(final byte[] plainKey/*, final SecurityKeyType keyType*/) throws FunctionalException;\n+    byte[] aesEncryptKey(final byte[] plainKey) throws FunctionalException;\n \n }\n", "next_change": {"commit": "76145a0fbfbae2dba2433ee1ef5cc8414caadd73", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\nindex d8c3e8808c..e658dadfa3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n", "chunk": "@@ -86,16 +86,16 @@ public interface SecurityKeyService {\n             final List<SecurityKeyType> keyTypes);\n \n     //RSA decrypt key (from incoming requests) and encrypt with AES (for in memory storage)\n-    byte[] reEncryptKey(final byte[] externallyEncryptedKey) throws\n-            FunctionalException;\n+    //byte[] reEncryptKey(final byte[] externallyEncryptedKey) throws\n+    //        FunctionalException;\n \n     //decrypt OSGP provided RSA key\n     byte[] rsaDecrypt(final byte[] externallyEncryptedKey) throws FunctionalException;\n \n     //AES decrypt (decrypt memory storage for actual use of key)\n-    byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException;\n+    //byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException;\n \n     //AES encrypt (encrypt for safe memory storage)\n-    byte[] aesEncryptKey(final byte[] plainKey) throws FunctionalException;\n+    //byte[] aesEncryptKey(final byte[] plainKey) throws FunctionalException;\n \n }\n", "next_change": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\ndeleted file mode 100644\nindex e658dadfa3..0000000000\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecurityKeyService.java\n+++ /dev/null\n", "chunk": "@@ -1,101 +0,0 @@\n-/**\n- * Copyright 2016 Smart Society Services B.V.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- */\n-package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n-import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-\n-public interface SecurityKeyService {\n-\n-    byte[] getKey(String deviceIdentification, SecurityKeyType type);\n-    Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes);\n-\n-    byte[] getNewKey(String deviceIdentification, SecurityKeyType type);\n-    Map<SecurityKeyType, byte[]> getNewKeys(String deviceIdentification, List<SecurityKeyType> keyTypes);\n-\n-    /**\n-     * Store new key\n-     * <p>\n-     * A new key is a security key with a device which status NEW.\n-     * This status is used when the new key is known, but not yet set on the device.\n-     * <p>\n-     * <strong>CAUTION:</strong> Only call this method when a successful\n-     * connection with the device has been set up (that is: a valid\n-     * communication key that works is known), and you are sure any existing new\n-     * key data that is not activated yet (for instance a new key stored earlier in an\n-     * attempt to replace the communication key that got aborted).<br>\n-     * <p>\n-     * The moment the new key is known to be transferred to the device, make\n-     * sure to activate it by calling\n-     * {@link #activateNewKey(String, SecurityKeyType)}.\n-     *\n-     * @param deviceIdentification\n-     *         DLMS device id\n-     * @param key\n-     *        key to store, unencrypted\n-     * @param keyType\n-     *         type of key\n-     *\n-     *\n-     * @see #activateNewKey(String, SecurityKeyType)\n-     */\n-    void storeNewKey(final String deviceIdentification, final SecurityKeyType keyType, final byte[] key);\n-    void storeNewKeys(final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType);\n-\n-    /**\n-     * @see #storeNewKey(String, SecurityKeyType, byte[])\n-     */\n-    //void aesDecryptAndStoreNewKey(final String deviceIdentification, final SecurityKeyType keyTypes,\n-    //        final byte[] aesEncryptedKeys) throws FunctionalException;\n-\n-    boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType);\n-\n-    /**\n-     * Updates the state of a new key from 'new' to 'active'\n-     * <p>\n-     * This method should be called to activate a new key stored with\n-     * {@link #storeNewKeys(String, Map)} after it has\n-     * been confirmed to be set on the device.\n-     *\n-     * @param deviceIdentification\n-     *         DLMS device id\n-     * @param keyType\n-     *         type of key\n-     *\n-     * @throws ProtocolAdapterException\n-     *         if no new key is stored with the given device\n-     * @see #storeNewKeys(String, Map)\n-     */\n-    void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType)\n-            throws ProtocolAdapterException;\n-    void activateNewKeys(final String deviceIdentification, final List<SecurityKeyType> keyTypes)\n-            throws ProtocolAdapterException;\n-\n-    byte[] generate128BitsKeyAndStoreAsNewKey(final String deviceIdentification, final SecurityKeyType keyType);\n-    Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(final String deviceIdentification,\n-            final List<SecurityKeyType> keyTypes);\n-\n-    //RSA decrypt key (from incoming requests) and encrypt with AES (for in memory storage)\n-    //byte[] reEncryptKey(final byte[] externallyEncryptedKey) throws\n-    //        FunctionalException;\n-\n-    //decrypt OSGP provided RSA key\n-    byte[] rsaDecrypt(final byte[] externallyEncryptedKey) throws FunctionalException;\n-\n-    //AES decrypt (decrypt memory storage for actual use of key)\n-    //byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException;\n-\n-    //AES encrypt (encrypt for safe memory storage)\n-    //byte[] aesEncryptKey(final byte[] plainKey) throws FunctionalException;\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA2ODQ3NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r456068475", "body": "Spring Boot will override the property `logging.config`.", "bodyText": "Spring Boot will override the property logging.config.", "bodyHTML": "<p dir=\"auto\">Spring Boot will override the property <code>logging.config</code>.</p>", "author": "kevinsmeets", "createdAt": "2020-07-16T20:47:47Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;\n+import org.springframework.boot.builder.SpringApplicationBuilder;\n+import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\n+import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.context.annotation.PropertySource;\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import java.util.Properties;\n+\n+@Slf4j\n+@SpringBootApplication(exclude = { SecurityAutoConfiguration.class })\n+@PropertySource(\"classpath:osgp-secret-management.properties\")\n+@PropertySource(value = \"file:${osgp/Global/config}\", ignoreResourceNotFound = true)\n+@PropertySource(value = \"file:${osgp/SecretManagement/config}\", ignoreResourceNotFound = true)\n+@ComponentScan(basePackages = { \"org.opensmartgridplatform.secretmanagement\" })\n+public class Application extends SpringBootServletInitializer {\n+\n+    private static final String LOG_CONFIG = \"java:comp/env/osgp/SecretManagement/log-config\";\n+\n+    public static void main(final String[] args) {\n+        //command line startup method (not used when app is started in application server)\n+        SpringApplication.run(Application.class, args);\n+    }\n+\n+    @Override\n+    protected SpringApplicationBuilder configure(final SpringApplicationBuilder builder) {\n+        String logPropertiesLocation = this.getLogbackConfigurationLocation();\n+\n+        log.info(\"Location for properties: {}\", logPropertiesLocation);\n+\n+        Properties props = new Properties();\n+        props.setProperty(\"logging.config\", logPropertiesLocation);\n+        builder.application().setDefaultProperties(props);\n+\n+        return builder.sources(Application.class);", "originalCommit": "83a8dddb1f6c3ee3e5e2ae9068a20132ecbf1ca3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0aaff58885efd4ad4159ccfd59178c055735da22", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\nindex 9b135abfbe..b2f0d629cd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\n", "chunk": "@@ -39,24 +41,34 @@ public class Application extends SpringBootServletInitializer {\n \n     @Override\n     protected SpringApplicationBuilder configure(final SpringApplicationBuilder builder) {\n-        String logPropertiesLocation = this.getLogbackConfigurationLocation();\n+        final Optional<String> logPropertiesLocation = this.getLogbackConfigurationLocation();\n \n-        log.info(\"Location for properties: {}\", logPropertiesLocation);\n+        if (logPropertiesLocation.isPresent()) {\n+            log.info(\"Location for properties: {}\", logPropertiesLocation.get());\n \n-        Properties props = new Properties();\n-        props.setProperty(\"logging.config\", logPropertiesLocation);\n-        builder.application().setDefaultProperties(props);\n+            final Properties props = new Properties();\n+            props.setProperty(\"logging.config\", logPropertiesLocation.get());\n+            builder.application().setDefaultProperties(props);\n+        }\n \n         return builder.sources(Application.class);\n     }\n \n-    private String getLogbackConfigurationLocation() {\n+    private Optional<String> getLogbackConfigurationLocation() {\n         try {\n             Context initialContext = new InitialContext();\n+            String location = (String) initialContext.lookup(LOG_CONFIG);\n+            File logConfig = new File(location);\n+\n+            if (logConfig.exists()) {\n+                return Optional.of(location);\n+            }\n \n-            return (String) initialContext.lookup(LOG_CONFIG);\n-        } catch (NamingException | RuntimeException e) {\n-            throw new IllegalStateException(\"Getting the location of the logback configuration file failed\", e);\n+            log.error(\"File {} does not exist.\", location);\n+        } catch (final NamingException | RuntimeException e) {\n+            log.error(\"Getting the location of the logback configuration file failed. Reason: {}\", e.getMessage());\n         }\n+\n+        return Optional.empty();\n     }\n }\n", "next_change": {"commit": "1a5975cc121f6272044cb1608e7ea345b97dd06b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\nindex b2f0d629cd..94916ef86e 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\n", "chunk": "@@ -66,7 +66,7 @@ public class Application extends SpringBootServletInitializer {\n \n             log.error(\"File {} does not exist.\", location);\n         } catch (final NamingException | RuntimeException e) {\n-            log.error(\"Getting the location of the logback configuration file failed. Reason: {}\", e.getMessage());\n+            log.error(\"Getting the location of the logback configuration file failed. Reason: {}\", e.getMessage(), e);\n         }\n \n         return Optional.empty();\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\nindex 94916ef86e..f634d56543 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/Application.java\n", "chunk": "@@ -17,58 +23,54 @@ import org.springframework.boot.web.servlet.support.SpringBootServletInitializer\n import org.springframework.context.annotation.ComponentScan;\n import org.springframework.context.annotation.PropertySource;\n \n-import javax.naming.Context;\n-import javax.naming.InitialContext;\n-import javax.naming.NamingException;\n-import java.io.File;\n-import java.util.Optional;\n-import java.util.Properties;\n-\n @Slf4j\n-@SpringBootApplication(exclude = { SecurityAutoConfiguration.class })\n+@SpringBootApplication(exclude = {SecurityAutoConfiguration.class})\n @PropertySource(\"classpath:osgp-secret-management.properties\")\n @PropertySource(value = \"file:${osgp/Global/config}\", ignoreResourceNotFound = true)\n @PropertySource(value = \"file:${osgp/SecretManagement/config}\", ignoreResourceNotFound = true)\n-@ComponentScan(basePackages = { \"org.opensmartgridplatform.secretmanagement\" })\n+@ComponentScan(basePackages = {\"org.opensmartgridplatform.secretmanagement\"})\n public class Application extends SpringBootServletInitializer {\n \n-    private static final String LOG_CONFIG = \"java:comp/env/osgp/SecretManagement/log-config\";\n-\n-    public static void main(final String[] args) {\n-        //command line startup method (not used when app is started in application server)\n-        SpringApplication.run(Application.class, args);\n-    }\n+  private static final String LOG_CONFIG = \"java:comp/env/osgp/SecretManagement/log-config\";\n \n-    @Override\n-    protected SpringApplicationBuilder configure(final SpringApplicationBuilder builder) {\n-        final Optional<String> logPropertiesLocation = this.getLogbackConfigurationLocation();\n+  public static void main(final String[] args) {\n+    // command line startup method (not used when app is started in application server)\n+    SpringApplication.run(Application.class, args);\n+  }\n \n-        if (logPropertiesLocation.isPresent()) {\n-            log.info(\"Location for properties: {}\", logPropertiesLocation.get());\n+  @Override\n+  protected SpringApplicationBuilder configure(final SpringApplicationBuilder builder) {\n+    final Optional<String> logPropertiesLocation = this.getLogbackConfigurationLocation();\n \n-            final Properties props = new Properties();\n-            props.setProperty(\"logging.config\", logPropertiesLocation.get());\n-            builder.application().setDefaultProperties(props);\n-        }\n+    if (logPropertiesLocation.isPresent()) {\n+      log.info(\"Location for properties: {}\", logPropertiesLocation.get());\n \n-        return builder.sources(Application.class);\n+      final Properties props = new Properties();\n+      props.setProperty(\"logging.config\", logPropertiesLocation.get());\n+      builder.application().setDefaultProperties(props);\n     }\n \n-    private Optional<String> getLogbackConfigurationLocation() {\n-        try {\n-            Context initialContext = new InitialContext();\n-            String location = (String) initialContext.lookup(LOG_CONFIG);\n-            File logConfig = new File(location);\n+    return builder.sources(Application.class);\n+  }\n \n-            if (logConfig.exists()) {\n-                return Optional.of(location);\n-            }\n+  private Optional<String> getLogbackConfigurationLocation() {\n+    try {\n+      final Context initialContext = new InitialContext();\n+      final String location = (String) initialContext.lookup(LOG_CONFIG);\n+      final File logConfig = new File(location);\n \n-            log.error(\"File {} does not exist.\", location);\n-        } catch (final NamingException | RuntimeException e) {\n-            log.error(\"Getting the location of the logback configuration file failed. Reason: {}\", e.getMessage(), e);\n-        }\n+      if (logConfig.exists()) {\n+        return Optional.of(location);\n+      }\n \n-        return Optional.empty();\n+      log.error(\"File {} does not exist.\", location);\n+    } catch (final NamingException | RuntimeException e) {\n+      log.error(\n+          \"Getting the location of the logback configuration file failed. Reason: {}\",\n+          e.getMessage(),\n+          e);\n     }\n+\n+    return Optional.empty();\n+  }\n }\n", "next_change": null}]}}]}}]}}, {"oid": "ca5c33f8e0e69b18366e0a79198f1ee25c0bcec1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ca5c33f8e0e69b18366e0a79198f1ee25c0bcec1", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' into test_2077", "committedDate": "2020-07-17T11:09:10Z", "type": "commit"}, {"oid": "bde1481a55eb7557be924ba8e0129113827c4162", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bde1481a55eb7557be924ba8e0129113827c4162", "message": "Remove tests for build", "committedDate": "2020-07-17T12:08:57Z", "type": "commit"}, {"oid": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fd7f59b56b5f6250d14db53ebb35f3c826b73056", "message": "Solved Sonar issues", "committedDate": "2020-07-17T13:19:39Z", "type": "commit"}, {"oid": "b33ea72db450ef9024872811269d65c2743dfd99", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b33ea72db450ef9024872811269d65c2743dfd99", "message": "Remove unused catch", "committedDate": "2020-07-17T13:28:43Z", "type": "commit"}, {"oid": "76c4b6da598e77347a129c0bc9fe636040c6c64c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/76c4b6da598e77347a129c0bc9fe636040c6c64c", "message": "Remove unused exception", "committedDate": "2020-07-17T13:42:28Z", "type": "commit"}, {"oid": "bd58ee80242d67262adf062325925d9bcfa90694", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bd58ee80242d67262adf062325925d9bcfa90694", "message": "Resolve Sonar issues", "committedDate": "2020-07-17T14:15:29Z", "type": "commit"}, {"oid": "f412aa1604ab1172bae19addfc5000971b7f5c0a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f412aa1604ab1172bae19addfc5000971b7f5c0a", "message": "Adjust pipeline script", "committedDate": "2020-07-17T14:47:00Z", "type": "commit"}, {"oid": "bf30f647c4161df08ef894f4e80f80be0cc9ba58", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bf30f647c4161df08ef894f4e80f80be0cc9ba58", "message": "SLIM-2077-extra-log-info", "committedDate": "2020-07-20T12:25:07Z", "type": "commit"}, {"oid": "d5057e11397b25692c4a84ba7f8050080ce199d4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d5057e11397b25692c4a84ba7f8050080ce199d4", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-07-20T13:17:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0MDU2NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455140565", "body": "Layout: only show one value per line for readability.", "bodyText": "Layout: only show one value per line for readability.", "bodyHTML": "<p dir=\"auto\">Layout: only show one value per line for readability.</p>", "author": "rlemmers", "createdAt": "2020-07-15T15:27:25Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java", "diffHunk": "@@ -0,0 +1,15 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+public enum SecretType {\n+    E_METER_MASTER_KEY, E_METER_AUTHENTICATION_KEY, E_METER_ENCRYPTION_KEY_UNICAST, E_METER_ENCRYPTION_KEY_BROADCAST,\n+    G_METER_MASTER_KEY, G_METER_ENCRYPTION_KEY, G_METER_FIRMWARE_UPDATE_AUTHENTICATION_KEY, G_METER_OPTICAL_PORT_KEY,\n+    PPP_PASSWORD", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java\nindex 995a89b9a4..df1642b7ca 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java\n", "chunk": "@@ -9,7 +9,13 @@\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n public enum SecretType {\n-    E_METER_MASTER_KEY, E_METER_AUTHENTICATION_KEY, E_METER_ENCRYPTION_KEY_UNICAST, E_METER_ENCRYPTION_KEY_BROADCAST,\n-    G_METER_MASTER_KEY, G_METER_ENCRYPTION_KEY, G_METER_FIRMWARE_UPDATE_AUTHENTICATION_KEY, G_METER_OPTICAL_PORT_KEY,\n+    E_METER_MASTER_KEY,\n+    E_METER_AUTHENTICATION_KEY,\n+    E_METER_ENCRYPTION_KEY_UNICAST,\n+    E_METER_ENCRYPTION_KEY_BROADCAST,\n+    G_METER_MASTER_KEY,\n+    G_METER_ENCRYPTION_KEY,\n+    G_METER_FIRMWARE_UPDATE_AUTHENTICATION_KEY,\n+    G_METER_OPTICAL_PORT_KEY,\n     PPP_PASSWORD\n }\n\\ No newline at end of file\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java\nindex df1642b7ca..e4c7b9af2f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/SecretType.java\n", "chunk": "@@ -1,21 +1,21 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n public enum SecretType {\n-    E_METER_MASTER_KEY,\n-    E_METER_AUTHENTICATION_KEY,\n-    E_METER_ENCRYPTION_KEY_UNICAST,\n-    E_METER_ENCRYPTION_KEY_BROADCAST,\n-    G_METER_MASTER_KEY,\n-    G_METER_ENCRYPTION_KEY,\n-    G_METER_FIRMWARE_UPDATE_AUTHENTICATION_KEY,\n-    G_METER_OPTICAL_PORT_KEY,\n-    PPP_PASSWORD\n-}\n\\ No newline at end of file\n+  E_METER_MASTER_KEY,\n+  E_METER_AUTHENTICATION_KEY,\n+  E_METER_ENCRYPTION_KEY_UNICAST,\n+  E_METER_ENCRYPTION_KEY_BROADCAST,\n+  G_METER_MASTER_KEY,\n+  G_METER_ENCRYPTION_KEY,\n+  G_METER_FIRMWARE_UPDATE_AUTHENTICATION_KEY,\n+  G_METER_OPTICAL_PORT_KEY,\n+  PPP_PASSWORD\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0MTU0OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455141549", "body": "To be consistent, use Lombok here as well.", "bodyText": "To be consistent, use Lombok here as well.", "bodyHTML": "<p dir=\"auto\">To be consistent, use Lombok here as well.</p>", "author": "rlemmers", "createdAt": "2020-07-15T15:28:55Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.domain;\n+\n+/**\n+ * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n+ */\n+public class TypedSecret {\n+    private SecretType secretType;\n+    private String secret;\n+\n+    public String getSecret() {\n+        return this.secret;\n+    }\n+\n+    public SecretType getSecretType() {\n+        return this.secretType;\n+    }\n+\n+    public void setSecret(final String secret) {\n+        this.secret = secret;\n+    }\n+\n+    public void setSecretType(final SecretType secretType) {\n+        this.secretType = secretType;\n+    }", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 1fe3bcb6c3..4c2f14eba6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -8,29 +8,20 @@\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n+import lombok.Getter;\n+\n /**\n  * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n  */\n+@Getter\n public class TypedSecret {\n-    private SecretType secretType;\n-    private String secret;\n-\n-    public String getSecret() {\n-        return this.secret;\n-    }\n-\n-    public SecretType getSecretType() {\n-        return this.secretType;\n-    }\n+    private final SecretType secretType;\n+    private final byte[] secret;\n \n-    public void setSecret(final String secret) {\n+    public TypedSecret(final byte[] secret, final SecretType secretType) {\n         this.secret = secret;\n-    }\n-\n-    public void setSecretType(final SecretType secretType) {\n         this.secretType = secretType;\n     }\n-\n }\n \n \n", "next_change": {"commit": "9949e261418959bfc6a3635533e00fca3f04ccc8", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 4c2f14eba6..6522073575 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -19,8 +21,16 @@ public class TypedSecret {\n     private final byte[] secret;\n \n     public TypedSecret(final byte[] secret, final SecretType secretType) {\n-        this.secret = secret;\n-        this.secretType = secretType;\n+        this.secret = Arrays.copyOf(secret, secret.length);\n+        if(secretType!=null) {\n+            this.secretType = secretType;\n+        } else {\n+            throw new IllegalArgumentException(\"Secret type can not be NULL\");\n+        }\n+    }\n+\n+    public byte[] getSecret() {\n+        return Arrays.copyOf(this.secret, this.secret.length);\n     }\n }\n \n", "next_change": {"commit": "2ad102dc23f1887d7e8309251500ff3e4ce8b28f", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 6522073575..7793f8ede4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -30,7 +30,7 @@ public class TypedSecret {\n     }\n \n     public byte[] getSecret() {\n-        return Arrays.copyOf(this.secret, this.secret.length);\n+        return this.secret == null ? null : Arrays.copyOf(this.secret, this.secret.length);\n     }\n }\n \n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\nindex 7793f8ede4..a2b9a4bb65 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/domain/TypedSecret.java\n", "chunk": "@@ -1,37 +1,32 @@\n-/**\n+/*\n  * Copyright 2020 Smart Society Services B.V.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  */\n package org.opensmartgridplatform.secretmanagement.application.domain;\n \n import java.util.Arrays;\n-\n import lombok.Getter;\n \n-/**\n- * TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type.\n- */\n+/** TypedSecret stores a secret (not necessarily an encrypted secret), along with it's type. */\n @Getter\n public class TypedSecret {\n-    private final SecretType secretType;\n-    private final byte[] secret;\n+  private final SecretType secretType;\n+  private final byte[] secret;\n \n-    public TypedSecret(final byte[] secret, final SecretType secretType) {\n-        this.secret = secret == null ? null : Arrays.copyOf(secret, secret.length);\n-        if (secretType != null) {\n-            this.secretType = secretType;\n-        } else {\n-            throw new IllegalArgumentException(\"Secret type can not be NULL\");\n-        }\n+  public TypedSecret(final byte[] secret, final SecretType secretType) {\n+    this.secret = secret == null ? null : Arrays.copyOf(secret, secret.length);\n+    if (secretType != null) {\n+      this.secretType = secretType;\n+    } else {\n+      throw new IllegalArgumentException(\"Secret type can not be NULL\");\n     }\n+  }\n \n-    public byte[] getSecret() {\n-        return this.secret == null ? null : Arrays.copyOf(this.secret, this.secret.length);\n-    }\n+  public byte[] getSecret() {\n+    return this.secret == null ? null : Arrays.copyOf(this.secret, this.secret.length);\n+  }\n }\n-\n-\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1NzI4NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455157284", "body": "Never use printStackTrace.", "bodyText": "Never use printStackTrace.", "bodyHTML": "<p dir=\"auto\">Never use printStackTrace.</p>", "author": "rlemmers", "createdAt": "2020-07-15T15:54:10Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.services.SecretManagementService;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+@Endpoint\n+@Slf4j\n+public class SecretManagementEndpoint {\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement\";\n+\n+    private final SecretManagementService secretManagementService;\n+    private final SoapEndpointDataTypeConverter converter;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n+            SoapEndpointDataTypeConverter converter) {\n+        this.secretManagementService = secretManagementService;\n+        this.converter = converter;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {\n+\n+        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        if (log.isTraceEnabled()) {\n+            log.trace(getSecretsRequestToString(request));\n+        }\n+\n+        try {\n+            GetSecretsResponse response = new GetSecretsResponse();\n+\n+            SecretTypes soapSecretTypes = request.getSecretTypes();\n+\n+            if (soapSecretTypes == null) {\n+                throw new TechnicalException(\"Missing input: secret types\");\n+            }\n+\n+            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n+            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                    secretTypeList);\n+\n+            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+\n+            response.setTypedSecrets(soapTypedSecrets);\n+            response.setResult(OsgpResultType.OK);\n+\n+            log.trace(response.toString());\n+\n+            return response;\n+\n+        } catch (Exception e) {\n+            if (log.isDebugEnabled()) {\n+                e.printStackTrace();", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44a3bcbb103c55ae89dcb931f229d8fda5d2bd2a", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 7eb42b6e8a..e7d9328893 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,7 +83,7 @@ public class SecretManagementEndpoint {\n             return response;\n \n         } catch (Exception e) {\n-            if (log.isDebugEnabled()) {\n+            if (log.isTraceEnabled()) {\n                 e.printStackTrace();\n             }\n             throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e7d9328893..6fd1c521f7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -60,34 +59,26 @@ public class SecretManagementEndpoint {\n             log.debug(getSecretsRequestToString(request));\n         }\n \n-        try {\n-            GetSecretsResponse response = new GetSecretsResponse();\n-\n-            SecretTypes soapSecretTypes = request.getSecretTypes();\n+        GetSecretsResponse response = new GetSecretsResponse();\n \n-            if (soapSecretTypes == null) {\n-                throw new TechnicalException(\"Missing input: secret types\");\n-            }\n+        SecretTypes soapSecretTypes = request.getSecretTypes();\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                    secretTypeList);\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n \n-            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                secretTypeList);\n \n-            response.setTypedSecrets(soapTypedSecrets);\n-            response.setResult(OsgpResultType.OK);\n+        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n \n-            log.trace(response.toString());\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n \n-            return response;\n+        log.trace(response.toString());\n \n-        } catch (Exception e) {\n-            if (log.isTraceEnabled()) {\n-                e.printStackTrace();\n-            }\n-            throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n-        }\n+        return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 6fd1c521f7..533a69c1fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,23 +86,21 @@ public class SecretManagementEndpoint {\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n+    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n \n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n \n-        StoreSecretsResponse response = new StoreSecretsResponse();\n+        final StoreSecretResponse response = new StoreSecretResponse();\n \n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n \n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+        try {\n+            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n+        } catch(final IOException ioe) {\n+            //TODO process/rethrow exception\n         }\n \n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n         response.setResult(OsgpResultType.OK);\n \n         log.trace(response.toString());\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 533a69c1fd..b2d3841c1d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -55,56 +59,60 @@ public class SecretManagementEndpoint {\n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n             log.debug(this.getSecretsRequestToString(request));\n         }\n-\n         final GetSecretsResponse response = new GetSecretsResponse();\n-\n         final SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n         if (soapSecretTypes == null) {\n             throw new TechnicalException(\"Missing input: secret types\");\n         }\n-\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n         final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n         final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n-\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        final StoreSecretResponse response = new StoreSecretResponse();\n-\n-        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n-\n-        try {\n-            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n-        } catch(final IOException ioe) {\n-            //TODO process/rethrow exception\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        if (soapTypedSecrets == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n+                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex b2d3841c1d..516b919866 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -112,6 +112,7 @@ public class SecretManagementEndpoint {\n                 t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n         this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n         return response;\n     }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 516b919866..63f7ec46d2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -108,9 +107,8 @@ public class SecretManagementEndpoint {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n-                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n         response.setResult(OsgpResultType.OK);\n         response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n", "next_change": {"commit": "fbdb92d61e267dcd963e7490941e8b628efeb594", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 63f7ec46d2..9285957e4a 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -115,10 +139,10 @@ public class SecretManagementEndpoint {\n         return response;\n     }\n \n-    private String getSecretsRequestToString(final GetSecretsRequest request) {\n+    private <T> String requestToString(final T request) {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            final JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n             final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 9285957e4a..e78b2429cf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -147,7 +155,8 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\", e);\n+            String logFormat = \"Could not serialize request of type %s\";\n+            log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n     }\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e78b2429cf..4b8396680c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -155,7 +150,7 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            String logFormat = \"Could not serialize request of type %s\";\n+            final String logFormat = \"Could not serialize request of type %s\";\n             log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 4b8396680c..991145a3a5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -45,153 +43,166 @@ import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI =\n-            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n-    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n-    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+  private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+  private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n-    private final SecretManagementService secretManagementService;\n-    private final SoapEndpointDataTypeConverter converter;\n+  private final SecretManagementService secretManagementService;\n+  private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n-            final SoapEndpointDataTypeConverter converter) {\n-        this.secretManagementService = secretManagementService;\n-        this.converter = converter;\n-    }\n+  public SecretManagementEndpoint(\n+      final SecretManagementService secretManagementService,\n+      final SoapEndpointDataTypeConverter converter) {\n+    this.secretManagementService = secretManagementService;\n+    this.converter = converter;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n-    @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetSecretsResponse response = new GetSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+  @ResponsePayload\n+  public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final GetSecretsResponse response = new GetSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n-    @ResponsePayload\n-    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+  @ResponsePayload\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      @RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveNewSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n-    @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final StoreSecretsResponse response = new StoreSecretsResponse();\n-        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n-        }\n-        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+  @ResponsePayload\n+  public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'storeSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final StoreSecretsResponse response = new StoreSecretsResponse();\n+    final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n+    }\n+    final List<TypedSecret> typedSecretList =\n+        this.converter.convertToTypedSecrets(soapTypedSecrets);\n+    this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n-    @ResponsePayload\n-    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n-            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n-                request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        response.setResult(OsgpResultType.OK);\n-        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+  @ResponsePayload\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+      @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecretList =\n+        this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(), secretTypeList);\n+    response.setResult(OsgpResultType.OK);\n+    response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+    return response;\n+  }\n \n-    private <T> String requestToString(final T request) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try {\n-            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n-            final Marshaller marshaller = ctx.createMarshaller();\n-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-            marshaller.marshal(request, baos);\n-        } catch (final JAXBException e) {\n-            final String logFormat = \"Could not serialize request of type %s\";\n-            log.error(String.format(logFormat,request.getClass()), e);\n-        }\n-        return baos.toString();\n+  private <T> String requestToString(final T request) {\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    try {\n+      final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+      final Marshaller marshaller = ctx.createMarshaller();\n+      marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+      marshaller.marshal(request, baos);\n+    } catch (final JAXBException e) {\n+      final String logFormat = \"Could not serialize request of type %s\";\n+      log.error(String.format(logFormat, request.getClass()), e);\n     }\n+    return baos.toString();\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n-    @ResponsePayload\n-    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        try {\n-            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n-                    this.converter.convertToSecretTypes(soapSecretTypes));\n-            response.setResult(OsgpResultType.OK);\n-        } catch (final RuntimeException rte) {\n-            log.error(\"Could not activate new secrets: \"+rte.toString());\n-            throw new TechnicalException(\"Could not activate new secrets\",rte);\n-        }\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+  @ResponsePayload\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    try {\n+      this.secretManagementService.activateNewSecrets(\n+          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n+      response.setResult(OsgpResultType.OK);\n+    } catch (final RuntimeException rte) {\n+      log.error(\"Could not activate new secrets: \" + rte.toString());\n+      throw new TechnicalException(\"Could not activate new secrets\", rte);\n     }\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n-    @ResponsePayload\n-    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final HasNewSecretResponse response = new HasNewSecretResponse();\n-        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-        response.setHasNewSecret(result);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+  @ResponsePayload\n+  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final HasNewSecretResponse response = new HasNewSecretResponse();\n+    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+    response.setHasNewSecret(result);\n+    return response;\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 991145a3a5..a710cf5252 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -166,43 +250,46 @@ public class SecretManagementEndpoint {\n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n   @ResponsePayload\n   public ActivateSecretsResponse activateSecretsRequest(\n-      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n-    }\n-    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-    final SecretTypes soapSecretTypes = request.getSecretTypes();\n-    if (soapSecretTypes == null) {\n-      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-    }\n-    try {\n-      this.secretManagementService.activateNewSecrets(\n-          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n-      response.setResult(OsgpResultType.OK);\n-    } catch (final RuntimeException rte) {\n-      log.error(\"Could not activate new secrets: \" + rte.toString());\n-      throw new TechnicalException(\"Could not activate new secrets\", rte);\n-    }\n-    return response;\n+      @RequestPayload final ActivateSecretsRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::activateSecrets,\n+        header,\n+        messageContext,\n+        this.nameList(request.getSecretTypes()));\n   }\n \n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n   @ResponsePayload\n-  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-      throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      @RequestPayload final HasNewSecretRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::hasNewSecret,\n+        header,\n+        messageContext,\n+        Arrays.asList(request.getSecretType().name()));\n+  }\n+\n+  private List<String> nameList(final SecretTypes secretTypes) {\n+    if (secretTypes == null) {\n+      return Collections.emptyList();\n     }\n-    final HasNewSecretResponse response = new HasNewSecretResponse();\n-    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-    response.setHasNewSecret(result);\n-    return response;\n+    return secretTypes.getSecretType().stream().map(st -> st.name()).collect(Collectors.toList());\n+  }\n+\n+  private List<String> nameList(final TypedSecrets typedSecrets) {\n+    if (typedSecrets == null) {\n+      return Collections.emptyList();\n+    }\n+    return typedSecrets.getTypedSecret().stream()\n+        .map(ts -> ts.getType().name())\n+        .collect(Collectors.toList());\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1OTAxNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455159015", "body": "The method only throws TechnicalExceptions, so why use OsgpException in the throws clause?", "bodyText": "The method only throws TechnicalExceptions, so why use OsgpException in the throws clause?", "bodyHTML": "<p dir=\"auto\">The method only throws TechnicalExceptions, so why use OsgpException in the throws clause?</p>", "author": "rlemmers", "createdAt": "2020-07-15T15:56:50Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.services.SecretManagementService;\n+import org.opensmartgridplatform.shared.exceptionhandling.ComponentType;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+@Endpoint\n+@Slf4j\n+public class SecretManagementEndpoint {\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform\"\n+            + \".org/schemas/security/secretmanagement\";\n+\n+    private final SecretManagementService secretManagementService;\n+    private final SoapEndpointDataTypeConverter converter;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService,\n+            SoapEndpointDataTypeConverter converter) {\n+        this.secretManagementService = secretManagementService;\n+        this.converter = converter;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) throws OsgpException {", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44a3bcbb103c55ae89dcb931f229d8fda5d2bd2a", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 7eb42b6e8a..e7d9328893 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -56,8 +56,8 @@ public class SecretManagementEndpoint {\n \n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n \n-        if (log.isTraceEnabled()) {\n-            log.trace(getSecretsRequestToString(request));\n+        if (log.isDebugEnabled()) {\n+            log.debug(getSecretsRequestToString(request));\n         }\n \n         try {\n", "next_change": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e7d9328893..6fd1c521f7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -60,34 +59,26 @@ public class SecretManagementEndpoint {\n             log.debug(getSecretsRequestToString(request));\n         }\n \n-        try {\n-            GetSecretsResponse response = new GetSecretsResponse();\n-\n-            SecretTypes soapSecretTypes = request.getSecretTypes();\n+        GetSecretsResponse response = new GetSecretsResponse();\n \n-            if (soapSecretTypes == null) {\n-                throw new TechnicalException(\"Missing input: secret types\");\n-            }\n+        SecretTypes soapSecretTypes = request.getSecretTypes();\n \n-            List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n-            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                    secretTypeList);\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: secret types\");\n+        }\n \n-            TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n+        List<SecretType> secretTypeList = converter.convertToSecretTypes(soapSecretTypes);\n+        List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(),\n+                secretTypeList);\n \n-            response.setTypedSecrets(soapTypedSecrets);\n-            response.setResult(OsgpResultType.OK);\n+        TypedSecrets soapTypedSecrets = converter.convertToSoapTypedSecrets(typedSecrets);\n \n-            log.trace(response.toString());\n+        response.setTypedSecrets(soapTypedSecrets);\n+        response.setResult(OsgpResultType.OK);\n \n-            return response;\n+        log.trace(response.toString());\n \n-        } catch (Exception e) {\n-            if (log.isTraceEnabled()) {\n-                e.printStackTrace();\n-            }\n-            throw new TechnicalException(ComponentType.SHARED, e.getMessage());\n-        }\n+        return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 6fd1c521f7..533a69c1fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -83,23 +86,21 @@ public class SecretManagementEndpoint {\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) throws OsgpException {\n+    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n \n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n \n-        StoreSecretsResponse response = new StoreSecretsResponse();\n+        final StoreSecretResponse response = new StoreSecretResponse();\n \n-        TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n \n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n+        try {\n+            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n+        } catch(final IOException ioe) {\n+            //TODO process/rethrow exception\n         }\n \n-        List<TypedSecret> typedSecretList = converter.convertToTypedSecrets(request.getTypedSecrets());\n-\n-        secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-\n         response.setResult(OsgpResultType.OK);\n \n         log.trace(response.toString());\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 533a69c1fd..b2d3841c1d 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -55,56 +59,60 @@ public class SecretManagementEndpoint {\n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n     @ResponsePayload\n     public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-\n         log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-\n         if (log.isDebugEnabled()) {\n             log.debug(this.getSecretsRequestToString(request));\n         }\n-\n         final GetSecretsResponse response = new GetSecretsResponse();\n-\n         final SecretTypes soapSecretTypes = request.getSecretTypes();\n-\n         if (soapSecretTypes == null) {\n             throw new TechnicalException(\"Missing input: secret types\");\n         }\n-\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n         final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n                 secretTypeList);\n-\n         final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-\n         response.setTypedSecrets(soapTypedSecrets);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n-\n         return response;\n     }\n \n     @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n     @ResponsePayload\n-    public StoreSecretResponse storeSecretsRequest(@RequestPayload final StoreSecretRequest request) throws OsgpException {\n-\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+            throws OsgpException {\n         log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n         log.trace(request.toString());\n-\n-        final StoreSecretResponse response = new StoreSecretResponse();\n-\n-        final TypedSecret typedSecret = this.converter.decryptAndConvertSoapTypedSecret(request.getTypedSecret());\n-\n-        try {\n-            this.secretManagementService.storeSecret(request.getDeviceId(), typedSecret);\n-        } catch(final IOException ioe) {\n-            //TODO process/rethrow exception\n+        final StoreSecretsResponse response = new StoreSecretsResponse();\n+        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+        if (soapTypedSecrets == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n+        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n-\n         log.trace(response.toString());\n+        return response;\n+    }\n \n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+    @ResponsePayload\n+    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+        log.trace(request.toString());\n+        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+        final SecretTypes soapSecretTypes = request.getSecretTypes();\n+        if (soapSecretTypes == null) {\n+            throw new TechnicalException(\"Missing input: typed secrets\");\n+        }\n+        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n+                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n+        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        response.setResult(OsgpResultType.OK);\n+        log.trace(response.toString());\n         return response;\n     }\n \n", "next_change": {"commit": "dc3978657a033f506fc2ad076e1daa6ffc14b8a6", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex b2d3841c1d..516b919866 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -112,6 +112,7 @@ public class SecretManagementEndpoint {\n                 t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n         this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n         response.setResult(OsgpResultType.OK);\n+        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n         return response;\n     }\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 516b919866..63f7ec46d2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -108,9 +107,8 @@ public class SecretManagementEndpoint {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = secretTypeList.stream().map(\n-                t -> this.secretManagementService.generateAes128BitsSecret(t)).collect(Collectors.toList());\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+        List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n+                secretTypeList);\n         response.setResult(OsgpResultType.OK);\n         response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n         log.trace(response.toString());\n", "next_change": {"commit": "fbdb92d61e267dcd963e7490941e8b628efeb594", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 63f7ec46d2..9285957e4a 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -115,10 +139,10 @@ public class SecretManagementEndpoint {\n         return response;\n     }\n \n-    private String getSecretsRequestToString(final GetSecretsRequest request) {\n+    private <T> String requestToString(final T request) {\n         final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         try {\n-            final JAXBContext ctx = JAXBContext.newInstance(GetSecretsRequest.class);\n+            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n             final Marshaller marshaller = ctx.createMarshaller();\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 9285957e4a..e78b2429cf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -147,7 +155,8 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            log.error(\"Could not serialize GetSecretsRequest\", e);\n+            String logFormat = \"Could not serialize request of type %s\";\n+            log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n     }\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex e78b2429cf..4b8396680c 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -155,7 +150,7 @@ public class SecretManagementEndpoint {\n             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n             marshaller.marshal(request, baos);\n         } catch (final JAXBException e) {\n-            String logFormat = \"Could not serialize request of type %s\";\n+            final String logFormat = \"Could not serialize request of type %s\";\n             log.error(String.format(logFormat,request.getClass()), e);\n         }\n         return baos.toString();\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 4b8396680c..991145a3a5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -45,153 +43,166 @@ import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n @Slf4j\n public class SecretManagementEndpoint {\n \n-    private static final String NAMESPACE_URI =\n-            \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n-    private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n-    private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement\";\n+  private static final String STR_MISSING_SECRET_TYPES = \"Missing input: secret types\";\n+  private static final String STR_MISSING_TYPED_SECRETS = \"Missing input: typed secrets\";\n \n-    private final SecretManagementService secretManagementService;\n-    private final SoapEndpointDataTypeConverter converter;\n+  private final SecretManagementService secretManagementService;\n+  private final SoapEndpointDataTypeConverter converter;\n \n-    public SecretManagementEndpoint(final SecretManagementService secretManagementService,\n-            final SoapEndpointDataTypeConverter converter) {\n-        this.secretManagementService = secretManagementService;\n-        this.converter = converter;\n-    }\n+  public SecretManagementEndpoint(\n+      final SecretManagementService secretManagementService,\n+      final SoapEndpointDataTypeConverter converter) {\n+    this.secretManagementService = secretManagementService;\n+    this.converter = converter;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n-    @ResponsePayload\n-    public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetSecretsResponse response = new GetSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+  @ResponsePayload\n+  public GetSecretsResponse getSecretsRequest(@RequestPayload final GetSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final GetSecretsResponse response = new GetSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n-    @ResponsePayload\n-    public GetNewSecretsResponse getNewSecretsRequest(@RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GetNewSecretsResponse response = new GetNewSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecrets = this.secretManagementService.retrieveNewSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n-        response.setTypedSecrets(soapTypedSecrets);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getNewSecretsRequest\")\n+  @ResponsePayload\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      @RequestPayload final GetNewSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GetNewSecretsResponse response = new GetNewSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecrets =\n+        this.secretManagementService.retrieveNewSecrets(request.getDeviceId(), secretTypeList);\n+    final TypedSecrets soapTypedSecrets = this.converter.convertToSoapTypedSecrets(typedSecrets);\n+    response.setTypedSecrets(soapTypedSecrets);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n-    @ResponsePayload\n-    public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final StoreSecretsResponse response = new StoreSecretsResponse();\n-        final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n-        }\n-        final List<TypedSecret> typedSecretList = this.converter.convertToTypedSecrets(soapTypedSecrets);\n-        this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n-        response.setResult(OsgpResultType.OK);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+  @ResponsePayload\n+  public StoreSecretsResponse storeSecretsRequest(@RequestPayload final StoreSecretsRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'storeSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final StoreSecretsResponse response = new StoreSecretsResponse();\n+    final TypedSecrets soapTypedSecrets = request.getTypedSecrets();\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(STR_MISSING_TYPED_SECRETS);\n+    }\n+    final List<TypedSecret> typedSecretList =\n+        this.converter.convertToTypedSecrets(soapTypedSecrets);\n+    this.secretManagementService.storeSecrets(request.getDeviceId(), typedSecretList);\n+    response.setResult(OsgpResultType.OK);\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n-    @ResponsePayload\n-    public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n-            @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n-                request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n-        final List<TypedSecret> typedSecretList = this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(),\n-                secretTypeList);\n-        response.setResult(OsgpResultType.OK);\n-        response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"generateAndStoreSecretsRequest\")\n+  @ResponsePayload\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecretsRequest(\n+      @RequestPayload final GenerateAndStoreSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'generateAndStoreSecretsRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final GenerateAndStoreSecretsResponse response = new GenerateAndStoreSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n     }\n+    final List<SecretType> secretTypeList = this.converter.convertToSecretTypes(soapSecretTypes);\n+    final List<TypedSecret> typedSecretList =\n+        this.secretManagementService.generateAndStoreSecrets(request.getDeviceId(), secretTypeList);\n+    response.setResult(OsgpResultType.OK);\n+    response.setTypedSecrets(this.converter.convertToSoapTypedSecrets(typedSecretList));\n+    return response;\n+  }\n \n-    private <T> String requestToString(final T request) {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try {\n-            final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n-            final Marshaller marshaller = ctx.createMarshaller();\n-            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-            marshaller.marshal(request, baos);\n-        } catch (final JAXBException e) {\n-            final String logFormat = \"Could not serialize request of type %s\";\n-            log.error(String.format(logFormat,request.getClass()), e);\n-        }\n-        return baos.toString();\n+  private <T> String requestToString(final T request) {\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    try {\n+      final JAXBContext ctx = JAXBContext.newInstance(request.getClass());\n+      final Marshaller marshaller = ctx.createMarshaller();\n+      marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n+      marshaller.marshal(request, baos);\n+    } catch (final JAXBException e) {\n+      final String logFormat = \"Could not serialize request of type %s\";\n+      log.error(String.format(logFormat, request.getClass()), e);\n     }\n+    return baos.toString();\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n-    @ResponsePayload\n-    public ActivateSecretsResponse activateSecretsRequest(@RequestPayload final ActivateSecretsRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'activateSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-        final SecretTypes soapSecretTypes = request.getSecretTypes();\n-        if (soapSecretTypes == null) {\n-            throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-        }\n-        try {\n-            this.secretManagementService.activateNewSecrets(request.getDeviceId(),\n-                    this.converter.convertToSecretTypes(soapSecretTypes));\n-            response.setResult(OsgpResultType.OK);\n-        } catch (final RuntimeException rte) {\n-            log.error(\"Could not activate new secrets: \"+rte.toString());\n-            throw new TechnicalException(\"Could not activate new secrets\",rte);\n-        }\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n+  @ResponsePayload\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n+    }\n+    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n+    final SecretTypes soapSecretTypes = request.getSecretTypes();\n+    if (soapSecretTypes == null) {\n+      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n+    }\n+    try {\n+      this.secretManagementService.activateNewSecrets(\n+          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n+      response.setResult(OsgpResultType.OK);\n+    } catch (final RuntimeException rte) {\n+      log.error(\"Could not activate new secrets: \" + rte.toString());\n+      throw new TechnicalException(\"Could not activate new secrets\", rte);\n     }\n+    return response;\n+  }\n \n-    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n-    @ResponsePayload\n-    public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-            throws OsgpException {\n-        log.info(\"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\", request.getDeviceId());\n-        if (log.isDebugEnabled()) {\n-            log.debug(this.requestToString(request));\n-        }\n-        final HasNewSecretResponse response = new HasNewSecretResponse();\n-        final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-        final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-        response.setHasNewSecret(result);\n-        return response;\n+  @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n+  @ResponsePayload\n+  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n+      throws OsgpException {\n+    log.info(\n+        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n+        request.getDeviceId());\n+    if (log.isDebugEnabled()) {\n+      log.debug(this.requestToString(request));\n     }\n+    final HasNewSecretResponse response = new HasNewSecretResponse();\n+    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n+    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n+    response.setHasNewSecret(result);\n+    return response;\n+  }\n }\n", "next_change": {"commit": "9939c1b53586e4ec202fdc914b33aba116c0738b", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\nindex 991145a3a5..a710cf5252 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SecretManagementEndpoint.java\n", "chunk": "@@ -166,43 +250,46 @@ public class SecretManagementEndpoint {\n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"activateSecretsRequest\")\n   @ResponsePayload\n   public ActivateSecretsResponse activateSecretsRequest(\n-      @RequestPayload final ActivateSecretsRequest request) throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'activateSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n-    }\n-    final ActivateSecretsResponse response = new ActivateSecretsResponse();\n-    final SecretTypes soapSecretTypes = request.getSecretTypes();\n-    if (soapSecretTypes == null) {\n-      throw new TechnicalException(STR_MISSING_SECRET_TYPES);\n-    }\n-    try {\n-      this.secretManagementService.activateNewSecrets(\n-          request.getDeviceId(), this.converter.convertToSecretTypes(soapSecretTypes));\n-      response.setResult(OsgpResultType.OK);\n-    } catch (final RuntimeException rte) {\n-      log.error(\"Could not activate new secrets: \" + rte.toString());\n-      throw new TechnicalException(\"Could not activate new secrets\", rte);\n-    }\n-    return response;\n+      @RequestPayload final ActivateSecretsRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::activateSecrets,\n+        header,\n+        messageContext,\n+        this.nameList(request.getSecretTypes()));\n   }\n \n   @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"hasNewSecretRequest\")\n   @ResponsePayload\n-  public HasNewSecretResponse hasNewSecretRequest(@RequestPayload final HasNewSecretRequest request)\n-      throws OsgpException {\n-    log.info(\n-        \"Handling incoming SOAP request 'hasNewSecretRequest' for device {}\",\n-        request.getDeviceId());\n-    if (log.isDebugEnabled()) {\n-      log.debug(this.requestToString(request));\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      @RequestPayload final HasNewSecretRequest request,\n+      @SoapHeader(CORRELATION_HEADER) final SoapHeaderElement header,\n+      final MessageContext messageContext)\n+      throws OsgpException, TransformerException {\n+    return this.handleRequest(\n+        request,\n+        this::hasNewSecret,\n+        header,\n+        messageContext,\n+        Arrays.asList(request.getSecretType().name()));\n+  }\n+\n+  private List<String> nameList(final SecretTypes secretTypes) {\n+    if (secretTypes == null) {\n+      return Collections.emptyList();\n     }\n-    final HasNewSecretResponse response = new HasNewSecretResponse();\n-    final SecretType type = this.converter.convertToSecretType(request.getSecretType());\n-    final boolean result = this.secretManagementService.hasNewSecret(request.getDeviceId(), type);\n-    response.setHasNewSecret(result);\n-    return response;\n+    return secretTypes.getSecretType().stream().map(st -> st.name()).collect(Collectors.toList());\n+  }\n+\n+  private List<String> nameList(final TypedSecrets typedSecrets) {\n+    if (typedSecrets == null) {\n+      return Collections.emptyList();\n+    }\n+    return typedSecrets.getTypedSecret().stream()\n+        .map(ts -> ts.getType().name())\n+        .collect(Collectors.toList());\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE2MDQ5OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455160499", "body": "We normally use Orika for mapping.", "bodyText": "We normally use Orika for mapping.", "bodyHTML": "<p dir=\"auto\">We normally use Orika for mapping.</p>", "author": "rlemmers", "createdAt": "2020-07-15T15:59:14Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.endpoints;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n+import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SoapEndpointDataTypeConverter {", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ddff301afd3f5b8376b0aadce3a4187dd140efcf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 2920305149..b8735c99fd 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -19,7 +19,6 @@ import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.springframework.beans.factory.annotation.Qualifier;\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex b8735c99fd..4a7c917bf1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -16,23 +16,19 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.shared.exceptionhandling.OsgpException;\n import org.opensmartgridplatform.shared.exceptionhandling.TechnicalException;\n-import org.opensmartgridplatform.shared.security.EncryptedSecret;\n-import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n-import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-\n+    //TODO Refactor this to directly use RsaEncryptionProvider (removing key_reference, delegate, etc.)\n     private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    private final EncryptionDelegate encryptionDelegate;\n+    //private final EncryptionDelegate encryptionDelegate;\n \n-    public SoapEndpointDataTypeConverter(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n+    public SoapEndpointDataTypeConverter() {\n+      /*      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;*/\n     }\n \n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 4a7c917bf1..8827b07aa1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,15 +22,6 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    //TODO Refactor this to directly use RsaEncryptionProvider (removing key_reference, delegate, etc.)\n-    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n-    //private final EncryptionDelegate encryptionDelegate;\n-\n-    public SoapEndpointDataTypeConverter() {\n-      /*      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;*/\n-    }\n-\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n \n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 8827b07aa1..6ae6841d60 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -23,38 +23,30 @@ import org.springframework.stereotype.Component;\n @Component\n public class SoapEndpointDataTypeConverter {\n     public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n-\n-        return soapSecretTypeList.stream().map(soapSecretType -> this.convertToSecretType(soapSecretType)).collect(\n+        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(\n                 Collectors.toList());\n     }\n \n     public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-\n         if (soapTypedSecrets == null) {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         return soapTypedSecretsList.stream().map(\n                 soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n                 soapTypedSecrets.getTypedSecret();\n-\n         for (final TypedSecret typedSecret : typedSecrets) {\n             final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n                     typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n-\n         return soapTypedSecrets;\n     }\n \n", "next_change": {"commit": "def46ea1f392a779005d2d15bc5d805e0ea7bcbf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 6ae6841d60..7c304b1407 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -33,18 +33,19 @@ public class SoapEndpointDataTypeConverter {\n             throw new TechnicalException(\"Missing input: typed secrets\");\n         }\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets.getTypedSecret();\n-        return soapTypedSecretsList.stream().map(\n-                soapTypedSecret -> this.decryptAndConvertSoapTypedSecret(soapTypedSecret)).collect(Collectors.toList());\n+                soapTypedSecrets\n+                .getTypedSecret();\n+        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n     }\n \n     public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n         final TypedSecrets soapTypedSecrets = new TypedSecrets();\n         final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets.getTypedSecret();\n+                soapTypedSecrets\n+                .getTypedSecret();\n         for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this.encryptAndConvertSoapTypedSecret(\n-                    typedSecret);\n+            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n+                    .encryptAndConvertSoapTypedSecret(typedSecret);\n             soapTypedSecretList.add(soapTypedSecret);\n         }\n         return soapTypedSecrets;\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\nindex 7c304b1407..6efa4e5540 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/endpoints/SoapEndpointDataTypeConverter.java\n", "chunk": "@@ -22,63 +21,65 @@ import org.springframework.stereotype.Component;\n \n @Component\n public class SoapEndpointDataTypeConverter {\n-    public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType> soapSecretTypeList =\n-                soapSecretTypes.getSecretType();\n-        return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n-    }\n+  public List<SecretType> convertToSecretTypes(final SecretTypes soapSecretTypes) {\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.SecretType>\n+        soapSecretTypeList = soapSecretTypes.getSecretType();\n+    return soapSecretTypeList.stream().map(this::convertToSecretType).collect(Collectors.toList());\n+  }\n \n-    public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets) throws OsgpException {\n-        if (soapTypedSecrets == null) {\n-            throw new TechnicalException(\"Missing input: typed secrets\");\n-        }\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretsList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        return soapTypedSecretsList.stream().map(this::decryptAndConvertSoapTypedSecret).collect(Collectors.toList());\n+  public List<TypedSecret> convertToTypedSecrets(final TypedSecrets soapTypedSecrets)\n+      throws OsgpException {\n+    if (soapTypedSecrets == null) {\n+      throw new TechnicalException(\"Missing input: typed secrets\");\n     }\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretsList = soapTypedSecrets.getTypedSecret();\n+    return soapTypedSecretsList.stream()\n+        .map(this::decryptAndConvertSoapTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n \n-    public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n-        final TypedSecrets soapTypedSecrets = new TypedSecrets();\n-        final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret> soapTypedSecretList =\n-                soapTypedSecrets\n-                .getTypedSecret();\n-        for (final TypedSecret typedSecret : typedSecrets) {\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret = this\n-                    .encryptAndConvertSoapTypedSecret(typedSecret);\n-            soapTypedSecretList.add(soapTypedSecret);\n-        }\n-        return soapTypedSecrets;\n+  public TypedSecrets convertToSoapTypedSecrets(final List<TypedSecret> typedSecrets) {\n+    final TypedSecrets soapTypedSecrets = new TypedSecrets();\n+    final List<org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret>\n+        soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+    for (final TypedSecret typedSecret : typedSecrets) {\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+          this.encryptAndConvertSoapTypedSecret(typedSecret);\n+      soapTypedSecretList.add(soapTypedSecret);\n     }\n+    return soapTypedSecrets;\n+  }\n \n-    public SecretType convertToSecretType(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n-        return SecretType.valueOf(soapSecretType.value());\n-    }\n+  public SecretType convertToSecretType(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.SecretType soapSecretType) {\n+    return SecretType.valueOf(soapSecretType.value());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType convertToSoapSecretType(\n-            final SecretType secretType) {\n-        return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(secretType.name());\n-    }\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.SecretType\n+      convertToSoapSecretType(final SecretType secretType) {\n+    return org.opensmartgridplatform.ws.schema.core.secret.management.SecretType.fromValue(\n+        secretType.name());\n+  }\n \n-    private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret encryptAndConvertSoapTypedSecret(\n-            final TypedSecret typedSecret) {\n-        final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n-                new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n+  private org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+      encryptAndConvertSoapTypedSecret(final TypedSecret typedSecret) {\n+    final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret =\n+        new org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret();\n \n-        final byte[] rsaSecret = typedSecret.getSecret();\n-        soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n+    final byte[] rsaSecret = typedSecret.getSecret();\n+    soapTypedSecret.setSecret(HexUtils.toHexString(rsaSecret));\n \n-        final SecretType secretType = typedSecret.getSecretType();\n-        soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n+    final SecretType secretType = typedSecret.getSecretType();\n+    soapTypedSecret.setType(this.convertToSoapSecretType(secretType));\n \n-        return soapTypedSecret;\n-    }\n-\n-    public TypedSecret decryptAndConvertSoapTypedSecret(\n-            final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret soapTypedSecret) {\n-        final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n-        return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n-    }\n+    return soapTypedSecret;\n+  }\n \n+  public TypedSecret decryptAndConvertSoapTypedSecret(\n+      final org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret\n+          soapTypedSecret) {\n+    final byte[] rsaEncryptedSecret = HexUtils.fromHexString(soapTypedSecret.getSecret());\n+    return new TypedSecret(rsaEncryptedSecret, this.convertToSecretType(soapTypedSecret.getType()));\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE2MTE1MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455161151", "body": "Do not use the \"Db\" prefix for repositories and entities.", "bodyText": "Do not use the \"Db\" prefix for repositories and entities.", "bodyHTML": "<p dir=\"auto\">Do not use the \"Db\" prefix for repositories and entities.</p>", "author": "rlemmers", "createdAt": "2020-07-15T16:00:18Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.repository;\n+\n+import java.util.Date;\n+\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.stereotype.Repository;\n+\n+@Repository\n+public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 50d7a9692b..7fff5931b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -8,9 +8,11 @@\n  */\n package org.opensmartgridplatform.secretmanagement.application.repository;\n \n-import java.util.Date;\n-\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n import org.springframework.data.jpa.repository.JpaRepository;\n import org.springframework.data.jpa.repository.Query;\n import org.springframework.data.repository.query.Param;\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 7fff5931b5..220f3dcaae 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -8,11 +8,11 @@\n  */\n package org.opensmartgridplatform.secretmanagement.application.repository;\n \n+import java.util.List;\n+\n import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretStatus;\n import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.data.jpa.repository.JpaRepository;\n import org.springframework.data.jpa.repository.Query;\n import org.springframework.data.repository.query.Param;\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 220f3dcaae..62188c57fc 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -21,17 +21,21 @@ import org.springframework.stereotype.Repository;\n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n     @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n-            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time()) \"\n-            + \"ORDER BY es.creation_time DESC, es.id DESC\")\n+            + \"JOIN es.encryptionKeyReference ekr \"\n+            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus \"\n+            + \"AND ekr.validFrom < current_timestamp() \"\n+            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp()) \"\n+            + \"ORDER BY es.creationTime DESC, es.id DESC\")\n     List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n \n     @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n-            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time())\")\n+            + \"JOIN es.encryptionKeyReference ekr \"\n+            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus \"\n+            + \"AND ekr.validFrom < current_timestamp() \"\n+            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp())\")\n     int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "9cb3262eeec80c4de35024ad396066d2ff8b3712", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 62188c57fc..b29d90afd7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -21,21 +21,15 @@ import org.springframework.stereotype.Repository;\n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n     @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"JOIN es.encryptionKeyReference ekr \"\n             + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n             + \"AND es.secretStatus= :secretStatus \"\n-            + \"AND ekr.validFrom < current_timestamp() \"\n-            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp()) \"\n             + \"ORDER BY es.creationTime DESC, es.id DESC\")\n     List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n \n     @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"JOIN es.encryptionKeyReference ekr \"\n             + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus \"\n-            + \"AND ekr.validFrom < current_timestamp() \"\n-            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp())\")\n+            + \"AND es.secretStatus= :secretStatus\")\n     int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex b29d90afd7..051581b4e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -20,16 +19,24 @@ import org.springframework.stereotype.Repository;\n \n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n-    @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus \"\n-            + \"ORDER BY es.creationTime DESC, es.id DESC\")\n-    List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n+  @Query(\n+      value =\n+          \"SELECT es FROM DbEncryptedSecret es \"\n+              + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+              + \"AND es.secretStatus= :secretStatus \"\n+              + \"ORDER BY es.creationTime DESC, es.id DESC\")\n+  List<DbEncryptedSecret> findSecrets(\n+      @Param(\"deviceIdentification\") String deviceIdentification,\n+      @Param(\"secretType\") SecretType secretType,\n+      @Param(\"secretStatus\") SecretStatus secretStatus);\n \n-    @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus\")\n-    int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n+  @Query(\n+      value =\n+          \"SELECT count(es) FROM DbEncryptedSecret es \"\n+              + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+              + \"AND es.secretStatus= :secretStatus\")\n+  int getSecretCount(\n+      @Param(\"deviceIdentification\") String deviceIdentification,\n+      @Param(\"secretType\") SecretType secretType,\n+      @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 50d7a9692b..7fff5931b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -18,12 +20,19 @@ import org.springframework.stereotype.Repository;\n \n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n-    @Query(value = \"SELECT es.id FROM encrypted_secret es \"\n-            + \"LEFT JOIN encryption_key_reference ekr ON es.encryption_key_reference_id = ekr.id \"\n+    @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n             + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND ekr.valid_from < :date AND (ekr.valid_to IS NULL OR ekr.valid_to > :date) \"\n-            + \"ORDER BY es.creation_time DESC, es.id DESC LIMIT 1\", nativeQuery = true)\n-    Long findIdOfValidMostRecent(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") String secretType, @Param(\"date\") Date validDate);\n+            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n+            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time()) \"\n+            + \"ORDER BY es.creation_time DESC, es.id DESC\")\n+    Page<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n+            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus,\n+            Pageable pageable);\n \n+    @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n+            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n+            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time())\")\n+    int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n+            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 7fff5931b5..62188c57fc 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -21,18 +21,21 @@ import org.springframework.stereotype.Repository;\n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n     @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n-            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time()) \"\n-            + \"ORDER BY es.creation_time DESC, es.id DESC\")\n-    Page<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus,\n-            Pageable pageable);\n+            + \"JOIN es.encryptionKeyReference ekr \"\n+            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus \"\n+            + \"AND ekr.validFrom < current_timestamp() \"\n+            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp()) \"\n+            + \"ORDER BY es.creationTime DESC, es.id DESC\")\n+    List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n+            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n \n     @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n-            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time())\")\n+            + \"JOIN es.encryptionKeyReference ekr \"\n+            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus \"\n+            + \"AND ekr.validFrom < current_timestamp() \"\n+            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp())\")\n     int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "9cb3262eeec80c4de35024ad396066d2ff8b3712", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 62188c57fc..b29d90afd7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -21,21 +21,15 @@ import org.springframework.stereotype.Repository;\n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n     @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"JOIN es.encryptionKeyReference ekr \"\n             + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n             + \"AND es.secretStatus= :secretStatus \"\n-            + \"AND ekr.validFrom < current_timestamp() \"\n-            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp()) \"\n             + \"ORDER BY es.creationTime DESC, es.id DESC\")\n     List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n \n     @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"JOIN es.encryptionKeyReference ekr \"\n             + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus \"\n-            + \"AND ekr.validFrom < current_timestamp() \"\n-            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp())\")\n+            + \"AND es.secretStatus= :secretStatus\")\n     int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex b29d90afd7..051581b4e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -20,16 +19,24 @@ import org.springframework.stereotype.Repository;\n \n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n-    @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus \"\n-            + \"ORDER BY es.creationTime DESC, es.id DESC\")\n-    List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n+  @Query(\n+      value =\n+          \"SELECT es FROM DbEncryptedSecret es \"\n+              + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+              + \"AND es.secretStatus= :secretStatus \"\n+              + \"ORDER BY es.creationTime DESC, es.id DESC\")\n+  List<DbEncryptedSecret> findSecrets(\n+      @Param(\"deviceIdentification\") String deviceIdentification,\n+      @Param(\"secretType\") SecretType secretType,\n+      @Param(\"secretStatus\") SecretStatus secretStatus);\n \n-    @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus\")\n-    int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n+  @Query(\n+      value =\n+          \"SELECT count(es) FROM DbEncryptedSecret es \"\n+              + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+              + \"AND es.secretStatus= :secretStatus\")\n+  int getSecretCount(\n+      @Param(\"deviceIdentification\") String deviceIdentification,\n+      @Param(\"secretType\") SecretType secretType,\n+      @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE2MzYyMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r455163622", "body": "We normally don't use the creation_time (and modification_time) in the code. And we've had some problems in the few places where we did use those columns. Consider using a separate column.\r\nOr would it be possible to just select \"max(es.id)\" instead of searching the highest creation_time?\r\n\r\nWhen searching a value, both edges (valid_from = :date and valid_to = :date) are excluded. I would expect at least one of those two to be included.", "bodyText": "We normally don't use the creation_time (and modification_time) in the code. And we've had some problems in the few places where we did use those columns. Consider using a separate column.\nOr would it be possible to just select \"max(es.id)\" instead of searching the highest creation_time?\nWhen searching a value, both edges (valid_from = :date and valid_to = :date) are excluded. I would expect at least one of those two to be included.", "bodyHTML": "<p dir=\"auto\">We normally don't use the creation_time (and modification_time) in the code. And we've had some problems in the few places where we did use those columns. Consider using a separate column.<br>\nOr would it be possible to just select \"max(es.id)\" instead of searching the highest creation_time?</p>\n<p dir=\"auto\">When searching a value, both edges (valid_from = :date and valid_to = :date) are excluded. I would expect at least one of those two to be included.</p>", "author": "rlemmers", "createdAt": "2020-07-15T16:04:40Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.repository;\n+\n+import java.util.Date;\n+\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.stereotype.Repository;\n+\n+@Repository\n+public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n+    @Query(value = \"SELECT es.id FROM encrypted_secret es \"\n+            + \"LEFT JOIN encryption_key_reference ekr ON es.encryption_key_reference_id = ekr.id \"\n+            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n+            + \"AND ekr.valid_from < :date AND (ekr.valid_to IS NULL OR ekr.valid_to > :date) \"\n+            + \"ORDER BY es.creation_time DESC, es.id DESC LIMIT 1\", nativeQuery = true)", "originalCommit": "27e8524ee4835a63fc556e033e0a2213932c401f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 50d7a9692b..7fff5931b5 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -18,12 +20,19 @@ import org.springframework.stereotype.Repository;\n \n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n-    @Query(value = \"SELECT es.id FROM encrypted_secret es \"\n-            + \"LEFT JOIN encryption_key_reference ekr ON es.encryption_key_reference_id = ekr.id \"\n+    @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n             + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND ekr.valid_from < :date AND (ekr.valid_to IS NULL OR ekr.valid_to > :date) \"\n-            + \"ORDER BY es.creation_time DESC, es.id DESC LIMIT 1\", nativeQuery = true)\n-    Long findIdOfValidMostRecent(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") String secretType, @Param(\"date\") Date validDate);\n+            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n+            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time()) \"\n+            + \"ORDER BY es.creation_time DESC, es.id DESC\")\n+    Page<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n+            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus,\n+            Pageable pageable);\n \n+    @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n+            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n+            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time())\")\n+    int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n+            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 7fff5931b5..62188c57fc 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -21,18 +21,21 @@ import org.springframework.stereotype.Repository;\n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n     @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n-            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time()) \"\n-            + \"ORDER BY es.creation_time DESC, es.id DESC\")\n-    Page<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus,\n-            Pageable pageable);\n+            + \"JOIN es.encryptionKeyReference ekr \"\n+            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus \"\n+            + \"AND ekr.validFrom < current_timestamp() \"\n+            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp()) \"\n+            + \"ORDER BY es.creationTime DESC, es.id DESC\")\n+    List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n+            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n \n     @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"WHERE es.device_identification = :deviceIdentification AND es.secret_type = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus AND es.encryptionKeyReference.valid_from < current_time() \"\n-            + \"AND (es.encryptionKeyReference.valid_to IS NULL OR es.encryptionKeyReference.valid_to > current_time())\")\n+            + \"JOIN es.encryptionKeyReference ekr \"\n+            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+            + \"AND es.secretStatus= :secretStatus \"\n+            + \"AND ekr.validFrom < current_timestamp() \"\n+            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp())\")\n     int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "9cb3262eeec80c4de35024ad396066d2ff8b3712", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex 62188c57fc..b29d90afd7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -21,21 +21,15 @@ import org.springframework.stereotype.Repository;\n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n     @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"JOIN es.encryptionKeyReference ekr \"\n             + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n             + \"AND es.secretStatus= :secretStatus \"\n-            + \"AND ekr.validFrom < current_timestamp() \"\n-            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp()) \"\n             + \"ORDER BY es.creationTime DESC, es.id DESC\")\n     List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n \n     @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"JOIN es.encryptionKeyReference ekr \"\n             + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus \"\n-            + \"AND ekr.validFrom < current_timestamp() \"\n-            + \"AND (ekr.validTo IS NULL OR ekr.validTo > current_timestamp())\")\n+            + \"AND es.secretStatus= :secretStatus\")\n     int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n             @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\nindex b29d90afd7..051581b4e9 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/repository/DbEncryptedSecretRepository.java\n", "chunk": "@@ -20,16 +19,24 @@ import org.springframework.stereotype.Repository;\n \n @Repository\n public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n-    @Query(value = \"SELECT es FROM DbEncryptedSecret es \"\n-            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus \"\n-            + \"ORDER BY es.creationTime DESC, es.id DESC\")\n-    List<DbEncryptedSecret> findSecrets(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n+  @Query(\n+      value =\n+          \"SELECT es FROM DbEncryptedSecret es \"\n+              + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+              + \"AND es.secretStatus= :secretStatus \"\n+              + \"ORDER BY es.creationTime DESC, es.id DESC\")\n+  List<DbEncryptedSecret> findSecrets(\n+      @Param(\"deviceIdentification\") String deviceIdentification,\n+      @Param(\"secretType\") SecretType secretType,\n+      @Param(\"secretStatus\") SecretStatus secretStatus);\n \n-    @Query(value = \"SELECT count(es) FROM DbEncryptedSecret es \"\n-            + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n-            + \"AND es.secretStatus= :secretStatus\")\n-    int getSecretCount(@Param(\"deviceIdentification\") String deviceIdentification,\n-            @Param(\"secretType\") SecretType secretType, @Param(\"secretStatus\") SecretStatus secretStatus);\n+  @Query(\n+      value =\n+          \"SELECT count(es) FROM DbEncryptedSecret es \"\n+              + \"WHERE es.deviceIdentification = :deviceIdentification AND es.secretType = :secretType \"\n+              + \"AND es.secretStatus= :secretStatus\")\n+  int getSecretCount(\n+      @Param(\"deviceIdentification\") String deviceIdentification,\n+      @Param(\"secretType\") SecretType secretType,\n+      @Param(\"secretStatus\") SecretStatus secretStatus);\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3ODA3Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r457478073", "body": "Avoid using the old java.util.Date class. ZonedDateTime is a better one.", "bodyText": "Avoid using the old java.util.Date class. ZonedDateTime is a better one.", "bodyHTML": "<p dir=\"auto\">Avoid using the old java.util.Date class. ZonedDateTime is a better one.</p>", "author": "rlemmers", "createdAt": "2020-07-20T15:11:26Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();", "originalCommit": "bf30f647c4161df08ef894f4e80f80be0cc9ba58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAyMzkxMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r458023910", "bodyText": "The date is also used in the call to the \"find\" for the DB, so using java.util.Date is still necessary. I'll mark this comment as resolved.", "author": "rlemmers", "createdAt": "2020-07-21T11:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3ODA3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -48,19 +51,10 @@ public class SecretManagementService {\n         this.keyRepository = keyRepository;\n     }\n \n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n-        //@formatter:off\n-        secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n-    }\n-\n     private DbEncryptionKeyReference getKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n-                this.encryptionProviderType, Pageable.unpaged());\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n+                this.encryptionProviderType, now, Pageable.unpaged());\n         if (keyRefsPage.getSize() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n         }\n", "next_change": {"commit": "94e63058d388392b7bf2745d334a0bae21f61ea3", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..b749f99b63 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -62,12 +60,13 @@ public class SecretManagementService {\n                 () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n         if (secret.getSecret() == null) {\n             throw new IllegalArgumentException(\"No secret string set\");\n         } else if (secret.getSecretType() == null) {\n             throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n             throw new IllegalArgumentException(\n                     String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n                             secret.getSecretType().name()));\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex b749f99b63..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,186 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateNewSecret(final String deviceIdentification, final TypedSecret secret) {\n-        this.checkNrNewSecretsOfType(deviceIdentification, secret.getSecretType(), 0);\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification,\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n             final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n-    }\n-\n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateNewSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n         }\n     }\n \n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        final DbEncryptionKeyReference keyReference = this.getKey();\n-        //TODO get key (KEK) from HSM and use it to generate AES 128-bits secret\n-        return null;\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3ODk2MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r457478960", "body": "Your IDE should be able to format this nicely automatically (the same goes for the previous \"@formatter\" code.", "bodyText": "Your IDE should be able to format this nicely automatically (the same goes for the previous \"@Formatter\" code.", "bodyHTML": "<p dir=\"auto\">Your IDE should be able to format this nicely automatically (the same goes for the previous \"<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Formatter/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Formatter\">@Formatter</a>\" code.</p>", "author": "rlemmers", "createdAt": "2020-07-20T15:12:15Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package org.opensmartgridplatform.secretmanagement.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService {\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    public SecretManagementService(\n+            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = defaultEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey() {\n+        final Date now = new Date();\n+        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(now,\n+                this.encryptionProviderType, Pageable.unpaged());\n+        if (keyRefsPage.getSize() > 1) {\n+            throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        }\n+        return keyRefsPage.stream().findFirst().orElseThrow(\n+                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+    }\n+\n+    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n+        if (secret.getSecret() == null) {\n+            throw new IllegalArgumentException(\"No secret string set\");\n+        } else if (secret.getSecretType() == null) {\n+            throw new IllegalArgumentException(\"No secret type set\");\n+        } else if (this.isIdenticalToCurrent(deviceIdentification, secret)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n+                            secret.getSecretType().name()));\n+        }\n+        return secret;\n+    }\n+\n+    private boolean isIdenticalToCurrent(final String deviceIdentification, final TypedSecret secret) {\n+        final Optional<TypedSecret> current = this.retrieveSecret(deviceIdentification, secret.getSecretType());\n+        return current.isPresent() ? current.get().getSecret().equals(secret.getSecret()) : false;\n+    }\n+\n+    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+            final DbEncryptionKeyReference keyReference) {\n+        final String secretString = typedSecret.getSecret();\n+        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n+        final Secret secret = new Secret(secretBytes);\n+        try {\n+            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n+                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n+            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n+            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n+            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+            dbEncryptedSecret.setCreationTime(new Date());\n+            return dbEncryptedSecret;\n+        } catch (final Exception exc) {\n+            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n+        }\n+    }\n+\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n+            throws Exception {\n+        try {\n+            //@formatter:off", "originalCommit": "bf30f647c4161df08ef894f4e80f80be0cc9ba58", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd7f59b56b5f6250d14db53ebb35f3c826b73056", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 618e001b7d..29d26a3ffb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -106,12 +106,11 @@ public class SecretManagementService {\n         }\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes)\n-            throws Exception {\n+    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         try {\n             //@formatter:off\n             return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification,secretType))\n+                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n                     .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n", "next_change": {"commit": "0eb589d93a73297fc1c9297e49eaae62cd4d24ae", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29d26a3ffb..c792f43fce 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -110,7 +106,7 @@ public class SecretManagementService {\n         try {\n             //@formatter:off\n             return secretTypes.stream()\n-                    .map(secretType -> this.retrieveSecret(deviceIdentification, secretType))\n+                    .map(secretType -> this.retrieveCurrentSecret(deviceIdentification, secretType))\n                     .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n", "next_change": {"commit": "3036acd028ad8099c3b8f6af2df1c2f67d76b8ef", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex c792f43fce..d38c5f1060 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -106,7 +104,7 @@ public class SecretManagementService {\n         try {\n             //@formatter:off\n             return secretTypes.stream()\n-                    .map(secretType -> this.retrieveCurrentSecret(deviceIdentification, secretType))\n+                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n                     .map(Optional::get)\n                     .collect(Collectors.toList());\n             //@formatter:on\n", "next_change": {"commit": "48f94738f3140d957048fe261b4be5bda3e90ddf", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex d38c5f1060..edc18809a6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -23,186 +28,280 @@ import org.opensmartgridplatform.secretmanagement.application.domain.SecretType;\n import org.opensmartgridplatform.secretmanagement.application.domain.TypedSecret;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptedSecretRepository;\n import org.opensmartgridplatform.secretmanagement.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionDelegate;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n-import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.RsaEncrypter;\n import org.springframework.beans.factory.annotation.Qualifier;\n-import org.springframework.data.domain.Page;\n-import org.springframework.data.domain.Pageable;\n import org.springframework.stereotype.Service;\n \n+/**\n+ * Service that manages secrets (store, retrieve, activate, generate).\n+ * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n+ * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n+ * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n+ * database corruption as a result of partially succeeded batch results.\n+ *\n+ * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n+ * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n+ * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n+ * by reencrypting the AES-encrypted secrets to RSA.\n+ */\n @Service\n public class SecretManagementService {\n+    //Internal datastructure to keep track of (intermediate) secret details\n+    private static class EncryptedTypedSecret {\n+        byte[] encryptedSecret;\n+        SecretType type;\n+        String encryptionKeyReference;  //NULL when RSA\n+\n+        private EncryptedTypedSecret(SecretType type) {\n+            this.type = type;\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type) {\n+            this(secret,type,null);\n+        }\n+\n+        private EncryptedTypedSecret(byte[] secret, SecretType type, String encryptionKeyReference) {\n+            if(secret==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+            } else if(type==null) {\n+                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+            }\n+            this.encryptedSecret = secret;\n+            this.type = type;\n+            this.encryptionKeyReference = encryptionKeyReference;\n+        }\n+\n+        private boolean hasNullSecret() {\n+            return this.encryptedSecret==null;\n+        }\n+\n+        private TypedSecret toTypedSecret() {\n+            return new TypedSecret(this.encryptedSecret, this.type);\n+        }\n+\n+        private static EncryptedTypedSecret getNullInstance(SecretType type) {\n+            return new EncryptedTypedSecret(type);\n+        }\n+    }\n+\n     private final EncryptionDelegate encryptionDelegate;\n     private final EncryptionProviderType encryptionProviderType;\n     private final DbEncryptedSecretRepository secretRepository;\n     private final DbEncryptionKeyRepository keyRepository;\n+    private final RsaEncrypter rsaEncrypter;\n \n     public SecretManagementService(\n             @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n             final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository) {\n+            final DbEncryptionKeyRepository keyRepository, RsaEncrypter rsaEncrypter) {\n         this.encryptionDelegate = defaultEncryptionDelegate;\n         this.encryptionProviderType = encryptionProviderType;\n         this.secretRepository = secretRepository;\n         this.keyRepository = keyRepository;\n+        this.rsaEncrypter = rsaEncrypter;\n     }\n \n-    private DbEncryptionKeyReference getKey() {\n+    private DbEncryptionKeyReference getCurrentKey() {\n         final Date now = new Date();\n-        final Page<DbEncryptionKeyReference> keyRefsPage = this.keyRepository.findByTypeAndValid(\n-                this.encryptionProviderType, now, Pageable.unpaged());\n-        if (keyRefsPage.getSize() > 1) {\n+        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n+                .findByTypeAndValid(this.encryptionProviderType, now);\n+        if (keyRefs.size() > 1) {\n             throw new IllegalStateException(\"Multiple encryption keys found that are valid at \" + now);\n+        } else if(keyRefs.size()==0) {\n+            throw new NoSuchElementException(\"No encryption key found that is valid at \" + now);\n         }\n-        return keyRefsPage.stream().findFirst().orElseThrow(\n-                () -> new NoSuchElementException(\"No encryption key found that is valid at \" + now));\n+        return keyRefs.get(0);\n     }\n \n-    private TypedSecret validateSecret(final String deviceIdentification, final TypedSecret secret) {\n-        if (secret.getSecret() == null) {\n+    private DbEncryptionKeyReference getKeyByReference(String reference) {\n+        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+    }\n+\n+    private EncryptedTypedSecret validateNewSecret(final String deviceIdentification,\n+            final EncryptedTypedSecret secret) {\n+        this.checkNrNewSecretsOfType(deviceIdentification, secret.type, 0);\n+        if (secret.hasNullSecret()) {\n             throw new IllegalArgumentException(\"No secret string set\");\n-        } else if (secret.getSecretType() == null) {\n-            throw new IllegalArgumentException(\"No secret type set\");\n-        } else if (this.isIdenticalToActive(deviceIdentification, secret)) {\n-            throw new IllegalArgumentException(\n-                    String.format(\"Secret is identical to current secret (%s, %s)\", deviceIdentification,\n-                            secret.getSecretType().name()));\n         }\n         return secret;\n     }\n \n-    private boolean isIdenticalToActive(final String deviceIdentification, final TypedSecret secret) {\n-        final Optional<TypedSecret> active = this.retrieveActiveSecret(deviceIdentification, secret.getSecretType());\n-        return active.isPresent() && active.get().getSecret().equals(secret.getSecret());\n-    }\n-\n-    private DbEncryptedSecret createEncrypted(final String deviceIdentification, final TypedSecret typedSecret,\n+    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n             final DbEncryptionKeyReference keyReference) {\n-        final String secretString = typedSecret.getSecret();\n-        final byte[] secretBytes = HexUtils.fromHexString(secretString);\n-        final Secret secret = new Secret(secretBytes);\n-        final Date now = new Date(); //TODO check creation & time zone\n-        try {\n-            final EncryptedSecret encryptedSecret = this.encryptionDelegate.encrypt(\n-                    keyReference.getEncryptionProviderType(), secret, keyReference.getReference());\n-            final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-            dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-            dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(encryptedSecret.getSecret()));\n-            dbEncryptedSecret.setSecretType(typedSecret.getSecretType());\n-            dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-            dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-            dbEncryptedSecret.setCreationTime(now);\n-            return dbEncryptedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not create encrypted secret\", exc);\n-        }\n+        final Date now = new Date();\n+        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+        dbEncryptedSecret.setSecretType(secret.type);\n+        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+        dbEncryptedSecret.setCreationTime(now);\n+        return dbEncryptedSecret;\n     }\n \n     public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n+        return this.retrieveAesSecrets(deviceIdentification, secretTypes).stream()\n+                   .map(this::reencryptAes2Rsa)\n+                   .map(EncryptedTypedSecret::toTypedSecret)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n         try {\n-            //@formatter:off\n-            return secretTypes.stream()\n-                    .map(secretType -> this.retrieveActiveSecret(deviceIdentification, secretType))\n-                    .map(Optional::get)\n-                    .collect(Collectors.toList());\n-            //@formatter:on\n+            return secretTypes.stream().map(secretType -> this.retrieveActiveSecret(deviceIdentification,\n+                    secretType))\n+                              .collect(Collectors.toList());\n         } catch (final Exception exc) {\n             throw new IllegalStateException(\n                     String.format(\"Something went wrong retrieving secrets for device %s\", deviceIdentification), exc);\n         }\n     }\n \n-    private Optional<TypedSecret> retrieveActiveSecret(final String deviceIdentification,\n+    private EncryptedTypedSecret retrieveActiveSecret(final String deviceIdentification,\n             final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> encryptedSecret = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n-        return encryptedSecret.isPresent() ? Optional.of(this.getTypedSecret(encryptedSecret.get())) : Optional.empty();\n-\n+        final Optional<DbEncryptedSecret> optional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+        if (optional.isPresent()) {\n+            DbEncryptedSecret dbEncryptedSecret = optional.get();\n+            byte[] aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+            String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference);\n+        } else {\n+            return EncryptedTypedSecret.getNullInstance(secretType);\n+        }\n     }\n \n     private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n             final SecretType secretType, final SecretStatus secretStatus) {\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository.findSecrets(deviceIdentification, secretType,\n-                secretStatus);\n+        final List<DbEncryptedSecret> secretsList = this.secretRepository\n+                .findSecrets(deviceIdentification, secretType, secretStatus);\n+        boolean onlySingleSecretAllowed =\n+                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n         if (secretsList.size() == 0) {\n             return Optional.empty();\n-        } else if (secretsList.size() > 1) {\n-            throw new IllegalStateException(); //TODO set proper msg\n+        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s\";\n+            throw new IllegalStateException(String.format(msgFormat, secretStatus, secretsList.size(),\n+                    deviceIdentification));\n         }\n         return Optional.of(secretsList.iterator().next());\n     }\n \n-    private TypedSecret getTypedSecret(final DbEncryptedSecret dbEncryptedSecret) {\n-        final DbEncryptionKeyReference keyReference = dbEncryptedSecret.getEncryptionKeyReference();\n-        if (keyReference == null) {\n-            throw new IllegalStateException(\"Could not create encrypted secret: secret has no key reference\");\n-        }\n-        final byte[] secretBytes = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-        final EncryptedSecret encryptedSecret = new EncryptedSecret(keyReference.getEncryptionProviderType(),\n-                secretBytes);\n-        return this.createTypedSecret(dbEncryptedSecret, keyReference, encryptedSecret);\n+    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n+        List<EncryptedTypedSecret> aesSecrets =\n+                secrets.stream()\n+                       .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+                       .map(this::reencryptRsa2Aes)\n+                       .collect(toList());\n+        this.storeAesSecrets(deviceIdentification, aesSecrets);\n     }\n \n-    private TypedSecret createTypedSecret(final DbEncryptedSecret dbEncryptedSecret,\n-            final DbEncryptionKeyReference keyReference, final EncryptedSecret encryptedSecret) {\n-        try {\n-            final Secret decryptedSecret = this.encryptionDelegate.decrypt(encryptedSecret,\n-                    keyReference.getReference());\n-            final TypedSecret typedSecret = new TypedSecret();\n-            typedSecret.setSecret(HexUtils.toHexString(decryptedSecret.getSecret()));\n-            typedSecret.setSecretType(dbEncryptedSecret.getSecretType());\n-            return typedSecret;\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\"Could not decrypt secret (id: \" + dbEncryptedSecret.getId() + \")\", exc);\n-        }\n-    }\n-\n-    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        //@formatter:off\n-        secrets.stream().map(s->s.getSecretType()).forEach(t-> this.checkNrNewSecretsOfType(deviceIdentification, t, 0));\n+    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n         secrets.stream()\n-                .map(t -> this.validateSecret(deviceIdentification, t))\n-                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey()))\n-                .forEach(this.secretRepository::save);\n-        //@formatter:on\n+               .map(ets -> this.validateNewSecret(deviceIdentification, ets))\n+               .map(ets -> this.createDbEncrypted(deviceIdentification, ets,\n+                       this.getKeyByReference(ets.encryptionKeyReference)))\n+               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n         secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().forEach(t -> this.activateNewSecret(deviceIdentification, t));\n+        secretTypes.stream()\n+                   .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+                   .flatMap(Collection::stream)\n+                   .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n     }\n \n     public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n         return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n     }\n \n-    private synchronized long activateNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this.getSingleDbEncryptedSecret(deviceIdentification,\n-                secretType, SecretStatus.ACTIVE);\n+    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n+            final SecretType secretType) {\n+        List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+        final Optional<DbEncryptedSecret> activeSecretOptional = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n         if (activeSecretOptional.isPresent()) {\n             final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n             currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            this.secretRepository.save(currentSecret);\n+            updatedSecrets.add(currentSecret);\n         }\n-        final DbEncryptedSecret newSecret = this.getSingleDbEncryptedSecret(deviceIdentification, secretType,\n-                SecretStatus.NEW).get(); //We have checked nr of new secrets already in activateNewSecrets\n+        final DbEncryptedSecret newSecret = this\n+                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW)\n+                .get(); //We have checked nr of new secrets already in activateNewSecrets\n         newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-        return this.secretRepository.save(newSecret).getId();\n+        updatedSecrets.add(newSecret);\n+        return updatedSecrets;\n     }\n \n     private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n         final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n         if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets, but %s new secret(s) present\";\n-            throw new IllegalStateException(String.format(errorMsg, expectedNr, nrNewSecretsOfType));\n+            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+            throw new IllegalStateException(String.format(errorMsg, expectedNr, t,\n+                    deviceIdentification, nrNewSecretsOfType));\n+        }\n+    }\n+\n+    public synchronized List<TypedSecret> generateAndStoreSecrets(String deviceIdentification,\n+            final List<SecretType> secretTypes) {\n+        List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream().map(this::generateAes128BitsSecret)\n+                                                                      .collect(Collectors.toList());\n+        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n+                                    .collect(Collectors.toList());\n+    }\n+\n+    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+        try {\n+            String keyReference = this.getCurrentKey().getReference();\n+            byte[] aesEncrypted = this.encryptionDelegate\n+                    .generateAes128BitsSecret(this.encryptionProviderType, keyReference);\n+            return new EncryptedTypedSecret(aesEncrypted, secretType, keyReference);\n+        } catch (EncrypterException ee) {\n+            throw new IllegalStateException(\"Eror generating secret\", ee);\n+        }\n+    }\n+\n+    private EncryptedTypedSecret reencryptRsa2Aes(EncryptedTypedSecret secret) {\n+            byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+            String keyReference = this.getCurrentKey().getReference();\n+            return new EncryptedTypedSecret(aesEncrypted, secret.type, keyReference);\n+    }\n+\n+    private EncryptedTypedSecret reencryptAes2Rsa(EncryptedTypedSecret secret) {\n+        if (secret.hasNullSecret()) {\n+            return secret;  //No need to encrypt NULL value\n+        } else  {\n+            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference);\n+            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n         }\n     }\n \n-    public TypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        final DbEncryptionKeyReference keyReference = this.getKey();\n-        //TODO get key (KEK) from HSM and use it to generate AES 128-bits secret\n-        return null;\n+    private byte[] reencryptRsa2Aes(byte[] rsa) {\n+        //Incoming new secret, so use current key\n+        String keyReference = this.getCurrentKey().getReference();\n+        try {\n+            return this.encryptionDelegate\n+                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+                    .getSecret();\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from RSA to AES\", ee);\n+        }\n+    }\n+\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        try {\n+            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n+                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+        } catch (final EncrypterException ee) {\n+            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+        }\n     }\n }\n", "next_change": {"commit": "1b865ba81923b501555a4ee23eb72b06eed7eb19", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex edc18809a6..27dc8c7145 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -301,7 +300,7 @@ public class SecretManagementService {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n                     .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reecrypt secret from AES to RSA\", ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "45e9f6f96c5ec51fb3e18fc9f5303406d50296ac", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 27dc8c7145..8cf8ba9f87 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -290,17 +299,17 @@ public class SecretManagementService {\n             return this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference) {\n+    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n             return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(this.encryptionProviderType, aes), keyReference));\n+                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \"+ee.toString(), ee);\n+            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n     }\n }\n", "next_change": {"commit": "04d6eb0acfd61f742c7ce81ed9807bcf241aeeff", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8cf8ba9f87..e1d2b2e4e7 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -306,8 +309,8 @@ public class SecretManagementService {\n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n         //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n         try {\n-            return this.rsaEncrypter.encrypt(this.encryptionDelegate\n-                    .decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+            return this.rsaEncrypter.encrypt(\n+                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n         }\n", "next_change": {"commit": "6fc837b99ad040e7541184578507c278b5e481e4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e1d2b2e4e7..8aa67c6a48 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -298,16 +316,26 @@ public class SecretManagementService {\n     private byte[] reencryptRsa2Aes(byte[] rsa) {\n         //Incoming new secret, so use current key\n         String keyReference = this.getCurrentKey().getReference();\n+        byte[] aes;\n         try {\n-            return this.encryptionDelegate\n+            aes = this.encryptionDelegate\n                     .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n+        return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key provided by parameter for decrypting aes\n+        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n+        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n+        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n+        //            ComponentType.SECRET_MANAGEMENT));\n+        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "40a643c8f5949e8f16de9c95013137600b4b1f2e", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 8aa67c6a48..0e5257659f 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -323,19 +326,10 @@ public class SecretManagementService {\n         } catch (final EncrypterException ee) {\n             throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n         }\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(this.encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         return aes;\n     }\n \n     private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n-        //Outgoing existing secret, so use AES key referenceprovided by parameter for decrypting aes\n-        //if (aes.length != this.encryptionDelegate.getSecretByteLength(encryptionProviderType)) {\n-        //    throw new ExceptionWrapper(new FunctionalException(FunctionalExceptionType.INVALID_DLMS_KEY_FORMAT,\n-        //            ComponentType.SECRET_MANAGEMENT));\n-        //}\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "8cd5cf5b3b6ca8456f4c696aa07f1947a7430bb4", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 0e5257659f..29abe83eb2 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -329,7 +330,7 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(byte[] aes, String keyReference, EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "faf172b555431808d55176540c23693ed21bf607", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 29abe83eb2..cf78ad33b1 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -330,7 +364,8 @@ public class SecretManagementService {\n         return aes;\n     }\n \n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference, final EncryptionProviderType encryptionProviderType) {\n+    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n+            final EncryptionProviderType encryptionProviderType) {\n         try {\n             return this.rsaEncrypter.encrypt(\n                     this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex cf78ad33b1..ab3a034dbf 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -42,335 +39,360 @@ import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n /**\n- * Service that manages secrets (store, retrieve, activate, generate).\n- * Secrets in this service are always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the\n- * secrets in the database (store/activate) are mostly batch-wise and are implemented transactionally: they do their\n- * pre-processing and finally persist any changes in transactional repository saveAll() call, in order to prevent\n- * database corruption as a result of partially succeeded batch results.\n+ * Service that manages secrets (store, retrieve, activate, generate). Secrets in this service are\n+ * always AES-encrypted secrets of type EncryptedTypedSecret. Methods that manipulate the secrets in\n+ * the database (store/activate) are mostly batch-wise and are implemented transactionally: they do\n+ * their pre-processing and finally persist any changes in transactional repository saveAll() call,\n+ * in order to prevent database corruption as a result of partially succeeded batch results.\n  *\n- * Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of type TypedSecret, so\n- * these secrets are always reencrypted to AES before being processed any further in order to keep unencrypted secret\n- * in JVM memory/heap for the shortest possible time. Likewise, any public method will return RSA-encrypted secrets\n- * by reencrypting the AES-encrypted secrets to RSA.\n+ * <p>Keep in mind that all public methods assume (externally provided) RSA-encrypted secrets of\n+ * type TypedSecret, so these secrets are always reencrypted to AES before being processed any\n+ * further in order to keep unencrypted secret in JVM memory/heap for the shortest possible time.\n+ * Likewise, any public method will return RSA-encrypted secrets by reencrypting the AES-encrypted\n+ * secrets to RSA.\n  */\n @Service\n-@Slf4j\n public class SecretManagementService {\n-    //Internal datastructure to keep track of (intermediate) secret details\n-    private static class EncryptedTypedSecret {\n-        byte[] encryptedSecret;\n-        SecretType type;\n-        String encryptionKeyReference;  //NULL when RSA\n-        EncryptionProviderType encryptionProviderType;  //NULL when RSA\n-\n-        private EncryptedTypedSecret(final SecretType type) {\n-            this.type = type;\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n-            this(secret, type, null, null);\n-        }\n-\n-        private EncryptedTypedSecret(final byte[] secret, final SecretType type, final String encryptionKeyReference,\n-                final EncryptionProviderType encryptionProviderType) {\n-            if (secret == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n-            } else if (type == null) {\n-                throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n-            }\n-            this.encryptedSecret = secret;\n-            this.type = type;\n-            this.encryptionKeyReference = encryptionKeyReference;\n-            this.encryptionProviderType = encryptionProviderType;\n-        }\n-\n-        private boolean hasNullSecret() {\n-            return this.encryptedSecret == null;\n-        }\n-\n-        private TypedSecret toTypedSecret() {\n-            return new TypedSecret(this.encryptedSecret, this.type);\n-        }\n-\n-        private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n-            return new EncryptedTypedSecret(type);\n-        }\n-\n-        private static EncryptedTypedSecret fromDbEncryptedSecret(final DbEncryptedSecret dbEncryptedSecret)\n-                throws FunctionalException {\n-            byte[] aesEncrypted;\n-            try {\n-                aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n-            } catch (IllegalArgumentException iae) {\n-                throw new FunctionalException(FunctionalExceptionType.INVALID_KEY_FORMAT,\n-                        ComponentType.SECRET_MANAGEMENT, iae);\n-            }\n-            final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n-            final EncryptionProviderType providerType = dbEncryptedSecret.getEncryptionKeyReference()\n-                                                                         .getEncryptionProviderType();\n-            return new EncryptedTypedSecret(aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference,\n-                    providerType);\n-        }\n-    }\n-\n-    private final EncryptionDelegate encryptionDelegate;\n-    private final EncryptionProviderType encryptionProviderType;\n-    private final DbEncryptedSecretRepository secretRepository;\n-    private final DbEncryptionKeyRepository keyRepository;\n-    private final RsaEncrypter rsaEncrypter;\n-\n-    public SecretManagementService(\n-            @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n-            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n-            final DbEncryptionKeyRepository keyRepository, final RsaEncrypter rsaEncrypter) {\n-        this.encryptionDelegate = defaultEncryptionDelegate;\n-        this.encryptionProviderType = encryptionProviderType;\n-        this.secretRepository = secretRepository;\n-        this.keyRepository = keyRepository;\n-        this.rsaEncrypter = rsaEncrypter;\n-    }\n-\n-    private DbEncryptionKeyReference getCurrentKey() {\n-        final Date now = new Date();\n-        final List<DbEncryptionKeyReference> keyRefs = this.keyRepository\n-                .findByTypeAndValid(this.encryptionProviderType, now);\n-        if (keyRefs.size() > 1) {\n-            String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n-            throw new IllegalStateException(String.format(messageFormat, this.encryptionProviderType, now));\n-        } else if (keyRefs.isEmpty()) {\n-            String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n-            throw new NoSuchElementException(String.format(messageFormat, this.encryptionProviderType, now));\n-        }\n-        return keyRefs.get(0);\n-    }\n-\n-    private DbEncryptionKeyReference getKeyByReference(final String reference) {\n-        return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n-    }\n-\n-    private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n-        if (secret.hasNullSecret()) {\n-            final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n-            throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n-        }\n-        return secret;\n+  // Internal datastructure to keep track of (intermediate) secret details\n+  private static class EncryptedTypedSecret {\n+    byte[] encryptedSecret;\n+    SecretType type;\n+    String encryptionKeyReference; // NULL when RSA\n+    EncryptionProviderType encryptionProviderType; // NULL when RSA\n+\n+    private EncryptedTypedSecret(final SecretType type) {\n+      this.type = type;\n     }\n \n-    private DbEncryptedSecret createDbEncrypted(final String deviceIdentification, final EncryptedTypedSecret secret,\n-            final DbEncryptionKeyReference keyReference) {\n-        final Date now = new Date();\n-        final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n-        dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n-        dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n-        dbEncryptedSecret.setSecretType(secret.type);\n-        dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n-        dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n-        dbEncryptedSecret.setCreationTime(now);\n-        return dbEncryptedSecret;\n+    private EncryptedTypedSecret(final byte[] secret, final SecretType type) {\n+      this(secret, type, null, null);\n     }\n \n-    public List<TypedSecret> retrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+    private EncryptedTypedSecret(\n+        final byte[] secret,\n+        final SecretType type,\n+        final String encryptionKeyReference,\n+        final EncryptionProviderType encryptionProviderType) {\n+      if (secret == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secret'\");\n+      } else if (type == null) {\n+        throw new IllegalArgumentException(\"No NULL value allowed for parameter 'secretType'\");\n+      }\n+      this.encryptedSecret = secret;\n+      this.type = type;\n+      this.encryptionKeyReference = encryptionKeyReference;\n+      this.encryptionProviderType = encryptionProviderType;\n     }\n \n-    public List<TypedSecret> retrieveNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        log.trace(\">>> retrieveNewSecrets({},{})\", deviceIdentification, secretTypes);\n-        return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+    private boolean hasNullSecret() {\n+      return this.encryptedSecret == null;\n     }\n \n-    private List<TypedSecret> doRetrieveSecrets(final String deviceIdentification, final List<SecretType> secretTypes,\n-            SecretStatus status) {\n-        log.trace(\">>> doRetrieveSecrets({},{},{})\", deviceIdentification, secretTypes, status);\n-        return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream().map(this::reencryptAes2Rsa)\n-                   .map(EncryptedTypedSecret::toTypedSecret).collect(Collectors.toList());\n+    private TypedSecret toTypedSecret() {\n+      return new TypedSecret(this.encryptedSecret, this.type);\n     }\n \n-    private List<EncryptedTypedSecret> retrieveAesSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes, final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretTypes, status);\n-        try {\n-            return secretTypes.stream().map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n-                              .collect(Collectors.toList());\n-        } catch (final Exception exc) {\n-            throw new IllegalStateException(\n-                    String.format(\"Something went wrong retrieving secrets for device %s: %s\", deviceIdentification,\n-                            exc.toString()), exc);\n-        }\n+    private static EncryptedTypedSecret getNullInstance(final SecretType type) {\n+      return new EncryptedTypedSecret(type);\n     }\n \n-    private EncryptedTypedSecret retrieveSecret(final String deviceIdentification, final SecretType secretType,\n-            final SecretStatus status) {\n-        log.trace(\">>> retrieveAesSecrets({},{})\", deviceIdentification, secretType, status);\n-        final Optional<DbEncryptedSecret> optional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n-        if (optional.isPresent()) {\n-            try {\n-                log.trace(\"<<< retrieveAesSecrets({},{}): secret found\", deviceIdentification, secretType, status);\n-                return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n-            } catch (FunctionalException e) {\n-                throw new ExceptionWrapper(e);\n-            }\n-        } else {\n-            log.trace(\"<<< retrieveAesSecrets({},{}): no secret found\", deviceIdentification, secretType, status);\n-            return EncryptedTypedSecret.getNullInstance(secretType);\n-        }\n+    private static EncryptedTypedSecret fromDbEncryptedSecret(\n+        final DbEncryptedSecret dbEncryptedSecret) throws FunctionalException {\n+      byte[] aesEncrypted;\n+      try {\n+        aesEncrypted = HexUtils.fromHexString(dbEncryptedSecret.getEncodedSecret());\n+      } catch (final IllegalArgumentException iae) {\n+        throw new FunctionalException(\n+            FunctionalExceptionType.INVALID_KEY_FORMAT, ComponentType.SECRET_MANAGEMENT, iae);\n+      }\n+      final String keyReference = dbEncryptedSecret.getEncryptionKeyReference().getReference();\n+      final EncryptionProviderType providerType =\n+          dbEncryptedSecret.getEncryptionKeyReference().getEncryptionProviderType();\n+      return new EncryptedTypedSecret(\n+          aesEncrypted, dbEncryptedSecret.getSecretType(), keyReference, providerType);\n     }\n-\n-    private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(final String deviceIdentification,\n-            final SecretType secretType, final SecretStatus secretStatus) {\n-        log.trace(\">>> getSingleDbEncryptedSecret({},{},{})\", deviceIdentification, secretType,\n-                secretStatus);\n-        final List<DbEncryptedSecret> secretsList = this.secretRepository\n-                .findSecrets(deviceIdentification, secretType, secretStatus);\n-        final boolean onlySingleSecretAllowed =\n-                SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n-        if (secretsList.isEmpty()) {\n-            log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): no secret found\", deviceIdentification, secretType,\n-                    secretStatus);\n-            return Optional.empty();\n-        } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n-            String msgFormat = \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n-            throw new IllegalStateException(\n-                    String.format(msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n-        }\n-        log.trace(\"<<< getSingleDbEncryptedSecret({},{},{}): secret found\", deviceIdentification, secretType,\n-                secretStatus);\n-        return Optional.of(secretsList.iterator().next());\n-    }\n-\n-    public synchronized void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) {\n-        secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n-        final List<EncryptedTypedSecret> aesSecrets = secrets.stream()\n-                                                             .map(ts -> new EncryptedTypedSecret(ts.getSecret(),\n-                                                                     ts.getSecretType())).map(this::reencryptRsa2Aes)\n-                                                             .collect(toList());\n-        this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private final EncryptionDelegate encryptionDelegate;\n+  private final EncryptionProviderType encryptionProviderType;\n+  private final DbEncryptedSecretRepository secretRepository;\n+  private final DbEncryptionKeyRepository keyRepository;\n+  private final RsaEncrypter rsaEncrypter;\n+\n+  public SecretManagementService(\n+      @Qualifier(\"DefaultEncryptionDelegate\") final EncryptionDelegate defaultEncryptionDelegate,\n+      final EncryptionProviderType encryptionProviderType,\n+      final DbEncryptedSecretRepository secretRepository,\n+      final DbEncryptionKeyRepository keyRepository,\n+      final RsaEncrypter rsaEncrypter) {\n+    this.encryptionDelegate = defaultEncryptionDelegate;\n+    this.encryptionProviderType = encryptionProviderType;\n+    this.secretRepository = secretRepository;\n+    this.keyRepository = keyRepository;\n+    this.rsaEncrypter = rsaEncrypter;\n+  }\n+\n+  private DbEncryptionKeyReference getCurrentKey() {\n+    final Date now = new Date();\n+    final List<DbEncryptionKeyReference> keyRefs =\n+        this.keyRepository.findByTypeAndValid(this.encryptionProviderType, now);\n+    if (keyRefs.size() > 1) {\n+      final String messageFormat = \"Multiple encryption keys found of type %s that are valid at %s\";\n+      throw new IllegalStateException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n+    } else if (keyRefs.isEmpty()) {\n+      final String messageFormat = \"No encryption key of type %s found that is valid at %s\";\n+      throw new NoSuchElementException(\n+          String.format(messageFormat, this.encryptionProviderType, now));\n     }\n+    return keyRefs.get(0);\n+  }\n \n-    private void storeAesSecrets(final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n-        log.trace(\">>> storeAesSecrets({},{})\", deviceIdentification, secrets);\n-        secrets.stream().map(this::validateAndReturnNewSecret).map(ets -> this\n-                .createDbEncrypted(deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n-               .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n-        log.trace(\"<<< storeAesSecrets({},{}): secrets stored\", deviceIdentification, secrets);\n+  private DbEncryptionKeyReference getKeyByReference(final String reference) {\n+    return this.keyRepository.findByTypeAndReference(this.encryptionProviderType, reference);\n+  }\n \n+  private EncryptedTypedSecret validateAndReturnNewSecret(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      final FunctionalExceptionType excType = FunctionalExceptionType.KEY_NOT_PRESENT;\n+      throw new ExceptionWrapper(new FunctionalException(excType, ComponentType.SECRET_MANAGEMENT));\n     }\n-\n-    public synchronized void activateNewSecrets(final String deviceIdentification, final List<SecretType> secretTypes) {\n-        secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n-        secretTypes.stream().map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n-                   .flatMap(Collection::stream).collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+    return secret;\n+  }\n+\n+  private DbEncryptedSecret createDbEncrypted(\n+      final String deviceIdentification,\n+      final EncryptedTypedSecret secret,\n+      final DbEncryptionKeyReference keyReference) {\n+    final Date now = new Date();\n+    final DbEncryptedSecret dbEncryptedSecret = new DbEncryptedSecret();\n+    dbEncryptedSecret.setDeviceIdentification(deviceIdentification);\n+    dbEncryptedSecret.setEncodedSecret(HexUtils.toHexString(secret.encryptedSecret));\n+    dbEncryptedSecret.setSecretType(secret.type);\n+    dbEncryptedSecret.setSecretStatus(SecretStatus.NEW);\n+    dbEncryptedSecret.setEncryptionKeyReference(keyReference);\n+    dbEncryptedSecret.setCreationTime(now);\n+    return dbEncryptedSecret;\n+  }\n+\n+  public List<TypedSecret> retrieveSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.ACTIVE);\n+  }\n+\n+  public List<TypedSecret> retrieveNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    return this.doRetrieveSecrets(deviceIdentification, secretTypes, SecretStatus.NEW);\n+  }\n+\n+  private List<TypedSecret> doRetrieveSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    return this.retrieveAesSecrets(deviceIdentification, secretTypes, status).stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<EncryptedTypedSecret> retrieveAesSecrets(\n+      final String deviceIdentification,\n+      final List<SecretType> secretTypes,\n+      final SecretStatus status) {\n+    try {\n+      return secretTypes.stream()\n+          .map(secretType -> this.retrieveSecret(deviceIdentification, secretType, status))\n+          .collect(Collectors.toList());\n+    } catch (final Exception exc) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Something went wrong retrieving secrets for device %s: %s\",\n+              deviceIdentification, exc.toString()),\n+          exc);\n     }\n-\n-    public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n-        return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW) > 0;\n+  }\n+\n+  private EncryptedTypedSecret retrieveSecret(\n+      final String deviceIdentification, final SecretType secretType, final SecretStatus status) {\n+    final Optional<DbEncryptedSecret> optional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, status);\n+    if (optional.isPresent()) {\n+      try {\n+        return EncryptedTypedSecret.fromDbEncryptedSecret(optional.get());\n+      } catch (final FunctionalException e) {\n+        throw new ExceptionWrapper(e);\n+      }\n+    } else {\n+      return EncryptedTypedSecret.getNullInstance(secretType);\n     }\n-\n-    private List<DbEncryptedSecret> getUpdatedSecretsForActivation(final String deviceIdentification,\n-            final SecretType secretType) {\n-        final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n-        final Optional<DbEncryptedSecret> activeSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n-        if (activeSecretOptional.isPresent()) {\n-            final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n-            currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n-            updatedSecrets.add(currentSecret);\n-        }\n-        final Optional<DbEncryptedSecret> newSecretOptional = this\n-                .getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n-        if (newSecretOptional.isPresent()) {\n-            final DbEncryptedSecret newSecret = newSecretOptional.get();\n-            newSecret.setSecretStatus(SecretStatus.ACTIVE);\n-            updatedSecrets.add(newSecret);\n-            return updatedSecrets;\n-        } else {\n-            throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n-        }\n+  }\n+\n+  private Optional<DbEncryptedSecret> getSingleDbEncryptedSecret(\n+      final String deviceIdentification,\n+      final SecretType secretType,\n+      final SecretStatus secretStatus) {\n+    final List<DbEncryptedSecret> secretsList =\n+        this.secretRepository.findSecrets(deviceIdentification, secretType, secretStatus);\n+    final boolean onlySingleSecretAllowed =\n+        SecretStatus.NEW.equals(secretStatus) || SecretStatus.ACTIVE.equals(secretStatus);\n+    if (secretsList.isEmpty()) {\n+      return Optional.empty();\n+    } else if (secretsList.size() > 1 && onlySingleSecretAllowed) {\n+      final String msgFormat =\n+          \"Only 1 instance allowed with status %s, but found %s for device %s, secret type %s\";\n+      throw new IllegalStateException(\n+          String.format(\n+              msgFormat, secretStatus, secretsList.size(), deviceIdentification, secretType));\n     }\n-\n-    private void checkNrNewSecretsOfType(final String deviceIdentification, final SecretType t, final int expectedNr) {\n-        log.trace(\">>> checkNrNewSecretsOfType({},{},{})\", deviceIdentification, t, expectedNr);\n-        final int nrNewSecretsOfType = this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n-        if (nrNewSecretsOfType != expectedNr) {\n-            final String errorMsg = \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n-            throw new IllegalStateException(\n-                    String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n-        }\n-        log.trace(\"<<< checkNrNewSecretsOfType({},{},{}): OK\", deviceIdentification, t, expectedNr);\n+    return Optional.of(secretsList.iterator().next());\n+  }\n+\n+  public synchronized void storeSecrets(\n+      final String deviceIdentification, final List<TypedSecret> secrets) {\n+    secrets.forEach(s -> this.checkNrNewSecretsOfType(deviceIdentification, s.getSecretType(), 0));\n+    final List<EncryptedTypedSecret> aesSecrets =\n+        secrets.stream()\n+            .map(ts -> new EncryptedTypedSecret(ts.getSecret(), ts.getSecretType()))\n+            .map(this::reencryptRsa2Aes)\n+            .collect(toList());\n+    this.storeAesSecrets(deviceIdentification, aesSecrets);\n+  }\n+\n+  private void storeAesSecrets(\n+      final String deviceIdentification, final List<EncryptedTypedSecret> secrets) {\n+    secrets.stream()\n+        .map(this::validateAndReturnNewSecret)\n+        .map(\n+            ets ->\n+                this.createDbEncrypted(\n+                    deviceIdentification, ets, this.getKeyByReference(ets.encryptionKeyReference)))\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public synchronized void activateNewSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.stream().forEach(t -> this.checkNrNewSecretsOfType(deviceIdentification, t, 1));\n+    secretTypes.stream()\n+        .map(t -> this.getUpdatedSecretsForActivation(deviceIdentification, t))\n+        .flatMap(Collection::stream)\n+        .collect(collectingAndThen(toList(), this.secretRepository::saveAll));\n+  }\n+\n+  public boolean hasNewSecret(final String deviceIdentification, final SecretType secretType) {\n+    return this.secretRepository.getSecretCount(deviceIdentification, secretType, SecretStatus.NEW)\n+        > 0;\n+  }\n+\n+  private List<DbEncryptedSecret> getUpdatedSecretsForActivation(\n+      final String deviceIdentification, final SecretType secretType) {\n+    final List<DbEncryptedSecret> updatedSecrets = new ArrayList<>();\n+    final Optional<DbEncryptedSecret> activeSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.ACTIVE);\n+    if (activeSecretOptional.isPresent()) {\n+      final DbEncryptedSecret currentSecret = activeSecretOptional.get();\n+      currentSecret.setSecretStatus(SecretStatus.EXPIRED);\n+      updatedSecrets.add(currentSecret);\n     }\n-\n-    public synchronized List<TypedSecret> generateAndStoreSecrets(final String deviceIdentification,\n-            final List<SecretType> secretTypes) {\n-        log.trace(\">>> generateAndStoreSecrets({},{})\", deviceIdentification, secretTypes);\n-        secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n-        final List<EncryptedTypedSecret> encryptedTypedSecrets = secretTypes.stream()\n-                                                                            .map(this::generateAes128BitsSecret)\n-                                                                            .collect(Collectors.toList());\n-        this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n-        log.trace(\"<<< generateAndStoreSecrets({},{}): convert and return stored secrets ({})\", deviceIdentification,\n-                secretTypes, encryptedTypedSecrets.size());\n-        return encryptedTypedSecrets.stream().map(this::reencryptAes2Rsa).map(EncryptedTypedSecret::toTypedSecret)\n-                                    .collect(Collectors.toList());\n+    final Optional<DbEncryptedSecret> newSecretOptional =\n+        this.getSingleDbEncryptedSecret(deviceIdentification, secretType, SecretStatus.NEW);\n+    if (newSecretOptional.isPresent()) {\n+      final DbEncryptedSecret newSecret = newSecretOptional.get();\n+      newSecret.setSecretStatus(SecretStatus.ACTIVE);\n+      updatedSecrets.add(newSecret);\n+      return updatedSecrets;\n+    } else {\n+      throw new IllegalStateException(\"Cannot activate new secret: no new secret present\");\n     }\n-\n-    private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n-        log.trace(\">>> generateAes128BitsSecret({})\", secretType);\n-        try {\n-            final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-            final byte[] aesEncrypted = this.encryptionDelegate\n-                    .generateAes128BitsSecret(this.encryptionProviderType, currentKey.getReference());\n-            log.debug(\"<<< generateAes128BitsSecret({}): generated AES secret with bytesize {}\", secretType,\n-                    aesEncrypted.length);\n-            return new EncryptedTypedSecret(aesEncrypted, secretType, currentKey.getReference(),\n-                    currentKey.getEncryptionProviderType());\n-        } catch (EncrypterException ee) {\n-            throw new IllegalStateException(\"Eror generating secret\", ee);\n-        }\n+  }\n+\n+  private void checkNrNewSecretsOfType(\n+      final String deviceIdentification, final SecretType t, final int expectedNr) {\n+    final int nrNewSecretsOfType =\n+        this.secretRepository.getSecretCount(deviceIdentification, t, SecretStatus.NEW);\n+    if (nrNewSecretsOfType != expectedNr) {\n+      final String errorMsg =\n+          \"Expected %s new secrets of type %s for device %s, but %s new secret(s) present\";\n+      throw new IllegalStateException(\n+          String.format(errorMsg, expectedNr, t, deviceIdentification, nrNewSecretsOfType));\n     }\n-\n-    private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptRsa2Aes(...)\");\n-        byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n-        final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n-        log.trace(\"<<< reencryptRsa2Aes(...)\");\n-        return new EncryptedTypedSecret(aesEncrypted, secret.type, currentKey.getReference(),\n-                currentKey.getEncryptionProviderType());\n+  }\n+\n+  public synchronized List<TypedSecret> generateAndStoreSecrets(\n+      final String deviceIdentification, final List<SecretType> secretTypes) {\n+    secretTypes.forEach(st -> this.checkNrNewSecretsOfType(deviceIdentification, st, 0));\n+    final List<EncryptedTypedSecret> encryptedTypedSecrets =\n+        secretTypes.stream().map(this::generateAes128BitsSecret).collect(Collectors.toList());\n+    this.storeAesSecrets(deviceIdentification, encryptedTypedSecrets);\n+    return encryptedTypedSecrets.stream()\n+        .map(this::reencryptAes2Rsa)\n+        .map(EncryptedTypedSecret::toTypedSecret)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private EncryptedTypedSecret generateAes128BitsSecret(final SecretType secretType) {\n+    try {\n+      final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+      final byte[] aesEncrypted =\n+          this.encryptionDelegate.generateAes128BitsSecret(\n+              this.encryptionProviderType, currentKey.getReference());\n+      return new EncryptedTypedSecret(\n+          aesEncrypted,\n+          secretType,\n+          currentKey.getReference(),\n+          currentKey.getEncryptionProviderType());\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\"Eror generating secret\", ee);\n     }\n-\n-    private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n-        log.trace(\">>> reencryptAes2Rsa(...)\");\n-        if (secret.hasNullSecret()) {\n-            log.trace(\"<<< reencryptAes2Rsa(...): NULL value\");\n-            return secret;  //No need to encrypt NULL value\n-        } else {\n-            byte[] rsaEncrypted = this.reencryptAes2Rsa(secret.encryptedSecret, secret.encryptionKeyReference,\n-                    secret.encryptionProviderType);\n-            log.trace(\"<<< reencryptAes2Rsa(...): non-NULL value\");\n-            return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n-        }\n+  }\n+\n+  private EncryptedTypedSecret reencryptRsa2Aes(final EncryptedTypedSecret secret) {\n+    final byte[] aesEncrypted = this.reencryptRsa2Aes(secret.encryptedSecret);\n+    final DbEncryptionKeyReference currentKey = this.getCurrentKey();\n+    return new EncryptedTypedSecret(\n+        aesEncrypted,\n+        secret.type,\n+        currentKey.getReference(),\n+        currentKey.getEncryptionProviderType());\n+  }\n+\n+  private EncryptedTypedSecret reencryptAes2Rsa(final EncryptedTypedSecret secret) {\n+    if (secret.hasNullSecret()) {\n+      return secret; // No need to encrypt NULL value\n+    } else {\n+      final byte[] rsaEncrypted =\n+          this.reencryptAes2Rsa(\n+              secret.encryptedSecret, secret.encryptionKeyReference, secret.encryptionProviderType);\n+      return new EncryptedTypedSecret(rsaEncrypted, secret.type);\n     }\n-\n-    private byte[] reencryptRsa2Aes(final byte[] rsa) {\n-        //Incoming new secret, so use current key\n-        final String keyReference = this.getCurrentKey().getReference();\n-        byte[] aes;\n-        try {\n-            aes = this.encryptionDelegate\n-                    .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference).getSecret();\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n-        }\n-        return aes;\n+  }\n+\n+  private byte[] reencryptRsa2Aes(final byte[] rsa) {\n+    // Incoming new secret, so use current key\n+    final String keyReference = this.getCurrentKey().getReference();\n+    byte[] aes;\n+    try {\n+      aes =\n+          this.encryptionDelegate\n+              .encrypt(this.encryptionProviderType, this.rsaEncrypter.decrypt(rsa), keyReference)\n+              .getSecret();\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from RSA to AES: \" + ee.toString(), ee);\n     }\n-\n-    private byte[] reencryptAes2Rsa(final byte[] aes, final String keyReference,\n-            final EncryptionProviderType encryptionProviderType) {\n-        try {\n-            return this.rsaEncrypter.encrypt(\n-                    this.encryptionDelegate.decrypt(new EncryptedSecret(encryptionProviderType, aes), keyReference));\n-        } catch (final EncrypterException ee) {\n-            throw new IllegalStateException(\"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n-        }\n+    return aes;\n+  }\n+\n+  private byte[] reencryptAes2Rsa(\n+      final byte[] aes,\n+      final String keyReference,\n+      final EncryptionProviderType encryptionProviderType) {\n+    try {\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n+              new EncryptedSecret(encryptionProviderType, aes), keyReference));\n+    } catch (final EncrypterException ee) {\n+      throw new IllegalStateException(\n+          \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n+  }\n }\n", "next_change": {"commit": "070b150e39f283adfbe5d9523ed23922c6a19692", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex ab3a034dbf..1ddbd6d589 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -387,8 +398,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "7c40c251ce4427041ced9792aaafc517e5d2d0a7", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex 1ddbd6d589..e0624915d6 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -398,8 +479,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.encrypterForSecretManagementClient.encrypt(\n-          this.encryptionDelegateForKeyStorage.decrypt(\n+      return this.rsaEncrypter.encrypt(\n+          this.encryptionDelegate.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e0624915d6..e127e7e4fb 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -479,8 +497,8 @@ public class SecretManagementService {\n       final String keyReference,\n       final EncryptionProviderType encryptionProviderType) {\n     try {\n-      return this.rsaEncrypter.encrypt(\n-          this.encryptionDelegate.decrypt(\n+      return this.encrypterForSecretManagementClient.encrypt(\n+          this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n       throw new IllegalStateException(\n", "next_change": {"commit": "b47868cd83b6ba22cb5156841af5a085a5a43f69", "changed_code": [{"header": "diff --git a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\nindex e127e7e4fb..a70a4885d4 100644\n--- a/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n+++ b/osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/services/SecretManagementService.java\n", "chunk": "@@ -501,8 +418,20 @@ public class SecretManagementService {\n           this.encryptionDelegateForKeyStorage.decrypt(\n               new EncryptedSecret(encryptionProviderType, aes), keyReference));\n     } catch (final EncrypterException ee) {\n-      throw new IllegalStateException(\n+      throw this.handleEncrypterException(\n           \"Could not reencrypt secret from AES to RSA: \" + ee.toString(), ee);\n     }\n   }\n+\n+  /*\n+   * com.ncipher.provider.nCCommunicationException is loaded into JVM by HSM.\n+   * JAR is not standard available in maven repo\n+   * Exception checking on class name is possible without importing jar\n+   */\n+  private IllegalStateException handleEncrypterException(\n+      final String message, final EncrypterException encrypterException) {\n+    this.secretManagementMetrics.incrementEncrypterException(encrypterException);\n+\n+    return new IllegalStateException(message, encrypterException);\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "e2b37fab39390dac5960a5a9e780f8b5162b3a54", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e2b37fab39390dac5960a5a9e780f8b5162b3a54", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' into test_2077", "committedDate": "2020-07-21T06:20:21Z", "type": "commit"}, {"oid": "7eb9a13750cb54d3c2533f1ff3954856805637f9", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/7eb9a13750cb54d3c2533f1ff3954856805637f9", "message": "Merge branch 'development' into test_2077", "committedDate": "2020-07-21T06:20:26Z", "type": "commit"}, {"oid": "13dc1cb72a2a3d9aad4a25da733e2e2fea6172b1", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/13dc1cb72a2a3d9aad4a25da733e2e2fea6172b1", "message": "Revert \"Remove tests for build\"\n\nThis reverts commit bde1481a55eb7557be924ba8e0129113827c4162.", "committedDate": "2020-07-21T07:01:46Z", "type": "commit"}, {"oid": "fb6248e8bf029e15394e1e0fa0cbc2968af22e33", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fb6248e8bf029e15394e1e0fa0cbc2968af22e33", "message": "Disable failing unit tests, solve minor sonar issues", "committedDate": "2020-07-21T07:16:42Z", "type": "commit"}, {"oid": "f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f41fa2e6cb64e6d9d2ec81a9f40865c97c62f380", "message": "SLIM-2077-review", "committedDate": "2020-07-21T08:45:23Z", "type": "commit"}, {"oid": "61d74da39a055a7282e4ed9d471e117ee0e09b7e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/61d74da39a055a7282e4ed9d471e117ee0e09b7e", "message": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmanagement/application/SoapServiceSecretManagementIT.java", "committedDate": "2020-07-21T08:55:15Z", "type": "commit"}, {"oid": "e80af70465197a2f500e08fe40b9f74ac3806c95", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e80af70465197a2f500e08fe40b9f74ac3806c95", "message": "Enable unit tests", "committedDate": "2020-07-21T08:55:41Z", "type": "commit"}, {"oid": "ed14ef97bad42284b11ab8117d86d7268281ed11", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ed14ef97bad42284b11ab8117d86d7268281ed11", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' into test_2077", "committedDate": "2020-07-21T08:56:23Z", "type": "commit"}, {"oid": "2eb6ffa103b266a63e4551960e8a9a3bd7e4b654", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2eb6ffa103b266a63e4551960e8a9a3bd7e4b654", "message": "public to private", "committedDate": "2020-07-21T09:00:32Z", "type": "commit"}, {"oid": "1dd5aedca9ddb6ab2bd7cb605bdeb772c3703551", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1dd5aedca9ddb6ab2bd7cb605bdeb772c3703551", "message": "Merge pull request #375 from OSGP/test_2077\n\nTest 2077", "committedDate": "2020-07-21T09:05:45Z", "type": "commit"}, {"oid": "0aaff58885efd4ad4159ccfd59178c055735da22", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0aaff58885efd4ad4159ccfd59178c055735da22", "message": "Added fix for not finding external logback configuration", "committedDate": "2020-07-21T09:09:25Z", "type": "commit"}, {"oid": "386a82357fdf8a0c2f31134a64087b09415bc2f7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/386a82357fdf8a0c2f31134a64087b09415bc2f7", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-07-21T09:09:45Z", "type": "commit"}, {"oid": "48a8d639fd19c7786b50e3a88ce00d744f804024", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/48a8d639fd19c7786b50e3a88ce00d744f804024", "message": "Removed file appender for integration test", "committedDate": "2020-07-21T09:15:52Z", "type": "commit"}, {"oid": "48660fefc94fb080feaeee024ece5bd90dbf40e4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/48660fefc94fb080feaeee024ece5bd90dbf40e4", "message": "Add context.xml", "committedDate": "2020-07-21T11:15:25Z", "type": "commit"}, {"oid": "1a5975cc121f6272044cb1608e7ea345b97dd06b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1a5975cc121f6272044cb1608e7ea345b97dd06b", "message": "Sonar Critical on log.error", "committedDate": "2020-07-21T12:36:13Z", "type": "commit"}, {"oid": "9927d20221b3a973c6afbac6deb042424d94bbcc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9927d20221b3a973c6afbac6deb042424d94bbcc", "message": "SLIM-2077-handled-review-comments", "committedDate": "2020-07-21T12:37:47Z", "type": "commit"}, {"oid": "00861f5300efe580d234c91e027f1d6ac6548e75", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/00861f5300efe580d234c91e027f1d6ac6548e75", "message": "Add secret management to pom and database", "committedDate": "2020-07-21T16:27:41Z", "type": "commit"}, {"oid": "375f0f01164b4a33bf9d0619b5abe945c00eb216", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/375f0f01164b4a33bf9d0619b5abe945c00eb216", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-07-21T16:28:10Z", "type": "commit"}, {"oid": "0cfc3079ae9e5917f37f5fe281cd3fba37461d56", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0cfc3079ae9e5917f37f5fe281cd3fba37461d56", "message": "Add missing db connection file", "committedDate": "2020-07-21T16:38:46Z", "type": "commit"}, {"oid": "4dc00294fff56796ae7c4af8e8099e75721879f8", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4dc00294fff56796ae7c4af8e8099e75721879f8", "message": "Solve db issues", "committedDate": "2020-07-21T17:15:01Z", "type": "commit"}, {"oid": "0fafd2b0fb242615222d9e0eee0cf61329ca5797", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0fafd2b0fb242615222d9e0eee0cf61329ca5797", "message": "Improve inserts", "committedDate": "2020-07-21T20:32:11Z", "type": "commit"}, {"oid": "caae04725c6f4c967a2c7e147b1eceffe63f2018", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/caae04725c6f4c967a2c7e147b1eceffe63f2018", "message": "change key file in properties", "committedDate": "2020-07-22T06:35:37Z", "type": "commit"}, {"oid": "836c59ef390bd4af38db8b9bdece1fe5e3d57eae", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/836c59ef390bd4af38db8b9bdece1fe5e3d57eae", "message": "Adapted context.xml and logging", "committedDate": "2020-07-22T07:23:39Z", "type": "commit"}, {"oid": "8caac38ef83c6bf8385b6f181d95b8d3535e95ba", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8caac38ef83c6bf8385b6f181d95b8d3535e95ba", "message": "Use generic keystore and truststore", "committedDate": "2020-07-22T09:47:00Z", "type": "commit"}, {"oid": "80dc367d9c7e29c1ae0a2eddbc73e10099344762", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/80dc367d9c7e29c1ae0a2eddbc73e10099344762", "message": "Set correct truststore password", "committedDate": "2020-07-22T11:17:34Z", "type": "commit"}, {"oid": "d74e3b3f5af25bee0f9ceec7e7ed907f82c15def", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d74e3b3f5af25bee0f9ceec7e7ed907f82c15def", "message": "SLIM-2077-option-no-hostname-verifier", "committedDate": "2020-07-22T13:47:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMzc1MQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r458813751", "body": "![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the literal \"false\" boolean value. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](http://ci.opensmartgridplatform.org/sonarqube/coding_rules#rule_key=squid%3AS1125)\n", "bodyText": "Remove the literal \"false\" boolean value.", "bodyHTML": "<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://camo.githubusercontent.com/7583166906b97dea085b4c7960eab0e846348ed9ba157a3a6bee5958811d6477/68747470733a2f2f736f6e6172736f757263652e6769746875622e696f2f736f6e61722d6769746875622f73657665726974792d6d696e6f722e706e67\"><img src=\"https://camo.githubusercontent.com/7583166906b97dea085b4c7960eab0e846348ed9ba157a3a6bee5958811d6477/68747470733a2f2f736f6e6172736f757263652e6769746875622e696f2f736f6e61722d6769746875622f73657665726974792d6d696e6f722e706e67\" alt=\"MINOR\" title=\"Severity: MINOR\" data-canonical-src=\"https://sonarsource.github.io/sonar-github/severity-minor.png\" style=\"max-width: 100%;\"></a> Remove the literal \"false\" boolean value. <a href=\"http://ci.opensmartgridplatform.org/sonarqube/coding_rules#rule_key=squid%3AS1125\" rel=\"nofollow\"><img src=\"https://camo.githubusercontent.com/90a66c56e56d5e4647676830313fa0693466067889c4c7dc2d7519da5a924230/68747470733a2f2f736f6e6172736f757263652e6769746875622e696f2f736f6e61722d6769746875622f72756c652e706e67\" alt=\"rule\" data-canonical-src=\"https://sonarsource.github.io/sonar-github/rule.png\" style=\"max-width: 100%;\"></a></p>", "author": "jenkins-ip-10-4-24-184", "createdAt": "2020-07-22T13:59:31Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright 2016 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.config;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.Resource;\n+import org.springframework.oxm.jaxb.Jaxb2Marshaller;\n+import org.springframework.ws.client.core.WebServiceTemplate;\n+import org.springframework.ws.soap.security.support.KeyManagersFactoryBean;\n+import org.springframework.ws.soap.security.support.KeyStoreFactoryBean;\n+import org.springframework.ws.soap.security.support.TrustManagersFactoryBean;\n+import org.springframework.ws.transport.http.HttpsUrlConnectionMessageSender;\n+\n+@Configuration\n+public class SoapClientConfig {\n+\n+    private static final String XSD_SCHEMA_PACKAGE = \"org.opensmartgridplatform.ws.schema.core.secret.management\";\n+\n+    @Value(\"${soapclient.use.client.auth:false}\")\n+    private String useClientAuth;\n+\n+    @Value(\"${soapclient.use.hostname.verifier:true}\")\n+    private String useHostNameVerifier;\n+\n+    @Value(\"${soapclient.default-uri}\")\n+\n+    private String defaultUri;\n+\n+    @Value(\"${soapclient.ssl.trust-store}\")\n+    private Resource trustStore;\n+\n+    @Value(\"${soapclient.ssl.trust-store-password}\")\n+    private String trustStorePassword;\n+\n+    @Value(\"${soapclient.ssl.key-store}\")\n+    private Resource keyStore;\n+\n+    @Value(\"${soapclient.ssl.key-store-password}\")\n+    private String keyStorePassword;\n+\n+    @Value(\"${soapclient.ssl.key-password}\")\n+    private String keyPassword;\n+\n+    @Value(\"${encryption.soap.rsa.private.key.resource}\")\n+    private Resource soapRsaPrivateKeyResource;\n+\n+    @Bean\n+    Jaxb2Marshaller soapClientJaxb2Marshaller() {\n+        Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();\n+        jaxb2Marshaller.setContextPath(XSD_SCHEMA_PACKAGE);\n+        return jaxb2Marshaller;\n+    }\n+\n+    @Bean\n+    public WebServiceTemplate webServiceTemplate() throws Exception {\n+        WebServiceTemplate webServiceTemplate = new WebServiceTemplate();\n+        webServiceTemplate.setMarshaller(soapClientJaxb2Marshaller());\n+        webServiceTemplate.setUnmarshaller(soapClientJaxb2Marshaller());\n+        webServiceTemplate.setDefaultUri(defaultUri);\n+\n+        if (Boolean.parseBoolean(useClientAuth)) {\n+            webServiceTemplate.setMessageSender(httpsUrlConnectionMessageSender());\n+        }\n+\n+        return webServiceTemplate;\n+    }\n+\n+    @Bean\n+    public HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender() throws Exception {\n+        HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender =\n+                new HttpsUrlConnectionMessageSender();\n+        // set the trust store(s)\n+        httpsUrlConnectionMessageSender.setTrustManagers(trustManagersFactoryBean().getObject());\n+        // set the key store(s)\n+        httpsUrlConnectionMessageSender.setKeyManagers(keyManagersFactoryBean().getObject());\n+\n+        if (Boolean.parseBoolean(useHostNameVerifier) == false) {", "originalCommit": "d74e3b3f5af25bee0f9ceec7e7ed907f82c15def", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 02a8e498f5..d6ffd650ad 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -82,11 +82,11 @@ public class SoapClientConfig {\n         HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender =\n                 new HttpsUrlConnectionMessageSender();\n         // set the trust store(s)\n-        httpsUrlConnectionMessageSender.setTrustManagers(trustManagersFactoryBean().getObject());\n+        httpsUrlConnectionMessageSender.setTrustManagers(this.trustManagersFactoryBean().getObject());\n         // set the key store(s)\n-        httpsUrlConnectionMessageSender.setKeyManagers(keyManagersFactoryBean().getObject());\n+        httpsUrlConnectionMessageSender.setKeyManagers(this.keyManagersFactoryBean().getObject());\n \n-        if (Boolean.parseBoolean(useHostNameVerifier) == false) {\n+        if (Boolean.parseBoolean(this.useHostNameVerifier) == false) {\n             httpsUrlConnectionMessageSender.setHostnameVerifier(new NoopHostnameVerifier());\n         }\n \n", "next_change": {"commit": "bfedad64e14235b17f44beb4508815276cbcf275", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex d6ffd650ad..481fe4cd06 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -86,7 +90,7 @@ public class SoapClientConfig {\n         // set the key store(s)\n         httpsUrlConnectionMessageSender.setKeyManagers(this.keyManagersFactoryBean().getObject());\n \n-        if (Boolean.parseBoolean(this.useHostNameVerifier) == false) {\n+        if (!Boolean.parseBoolean(this.useHostNameVerifier)) {\n             httpsUrlConnectionMessageSender.setHostnameVerifier(new NoopHostnameVerifier());\n         }\n \n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 481fe4cd06..389c0fd67e 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -26,123 +26,122 @@ import org.springframework.ws.transport.http.HttpsUrlConnectionMessageSender;\n @Configuration\n public class SoapClientConfig {\n \n-    private static final String XSD_SCHEMA_PACKAGE = \"org.opensmartgridplatform.ws.schema.core.secret.management\";\n-\n-    @Value(\"${soapclient.use.client.auth:false}\")\n-    private String useClientAuth;\n-\n-    @Value(\"${soapclient.use.hostname.verifier:true}\")\n-    private String useHostNameVerifier;\n-\n-    @Value(\"${soapclient.default-uri}\")\n+  private static final String XSD_SCHEMA_PACKAGE =\n+      \"org.opensmartgridplatform.ws.schema.core.secret.management\";\n \n-    private String defaultUri;\n+  @Value(\"${soapclient.use.client.auth:false}\")\n+  private String useClientAuth;\n \n-    @Value(\"${soapclient.ssl.trust-store}\")\n-    private Resource trustStore;\n+  @Value(\"${soapclient.use.hostname.verifier:true}\")\n+  private String useHostNameVerifier;\n \n-    @Value(\"${soapclient.ssl.trust-store-password}\")\n-    private String trustStorePassword;\n+  @Value(\"${soapclient.default-uri}\")\n+  private String defaultUri;\n \n-    @Value(\"${soapclient.ssl.key-store}\")\n-    private Resource keyStore;\n+  @Value(\"${soapclient.ssl.trust-store}\")\n+  private Resource trustStore;\n \n-    @Value(\"${soapclient.ssl.key-store-password}\")\n-    private String keyStorePassword;\n+  @Value(\"${soapclient.ssl.trust-store-password}\")\n+  private String trustStorePassword;\n \n-    @Value(\"${soapclient.ssl.key-password}\")\n-    private String keyPassword;\n+  @Value(\"${soapclient.ssl.key-store}\")\n+  private Resource keyStore;\n \n-    @Value(\"${encryption.soap.rsa.private.key.resource}\")\n-    private Resource soapRsaPrivateKeyResource;\n+  @Value(\"${soapclient.ssl.key-store-password}\")\n+  private String keyStorePassword;\n \n-    @Value(\"${encryption.soap.rsa.public.key.resource}\")\n-    private Resource soapRsaPublicKeyResource;\n+  @Value(\"${soapclient.ssl.key-password}\")\n+  private String keyPassword;\n \n-    @Bean\n-    Jaxb2Marshaller soapClientJaxb2Marshaller() {\n-        Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();\n-        jaxb2Marshaller.setContextPath(XSD_SCHEMA_PACKAGE);\n-        return jaxb2Marshaller;\n-    }\n-\n-    @Bean\n-    public WebServiceTemplate webServiceTemplate() throws Exception {\n+  @Value(\"${encryption.soap.rsa.private.key.resource}\")\n+  private Resource soapRsaPrivateKeyResource;\n \n-        WebServiceTemplate webServiceTemplate = new WebServiceTemplate();\n-        webServiceTemplate.setMarshaller(this.soapClientJaxb2Marshaller());\n-        webServiceTemplate.setUnmarshaller(this.soapClientJaxb2Marshaller());\n-        webServiceTemplate.setDefaultUri(this.defaultUri);\n+  @Value(\"${encryption.soap.rsa.public.key.resource}\")\n+  private Resource soapRsaPublicKeyResource;\n \n-        if (Boolean.parseBoolean(this.useClientAuth)) {\n-            webServiceTemplate.setMessageSender(this.httpsUrlConnectionMessageSender());\n-        }\n-\n-        return webServiceTemplate;\n-    }\n+  @Bean\n+  Jaxb2Marshaller soapClientJaxb2Marshaller() {\n+    final Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();\n+    jaxb2Marshaller.setContextPath(XSD_SCHEMA_PACKAGE);\n+    return jaxb2Marshaller;\n+  }\n \n-    @Bean\n-    public HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender() throws Exception {\n-        HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender =\n-                new HttpsUrlConnectionMessageSender();\n-        // set the trust store(s)\n-        httpsUrlConnectionMessageSender.setTrustManagers(this.trustManagersFactoryBean().getObject());\n-        // set the key store(s)\n-        httpsUrlConnectionMessageSender.setKeyManagers(this.keyManagersFactoryBean().getObject());\n+  @Bean\n+  public WebServiceTemplate webServiceTemplate() throws Exception {\n \n-        if (!Boolean.parseBoolean(this.useHostNameVerifier)) {\n-            httpsUrlConnectionMessageSender.setHostnameVerifier(new NoopHostnameVerifier());\n-        }\n+    final WebServiceTemplate webServiceTemplate = new WebServiceTemplate();\n+    webServiceTemplate.setMarshaller(this.soapClientJaxb2Marshaller());\n+    webServiceTemplate.setUnmarshaller(this.soapClientJaxb2Marshaller());\n+    webServiceTemplate.setDefaultUri(this.defaultUri);\n \n-        return httpsUrlConnectionMessageSender;\n+    if (Boolean.parseBoolean(this.useClientAuth)) {\n+      webServiceTemplate.setMessageSender(this.httpsUrlConnectionMessageSender());\n     }\n \n-    @Bean\n-    public KeyStoreFactoryBean trustStore() {\n-        KeyStoreFactoryBean keyStoreFactoryBean = new KeyStoreFactoryBean();\n-        keyStoreFactoryBean.setLocation(this.trustStore);\n-        keyStoreFactoryBean.setPassword(this.trustStorePassword);\n+    return webServiceTemplate;\n+  }\n \n-        return keyStoreFactoryBean;\n-    }\n-\n-    @Bean\n-    public TrustManagersFactoryBean trustManagersFactoryBean() {\n-        TrustManagersFactoryBean trustManagersFactoryBean = new TrustManagersFactoryBean();\n-        trustManagersFactoryBean.setKeyStore(this.trustStore().getObject());\n-\n-        return trustManagersFactoryBean;\n-    }\n-\n-    @Bean\n-    public KeyStoreFactoryBean keyStore() {\n-        KeyStoreFactoryBean keyStoreFactoryBean = new KeyStoreFactoryBean();\n-        keyStoreFactoryBean.setLocation(this.keyStore);\n-        keyStoreFactoryBean.setPassword(this.keyStorePassword);\n-\n-        return keyStoreFactoryBean;\n-    }\n+  @Bean\n+  public HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender() throws Exception {\n+    final HttpsUrlConnectionMessageSender httpsUrlConnectionMessageSender =\n+        new HttpsUrlConnectionMessageSender();\n+    // set the trust store(s)\n+    httpsUrlConnectionMessageSender.setTrustManagers(this.trustManagersFactoryBean().getObject());\n+    // set the key store(s)\n+    httpsUrlConnectionMessageSender.setKeyManagers(this.keyManagersFactoryBean().getObject());\n \n-    @Bean\n-    public KeyManagersFactoryBean keyManagersFactoryBean() {\n-        KeyManagersFactoryBean keyManagersFactoryBean = new KeyManagersFactoryBean();\n-        keyManagersFactoryBean.setKeyStore(this.keyStore().getObject());\n-        keyManagersFactoryBean.setPassword(this.keyPassword);\n-        return keyManagersFactoryBean;\n+    if (!Boolean.parseBoolean(this.useHostNameVerifier)) {\n+      httpsUrlConnectionMessageSender.setHostnameVerifier(new NoopHostnameVerifier());\n     }\n \n-    @Bean\n-    public RsaEncrypter rsaEncrypter() {\n-        try {\n-            File privateRsaKeyFile = this.soapRsaPrivateKeyResource.getFile();\n-            File publicRsaKeyFile = this.soapRsaPublicKeyResource.getFile();\n-            RsaEncrypter rsaEncrypter= new RsaEncrypter();\n-            rsaEncrypter.setPrivateKeyStore(privateRsaKeyFile);\n-            rsaEncrypter.setPublicKeyStore(publicRsaKeyFile);\n-            return rsaEncrypter;\n-        }\n-        catch(IOException e) {\n-            throw new IllegalStateException(\"Could not initialize RsaEncrypter\", e);\n-        }\n+    return httpsUrlConnectionMessageSender;\n+  }\n+\n+  @Bean\n+  public KeyStoreFactoryBean trustStore() {\n+    final KeyStoreFactoryBean keyStoreFactoryBean = new KeyStoreFactoryBean();\n+    keyStoreFactoryBean.setLocation(this.trustStore);\n+    keyStoreFactoryBean.setPassword(this.trustStorePassword);\n+\n+    return keyStoreFactoryBean;\n+  }\n+\n+  @Bean\n+  public TrustManagersFactoryBean trustManagersFactoryBean() {\n+    final TrustManagersFactoryBean trustManagersFactoryBean = new TrustManagersFactoryBean();\n+    trustManagersFactoryBean.setKeyStore(this.trustStore().getObject());\n+\n+    return trustManagersFactoryBean;\n+  }\n+\n+  @Bean\n+  public KeyStoreFactoryBean keyStore() {\n+    final KeyStoreFactoryBean keyStoreFactoryBean = new KeyStoreFactoryBean();\n+    keyStoreFactoryBean.setLocation(this.keyStore);\n+    keyStoreFactoryBean.setPassword(this.keyStorePassword);\n+\n+    return keyStoreFactoryBean;\n+  }\n+\n+  @Bean\n+  public KeyManagersFactoryBean keyManagersFactoryBean() {\n+    final KeyManagersFactoryBean keyManagersFactoryBean = new KeyManagersFactoryBean();\n+    keyManagersFactoryBean.setKeyStore(this.keyStore().getObject());\n+    keyManagersFactoryBean.setPassword(this.keyPassword);\n+    return keyManagersFactoryBean;\n+  }\n+\n+  @Bean\n+  public RsaEncrypter rsaEncrypter() {\n+    try {\n+      final File privateRsaKeyFile = this.soapRsaPrivateKeyResource.getFile();\n+      final File publicRsaKeyFile = this.soapRsaPublicKeyResource.getFile();\n+      final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n+      rsaEncrypter.setPrivateKeyStore(privateRsaKeyFile);\n+      rsaEncrypter.setPublicKeyStore(publicRsaKeyFile);\n+      return rsaEncrypter;\n+    } catch (final IOException e) {\n+      throw new IllegalStateException(\"Could not initialize RsaEncrypter\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 389c0fd67e..71b45f6510 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -131,17 +131,31 @@ public class SoapClientConfig {\n     return keyManagersFactoryBean;\n   }\n \n-  @Bean\n-  public RsaEncrypter rsaEncrypter() {\n+  @Bean(name = \"encrypterWithSecretManagementPublicKey\")\n+  public RsaEncrypter encrypterWithSecretManagementPublicKey() {\n+    try {\n+      final File publicKeySecretManagementFile =\n+          this.rsaPublicKeySecretManagementResource.getFile();\n+      final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n+      rsaEncrypter.setPublicKeyStore(publicKeySecretManagementFile);\n+      return rsaEncrypter;\n+    } catch (final IOException e) {\n+      throw new IllegalStateException(\n+          \"Could not initialize encrypterWithSecretManagementPublicKey\", e);\n+    }\n+  }\n+\n+  @Bean(name = \"decrypterWithProtocolAdapterPrivateKey\")\n+  public RsaEncrypter decrypterWithProtocolAdapterPrivateKey() {\n     try {\n-      final File privateRsaKeyFile = this.soapRsaPrivateKeyResource.getFile();\n-      final File publicRsaKeyFile = this.soapRsaPublicKeyResource.getFile();\n+      final File privateKeyProtocolAdapterFile =\n+          this.rsaPrivateKeyProtocolAdapterResource.getFile();\n       final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n-      rsaEncrypter.setPrivateKeyStore(privateRsaKeyFile);\n-      rsaEncrypter.setPublicKeyStore(publicRsaKeyFile);\n+      rsaEncrypter.setPrivateKeyStore(privateKeyProtocolAdapterFile);\n       return rsaEncrypter;\n     } catch (final IOException e) {\n-      throw new IllegalStateException(\"Could not initialize RsaEncrypter\", e);\n+      throw new IllegalStateException(\n+          \"Could not initialize decrypterWithProtocolAdapterPrivateKey\", e);\n     }\n   }\n }\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex 71b45f6510..be78acd3c1 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -131,31 +131,29 @@ public class SoapClientConfig {\n     return keyManagersFactoryBean;\n   }\n \n-  @Bean(name = \"encrypterWithSecretManagementPublicKey\")\n-  public RsaEncrypter encrypterWithSecretManagementPublicKey() {\n+  // RsaEncrypter for encrypting secrets to be sent to Secret Management.\n+  @Bean(name = \"encrypterForSecretManagement\")\n+  public RsaEncrypter encrypterForSecretManagement() {\n     try {\n-      final File publicKeySecretManagementFile =\n-          this.rsaPublicKeySecretManagementResource.getFile();\n+      final File publicKeySecretManagementFile = this.rsaPublicKeySecretManagement.getFile();\n       final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n       rsaEncrypter.setPublicKeyStore(publicKeySecretManagementFile);\n       return rsaEncrypter;\n     } catch (final IOException e) {\n-      throw new IllegalStateException(\n-          \"Could not initialize encrypterWithSecretManagementPublicKey\", e);\n+      throw new IllegalStateException(\"Could not initialize encrypterForSecretManagement\", e);\n     }\n   }\n \n-  @Bean(name = \"decrypterWithProtocolAdapterPrivateKey\")\n-  public RsaEncrypter decrypterWithProtocolAdapterPrivateKey() {\n+  // RsaEncrypter for decrypting secrets received by the DLMS protocol adapter.\n+  @Bean(name = \"decrypterForProtocolAdapterDlms\")\n+  public RsaEncrypter decrypterForProtocolAdapterDlms() {\n     try {\n-      final File privateKeyProtocolAdapterFile =\n-          this.rsaPrivateKeyProtocolAdapterResource.getFile();\n+      final File privateKeyProtocolAdapterFile = this.rsaPrivateKeyProtocolAdapterDlms.getFile();\n       final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n       rsaEncrypter.setPrivateKeyStore(privateKeyProtocolAdapterFile);\n       return rsaEncrypter;\n     } catch (final IOException e) {\n-      throw new IllegalStateException(\n-          \"Could not initialize decrypterWithProtocolAdapterPrivateKey\", e);\n+      throw new IllegalStateException(\"Could not initialize decrypterForProtocolAdapterDlms\", e);\n     }\n   }\n }\n", "next_change": {"commit": "bc2b5503c9d12c76eaf7187881cd3c078f40a048", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\nindex be78acd3c1..ba0a4b51a6 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/config/SoapClientConfig.java\n", "chunk": "@@ -156,4 +163,30 @@ public class SoapClientConfig {\n       throw new IllegalStateException(\"Could not initialize decrypterForProtocolAdapterDlms\", e);\n     }\n   }\n+\n+  // RsaEncrypter for encrypting secrets to be sent to other GXF components.\n+  @Bean(name = \"encrypterForGxfSmartMetering\")\n+  public RsaEncrypter encrypterForGxfSmartMetering() {\n+    try {\n+      final File publicKeyGxfSmartMeteringFile = this.rsaPublicKeyGxfSmartMetering.getFile();\n+      final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n+      rsaEncrypter.setPublicKeyStore(publicKeyGxfSmartMeteringFile);\n+      return rsaEncrypter;\n+    } catch (final IOException e) {\n+      throw new IllegalStateException(\"Could not initialize encrypterForGxfSmartMetering\", e);\n+    }\n+  }\n+\n+  // RsaEncrypter for decrypting secrets from applications received by the DLMS protocol adapter.\n+  @Bean(name = \"decrypterForGxfSmartMetering\")\n+  public RsaEncrypter decrypterForGxfSmartMetering() {\n+    try {\n+      final File privateKeyGxfSmartMeteringFile = this.rsaPrivateKeyGxfSmartMetering.getFile();\n+      final RsaEncrypter rsaEncrypter = new RsaEncrypter();\n+      rsaEncrypter.setPrivateKeyStore(privateKeyGxfSmartMeteringFile);\n+      return rsaEncrypter;\n+    } catch (final IOException e) {\n+      throw new IllegalStateException(\"Could not initialize decrypterForGxfSmartMetering\", e);\n+    }\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "a289d4567ed4ce79a06d47423208a05518ae88a3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a289d4567ed4ce79a06d47423208a05518ae88a3", "message": "Skip PR failing tests", "committedDate": "2020-07-22T14:38:16Z", "type": "commit"}, {"oid": "c56ebb4fb0b904c86e87bf75229b202394da40e2", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c56ebb4fb0b904c86e87bf75229b202394da40e2", "message": "Undo groovy change for release branch", "committedDate": "2020-07-22T14:49:44Z", "type": "commit"}, {"oid": "a6ae07aa56913797c686daf3169e8827f0c26c7c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a6ae07aa56913797c686daf3169e8827f0c26c7c", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-05-27T13:35:21Z", "type": "commit"}, {"oid": "c572ca0cb59b0a78b41bb9fc353c564f1dc9c3b8", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c572ca0cb59b0a78b41bb9fc353c564f1dc9c3b8", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-05-28T16:03:00Z", "type": "commit"}, {"oid": "de9edc52ccfbfe6dd21a3a06aec258773c1112e4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/de9edc52ccfbfe6dd21a3a06aec258773c1112e4", "message": "SLIM-2460-implement-soap-service-with-encryption", "committedDate": "2020-06-03T08:03:13Z", "type": "commit"}, {"oid": "ca2f0172359d2a78bf5537ee4fb1bc9154e9d7a3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ca2f0172359d2a78bf5537ee4fb1bc9154e9d7a3", "message": "SLIM-2460-create-soap-service-with-encryption", "committedDate": "2020-06-03T13:01:48Z", "type": "commit"}, {"oid": "c90d7d8eb4a488336e3fe18a8e572ad23fef0d03", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c90d7d8eb4a488336e3fe18a8e572ad23fef0d03", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-03T13:26:16Z", "type": "commit"}, {"oid": "9ef81a677d5bc8a4d7c6f55b4e18b93fbd55104f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9ef81a677d5bc8a4d7c6f55b4e18b93fbd55104f", "message": "typo fixed", "committedDate": "2020-06-03T13:43:42Z", "type": "commit"}, {"oid": "78c2a4b157b69e261b2eac9de64059a833912ac7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/78c2a4b157b69e261b2eac9de64059a833912ac7", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-03T16:52:36Z", "type": "commit"}, {"oid": "bbec761fdf93700bbf98ec3da77f034512bdc057", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bbec761fdf93700bbf98ec3da77f034512bdc057", "message": "Initial version of secret management service and repo's", "committedDate": "2020-06-03T17:20:06Z", "type": "commit"}, {"oid": "9549e751bc945bd3c979eee42597ca01cfdda6be", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9549e751bc945bd3c979eee42597ca01cfdda6be", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application\n\n\u0001 Conflicts:\n\u0001\tosgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/domain/TypedSecret.java\n\u0001\tosgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/SecretManagementService.java", "committedDate": "2020-06-03T17:22:06Z", "type": "commit"}, {"oid": "7234fa91d298770ee1488748cba73c8109bd2d2e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/7234fa91d298770ee1488748cba73c8109bd2d2e", "message": "Removed generate secret method for now", "committedDate": "2020-06-03T17:23:51Z", "type": "commit"}, {"oid": "94620cbaaea7f9956a99e974bb17c56799546b04", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/94620cbaaea7f9956a99e974bb17c56799546b04", "message": "Added encryption/decryption & exception handling to service", "committedDate": "2020-06-04T12:33:29Z", "type": "commit"}, {"oid": "ae6d8b625253702c1f3d9cfcf48cd6b269b17fe3", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ae6d8b625253702c1f3d9cfcf48cd6b269b17fe3", "message": "Changes resulting from discussion with Erik", "committedDate": "2020-06-04T14:09:33Z", "type": "commit"}, {"oid": "e841604b5a1ae073a37b2130205543d07d03d650", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e841604b5a1ae073a37b2130205543d07d03d650", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-04T16:35:38Z", "type": "commit"}, {"oid": "d1bfa13f6d3ec99adb6f83676196e50b4179d309", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/d1bfa13f6d3ec99adb6f83676196e50b4179d309", "message": "Added dynamic encryption provider type key lookup", "committedDate": "2020-06-05T08:39:59Z", "type": "commit"}, {"oid": "f7ec2d7b8fe90a04383a7fcd3c549ff67a61147c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f7ec2d7b8fe90a04383a7fcd3c549ff67a61147c", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application\n\n\u0001 Conflicts:\n\u0001\tosgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/SecretManagementService.java", "committedDate": "2020-06-05T08:42:15Z", "type": "commit"}, {"oid": "573c9654d09454e8f3bd4f8e8a2478f3718f0c9d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/573c9654d09454e8f3bd4f8e8a2478f3718f0c9d", "message": "Changes to accomodate key dereferencing and code cleanup/shuffle", "committedDate": "2020-06-05T09:22:14Z", "type": "commit"}, {"oid": "c4644bd6bd482510e0b0aeb48f9182b2bccea04b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c4644bd6bd482510e0b0aeb48f9182b2bccea04b", "message": "Added repository IT & fixed persistency related problems", "committedDate": "2020-06-08T12:32:47Z", "type": "commit"}, {"oid": "6e2f5d44bd07c0cc983b6a46ee71062e9fba4c8e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6e2f5d44bd07c0cc983b6a46ee71062e9fba4c8e", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-08T12:42:54Z", "type": "commit"}, {"oid": "1c6247d34a9a0d4149adcd00a88dfd42d7dbf252", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1c6247d34a9a0d4149adcd00a88dfd42d7dbf252", "message": "SLIM-2077 related. fix in DbEncryptionKeyReference", "committedDate": "2020-06-08T13:02:39Z", "type": "commit"}, {"oid": "e4204c55c3f81a81bf061c1d05841b5e93c57743", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e4204c55c3f81a81bf061c1d05841b5e93c57743", "message": "SLIM-2077 first test", "committedDate": "2020-06-08T13:27:25Z", "type": "commit"}, {"oid": "95b4fa74b8bf4a78f06aca7ff2e7c5003f9e9e5b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/95b4fa74b8bf4a78f06aca7ff2e7c5003f9e9e5b", "message": "Added encryption provider type to repo find method", "committedDate": "2020-06-08T14:41:55Z", "type": "commit"}, {"oid": "35cef18e8a0be42202668ff18ac6f65513545ee0", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/35cef18e8a0be42202668ff18ac6f65513545ee0", "message": "Added configuralbe encryption type", "committedDate": "2020-06-08T14:58:29Z", "type": "commit"}, {"oid": "5dfcb4ac9595b4649fb694be05d391ecd0957863", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5dfcb4ac9595b4649fb694be05d391ecd0957863", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-08T15:14:46Z", "type": "commit"}, {"oid": "cc974d5f431c339e46863218884e1b7aba54e7cf", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/cc974d5f431c339e46863218884e1b7aba54e7cf", "message": "Moved IT and changed test default to JRE encryption", "committedDate": "2020-06-08T15:41:20Z", "type": "commit"}, {"oid": "6837bff9ed177a6c16482ca45e1b8c7da535c57b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6837bff9ed177a6c16482ca45e1b8c7da535c57b", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-08T15:41:28Z", "type": "commit"}, {"oid": "4bef9f50a22bcab1654445d904f9081b4233cadc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/4bef9f50a22bcab1654445d904f9081b4233cadc", "message": "SLIM-2077 improvements on integration test", "committedDate": "2020-06-08T16:42:09Z", "type": "commit"}, {"oid": "0ee08ed09848af3c18278da8652221af4b8ae93f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0ee08ed09848af3c18278da8652221af4b8ae93f", "message": "SLIM-2077-improved-tests-and-added-keys-for-test", "committedDate": "2020-06-09T12:38:40Z", "type": "commit"}, {"oid": "335d534e55396bbfefc8ff8e1db4e49fce37f914", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/335d534e55396bbfefc8ff8e1db4e49fce37f914", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-09T12:57:24Z", "type": "commit"}, {"oid": "6ff6a5dc51cd86148a4f05c298aa8d742a353732", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6ff6a5dc51cd86148a4f05c298aa8d742a353732", "message": "SLIM-2077-create-new-secret-mgmt-application", "committedDate": "2020-06-09T13:05:03Z", "type": "commit"}, {"oid": "123a5296f26f4ec1207e233936a1dcf8b55d44a7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/123a5296f26f4ec1207e233936a1dcf8b55d44a7", "message": "SLIM-2077-added-custom-exception-handling", "committedDate": "2020-06-09T16:56:45Z", "type": "commit"}, {"oid": "b067a401782db58af46e77857bcf923e47ed3522", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b067a401782db58af46e77857bcf923e47ed3522", "message": "SLIM-2077-fixed-tests", "committedDate": "2020-06-10T09:11:29Z", "type": "commit"}, {"oid": "c763ff5ac10305ce4687ad558c5164f9d9a9936a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/c763ff5ac10305ce4687ad558c5164f9d9a9936a", "message": "IT and unit tests (work in progress)", "committedDate": "2020-06-10T10:00:07Z", "type": "commit"}, {"oid": "2c3aa050dbdaa79905f50d38ef633521773fe6ae", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/2c3aa050dbdaa79905f50d38ef633521773fe6ae", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-10T10:00:15Z", "type": "commit"}, {"oid": "1031358c5e3d07d2e966f8a725ab5ea2dc4ca553", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1031358c5e3d07d2e966f8a725ab5ea2dc4ca553", "message": "Finished unit test", "committedDate": "2020-06-10T13:19:50Z", "type": "commit"}, {"oid": "dd286e4034d78b47a34e3283c605fc7940862e1b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/dd286e4034d78b47a34e3283c605fc7940862e1b", "message": "SLIM-2077-added-test-with-mock-server", "committedDate": "2020-06-10T13:45:25Z", "type": "commit"}, {"oid": "9048680727bb4b8f907c540f806c56fe3a238520", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9048680727bb4b8f907c540f806c56fe3a238520", "message": "Added test asserts on secret stored to DB", "committedDate": "2020-06-10T13:49:50Z", "type": "commit"}, {"oid": "218754b1619a5258596fc0c65d57a4631697c016", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/218754b1619a5258596fc0c65d57a4631697c016", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-10T13:50:08Z", "type": "commit"}, {"oid": "cc282595dc80429c47adf8769dc12416e01c42ec", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/cc282595dc80429c47adf8769dc12416e01c42ec", "message": "Attempt IT", "committedDate": "2020-06-10T15:19:30Z", "type": "commit"}, {"oid": "0c6103b8275a874d07dec56c63fbde753ebe96fa", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0c6103b8275a874d07dec56c63fbde753ebe96fa", "message": "Setup roundtrip IT using SOAP", "committedDate": "2020-06-10T19:55:47Z", "type": "commit"}, {"oid": "03b1229222c5cab8f9378d3cf5b66add668d3c80", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/03b1229222c5cab8f9378d3cf5b66add668d3c80", "message": "Error message improved", "committedDate": "2020-06-10T19:56:50Z", "type": "commit"}, {"oid": "ea6c5a10333ac689e00b79a252b53311c04650e5", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ea6c5a10333ac689e00b79a252b53311c04650e5", "message": "Improved IT (setup, testdata, request resource)", "committedDate": "2020-06-11T06:48:22Z", "type": "commit"}, {"oid": "9974e9b33cd1c3469a90dca99f74b3da1d9286fa", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9974e9b33cd1c3469a90dca99f74b3da1d9286fa", "message": "Added expected response (context todo); added test request and response folders", "committedDate": "2020-06-11T08:39:58Z", "type": "commit"}, {"oid": "6c020b390c09cf3b5a9a53fc34386f4d2bee4de8", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6c020b390c09cf3b5a9a53fc34386f4d2bee4de8", "message": "SLIM-2077-added-test-with-mocked-soap-client", "committedDate": "2020-06-11T11:45:48Z", "type": "commit"}, {"oid": "5b485c162c1959ec57929c2f6ca32197981c85ee", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5b485c162c1959ec57929c2f6ca32197981c85ee", "message": "SLIM-2077-added-store-secrets-test", "committedDate": "2020-06-11T12:32:42Z", "type": "commit"}, {"oid": "f1c46c2cc45c6fdf4e411d6cf9fa6291af4b4064", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f1c46c2cc45c6fdf4e411d6cf9fa6291af4b4064", "message": "SLIM-2077-added-exception-handling-tests", "committedDate": "2020-06-11T14:47:03Z", "type": "commit"}, {"oid": "b26b3441e03e9e6ea69d1357dca43742eb8c1671", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/b26b3441e03e9e6ea69d1357dca43742eb8c1671", "message": "Added repo IT for key repo", "committedDate": "2020-06-11T16:01:27Z", "type": "commit"}, {"oid": "75edd80300464cb23214b936f6a45bf2ed244f8c", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/75edd80300464cb23214b936f6a45bf2ed244f8c", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-11T16:01:38Z", "type": "commit"}, {"oid": "37b67777bbeb6633975b6209ba153918410b6c29", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/37b67777bbeb6633975b6209ba153918410b6c29", "message": "SLIM-2077 load keyfile on init and coverage improvents", "committedDate": "2020-06-11T17:58:49Z", "type": "commit"}, {"oid": "e5b1a215349e862c826c68c578577058d0911c51", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e5b1a215349e862c826c68c578577058d0911c51", "message": "Initial Flyway script", "committedDate": "2020-06-12T12:33:00Z", "type": "commit"}, {"oid": "fef9835bf6fd2981b8a8836f14994d8fc983e1fe", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/fef9835bf6fd2981b8a8836f14994d8fc983e1fe", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-15T09:28:28Z", "type": "commit"}, {"oid": "ea34b33d499c78a6a2fff588d96dc0f801f43702", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ea34b33d499c78a6a2fff588d96dc0f801f43702", "message": "Added Postgresql and Flyway configuration", "committedDate": "2020-06-15T14:43:21Z", "type": "commit"}, {"oid": "3d3b7f5ef29b7b75a73a9de81a8184b7d18d335b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3d3b7f5ef29b7b75a73a9de81a8184b7d18d335b", "message": "Added provisional DB creation script", "committedDate": "2020-06-15T14:45:01Z", "type": "commit"}, {"oid": "07ca1dac658849263aa0889753d22931f40661b7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/07ca1dac658849263aa0889753d22931f40661b7", "message": "Fixed bug regarding NOT NULL constraint for creation time", "committedDate": "2020-06-15T15:02:07Z", "type": "commit"}, {"oid": "9b0d5b00acb60d4d3e1a5f9f65293c7137c7b096", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/9b0d5b00acb60d4d3e1a5f9f65293c7137c7b096", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application\n\n\u0001 Conflicts:\n\u0001\tosgp/platform/osgp-secret-management/src/main/resources/application.properties", "committedDate": "2020-06-15T15:07:07Z", "type": "commit"}, {"oid": "5b3c5caa21fdd9249057885df7acef4957fc0194", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5b3c5caa21fdd9249057885df7acef4957fc0194", "message": "Removed constraint on unique secrets; added check on adding existing (identical) secret; changed retrieval (get latest valid secret)", "committedDate": "2020-06-15T20:30:58Z", "type": "commit"}, {"oid": "0f76ff094848996ba8b2b67633587ab75d772241", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0f76ff094848996ba8b2b67633587ab75d772241", "message": "Changed logging levels/output for ITs", "committedDate": "2020-06-15T20:32:28Z", "type": "commit"}, {"oid": "61bd836485bb0a583aa6ef0dcce84b842ff3553e", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/61bd836485bb0a583aa6ef0dcce84b842ff3553e", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-16T14:27:45Z", "type": "commit"}, {"oid": "6a1dfacff715203d3349014a6ca9091182c227e6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6a1dfacff715203d3349014a6ca9091182c227e6", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-16T16:25:23Z", "type": "commit"}, {"oid": "6bd41c8e1f007b8b929c4aea46c78776fc50c4c6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6bd41c8e1f007b8b929c4aea46c78776fc50c4c6", "message": "Fixed bug (regarding incorrect query generation for DB paging) by changing repo query", "committedDate": "2020-06-17T11:25:24Z", "type": "commit"}, {"oid": "58645014655aca64d9497b68c90ca8e8d454d4c7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/58645014655aca64d9497b68c90ca8e8d454d4c7", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-17T11:58:36Z", "type": "commit"}, {"oid": "e652282d05d5f6f3c27a2f9e3947399b881baee4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e652282d05d5f6f3c27a2f9e3947399b881baee4", "message": "Fixed inconsistent ITs caused by timing issue in query", "committedDate": "2020-06-18T09:08:06Z", "type": "commit"}, {"oid": "3a7a0be4830c7e0923e322d2174948301f10dcfc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3a7a0be4830c7e0923e322d2174948301f10dcfc", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-18T09:20:35Z", "type": "commit"}, {"oid": "e123e77e81814331fe614a56b63e44a016b1a852", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e123e77e81814331fe614a56b63e44a016b1a852", "message": "Changed repo query (no encryption provider type parameter)", "committedDate": "2020-06-18T09:52:08Z", "type": "commit"}, {"oid": "1b5fa799ca78b43ee9f0a1e5ee6658675c924f27", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1b5fa799ca78b43ee9f0a1e5ee6658675c924f27", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-18T10:00:38Z", "type": "commit"}, {"oid": "8db06fd8c0d89cc552ae0a354dbc6391138dc881", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8db06fd8c0d89cc552ae0a354dbc6391138dc881", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-18T10:05:31Z", "type": "commit"}, {"oid": "25adddc4a129c95cb5e571f6164e19c3a9534806", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/25adddc4a129c95cb5e571f6164e19c3a9534806", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-18T10:07:04Z", "type": "commit"}, {"oid": "5ab3d8f8592aced8f3e6a12f99d9b45cb1ea2370", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5ab3d8f8592aced8f3e6a12f99d9b45cb1ea2370", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-18T11:30:49Z", "type": "commit"}, {"oid": "8f82a15c92e135420a06bde377856c0f607a6d93", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8f82a15c92e135420a06bde377856c0f607a6d93", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-18T14:06:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxMzI1NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442213255", "body": "dit is gegenereerde source code, deze zou niet moeten worden ingechecked.", "bodyText": "dit is gegenereerde source code, deze zou niet moeten worden ingechecked.", "bodyHTML": "<p dir=\"auto\">dit is gegenereerde source code, deze zou niet moeten worden ingechecked.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:10:21Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/schemas/security/secretmanagement/_2020/_05/TypedSecrets.java", "diffHunk": "@@ -0,0 +1,76 @@\n+//", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxMzU5Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442213592", "body": "dit is gegenereerde code.", "bodyText": "dit is gegenereerde code.", "bodyHTML": "<p dir=\"auto\">dit is gegenereerde code.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:10:51Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/schemas/security/secretmanagement/_2020/_05/package-info.java", "diffHunk": "@@ -0,0 +1,9 @@\n+//", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxMzg1Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442213853", "body": "gegenereerd.", "bodyText": "gegenereerd.", "bodyHTML": "<p dir=\"auto\">gegenereerd.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:11:15Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/schemas/security/secretmanagement/_2020/_05/TypedSecret.java", "diffHunk": "@@ -0,0 +1,99 @@\n+//", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxNDA1Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442214052", "body": "gegenereerd.", "bodyText": "gegenereerd.", "bodyHTML": "<p dir=\"auto\">gegenereerd.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:11:34Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/schemas/security/secretmanagement/_2020/_05/TechnicalFault.java", "diffHunk": "@@ -0,0 +1,155 @@\n+//", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxNTE4Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442215182", "body": "why is a qualifier needed ?", "bodyText": "why is a qualifier needed ?", "bodyHTML": "<p dir=\"auto\">why is a qualifier needed ?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:13:23Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java", "diffHunk": "@@ -35,6 +36,7 @@\n     private ReplaceKeyCommandExecutor replaceKeyCommandExecutor;\n \n     @Autowired\n+    @Qualifier(\"secretMangementService\")", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f9727419135de5ab1372cf781bf5551ed9be5a28", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\nindex 3ace614331..262b89d62e 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\n", "chunk": "@@ -36,7 +36,7 @@ public class GenerateAndReplaceKeyCommandExecutor extends AbstractCommandExecuto\n     private ReplaceKeyCommandExecutor replaceKeyCommandExecutor;\n \n     @Autowired\n-    @Qualifier(\"secretMangementService\")\n+    @Qualifier(\"secretManagementService\")\n     private SecurityKeyService securityKeyService;\n \n     public GenerateAndReplaceKeyCommandExecutor() {\n", "next_change": {"commit": "3ba399636f400d309698aedf9b6d99c97b05b6fd", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\nindex 262b89d62e..544a158cc9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\n", "chunk": "@@ -36,8 +43,7 @@ public class GenerateAndReplaceKeyCommandExecutor extends AbstractCommandExecuto\n     private ReplaceKeyCommandExecutor replaceKeyCommandExecutor;\n \n     @Autowired\n-    @Qualifier(\"secretManagementService\")\n-    private SecurityKeyService securityKeyService;\n+    private SecretManagementService secretManagementService;\n \n     public GenerateAndReplaceKeyCommandExecutor() {\n         super(GenerateAndReplaceKeysRequestDataDto.class);\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\nindex 544a158cc9..2eda44bb9d 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/domain/commands/security/GenerateAndReplaceKeyCommandExecutor.java\n", "chunk": "@@ -35,46 +34,58 @@ import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n \n @Component\n-public class GenerateAndReplaceKeyCommandExecutor extends AbstractCommandExecutor<ActionRequestDto, ActionResponseDto> {\n+public class GenerateAndReplaceKeyCommandExecutor\n+    extends AbstractCommandExecutor<ActionRequestDto, ActionResponseDto> {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(GenerateAndReplaceKeyCommandExecutor.class);\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(GenerateAndReplaceKeyCommandExecutor.class);\n \n-    @Autowired\n-    private ReplaceKeyCommandExecutor replaceKeyCommandExecutor;\n+  @Autowired private ReplaceKeyCommandExecutor replaceKeyCommandExecutor;\n \n-    @Autowired\n-    private SecretManagementService secretManagementService;\n+  @Autowired private SecretManagementService secretManagementService;\n \n-    public GenerateAndReplaceKeyCommandExecutor() {\n-        super(GenerateAndReplaceKeysRequestDataDto.class);\n-    }\n+  public GenerateAndReplaceKeyCommandExecutor() {\n+    super(GenerateAndReplaceKeysRequestDataDto.class);\n+  }\n \n-    @Override\n-    public ActionResponseDto executeBundleAction(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final ActionRequestDto actionRequestDto) throws OsgpException {\n+  @Override\n+  public ActionResponseDto executeBundleAction(\n+      final DlmsConnectionManager conn,\n+      final DlmsDevice device,\n+      final ActionRequestDto actionRequestDto)\n+      throws OsgpException {\n \n-        return this.execute(conn, device, actionRequestDto);\n-    }\n+    return this.execute(conn, device, actionRequestDto);\n+  }\n \n-    @Override\n-    public ActionResponseDto execute(final DlmsConnectionManager conn, final DlmsDevice device,\n-            final ActionRequestDto actionRequestDto) throws OsgpException {\n-        LOGGER.info(\"Generate new keys for device {}\", device.getDeviceIdentification());\n-        final SetKeysRequestDto setKeysRequest = this.generateSetKeysRequest(device.getDeviceIdentification());\n-        return this.replaceKeyCommandExecutor.executeBundleAction(conn, device, setKeysRequest);\n-    }\n+  @Override\n+  public ActionResponseDto execute(\n+      final DlmsConnectionManager conn,\n+      final DlmsDevice device,\n+      final ActionRequestDto actionRequestDto)\n+      throws OsgpException {\n+    LOGGER.info(\"Generate new keys for device {}\", device.getDeviceIdentification());\n+    final SetKeysRequestDto setKeysRequest =\n+        this.generateSetKeysRequest(device.getDeviceIdentification());\n+    return this.replaceKeyCommandExecutor.executeBundleAction(conn, device, setKeysRequest);\n+  }\n \n-    private SetKeysRequestDto generateSetKeysRequest(String deviceIdentification) throws FunctionalException {\n-        try {\n-            final List<SecurityKeyType> keyTypes = Arrays.asList(E_METER_AUTHENTICATION, E_METER_ENCRYPTION);\n-            final Map<SecurityKeyType, byte[]> generatedKeys = this.secretManagementService\n-                    .generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, keyTypes);\n-            final SetKeysRequestDto setKeysRequest = new SetKeysRequestDto(generatedKeys.get(E_METER_AUTHENTICATION),\n-                    generatedKeys.get(E_METER_ENCRYPTION));\n-            setKeysRequest.setGeneratedKeys(true);\n-            return setKeysRequest;\n-        } catch (final EncrypterException e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+  private SetKeysRequestDto generateSetKeysRequest(final String deviceIdentification)\n+      throws FunctionalException {\n+    try {\n+      final List<SecurityKeyType> keyTypes =\n+          Arrays.asList(E_METER_AUTHENTICATION, E_METER_ENCRYPTION);\n+      final Map<SecurityKeyType, byte[]> generatedKeys =\n+          this.secretManagementService.generate128BitsKeysAndStoreAsNewKeys(\n+              deviceIdentification, keyTypes);\n+      final SetKeysRequestDto setKeysRequest =\n+          new SetKeysRequestDto(\n+              generatedKeys.get(E_METER_AUTHENTICATION), generatedKeys.get(E_METER_ENCRYPTION));\n+      setKeysRequest.setGeneratedKeys(true);\n+      return setKeysRequest;\n+    } catch (final EncrypterException e) {\n+      throw new FunctionalException(\n+          FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n     }\n+  }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxODgwNA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442218804", "body": "I would expect Spring injection here.", "bodyText": "I would expect Spring injection here.", "bodyHTML": "<p dir=\"auto\">I would expect Spring injection here.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:18:59Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient;\n+\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsResponse;\n+import org.springframework.oxm.jaxb.Jaxb2Marshaller;\n+import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceTemplate;\n+\n+/**\n+ * SOAP Client for SecretManagement\n+ */\n+@Component\n+public class SecretManagementClient {\n+\n+    private final WebServiceTemplate webServiceTemplate;\n+\n+    SecretManagementClient() {\n+\n+        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();\n+        // this package must match the package in the <generatePackage> specified in\n+        // pom.xml\n+        marshaller.setContextPath(\"org.opensmartgridplatform.schemas.security.secretmanagement._2020._05\");\n+\n+        this.webServiceTemplate = new WebServiceTemplate(marshaller);", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d3f6e7354717549f9aab0b23ae156ac087a4fc8", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 71759b7926..f036162746 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -15,22 +16,20 @@ import org.springframework.ws.client.core.WebServiceTemplate;\n @Component\n public class SecretManagementClient {\n \n-    private final WebServiceTemplate webServiceTemplate;\n-\n-    SecretManagementClient() {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n-        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();\n-        // this package must match the package in the <generatePackage> specified in\n-        // pom.xml\n-        marshaller.setContextPath(\"org.opensmartgridplatform.schemas.security.secretmanagement._2020._05\");\n+    private final WebServiceTemplate webServiceTemplate;\n \n-        this.webServiceTemplate = new WebServiceTemplate(marshaller);\n+    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n+        this.webServiceTemplate = webServiceTemplate;\n     }\n \n     public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n \n+        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+\n         return (GetSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(\"http://localhost:8080/osgp-secret-management/ws/SecretManagement\", request);\n+                .marshalSendAndReceive(request);\n \n     }\n \n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex f036162746..362c5e30ff 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -26,7 +24,7 @@ public class SecretManagementClient {\n \n     public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+        log.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n \n         return (GetSecretsResponse) this.webServiceTemplate\n                 .marshalSendAndReceive(request);\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 362c5e30ff..a4ffa5e674 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -28,11 +40,36 @@ public class SecretManagementClient {\n \n         return (GetSecretsResponse) this.webServiceTemplate\n                 .marshalSendAndReceive(request);\n-\n     }\n \n     public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        throw new NotImplementedException();\n+        log.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+\n+        return (StoreSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n+\n+    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n+        log.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (ActivateSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n+\n+    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n+        log.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (HasNewSecretResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n     }\n \n+    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n+        log.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n }\n", "next_change": {"commit": "ee07b18fb34cda88d8e134059b2e2527c3dc5e84", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex a4ffa5e674..b2524e7e00 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -66,7 +77,7 @@ public class SecretManagementClient {\n     }\n \n     public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        log.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n                 request.getDeviceId());\n \n         return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex b2524e7e00..c8d3fb04ef 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -24,63 +25,65 @@ import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n import org.springframework.ws.client.core.WebServiceTemplate;\n \n-/**\n- * SOAP Client for SecretManagement\n- */\n+/** SOAP Client for SecretManagement */\n @Component\n public class SecretManagementClient {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n-    private final WebServiceTemplate webServiceTemplate;\n+  private final WebServiceTemplate webServiceTemplate;\n \n-    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n-        this.webServiceTemplate = webServiceTemplate;\n-    }\n+  SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n+    this.webServiceTemplate = webServiceTemplate;\n+  }\n \n-    public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n+  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GetNewSecretsResponse getNewSecretsRequest(GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetNewSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (StoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (ActivateSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (HasNewSecretResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n-                request.getDeviceId());\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n+      final GenerateAndStoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n }\n", "next_change": {"commit": "bae6f663b4100b43f076c7fe499728b5749dc28f", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex c8d3fb04ef..a2e70a7226 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -20,70 +23,102 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRe\n import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceMessageCallback;\n import org.springframework.ws.client.core.WebServiceTemplate;\n+import org.springframework.ws.soap.SoapHeader;\n+import org.springframework.ws.soap.SoapMessage;\n \n /** SOAP Client for SecretManagement */\n+@Slf4j\n @Component\n public class SecretManagementClient {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+  private static final String CORRELATION_UID = \"correlationUid\";\n   private final WebServiceTemplate webServiceTemplate;\n \n   SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n     this.webServiceTemplate = webServiceTemplate;\n   }\n \n-  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n+  private WebServiceMessageCallback createCorrelationHeaderCallback(\n+      final MessageMetadata messageMetadata) {\n+    return message -> {\n+      final SoapMessage soapMessage = (SoapMessage) message;\n+      final SoapHeader header = soapMessage.getSoapHeader();\n+      header\n+          .addHeaderElement(new QName(NAMESPACE_URI, CORRELATION_UID))\n+          .setText(messageMetadata.getCorrelationUid());\n+    };\n+  }\n+\n+  public GetSecretsResponse getSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetNewSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetNewSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n-    LOGGER.info(\n+  public StoreSecretsResponse storeSecretsRequest(\n+      final MessageMetadata messageMetadata, final StoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (StoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n-    LOGGER.info(\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      final MessageMetadata messageMetadata, final ActivateSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (ActivateSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n-    LOGGER.info(\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      final MessageMetadata messageMetadata, final HasNewSecretRequest request) {\n+    log.info(\n         \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (HasNewSecretResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n   public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n-      final GenerateAndStoreSecretsRequest request) {\n-    LOGGER.info(\n+      final MessageMetadata messageMetadata, final GenerateAndStoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GenerateAndStoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxOTMyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442219328", "body": "hardcoded url. on non https channel", "bodyText": "hardcoded url. on non https channel", "bodyHTML": "<p dir=\"auto\">hardcoded url. on non https channel</p>", "author": "coendamen", "createdAt": "2020-06-18T13:19:46Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient;\n+\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsResponse;\n+import org.springframework.oxm.jaxb.Jaxb2Marshaller;\n+import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceTemplate;\n+\n+/**\n+ * SOAP Client for SecretManagement\n+ */\n+@Component\n+public class SecretManagementClient {\n+\n+    private final WebServiceTemplate webServiceTemplate;\n+\n+    SecretManagementClient() {\n+\n+        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();\n+        // this package must match the package in the <generatePackage> specified in\n+        // pom.xml\n+        marshaller.setContextPath(\"org.opensmartgridplatform.schemas.security.secretmanagement._2020._05\");\n+\n+        this.webServiceTemplate = new WebServiceTemplate(marshaller);\n+    }\n+\n+    public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n+\n+        return (GetSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(\"http://localhost:8080/osgp-secret-management/ws/SecretManagement\", request);", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d3f6e7354717549f9aab0b23ae156ac087a4fc8", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 71759b7926..f036162746 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -15,22 +16,20 @@ import org.springframework.ws.client.core.WebServiceTemplate;\n @Component\n public class SecretManagementClient {\n \n-    private final WebServiceTemplate webServiceTemplate;\n-\n-    SecretManagementClient() {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n-        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();\n-        // this package must match the package in the <generatePackage> specified in\n-        // pom.xml\n-        marshaller.setContextPath(\"org.opensmartgridplatform.schemas.security.secretmanagement._2020._05\");\n+    private final WebServiceTemplate webServiceTemplate;\n \n-        this.webServiceTemplate = new WebServiceTemplate(marshaller);\n+    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n+        this.webServiceTemplate = webServiceTemplate;\n     }\n \n     public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n \n+        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+\n         return (GetSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(\"http://localhost:8080/osgp-secret-management/ws/SecretManagement\", request);\n+                .marshalSendAndReceive(request);\n \n     }\n \n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex f036162746..362c5e30ff 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -26,7 +24,7 @@ public class SecretManagementClient {\n \n     public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+        log.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n \n         return (GetSecretsResponse) this.webServiceTemplate\n                 .marshalSendAndReceive(request);\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex 362c5e30ff..a4ffa5e674 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -28,11 +40,36 @@ public class SecretManagementClient {\n \n         return (GetSecretsResponse) this.webServiceTemplate\n                 .marshalSendAndReceive(request);\n-\n     }\n \n     public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        throw new NotImplementedException();\n+        log.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+\n+        return (StoreSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n+\n+    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n+        log.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (ActivateSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n+\n+    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n+        log.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (HasNewSecretResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n     }\n \n+    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n+        log.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+                request.getDeviceId());\n+\n+        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n+                .marshalSendAndReceive(request);\n+    }\n }\n", "next_change": {"commit": "ee07b18fb34cda88d8e134059b2e2527c3dc5e84", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex a4ffa5e674..b2524e7e00 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -66,7 +77,7 @@ public class SecretManagementClient {\n     }\n \n     public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        log.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n                 request.getDeviceId());\n \n         return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex b2524e7e00..c8d3fb04ef 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -24,63 +25,65 @@ import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n import org.springframework.ws.client.core.WebServiceTemplate;\n \n-/**\n- * SOAP Client for SecretManagement\n- */\n+/** SOAP Client for SecretManagement */\n @Component\n public class SecretManagementClient {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n-    private final WebServiceTemplate webServiceTemplate;\n+  private final WebServiceTemplate webServiceTemplate;\n \n-    SecretManagementClient(WebServiceTemplate webServiceTemplate) {\n-        this.webServiceTemplate = webServiceTemplate;\n-    }\n+  SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n+    this.webServiceTemplate = webServiceTemplate;\n+  }\n \n-    public GetSecretsResponse getSecretsRequest(GetSecretsRequest request) {\n+  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GetNewSecretsResponse getNewSecretsRequest(GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n \n-        LOGGER.info(\"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+    LOGGER.info(\n+        \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GetNewSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public StoreSecretsResponse storeSecretsRequest(StoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\", request.getDeviceId());\n+  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (StoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public ActivateSecretsResponse activateSecretsRequest(ActivateSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (ActivateSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public HasNewSecretResponse hasNewSecretRequest(HasNewSecretRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n-                request.getDeviceId());\n+  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (HasNewSecretResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n \n-    public GenerateAndStoreSecretsResponse generateAndStoreSecrets(GenerateAndStoreSecretsRequest request) {\n-        LOGGER.info(\"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n-                request.getDeviceId());\n+  public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n+      final GenerateAndStoreSecretsRequest request) {\n+    LOGGER.info(\n+        \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n+        request.getDeviceId());\n \n-        return (GenerateAndStoreSecretsResponse) this.webServiceTemplate\n-                .marshalSendAndReceive(request);\n-    }\n+    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+  }\n }\n", "next_change": {"commit": "bae6f663b4100b43f076c7fe499728b5749dc28f", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\nindex c8d3fb04ef..a2e70a7226 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/wsclient/SecretManagementClient.java\n", "chunk": "@@ -20,70 +23,102 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretRe\n import org.opensmartgridplatform.ws.schema.core.secret.management.HasNewSecretResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n+import org.springframework.ws.client.core.WebServiceMessageCallback;\n import org.springframework.ws.client.core.WebServiceTemplate;\n+import org.springframework.ws.soap.SoapHeader;\n+import org.springframework.ws.soap.SoapMessage;\n \n /** SOAP Client for SecretManagement */\n+@Slf4j\n @Component\n public class SecretManagementClient {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementClient.class);\n \n+  private static final String NAMESPACE_URI =\n+      \"http://www.opensmartgridplatform\" + \".org/schemas/security/secretmanagement\";\n+  private static final String CORRELATION_UID = \"correlationUid\";\n   private final WebServiceTemplate webServiceTemplate;\n \n   SecretManagementClient(final WebServiceTemplate webServiceTemplate) {\n     this.webServiceTemplate = webServiceTemplate;\n   }\n \n-  public GetSecretsResponse getSecretsRequest(final GetSecretsRequest request) {\n+  private WebServiceMessageCallback createCorrelationHeaderCallback(\n+      final MessageMetadata messageMetadata) {\n+    return message -> {\n+      final SoapMessage soapMessage = (SoapMessage) message;\n+      final SoapHeader header = soapMessage.getSoapHeader();\n+      header\n+          .addHeaderElement(new QName(NAMESPACE_URI, CORRELATION_UID))\n+          .setText(messageMetadata.getCorrelationUid());\n+    };\n+  }\n+\n+  public GetSecretsResponse getSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public GetNewSecretsResponse getNewSecretsRequest(final GetNewSecretsRequest request) {\n+  public GetNewSecretsResponse getNewSecretsRequest(\n+      final MessageMetadata messageMetadata, final GetNewSecretsRequest request) {\n \n-    LOGGER.info(\n+    log.info(\n         \"Calling SecretManagement.getNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GetNewSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GetNewSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public StoreSecretsResponse storeSecretsRequest(final StoreSecretsRequest request) {\n-    LOGGER.info(\n+  public StoreSecretsResponse storeSecretsRequest(\n+      final MessageMetadata messageMetadata, final StoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.storeSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (StoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (StoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public ActivateSecretsResponse activateSecretsRequest(final ActivateSecretsRequest request) {\n-    LOGGER.info(\n+  public ActivateSecretsResponse activateSecretsRequest(\n+      final MessageMetadata messageMetadata, final ActivateSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.activateSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (ActivateSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (ActivateSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n-  public HasNewSecretResponse hasNewSecretRequest(final HasNewSecretRequest request) {\n-    LOGGER.info(\n+  public HasNewSecretResponse hasNewSecretRequest(\n+      final MessageMetadata messageMetadata, final HasNewSecretRequest request) {\n+    log.info(\n         \"Calling SecretManagement.hasNewSecretsRequest over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (HasNewSecretResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (HasNewSecretResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n \n   public GenerateAndStoreSecretsResponse generateAndStoreSecrets(\n-      final GenerateAndStoreSecretsRequest request) {\n-    LOGGER.info(\n+      final MessageMetadata messageMetadata, final GenerateAndStoreSecretsRequest request) {\n+    log.info(\n         \"Calling SecretManagement.generateAndStoreSecrets over SOAP for device {}\",\n         request.getDeviceId());\n \n-    return (GenerateAndStoreSecretsResponse) this.webServiceTemplate.marshalSendAndReceive(request);\n+    return (GenerateAndStoreSecretsResponse)\n+        this.webServiceTemplate.marshalSendAndReceive(\n+            request, this.createCorrelationHeaderCallback(messageMetadata));\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDI5NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442220294", "body": "value param is redundant.", "bodyText": "value param is redundant.", "bodyHTML": "<p dir=\"auto\">value param is redundant.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:21:14Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service(value = \"secretMangementService\")", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDQ5Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442220492", "bodyText": "also name is misspelled.", "author": "coendamen", "createdAt": "2020-06-18T13:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1OTI3Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442359273", "bodyText": "Wow, eagle-eye! +1", "author": "jandik", "createdAt": "2020-06-18T16:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2ODIyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444068228", "bodyText": "hahaha +1", "author": "jboon", "createdAt": "2020-06-23T08:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "f9727419135de5ab1372cf781bf5551ed9be5a28", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex e9acf98139..447857c1b1 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -24,7 +24,7 @@ import org.springframework.transaction.annotation.Transactional;\n import java.util.List;\n import java.util.Optional;\n \n-@Service(value = \"secretMangementService\")\n+@Service(value = \"secretManagementService\")\n @Transactional(value = \"transactionManager\")\n public class SecretManagementService implements SecurityKeyService {\n \n", "next_change": {"commit": "0422cdce058532f0245a685f2d2030e78a8dc0d5", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 447857c1b1..03bea7c193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -25,20 +24,18 @@ import java.util.List;\n import java.util.Optional;\n \n @Service(value = \"secretManagementService\")\n-@Transactional(value = \"transactionManager\")\n+@Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private EncryptionService soapSecretEncryptionService;\n+    private SecretManagementClient secretManagementClient;\n \n-    @Autowired\n-    EncryptionService soapSecretEncryptionService;\n-\n-    @Autowired\n-    SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    @Qualifier(\"dlmsSecurityKeyService\")\n-    DlmsSecurityKeyService dlmsSecurityKeyService;\n+    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    {\n+        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.secretManagementClient = secretManagementClient;\n+    }\n \n     @Override\n     public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n", "next_change": {"commit": "41b1e47ec7d78cb700489b512fc7f9e6b7f85d50", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 03bea7c193..0f88b56f60 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -13,27 +16,26 @@ import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.Sec\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-import java.util.List;\n-import java.util.Optional;\n-\n @Service(value = \"secretManagementService\")\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private EncryptionService soapSecretEncryptionService;\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n     private SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n     {\n-        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 0f88b56f60..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDkwMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442220900", "body": "is qualifier needed?", "bodyText": "is qualifier needed?", "bodyHTML": "<p dir=\"auto\">is qualifier needed?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:22:07Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service(value = \"secretMangementService\")\n+@Transactional(value = \"transactionManager\")\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+\n+    @Autowired\n+    EncryptionService soapSecretEncryptionService;\n+\n+    @Autowired\n+    SecretManagementClient secretManagementClient;\n+\n+    @Autowired\n+    @Qualifier(\"dlmsSecurityKeyService\")", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0422cdce058532f0245a685f2d2030e78a8dc0d5", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex e9acf98139..03bea7c193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -24,21 +23,19 @@ import org.springframework.transaction.annotation.Transactional;\n import java.util.List;\n import java.util.Optional;\n \n-@Service(value = \"secretMangementService\")\n-@Transactional(value = \"transactionManager\")\n+@Service(value = \"secretManagementService\")\n+@Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private EncryptionService soapSecretEncryptionService;\n+    private SecretManagementClient secretManagementClient;\n \n-    @Autowired\n-    EncryptionService soapSecretEncryptionService;\n-\n-    @Autowired\n-    SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    @Qualifier(\"dlmsSecurityKeyService\")\n-    DlmsSecurityKeyService dlmsSecurityKeyService;\n+    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    {\n+        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.secretManagementClient = secretManagementClient;\n+    }\n \n     @Override\n     public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n", "next_change": {"commit": "41b1e47ec7d78cb700489b512fc7f9e6b7f85d50", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 03bea7c193..0f88b56f60 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -13,27 +16,26 @@ import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.Sec\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-import java.util.List;\n-import java.util.Optional;\n-\n @Service(value = \"secretManagementService\")\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private EncryptionService soapSecretEncryptionService;\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n     private SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n     {\n-        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 0f88b56f60..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMTQ3Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442221476", "body": "a lot of NotImplementedExceptions, is the story/EPIC done?", "bodyText": "a lot of NotImplementedExceptions, is the story/EPIC done?", "bodyHTML": "<p dir=\"auto\">a lot of NotImplementedExceptions, is the story/EPIC done?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:22:53Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service(value = \"secretMangementService\")\n+@Transactional(value = \"transactionManager\")\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+\n+    @Autowired\n+    EncryptionService soapSecretEncryptionService;\n+\n+    @Autowired\n+    SecretManagementClient secretManagementClient;\n+\n+    @Autowired\n+    @Qualifier(\"dlmsSecurityKeyService\")\n+    DlmsSecurityKeyService dlmsSecurityKeyService;\n+\n+    @Override\n+    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2MDA4Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442360083", "bodyText": "I think this is all post-MVP work, so should be covered by other epic/story", "author": "jandik", "createdAt": "2020-06-18T16:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMTQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0422cdce058532f0245a685f2d2030e78a8dc0d5", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex e9acf98139..03bea7c193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -24,21 +23,19 @@ import org.springframework.transaction.annotation.Transactional;\n import java.util.List;\n import java.util.Optional;\n \n-@Service(value = \"secretMangementService\")\n-@Transactional(value = \"transactionManager\")\n+@Service(value = \"secretManagementService\")\n+@Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private EncryptionService soapSecretEncryptionService;\n+    private SecretManagementClient secretManagementClient;\n \n-    @Autowired\n-    EncryptionService soapSecretEncryptionService;\n-\n-    @Autowired\n-    SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    @Qualifier(\"dlmsSecurityKeyService\")\n-    DlmsSecurityKeyService dlmsSecurityKeyService;\n+    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    {\n+        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.secretManagementClient = secretManagementClient;\n+    }\n \n     @Override\n     public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n", "next_change": {"commit": "41b1e47ec7d78cb700489b512fc7f9e6b7f85d50", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 03bea7c193..0f88b56f60 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -13,27 +16,26 @@ import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.Sec\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-import java.util.List;\n-import java.util.Optional;\n-\n @Service(value = \"secretManagementService\")\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private EncryptionService soapSecretEncryptionService;\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n     private SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n     {\n-        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 0f88b56f60..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMjUxMQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442222511", "body": "scope should be private I think.\r\n\r\nconsider using constructor injection to make testing available", "bodyText": "scope should be private I think.\nconsider using constructor injection to make testing available", "bodyHTML": "<p dir=\"auto\">scope should be private I think.</p>\n<p dir=\"auto\">consider using constructor injection to make testing available</p>", "author": "coendamen", "createdAt": "2020-06-18T13:24:26Z", "path": "osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.opensmartgridplatform.adapter.protocol.dlms.application.services;\n+\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.SecretManagementClient;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n+import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n+import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n+import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service(value = \"secretMangementService\")\n+@Transactional(value = \"transactionManager\")\n+public class SecretManagementService implements SecurityKeyService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+\n+    @Autowired\n+    EncryptionService soapSecretEncryptionService;", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f9727419135de5ab1372cf781bf5551ed9be5a28", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex e9acf98139..447857c1b1 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -24,7 +24,7 @@ import org.springframework.transaction.annotation.Transactional;\n import java.util.List;\n import java.util.Optional;\n \n-@Service(value = \"secretMangementService\")\n+@Service(value = \"secretManagementService\")\n @Transactional(value = \"transactionManager\")\n public class SecretManagementService implements SecurityKeyService {\n \n", "next_change": {"commit": "0422cdce058532f0245a685f2d2030e78a8dc0d5", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 447857c1b1..03bea7c193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -25,20 +24,18 @@ import java.util.List;\n import java.util.Optional;\n \n @Service(value = \"secretManagementService\")\n-@Transactional(value = \"transactionManager\")\n+@Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+    private EncryptionService soapSecretEncryptionService;\n+    private SecretManagementClient secretManagementClient;\n \n-    @Autowired\n-    EncryptionService soapSecretEncryptionService;\n-\n-    @Autowired\n-    SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    @Qualifier(\"dlmsSecurityKeyService\")\n-    DlmsSecurityKeyService dlmsSecurityKeyService;\n+    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    {\n+        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.secretManagementClient = secretManagementClient;\n+    }\n \n     @Override\n     public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n", "next_change": {"commit": "41b1e47ec7d78cb700489b512fc7f9e6b7f85d50", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 03bea7c193..0f88b56f60 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -13,27 +16,26 @@ import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.Sec\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n-import org.opensmartgridplatform.shared.security.EncryptionService;\n+import org.opensmartgridplatform.shared.security.EncryptedSecret;\n+import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n+import org.opensmartgridplatform.shared.security.Secret;\n+import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-import java.util.List;\n-import java.util.Optional;\n-\n @Service(value = \"secretManagementService\")\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private EncryptionService soapSecretEncryptionService;\n+    private RsaEncryptionProvider rsaEncryptionProvider;\n     private SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(EncryptionService soapSecretEncryptionService, SecretManagementClient secretManagementClient)\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n     {\n-        this.soapSecretEncryptionService = soapSecretEncryptionService;\n+        this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n \n", "next_change": {"commit": "21b3bdbc3abb7923c361f76bd8eab179fdd1262c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 0f88b56f60..5d5bcd0e0c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -9,32 +9,33 @@ import org.opensmartgridplatform.adapter.protocol.dlms.application.wsclient.Secr\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.DlmsDevice;\n import org.opensmartgridplatform.adapter.protocol.dlms.domain.entities.SecurityKeyType;\n import org.opensmartgridplatform.adapter.protocol.dlms.exceptions.ProtocolAdapterException;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret;\n-import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.shared.exceptionhandling.EncrypterException;\n import org.opensmartgridplatform.shared.exceptionhandling.FunctionalException;\n import org.opensmartgridplatform.shared.security.EncryptedSecret;\n import org.opensmartgridplatform.shared.security.EncryptionProviderType;\n import org.opensmartgridplatform.shared.security.Secret;\n import org.opensmartgridplatform.shared.security.providers.RsaEncryptionProvider;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.GetSecretsResponse;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Service;\n import org.springframework.transaction.annotation.Transactional;\n \n-@Service(value = \"secretManagementService\")\n+@Service\n @Transactional\n public class SecretManagementService implements SecurityKeyService {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private RsaEncryptionProvider rsaEncryptionProvider;\n-    private SecretManagementClient secretManagementClient;\n+    private final RsaEncryptionProvider rsaEncryptionProvider;\n+    private final SecretManagementClient secretManagementClient;\n \n-    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider, SecretManagementClient secretManagementClient)\n-    {\n+    public SecretManagementService(RsaEncryptionProvider rsaEncryptionProvider,\n+            SecretManagementClient secretManagementClient) {\n         this.rsaEncryptionProvider = rsaEncryptionProvider;\n         this.secretManagementClient = secretManagementClient;\n     }\n", "next_change": {"commit": "aad83a4ff3f419b46c058aa98a7c772f25e4a329", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5d5bcd0e0c..a26364f54a 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -40,74 +49,159 @@ public class SecretManagementService implements SecurityKeyService {\n         this.secretManagementClient = secretManagementClient;\n     }\n \n-    @Override\n-    public byte[] reEncryptKey(byte[] externallyEncryptedKey, SecurityKeyType keyType) throws FunctionalException {\n-        throw new NotImplementedException();\n-    }\n+    /**\n+     * Re-encrypts the given key with a secret known only inside this protocol\n+     * adapter.\n+     * <p>\n+     * New keys can be provided to OSGP from outside in a form encrypted with\n+     * the public key from an asymmetrical key pair for the platform, which is\n+     * available to external organizations.<br>\n+     * Inside the DLMS protocol adapter keys are encrypted with a faster\n+     * symmetrical encryption using a secret key that is not supposed to be\n+     * known outside this protocol adapter.\n+     *\n+     * @param externallyEncryptedKey\n+     *         key encrypted with the externally known public key for OSGP\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the key encrypted with the symmetrical secret key used only\n+     *         inside the DLMS protocol adapter, or an empty byte array if\n+     *         {@code externallyEncryptedKey == null}\n+     *\n+     * @throws FunctionalException\n+     *         in case of a encryption/decryption errors while handling the\n+     *         key\n+     */\n+    public byte[] reEncryptKey(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /* TODO\n+        if (externallyEncryptedKey == null) {\n+            return new byte[0];\n+        }\n \n-    @Override\n-    public byte[] decryptKey(byte[] encryptedKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        final byte[] key = this.rsaDecrypt(externallyEncryptedKey, keyType);\n+        return this.aesEncrypt(key, keyType);\n+\n+         */\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] encryptKey(byte[] plainKey, SecurityKeyType keyType) throws ProtocolAdapterException {\n+    private byte[] rsaDecrypt(final byte[] externallyEncryptedKey, final SecurityKeyType keyType)\n+            throws FunctionalException {\n+        /*\n+        try {\n+            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during decryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during decryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+    private byte[] aesEncrypt(final byte[] key, final SecurityKeyType keyType) throws FunctionalException {\n+        /*TODO\n+        try {\n+            return this.encryptionService.encrypt(key);\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Unexpected exception during encryption\", e);\n+\n+            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS,\n+                    new EncrypterException(\n+                            String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n+        }*/\n         throw new NotImplementedException();\n     }\n \n-    @Override\n-    public byte[] getDlmsAuthenticationKey(String deviceIdentification) throws EncrypterException {\n-\n+    /**\n+     * Decrypts the given symmetrically encrypted key.\n+     * <p>\n+     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n+     * required as part of the communication with a device.\n+     *\n+     * @param encryptedKey\n+     *         key encrypted with the symmetrical key internal to the DLMS\n+     *         protocol adapter.\n+     * @param keyType\n+     *         type of the key, for logging purposes\n+     *\n+     * @return the plain key, or an empty byte array if\n+     *         {@code encryptedKey == null}\n+     */\n+    public byte[] decryptKey(final byte[] encryptedKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (encryptedKey == null) {\n+            return new byte[0];\n+        }\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_AUTHENTICATION_KEY);\n+            return this.encryptionService.decrypt(encryptedKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error decrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving authentication key\", e);\n+    /**\n+     * Encrypts the given {@code plainKey} with the symmetrical secret key that\n+     * is internal to the DLMS protocol adapter.\n+     *\n+     * @param plainKey\n+     *            plain key without encryption\n+     * @param keyType\n+     *            type of the key, for logging purposes\n+     * @return the given key encrypted with the symmetrical key internal to the\n+     *         DLMS protocol adapter.\n+     */\n+    public byte[] encryptKey(final byte[] plainKey, final SecurityKeyType keyType) throws ProtocolAdapterException {\n+        /*TODO\n+        if (plainKey == null) {\n+            return new byte[0];\n         }\n+        try {\n+            return this.encryptionService.encrypt(plainKey);\n+        } catch (final Exception e) {\n+            throw new ProtocolAdapterException(\"Error encrypting \" + keyType + \" key\", e);\n+        }*/\n+        throw new NotImplementedException();\n     }\n \n     @Override\n-    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+    public byte[] getDlmsMasterKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS master key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_MASTER_KEY);\n+    }\n \n-        try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response,\n-                    SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n+    @Override\n+    public byte[] getDlmsAuthenticationKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS authentication key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_AUTHENTICATION_KEY);\n+    }\n \n-            return decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification)));\n-        } catch (Exception e) {\n-            LOGGER.error(\"Error while retrieving encryption key\", e);\n-        }\n-        return new byte[0];\n+    @Override\n+    public byte[] getDlmsGlobalUnicastEncryptionKey(String deviceIdentification) {\n+        LOGGER.info(\"Retrieving DLMS global unicast encryption key for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.E_METER_ENCRYPTION_KEY_UNICAST);\n     }\n \n     @Override\n     public byte[] getMbusDefaultKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus Default key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_MASTER_KEY);\n     }\n \n     @Override\n     public byte[] getMbusUserKey(String mbusDeviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving M-Bus User key for device {}\", mbusDeviceIdentification);\n+        return getSecret(mbusDeviceIdentification, SecretType.G_METER_ENCRYPTION_KEY);\n     }\n \n     @Override\n     public byte[] getDlmsPassword(String deviceIdentification) {\n-        throw new NotImplementedException();\n+        LOGGER.info(\"Retrieving DLMS LLS Password for device {}\", deviceIdentification);\n+        return getSecret(deviceIdentification, SecretType.PPP_PASSWORD);\n     }\n \n     @Override\n", "next_change": {"commit": "fbb4d45f1203ad85de9a6c858e33bcac98fe8f42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a26364f54a..baf9d88726 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -205,33 +212,140 @@ public class SecretManagementService implements SecurityKeyService {\n     }\n \n     @Override\n-    public DlmsDevice storeNewKey(DlmsDevice device, byte[] encryptedKey, SecurityKeyType keyType) {\n-        throw new NotImplementedException();\n+    public byte[][] getKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GetSecretsRequest request = new GetSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    @Override\n+    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]encryptedKey) throws FunctionalException {\n+        byte[] plainKey = aesDecryptKey(encryptedKey, keyType);\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {plainKey});\n     }\n \n     @Override\n-    public DlmsDevice validateNewKey(DlmsDevice device, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[]key) {\n+        storeNewKeys(deviceIdentification, new  SecurityKeyType[] { keyType}, new byte[][] {key});\n+    }\n+\n+    @Override\n+    public void storeNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes, byte[][]keys) {\n+        StoreSecretsRequest request = new StoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+\n+        TypedSecrets typedSecrets = new TypedSecrets();\n+        request.setTypedSecrets(new TypedSecrets());\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            TypedSecret typedSecret = new TypedSecret();\n+            typedSecret.setSecret(encryptSoapSecret(deviceIdentification, keys[i]));\n+            typedSecret.setType(getSecretTypeFrom(keyTypes[i]));\n+            typedSecretList.add(typedSecret);\n+        }\n+\n+        secretManagementClient.storeSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateKey() {\n-        throw new NotImplementedException();\n+    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n+        ActivateSecretsRequest request = new ActivateSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+        secretTypeList.add(getSecretTypeFrom(keyType));\n+        secretManagementClient.activateSecretsRequest(request);\n     }\n \n     @Override\n-    public byte[] generateAndEncryptKey() {\n-        throw new NotImplementedException();\n+    public boolean isActivated(String deviceIdentification, SecurityKeyType keyType) {\n+        //isActivated is = !hasNewSecret\n+        HasNewSecretRequest request = new HasNewSecretRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretType(getSecretTypeFrom(keyType));\n+        HasNewSecretResponse response = secretManagementClient.hasNewSecretRequest(request);\n+        return !response.isHasNewSecret();\n     }\n \n+    /**\n+     * Generates a new key that can be used as DLMS master key, authentication\n+     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n+     * <p>\n+     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n+     * device, but can be generated for use in tests or with simulated devices.\n+     *\n+     * @return a new 128bits AES key.\n+     */\n     @Override\n-    public byte[] encryptMbusUserKey(byte[] mbusDefaultKey, byte[] mbusUserKey) throws ProtocolAdapterException {\n-        throw new NotImplementedException();\n+    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(new SecretTypes());\n+        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+\n+        for (SecurityKeyType keyType: keyTypes) {\n+            secretTypeList.add(getSecretTypeFrom(keyType));\n+        }\n+\n+        GenerateAndStoreSecretsResponse response = secretManagementClient.generateAndStoreSecrets(request);\n+\n+        TypedSecrets typedSecrets = response.getTypedSecrets();\n+        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+\n+        if (keyTypes.length != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n+        }\n+\n+        byte[][] decryptedKeys = new byte[keyTypes.length][];\n+\n+        for (int i = 0; i < keyTypes.length; i++) {\n+            if (typedSecretList.get(i).getType().equals(getSecretTypeFrom(keyTypes[i]))) {\n+                decryptedKeys[i] = decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n+            }\n+        }\n+\n+        return decryptedKeys;\n+    }\n+\n+    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n+        switch (keyType) {\n+            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n+            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n+            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n+            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n+            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n+        }\n     }\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapRequestForKey(deviceIdentification, secretType);\n+            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n             GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n             Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n \n", "next_change": {"commit": "888761601c8492b82a72285caf413011ab3b99e0", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex baf9d88726..21a99e7d74 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -345,11 +347,11 @@ public class SecretManagementService implements SecurityKeyService {\n \n     private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n         try {\n-            GetSecretsRequest request = getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = getTypedSecretFromSoapResponse(response, secretType);\n+            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n+            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n \n-            byte[] decryptedKey = decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n+            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n                     () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n \n             log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n", "next_change": {"commit": "bb5fbeecd6d0fed2caede8f97c43e419da411417", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 21a99e7d74..5979870ba3 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -301,99 +264,58 @@ public class SecretManagementService implements SecurityKeyService {\n      * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n      * device, but can be generated for use in tests or with simulated devices.\n      *\n-     * @return a new 128bits AES key.\n+     * @return a new 128bits key, unencrypted.\n      */\n     @Override\n-    public byte[][] generateAES128BitsKeysAndStoreAsNewKeys(String deviceIdentification, SecurityKeyType[] keyTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-\n-        for (SecurityKeyType keyType: keyTypes) {\n-            secretTypeList.add(this.getSecretTypeFrom(keyType));\n-        }\n+    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n+            List<SecurityKeyType> keyTypes) {\n+        SecretTypes secretTypes = new SecretTypes();\n+        GenerateAndStoreSecretsRequest request = this\n+                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n \n         GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-\n         TypedSecrets typedSecrets = response.getTypedSecrets();\n         List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        if (keyTypes.length != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-\n-        byte[][] decryptedKeys = new byte[keyTypes.length][];\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            if (typedSecretList.get(i).getType().equals(this.getSecretTypeFrom(keyTypes[i]))) {\n-                decryptedKeys[i] = this.decryptSoapSecret(deviceIdentification, typedSecretList.get(i));\n-            }\n-        }\n-\n-        return decryptedKeys;\n+        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n+        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n+        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n     }\n \n-    private SecretType getSecretTypeFrom(SecurityKeyType keyType) {\n-        switch (keyType) {\n-            case E_METER_AUTHENTICATION: return SecretType.E_METER_AUTHENTICATION_KEY;\n-            case E_METER_MASTER: return SecretType.E_METER_MASTER_KEY;\n-            case E_METER_ENCRYPTION: return SecretType.E_METER_ENCRYPTION_KEY_UNICAST;\n-            case G_METER_MASTER: return SecretType.G_METER_MASTER_KEY;\n-            default: throw new IllegalStateException(\"Invalid SecurityKeyType specified\");\n-        }\n+    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n+            SecretTypes secretTypes) {\n+        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+        request.setDeviceId(deviceIdentification);\n+        request.setSecretTypes(secretTypes);\n+        return request;\n     }\n \n-    private byte[] getSecret(String deviceIdentification, SecretType secretType) {\n-        try {\n-            GetSecretsRequest request = this.getSoapGetRequestForSingleKey(deviceIdentification, secretType);\n-            GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-            Optional<TypedSecret> optionalTypedSecret = this.getTypedSecretFromSoapResponse(response, secretType);\n-\n-            byte[] decryptedKey = this.decryptSoapSecret(deviceIdentification, optionalTypedSecret.orElseThrow(\n-                    () -> new IllegalStateException(\"Secret not found:\" + deviceIdentification + \" \" + secretType.name())));\n-\n-            log.trace(secretType.name() + \" for device \" + deviceIdentification + \" is \" + Hex.encodeHexString(decryptedKey));\n-\n-            return decryptedKey;\n-\n-        } catch (Exception e) {\n-            throw new EncrypterException(\"Error while retrieving encryption key\", e);\n+    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n+            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n+        if (!OsgpResultType.OK.equals(response.getResult())) {\n+            throw new IllegalStateException(\n+                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n+        } else if (keyTypes.size() != typedSecretList.size()) {\n+            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n         }\n     }\n \n-    private Optional<TypedSecret> getTypedSecretFromSoapResponse(GetSecretsResponse response, SecretType secretType) {\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-\n-        return typedSecretList.stream().filter(typedSecret -> typedSecret.getType() == secretType).findFirst();\n-    }\n-\n-    private GetSecretsRequest getSoapGetRequestForSingleKey(String deviceIdentification, SecretType secretType) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(secretType);\n-        return request;\n-    }\n-\n-    private byte[] decryptSoapSecret(String deviceIdentification, TypedSecret typedSecret) {\n+    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n         try {\n             byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapSecretsRsaEncryptionProvider.decrypt(encryptedDecodedSoapSecret);\n+            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Decrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n         }\n     }\n \n-    private String encryptSoapSecret(String deviceIdentification, byte[] secret) {\n+    private String encryptSoapSecret(byte[] secret) {\n         try {\n-            byte[] encrypted = this.soapSecretsRsaEncryptionProvider.encrypt(secret);\n+            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n             return Hex.encodeHexString(encrypted);\n         } catch (Exception e) {\n-            throw new IllegalStateException(\"Encrypting key for device: \" + deviceIdentification, e);\n+            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n         }\n     }\n }\n", "next_change": {"commit": "1df95f5dc74fd2e8790382994a6b26c9e2938900", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 5979870ba3..a8c814dc95 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -39,283 +33,345 @@ import org.opensmartgridplatform.ws.schema.core.secret.management.OsgpResultType\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretType;\n import org.opensmartgridplatform.ws.schema.core.secret.management.SecretTypes;\n import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsRequest;\n+import org.opensmartgridplatform.ws.schema.core.secret.management.StoreSecretsResponse;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecret;\n import org.opensmartgridplatform.ws.schema.core.secret.management.TypedSecrets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-@Slf4j\n-public class SecretManagementService implements SecurityKeyService {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n-    private final RsaEncrypter soapRsaEncrypter;\n-    private final SecretManagementClient secretManagementClient;\n-\n-    @Autowired\n-    private RsaEncryptionService rsaEncryptionService;\n-\n-    @Autowired\n-    private EncryptionService aesEncryptionService;\n-\n-    public SecretManagementService(RsaEncrypter soapRsaEncrypter, SecretManagementClient secretManagementClient) {\n-        this.soapRsaEncrypter = soapRsaEncrypter;\n-        this.secretManagementClient = secretManagementClient;\n-    }\n-\n-    /**\n-     * Re-encrypts the given key with a secret known only inside this protocol\n-     * adapter.\n-     * <p>\n-     * New keys can be provided to OSGP from outside in a form encrypted with\n-     * the public key from an asymmetrical key pair for the platform, which is\n-     * available to external organizations.<br>\n-     * Inside the DLMS protocol adapter keys are encrypted with a faster\n-     * symmetrical encryption using a secret key that is not supposed to be\n-     * known outside this protocol adapter.\n-     *\n-     * @param externallyEncryptedKey\n-     *         key encrypted with the externally known public key for OSGP\n-     *\n-     * @return the key encrypted with the symmetrical secret key used only\n-     *         inside the DLMS protocol adapter, or an empty byte array if\n-     *         {@code externallyEncryptedKey == null}\n-     *\n-     * @throws FunctionalException\n-     *         in case of a encryption/decryption errors while handling the\n-     *         key\n-     */\n-    @Override\n-    public byte[] reEncryptKey(final byte[] externallyEncryptedKey/*, final SecurityKeyType keyType*/)\n-            throws FunctionalException {\n-\n-        if (externallyEncryptedKey == null) {\n-            return new byte[0];\n-        }\n-\n-        final byte[] key = this.rsaDecrypt(externallyEncryptedKey);//, keyType);\n-        return this.aesEncryptKey(key);//, keyType);\n-\n+/**\n+ * Service for storing, activating and retrieving device keys. Also performs RSA\n+ * encryption/decryption operations for SOAP messaging purposes.\n+ */\n+public class SecretManagementService {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementService.class);\n+  private final RsaEncrypter soapRsaEncrypter;\n+  private final SecretManagementClient secretManagementClient;\n+\n+  public SecretManagementService(\n+      final RsaEncrypter soapRsaEncrypter, final SecretManagementClient secretManagementClient) {\n+    this.soapRsaEncrypter = soapRsaEncrypter;\n+    this.secretManagementClient = secretManagementClient;\n+  }\n+\n+  /**\n+   * Retrieve an active key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    @Override\n-    public byte[] rsaDecrypt(final byte[] externallyEncryptedKey) //, final SecurityKeyType keyType)\n-            throws FunctionalException {\n-\n-        try {\n-            return this.rsaEncryptionService.decrypt(externallyEncryptedKey);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during decryption\", e);\n-            throw new FunctionalException(FunctionalExceptionType.DECRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            // new EncrypterException(\n-            //         String.format(\"Unexpected exception during decryption of key.\", keyType)));\n-        }\n-\n+    return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the active keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n+    final GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n+    this.validateGetResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  /**\n+   * Retrieve a new (not yet activated) key of a certain type for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyType the requested key type\n+   * @return the key or NULL if not present\n+   */\n+  public byte[] getNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    if (LOGGER.isInfoEnabled()) {\n+      LOGGER.info(\"Retrieving new {} for device {}\", keyType.name(), deviceIdentification);\n     }\n-\n-    //@Override\n-    public byte[] aesEncryptKey(final byte[] key) /*, final SecurityKeyType keyType)*/ throws FunctionalException {\n-\n-        try {\n-            return this.aesEncryptionService.encrypt(key);\n-        } catch (final Exception e) {\n-            LOGGER.error(\"Unexpected exception during encryption\", e);\n-            //TODO refactor this?\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-            //   new EncrypterException(\n-            //           String.format(\"Unexpected exception during encryption of %s key.\", keyType)));\n-        }\n+    return this.getNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  /**\n+   * Retrieves the new (not yet activated) keys of requested types for a specified device\n+   *\n+   * @param deviceIdentification the device identification string of the device\n+   * @param keyTypes the requested key types\n+   * @return the requested keys in a map by key type, with value NULL if not present\n+   */\n+  public Map<SecurityKeyType, byte[]> getNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request =\n+        this.createGetNewSecretsRequest(deviceIdentification, keyTypes);\n+    final GetNewSecretsResponse response =\n+        this.secretManagementClient.getNewSecretsRequest(request);\n+    this.validateGetNewResponse(keyTypes, response);\n+    return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  }\n+\n+  private void validateGetResponse(\n+      final List<SecurityKeyType> keyTypes, final GetSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private void validateGetNewResponse(\n+      final List<SecurityKeyType> keyTypes, final GetNewSecretsResponse response) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+  }\n+\n+  private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(\n+      final List<TypedSecret> soapSecrets) {\n+    final Function<TypedSecret, SecurityKeyType> convertType =\n+        ts -> SecurityKeyType.fromSecretType(ts.getType());\n+    final Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts, false);\n+    final Map<SecurityKeyType, byte[]> decryptedKeysByType = new EnumMap<>(SecurityKeyType.class);\n+    soapSecrets.forEach(\n+        ts -> decryptedKeysByType.put(convertType.apply(ts), convertSecret.apply(ts)));\n+    return decryptedKeysByType;\n+  }\n+\n+  private GetSecretsRequest createGetSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetSecretsRequest request = new GetSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  private GetNewSecretsRequest createGetNewSecretsRequest(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final GetNewSecretsRequest request = new GetNewSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    return request;\n+  }\n+\n+  /**\n+   * Store new key\n+   *\n+   * <p>A new key is a security key with a device which status NEW. This status is used when the new\n+   * key is known, but not yet set on the device.\n+   *\n+   * <p><strong>CAUTION:</strong> Only call this method when a successful connection with the device\n+   * has been set up (that is: a valid communication key that works is known), and you are sure any\n+   * existing new key data that is not activated yet (for instance a new key stored earlier in an\n+   * attempt to replace the communication key that got aborted).<br>\n+   *\n+   * <p>The moment the new key is known to be transferred to the device, make sure to activate it by\n+   * calling {@link #activateNewKey(String, SecurityKeyType)}.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param key key to store, unencrypted\n+   * @param keyType type of key\n+   * @see #activateNewKey(String, SecurityKeyType)\n+   */\n+  public void storeNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType, final byte[] key) {\n+    final Map<SecurityKeyType, byte[]> keysByType = new EnumMap<>(SecurityKeyType.class);\n+    keysByType.put(keyType, key);\n+    this.storeNewKeys(deviceIdentification, keysByType);\n+  }\n+\n+  public void storeNewKeys(\n+      final String deviceIdentification, final Map<SecurityKeyType, byte[]> keysByType) {\n+    this.validateKeys(keysByType);\n+    final TypedSecrets typedSecrets = new TypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    for (final Map.Entry<SecurityKeyType, byte[]> entry : keysByType.entrySet()) {\n+      final TypedSecret ts = new TypedSecret();\n+      ts.setType(entry.getKey().toSecretType());\n+      ts.setSecret(this.encryptSoapSecret(entry.getValue(), true));\n+      typedSecretList.add(ts);\n     }\n-\n-    /*\n-     * Decrypts the given symmetrically encrypted key.\n-     * <p>\n-     * <strong>NB:</strong> Only decrypt keys like this at the moment they are\n-     * required as part of the communication with a device.\n-     *\n-     * @param encryptedKey\n-     *         key encrypted with the symmetrical key internal to the DLMS\n-     *         protocol adapter.\n-     *\n-     * @return the plain key, or an empty byte array if\n-     *         {@code encryptedKey == null}\n-     */\n-    @Override\n-    public byte[] aesDecryptKey(final byte[] encryptedKey) throws FunctionalException {\n-        if (encryptedKey == null) {\n-            throw new IllegalArgumentException(\"Cannot decrypt NULL key\");\n-        }\n-        try {\n-            return this.aesEncryptionService.decrypt(encryptedKey);\n-        } catch (final Exception e) {\n-            throw new FunctionalException(FunctionalExceptionType.ENCRYPTION_EXCEPTION, ComponentType.PROTOCOL_DLMS, e);\n-        }\n+    final StoreSecretsRequest request =\n+        this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n+    StoreSecretsResponse response = null;\n+    try {\n+      response = this.secretManagementClient.storeSecretsRequest(request);\n+    } catch (final RuntimeException exc) {\n+      throw new IllegalStateException(\"Could not store keys: unexpected exception occured\", exc);\n     }\n-\n-    @Override\n-    public byte[] getKey(String deviceIdentification, SecurityKeyType keyType) {\n-        LOGGER.info(\"Retrieving {} for device {}\", keyType.name(), deviceIdentification);\n-        return this.getKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+    if (response == null) {\n+      throw new IllegalStateException(\"Could not store keys: NULL response\");\n+    } else if (!OsgpResultType.OK.equals(response.getResult())) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Could not store keys: result=%s; fault=%s\",\n+              response.getResult(), response.getTechnicalFault()));\n     }\n+  }\n \n-    @Override\n-    public Map<SecurityKeyType, byte[]> getKeys(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = this.createGetSecretsRequest(deviceIdentification, keyTypes);\n-        GetSecretsResponse response = this.secretManagementClient.getSecretsRequest(request);\n-        this.validateGetResponse(keyTypes, response);\n-        return this.convertSoapSecretsToSecretMapByType(response.getTypedSecrets().getTypedSecret());\n+  private void validateKeys(final Map<SecurityKeyType, byte[]> keysByType) {\n+    final long nrNulls = keysByType.values().stream().filter(Objects::isNull).count();\n+    if (nrNulls > 0) {\n+      throw new IllegalArgumentException(\n+          String.format(\"Provided %s keys, %s of which were NULL\", keysByType.size(), nrNulls));\n     }\n-\n-    private void validateGetResponse(List<SecurityKeyType> keyTypes, GetSecretsResponse response) {\n-        if (!OsgpResultType.OK.equals(response.getResult()) || response.getTypedSecrets() == null\n-                || response.getTypedSecrets().getTypedSecret() == null) {\n+  }\n+\n+  private StoreSecretsRequest createStoreSecretsRequest(\n+      final String deviceIdentification, final TypedSecrets typedSecrets) {\n+    final StoreSecretsRequest request = new StoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setTypedSecrets(typedSecrets);\n+    return request;\n+  }\n+\n+  /**\n+   * Updates the state of a new key from 'new' to 'active'\n+   *\n+   * <p>This method should be called to activate a new key stored with {@link #storeNewKeys(String,\n+   * Map)} after it has been confirmed to be set on the device.\n+   *\n+   * @param deviceIdentification DLMS device id\n+   * @param keyType type of key\n+   * @see #storeNewKeys(String, Map)\n+   */\n+  public void activateNewKey(final String deviceIdentification, final SecurityKeyType keyType) {\n+    this.activateNewKeys(deviceIdentification, Arrays.asList(keyType));\n+  }\n+\n+  public void activateNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final ActivateSecretsRequest request = new ActivateSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(new SecretTypes());\n+    final List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n+    keyTypes.forEach(kt -> secretTypeList.add(kt.toSecretType()));\n+    this.secretManagementClient.activateSecretsRequest(request);\n+  }\n+\n+  public boolean hasNewSecretOfType(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    final HasNewSecretRequest request = new HasNewSecretRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretType(keyType.toSecretType());\n+    final HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n+    return response.isHasNewSecret();\n+  }\n+\n+  public byte[] generate128BitsKeyAndStoreAsNewKey(\n+      final String deviceIdentification, final SecurityKeyType keyType) {\n+    return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType))\n+        .get(keyType);\n+  }\n+\n+  /**\n+   * Generates a new key that can be used as DLMS master key, authentication key, global unicast\n+   * encryption key, M-Bus Default key or M-Bus User key.\n+   *\n+   * <p>The master keys (DLMS master or M-Bus Default) cannot be changed on a device, but can be\n+   * generated for use in tests or with simulated devices.\n+   *\n+   * @return a new 128bits key, unencrypted.\n+   */\n+  public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(\n+      final String deviceIdentification, final List<SecurityKeyType> keyTypes) {\n+    final SecretTypes secretTypes = new SecretTypes();\n+    final GenerateAndStoreSecretsRequest request =\n+        this.createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n+    secretTypes\n+        .getSecretType()\n+        .addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n+\n+    final GenerateAndStoreSecretsResponse response =\n+        this.secretManagementClient.generateAndStoreSecrets(request);\n+    final TypedSecrets typedSecrets = response.getTypedSecrets();\n+    final List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n+    this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n+    return this.convertSoapSecretsToSecretMapByType(typedSecrets.getTypedSecret());\n+  }\n+\n+  private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(\n+      final String deviceIdentification, final SecretTypes secretTypes) {\n+    final GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n+    request.setDeviceId(deviceIdentification);\n+    request.setSecretTypes(secretTypes);\n+    return request;\n+  }\n+\n+  private void validateGenerateAndStoreResponse(\n+      final List<SecurityKeyType> keyTypes,\n+      final GenerateAndStoreSecretsResponse response,\n+      final List<TypedSecret> typedSecretList) {\n+    this.validateOsgpResultAndTypedSecrets(\n+        response.getResult(),\n+        response.getTechnicalFault(),\n+        response.getTypedSecrets(),\n+        keyTypes.size());\n+    typedSecretList.forEach(\n+        ts -> {\n+          if (ts.getSecret() == null) {\n             throw new IllegalStateException(\n-                    \"Invalid/incomplete soap response: resulttype=\" + response.getResult().value());\n-        }\n-        if (keyTypes.size() != response.getTypedSecrets().getTypedSecret().size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private Map<SecurityKeyType, byte[]> convertSoapSecretsToSecretMapByType(List<TypedSecret> soapSecrets) {\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return soapSecrets.stream().collect(Collectors.toMap(convertType, convertSecret));\n+                String.format(\"Generated a NULL key (key_type=%s)\", ts.getType()));\n+          }\n+        });\n+  }\n+\n+  private void validateOsgpResultAndTypedSecrets(\n+      final OsgpResultType result,\n+      final Object fault,\n+      final TypedSecrets typedSecrets,\n+      final int expectedNrKeys) {\n+    if (!OsgpResultType.OK.equals(result)) {\n+      throw new IllegalStateException(\"Could not process keys in secret-mgmt: \" + fault);\n+    } else if (typedSecrets == null || typedSecrets.getTypedSecret() == null) {\n+      throw new IllegalStateException(\"No secrets in response\");\n+    } else if (expectedNrKeys != typedSecrets.getTypedSecret().size()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unexpected number of secrets in response: expected %s but found %s\",\n+              expectedNrKeys, typedSecrets.getTypedSecret().size()));\n     }\n-\n-    private GetSecretsRequest createGetSecretsRequest(String deviceIdentification, List<SecurityKeyType> keyTypes) {\n-        GetSecretsRequest request = new GetSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        keyTypes.stream().forEach(kt -> secretTypeList.add(kt.toSecretType()));\n-        return request;\n-    }\n-\n-    /*@Override\n-    public void aesDecryptAndStoreNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] encryptedKey)\n-            throws FunctionalException {\n-        byte[] plainKey = this.aesDecryptKey(encryptedKey); //, keyType);\n-        this.storeNewKeys(deviceIdentification, new SecurityKeyType[] { keyType }, new byte[][] { plainKey });\n-    }*/\n-\n-    @Override\n-    public void storeNewKey(String deviceIdentification, SecurityKeyType keyType, byte[] aesKey) {\n-        Map<SecurityKeyType, byte[]> keysByType = new HashMap<>();\n-        keysByType.put(keyType, aesKey);\n-        this.storeNewKeys(deviceIdentification, keysByType);\n-    }\n-\n-    @Override\n-    public void storeNewKeys(String deviceIdentification, Map<SecurityKeyType, byte[]> aesKeysByType) {\n-        TypedSecrets typedSecrets = new TypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        for (SecurityKeyType type : aesKeysByType.keySet()) {\n-            TypedSecret ts = new TypedSecret();\n-            ts.setType(type.toSecretType());\n-            try {\n-                ts.setSecret(this.encryptSoapSecret(this.aesDecryptKey(aesKeysByType.get(type))));\n-            } catch (FunctionalException e) {\n-                LOGGER.error(\"Could not encrypt/decrypt secret of type {}\", type, e);\n-            }\n-            typedSecretList.add(ts);\n-        }\n-        StoreSecretsRequest request = this.createStoreSecretsRequest(deviceIdentification, typedSecrets);\n-        this.secretManagementClient.storeSecretsRequest(request);\n+  }\n+\n+  private byte[] decryptSoapSecret(final TypedSecret typedSecret, final boolean exceptionOnNull) {\n+    final boolean nullValue = typedSecret.getSecret() == null || typedSecret.getSecret().isEmpty();\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot decrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    private StoreSecretsRequest createStoreSecretsRequest(String deviceIdentification, TypedSecrets typedSecrets) {\n-        StoreSecretsRequest request = new StoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setTypedSecrets(typedSecrets);\n-        return request;\n-    }\n-\n-    @Override\n-    public void activateNewKey(String deviceIdentification, SecurityKeyType keyType) throws ProtocolAdapterException {\n-        ActivateSecretsRequest request = new ActivateSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(new SecretTypes());\n-        List<SecretType> secretTypeList = request.getSecretTypes().getSecretType();\n-        secretTypeList.add(keyType.toSecretType());\n-        this.secretManagementClient.activateSecretsRequest(request);\n+    try {\n+      final byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n+      return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n     }\n-\n-    @Override\n-    public boolean hasNewSecretOfType(String deviceIdentification, SecurityKeyType keyType) {\n-        HasNewSecretRequest request = new HasNewSecretRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretType(keyType.toSecretType());\n-        HasNewSecretResponse response = this.secretManagementClient.hasNewSecretRequest(request);\n-        return response.isHasNewSecret();\n-    }\n-\n-    @Override\n-    public byte[] generate128BitsKeyAndStoreAsNewKey(String deviceIdentification, SecurityKeyType keyType) {\n-        return this.generate128BitsKeysAndStoreAsNewKeys(deviceIdentification, Arrays.asList(keyType)).get(keyType);\n+  }\n+\n+  private String encryptSoapSecret(final byte[] secret, final boolean exceptionOnNull) {\n+    final boolean nullValue = secret == null || secret.length == 0;\n+    if (exceptionOnNull && nullValue) {\n+      throw new IllegalArgumentException(\"Cannot encrypt NULL value\");\n+    } else if (!exceptionOnNull && nullValue) {\n+      return null;\n     }\n-\n-    /**\n-     * Generates a new key that can be used as DLMS master key, authentication\n-     * key, global unicast encryption key, M-Bus Default key or M-Bus User key.\n-     * <p>\n-     * The master keys (DLMS master or M-Bus Default) cannot be changed on a\n-     * device, but can be generated for use in tests or with simulated devices.\n-     *\n-     * @return a new 128bits key, unencrypted.\n-     */\n-    @Override\n-    public Map<SecurityKeyType, byte[]> generate128BitsKeysAndStoreAsNewKeys(String deviceIdentification,\n-            List<SecurityKeyType> keyTypes) {\n-        SecretTypes secretTypes = new SecretTypes();\n-        GenerateAndStoreSecretsRequest request = this\n-                .createGenerateAndStoreSecretsRequest(deviceIdentification, secretTypes);\n-        secretTypes.getSecretType().addAll(keyTypes.stream().map(SecurityKeyType::toSecretType).collect(toList()));\n-\n-        GenerateAndStoreSecretsResponse response = this.secretManagementClient.generateAndStoreSecrets(request);\n-        TypedSecrets typedSecrets = response.getTypedSecrets();\n-        List<TypedSecret> typedSecretList = typedSecrets.getTypedSecret();\n-        this.validateGenerateAndStoreResponse(keyTypes, response, typedSecretList);\n-        Function<TypedSecret, SecurityKeyType> convertType = ts -> SecurityKeyType.fromSecretType(ts.getType());\n-        Function<TypedSecret, byte[]> convertSecret = ts -> this.decryptSoapSecret(ts);\n-        return typedSecretList.stream().collect(Collectors.toMap(convertType, convertSecret));\n-    }\n-\n-    private GenerateAndStoreSecretsRequest createGenerateAndStoreSecretsRequest(String deviceIdentification,\n-            SecretTypes secretTypes) {\n-        GenerateAndStoreSecretsRequest request = new GenerateAndStoreSecretsRequest();\n-        request.setDeviceId(deviceIdentification);\n-        request.setSecretTypes(secretTypes);\n-        return request;\n-    }\n-\n-    private void validateGenerateAndStoreResponse(List<SecurityKeyType> keyTypes,\n-            GenerateAndStoreSecretsResponse response, List<TypedSecret> typedSecretList) {\n-        if (!OsgpResultType.OK.equals(response.getResult())) {\n-            throw new IllegalStateException(\n-                    \"Could not generate and store keys in secret-mgmt: \" + response.getTechnicalFault().toString());\n-        } else if (keyTypes.size() != typedSecretList.size()) {\n-            throw new IllegalStateException(\"Unexpected number of secrets in response\");\n-        }\n-    }\n-\n-    private byte[] decryptSoapSecret(TypedSecret typedSecret) {\n-        try {\n-            byte[] encryptedDecodedSoapSecret = Hex.decodeHex(typedSecret.getSecret());\n-            return this.soapRsaEncrypter.decrypt(encryptedDecodedSoapSecret);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error decoding/decrypting SOAP key\", e);\n-        }\n-    }\n-\n-    private String encryptSoapSecret(byte[] secret) {\n-        try {\n-            byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n-            return Hex.encodeHexString(encrypted);\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n-        }\n+    try {\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      return Hex.encodeHexString(encrypted);\n+    } catch (final Exception e) {\n+      throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n     }\n+  }\n }\n", "next_change": {"commit": "435ca18a134b4c51608b2f85b32ded99a881522d", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex a8c814dc95..58101a2193 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -368,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "f89d0f39ae93b6d59d70b38f37c46ed873f92e2a", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 58101a2193..2531fbe3f0 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +418,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterWithSecretManagementPublicKey.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "074785c421df2f7786b98ecef7ebffe1f4109d42", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 2531fbe3f0..8c77f183ce 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -418,7 +439,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "da2dcf8049207af58ff7d71b27951fc77c5ac31c", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 8c77f183ce..bdfde725fc 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -439,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "582a014839f8e19d8a1b2823f44c70c68fdd6ebc", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex bdfde725fc..22309050d9 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +446,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n+      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": {"commit": "1453d0d2dab45d7ce92ffa2b4d6655aa9643ff49", "changed_code": [{"header": "diff --git a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\nindex 22309050d9..d0d93b965c 100644\n--- a/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n+++ b/osgp/protocol-adapter-dlms/osgp-protocol-adapter-dlms/src/main/java/org/opensmartgridplatform/adapter/protocol/dlms/application/services/SecretManagementService.java\n", "chunk": "@@ -446,7 +453,7 @@ public class SecretManagementService {\n       return null;\n     }\n     try {\n-      final byte[] encrypted = this.soapRsaEncrypter.encrypt(secret);\n+      final byte[] encrypted = this.encrypterForSecretManagement.encrypt(secret);\n       return Hex.encodeHexString(encrypted);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Error encoding/encrypting SOAP key\", e);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyOTg5Mw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442229893", "body": "I would expect this to be a Spring Component.", "bodyText": "I would expect this to be a Spring Component.", "bodyHTML": "<p dir=\"auto\">I would expect this to be a Spring Component.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:34:58Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMDEyOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442230128", "body": "inject as Spring @Resource ?", "bodyText": "inject as Spring @resource ?", "bodyHTML": "<p dir=\"auto\">inject as Spring <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/resource/hovercard\" href=\"https://github.com/resource\">@resource</a> ?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:35:17Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"AES\";\n+    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    public static final String PROVIDER = \"SunJCE\";\n+    public static final String FORMAT = \"RAW\";\n+    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+\n+    private byte[] key;\n+\n+    protected int getIVLength() {\n+        return IV.length;\n+    }\n+\n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n+    @Override\n+    public void setKeyFile(File keyStoreFile) throws Exception {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMDQ1Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442230456", "body": "what is \"1\" , better to create a constant ", "bodyText": "what is \"1\" , better to create a constant", "bodyHTML": "<p dir=\"auto\">what is \"1\" , better to create a constant</p>", "author": "coendamen", "createdAt": "2020-06-18T13:35:47Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/JreEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+public class JreEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    public static final String ALG = \"AES\";\n+    public static final String ALGORITHM = \"AES/CBC/PKCS5PADDING\";\n+    public static final String PROVIDER = \"SunJCE\";\n+    public static final String FORMAT = \"RAW\";\n+    private static final byte[] IV = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+\n+    private byte[] key;\n+\n+    protected int getIVLength() {\n+        return IV.length;\n+    }\n+\n+    protected Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException {\n+        return Cipher.getInstance(ALGORITHM, PROVIDER);\n+    }\n+\n+    @Override\n+    public void setKeyFile(File keyStoreFile) throws Exception {\n+        super.setKeyFile(keyStoreFile);\n+        this.key = Files.readAllBytes(Paths.get(keyStoreFile.getAbsolutePath()));\n+    }\n+\n+    protected Key getSecretEncryptionKey(String keyReference) {\n+\n+        if (!keyReference.equals(\"1\")) {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMTAwOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442231009", "body": "Spring component ?", "bodyText": "Spring component ?", "bodyHTML": "<p dir=\"auto\">Spring component ?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:36:36Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMjI5Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442232292", "body": "warning or error ?", "bodyText": "warning or error ?", "bodyHTML": "<p dir=\"auto\">warning or error ?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:38:26Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+import java.util.logging.Logger;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AbstractEncryptionProvider.class.getName());\n+\n+    protected File keyFile;\n+\n+    public abstract EncryptionProviderType getType();\n+    protected abstract Cipher getCipher() throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException;\n+    protected abstract AlgorithmParameterSpec getAlgorithmParameterSpec();\n+    protected abstract Key getSecretEncryptionKey(String keyReference) throws Exception;\n+    protected abstract int getIVLength();\n+\n+    public void setKeyFile(File keyFile) throws Exception {\n+        this.keyFile = keyFile;\n+    }\n+\n+    public EncryptedSecret encrypt(Secret secret, String keyReference) throws Exception {\n+        try {\n+            final Cipher cipher = this.getCipher();\n+            cipher.init(Cipher.ENCRYPT_MODE, this.getSecretEncryptionKey(keyReference), this.getAlgorithmParameterSpec());\n+            return new EncryptedSecret(this.getType(), cipher.doFinal(secret.getSecret()));\n+        } catch (Exception e) {\n+            //InvalidKeyException | IllegalBlockSizeException | BadPaddingException | InvalidAlgorithmParameterException |\n+            //NoSuchPaddingException | NoSuchAlgorithmException | NoSuchProviderException\n+            LOGGER.warning(e.getMessage());", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzNjI3MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442236270", "body": "basically returning null is a code-smell. consider returning Optional", "bodyText": "basically returning null is a code-smell. consider returning Optional", "bodyHTML": "<p dir=\"auto\">basically returning null is a code-smell. consider returning Optional</p>", "author": "coendamen", "createdAt": "2020-06-18T13:44:06Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.JreEncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.HsmEncryptionProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers = new ArrayList<>();\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile) throws Exception {\n+        this(jreKeyFile, null);\n+    }\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile, File hsmKeyStoreFile) throws Exception {\n+        JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider();\n+        jreEncryptionProvider.setKeyFile(jreKeyFile);\n+\n+        providers.add(jreEncryptionProvider);\n+\n+        if (hsmKeyStoreFile != null) {\n+            HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider();\n+            hsmEncryptionProvider.setKeyFile(hsmKeyStoreFile);\n+            providers.add(hsmEncryptionProvider);\n+        }\n+    }\n+\n+    @Override\n+    public EncryptedSecret encrypt(EncryptionProviderType encType, Secret secret, String keyReference) throws Exception {\n+        Optional<EncryptionProvider> oep = providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();\n+        return oep.isPresent()?oep.get().encrypt(secret, keyReference):null;\n+    }\n+\n+    @Override\n+    public Secret decrypt(EncryptedSecret secret, String keyReference) throws Exception {\n+        EncryptionProviderType encType = secret.getType();\n+        Optional<EncryptionProvider> oep = providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();\n+        return oep.isPresent()?oep.get().decrypt(secret, keyReference):null;", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzNjM3Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442236376", "body": "basically returning null is a code-smell. consider returning Optional\r\n\r\n", "bodyText": "basically returning null is a code-smell. consider returning Optional", "bodyHTML": "<p dir=\"auto\">basically returning null is a code-smell. consider returning Optional</p>", "author": "coendamen", "createdAt": "2020-06-18T13:44:17Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.JreEncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.HsmEncryptionProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers = new ArrayList<>();\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile) throws Exception {\n+        this(jreKeyFile, null);\n+    }\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile, File hsmKeyStoreFile) throws Exception {\n+        JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider();\n+        jreEncryptionProvider.setKeyFile(jreKeyFile);\n+\n+        providers.add(jreEncryptionProvider);\n+\n+        if (hsmKeyStoreFile != null) {\n+            HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider();\n+            hsmEncryptionProvider.setKeyFile(hsmKeyStoreFile);\n+            providers.add(hsmEncryptionProvider);\n+        }\n+    }\n+\n+    @Override\n+    public EncryptedSecret encrypt(EncryptionProviderType encType, Secret secret, String keyReference) throws Exception {\n+        Optional<EncryptionProvider> oep = providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();\n+        return oep.isPresent()?oep.get().encrypt(secret, keyReference):null;", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzNjk4MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442236980", "body": "change to Spring bean and use @Resource injection", "bodyText": "change to Spring bean and use @resource injection", "bodyHTML": "<p dir=\"auto\">change to Spring bean and use <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/resource/hovercard\" href=\"https://github.com/resource\">@resource</a> injection</p>", "author": "coendamen", "createdAt": "2020-06-18T13:45:07Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.JreEncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.HsmEncryptionProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NzExMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442247113", "body": "minor: consider naming interface SecretManagementService and the impl SecretManagementServiceImpl as this is the most common way to do this. ", "bodyText": "minor: consider naming interface SecretManagementService and the impl SecretManagementServiceImpl as this is the most common way to do this.", "bodyHTML": "<p dir=\"auto\">minor: consider naming interface SecretManagementService and the impl SecretManagementServiceImpl as this is the most common way to do this.</p>", "author": "coendamen", "createdAt": "2020-06-18T13:58:15Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package org.opensmartgridplatform.secretmgmt.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmgmt.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmgmt.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmgmt.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptionDelegate;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService implements SecretManagement {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1NTc3OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442355778", "bodyText": "Agreed.", "author": "jandik", "createdAt": "2020-06-18T16:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NzExMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NzY2OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442247668", "body": "do yo need a native query per se ?", "bodyText": "do yo need a native query per se ?", "bodyHTML": "<p dir=\"auto\">do yo need a native query per se ?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:58:58Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/repository/DbEncryptedSecretRepository.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.opensmartgridplatform.secretmgmt.application.repository;\n+\n+import java.util.Date;\n+\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptedSecret;\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.stereotype.Repository;\n+\n+@Repository\n+public interface DbEncryptedSecretRepository extends JpaRepository<DbEncryptedSecret, Long> {\n+    @Query(value = \"SELECT es.id FROM encrypted_secret es \" +\n+            \"LEFT JOIN encryption_key_reference ekr ON es.encryption_key_reference_id = ekr.id \" +\n+            \"WHERE es.device_identification = :deviceIdentification \" +\n+            \"AND es.secret_type = :secretType \" +\n+            \"AND ekr.valid_from < :date AND (ekr.valid_to IS NULL OR ekr.valid_to > :date) \" +\n+            \"ORDER BY es.creation_time DESC, es.id DESC \" +\n+            \"LIMIT 1\",\n+            nativeQuery = true)", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1NTQ1OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442355458", "bodyText": "Unfortunately, I do. Jpql doesn't support LIMIT. Alternative option (which I tried first) is to use Jpql in combination with pagination, but this resulted in an error (hibernate tries to generate a count query, but this query was incorrect SQL) and might also be less performant.", "author": "jandik", "createdAt": "2020-06-18T16:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1MDY2OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444050669", "bodyText": "hmm, I think there is a setMaxResults setting on a query, maybe could be worth a try", "author": "coendamen", "createdAt": "2020-06-23T08:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2ODIxOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r447568219", "bodyText": "the setMaxResults property applies to a Hibernate query, not on a Spring query annotation", "author": "jandik", "createdAt": "2020-06-30T10:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NzY2OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0ODM3OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442248379", "body": "TechnicalServiceFault seems vague. Maybe rename to SecretManagementException or something like that ?", "bodyText": "TechnicalServiceFault seems vague. Maybe rename to SecretManagementException or something like that ?", "bodyHTML": "<p dir=\"auto\">TechnicalServiceFault seems vague. Maybe rename to SecretManagementException or something like that ?</p>", "author": "coendamen", "createdAt": "2020-06-18T13:59:56Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/exception/TechnicalServiceFaultException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package org.opensmartgridplatform.secretmgmt.application.exception;\n+\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TechnicalFault;\n+\n+public class TechnicalServiceFaultException extends RuntimeException {", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0ODk4Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442248982", "body": "add accolades as per the standard.", "bodyText": "add accolades as per the standard.", "bodyHTML": "<p dir=\"auto\">add accolades as per the standard.</p>", "author": "coendamen", "createdAt": "2020-06-18T14:00:43Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/exception/DetailSoapFaultMappingExceptionResolver.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package org.opensmartgridplatform.secretmgmt.application.exception;\n+\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TechnicalFault;\n+import org.springframework.ws.soap.SoapFault;\n+import org.springframework.ws.soap.SoapFaultDetail;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+\n+import javax.xml.namespace.QName;\n+\n+public class DetailSoapFaultMappingExceptionResolver extends SoapFaultMappingExceptionResolver {\n+\n+    private static final QName MESSAGE = new QName(\"Message\");\n+    private static final QName COMPONENT = new QName(\"Component\");\n+    private static final QName INNER_MESSAGE = new QName(\"InnerMessage\");\n+    private static final QName INNER_EXCEPTION = new QName(\"InnerException\");\n+\n+    @Override\n+    protected void customizeFault(Object endpoint, Exception ex, SoapFault fault) {\n+        if (ex instanceof TechnicalServiceFaultException) {\n+            TechnicalFault technicalFault = ((TechnicalServiceFaultException) ex).getTechnicalFault();\n+            SoapFaultDetail detail = fault.addFaultDetail();\n+            if (technicalFault.getMessage() != null) detail.addFaultDetailElement(MESSAGE).addText(technicalFault.getMessage());", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI1MDY2Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442250666", "body": "I see a lot of hardcoded strings, consider moving to properties as in the rest of OSGP", "bodyText": "I see a lot of hardcoded strings, consider moving to properties as in the rest of OSGP", "bodyHTML": "<p dir=\"auto\">I see a lot of hardcoded strings, consider moving to properties as in the rest of OSGP</p>", "author": "coendamen", "createdAt": "2020-06-18T14:03:05Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/config/WebServiceConfig.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.opensmartgridplatform.secretmgmt.application.config;\n+\n+import org.opensmartgridplatform.secretmgmt.application.exception.DetailSoapFaultMappingExceptionResolver;\n+import org.opensmartgridplatform.secretmgmt.application.exception.TechnicalServiceFaultException;\n+import org.springframework.boot.web.servlet.ServletRegistrationBean;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.ws.config.annotation.EnableWs;\n+import org.springframework.ws.config.annotation.WsConfigurerAdapter;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultDefinition;\n+import org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver;\n+import org.springframework.ws.transport.http.MessageDispatcherServlet;\n+import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;\n+import org.springframework.xml.xsd.XsdSchemaCollection;\n+import org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection;\n+\n+import java.util.Properties;\n+\n+@EnableWs\n+@Configuration\n+public class WebServiceConfig extends WsConfigurerAdapter {\n+    @Bean\n+    public ServletRegistrationBean messageDispatcherServlet(ApplicationContext applicationContext) {\n+        MessageDispatcherServlet servlet = new MessageDispatcherServlet();\n+        servlet.setApplicationContext(applicationContext);\n+        servlet.setTransformWsdlLocations(true);\n+        return new ServletRegistrationBean(servlet, \"/ws/SecretManagement/*\");\n+    }\n+\n+    /**\n+     * url of the WSDL by this definition is:\n+     *\n+     *    http://localhost:8080/ws/SecretManagement/secretManagement.wsdl\n+     */\n+    @Bean(name = \"secretManagement\")\n+    public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchemaCollection secretManagementSchemas) {\n+        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();\n+        wsdl11Definition.setPortTypeName(\"SecretManagementPort\");\n+        wsdl11Definition.setLocationUri(\"/ws/SecretManagement\");\n+        wsdl11Definition.setTargetNamespace(\"http://www.opensmartgridplatform.org/schemas/security/secretmanagement/2020/05\");", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI1MzU4Nw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442253587", "body": "Note that the DefaultEncryptionDelegate is not a delegate but a Delegator. The actual Delegates are the providers doing the work.\r\nConsider renaming.", "bodyText": "Note that the DefaultEncryptionDelegate is not a delegate but a Delegator. The actual Delegates are the providers doing the work.\nConsider renaming.", "bodyHTML": "<p dir=\"auto\">Note that the DefaultEncryptionDelegate is not a delegate but a Delegator. The actual Delegates are the providers doing the work.<br>\nConsider renaming.</p>", "author": "coendamen", "createdAt": "2020-06-18T14:06:59Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/config/SecurityConfig.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.opensmartgridplatform.secretmgmt.application.config;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.DefaultEncryptionDelegate;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptionDelegate;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.JreEncryptionProvider;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.Resource;\n+\n+import java.util.Optional;\n+\n+@Configuration\n+public class SecurityConfig {\n+\n+    @Value(\"${soap.secret.resource}\")\n+    private Resource soapSecretResource;\n+\n+    @Value(\"${database.secret.resource}\")\n+    private Resource databaseSecretResource;\n+\n+    @Value(\"${hsm.keystore.resource:#{null}}\")\n+    private Optional<Resource> hsmKeystoreResource;\n+\n+    @Value(\"${encryption.provider.type}\")\n+    private String encryptionProviderTypeName;\n+\n+    @Bean(name = \"osgpEncryptionDelegate\")\n+    public EncryptionDelegate getDefaultEncryptionDelegate() throws Exception {\n+        EncryptionDelegate encryptionDelegate;", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI2MzQ5OA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442263498", "body": "this seems a strange construct and not open to extension. Why not create a second Provider for HSM?", "bodyText": "this seems a strange construct and not open to extension. Why not create a second Provider for HSM?", "bodyHTML": "<p dir=\"auto\">this seems a strange construct and not open to extension. Why not create a second Provider for HSM?</p>", "author": "coendamen", "createdAt": "2020-06-18T14:20:54Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.JreEncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.HsmEncryptionProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers = new ArrayList<>();\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile) throws Exception {\n+        this(jreKeyFile, null);\n+    }\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile, File hsmKeyStoreFile) throws Exception {\n+        JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider();\n+        jreEncryptionProvider.setKeyFile(jreKeyFile);\n+\n+        providers.add(jreEncryptionProvider);", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI2NDI5NA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442264294", "body": "for my understanding: is it ever possible that multiple providers for the same EncryptionProviderType are registered?", "bodyText": "for my understanding: is it ever possible that multiple providers for the same EncryptionProviderType are registered?", "bodyHTML": "<p dir=\"auto\">for my understanding: is it ever possible that multiple providers for the same EncryptionProviderType are registered?</p>", "author": "coendamen", "createdAt": "2020-06-18T14:21:55Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/DefaultEncryptionDelegate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.JreEncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.HsmEncryptionProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * This class is used to encrypt/decrypt typed secrets by either the HardwareSecurityModule or by the JRE\n+ */\n+public class DefaultEncryptionDelegate implements EncryptionDelegate {\n+\n+    private final List<EncryptionProvider> providers = new ArrayList<>();\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile) throws Exception {\n+        this(jreKeyFile, null);\n+    }\n+\n+    public DefaultEncryptionDelegate(File jreKeyFile, File hsmKeyStoreFile) throws Exception {\n+        JreEncryptionProvider jreEncryptionProvider = new JreEncryptionProvider();\n+        jreEncryptionProvider.setKeyFile(jreKeyFile);\n+\n+        providers.add(jreEncryptionProvider);\n+\n+        if (hsmKeyStoreFile != null) {\n+            HsmEncryptionProvider hsmEncryptionProvider = new HsmEncryptionProvider();\n+            hsmEncryptionProvider.setKeyFile(hsmKeyStoreFile);\n+            providers.add(hsmEncryptionProvider);\n+        }\n+    }\n+\n+    @Override\n+    public EncryptedSecret encrypt(EncryptionProviderType encType, Secret secret, String keyReference) throws Exception {\n+        Optional<EncryptionProvider> oep = providers.stream().filter(ep -> ep.getType().equals(encType)).findFirst();", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI2NTEwMg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442265102", "bodyText": "consider keeping the param names equal to the Object types. EncryptionProviderType --> encType misses \"provider\" and is thus less readable.", "author": "coendamen", "createdAt": "2020-06-18T14:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI2NDI5NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI2NjYyNw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442266627", "body": "use default value in annotation:\r\n\r\n\"${component.name:OSGP-SECRET-MANAGEMENT}\"", "bodyText": "use default value in annotation:\n\"${component.name:OSGP-SECRET-MANAGEMENT}\"", "bodyHTML": "<p dir=\"auto\">use default value in annotation:</p>\n<p dir=\"auto\">\"${component.name:OSGP-SECRET-MANAGEMENT}\"</p>", "author": "coendamen", "createdAt": "2020-06-18T14:24:53Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/config/ApplicationConfig.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package org.opensmartgridplatform.secretmgmt.application.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+\n+@Configuration\n+public class ApplicationConfig {\n+\n+    @Value(\"${component.name}\")\n+    public final static String COMPONENT_NAME = \"OSGP-SECRET-MANAGEMENT\";", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI2NzUyMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r442267523", "body": "I don't think this should be hardcoded here.", "bodyText": "I don't think this should be hardcoded here.", "bodyHTML": "<p dir=\"auto\">I don't think this should be hardcoded here.</p>", "author": "coendamen", "createdAt": "2020-06-18T14:25:57Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmgmt/config/WebClientConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.opensmartgridplatform.secretmgmt.config;\n+\n+import org.opensmartgridplatform.secretmgmt.serviceclient.SoapConnector;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.oxm.jaxb.Jaxb2Marshaller;\n+\n+@Configuration\n+public class WebClientConfig {\n+\n+    @Bean\n+    public Jaxb2Marshaller marshaller() {\n+        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();\n+\n+        marshaller.setContextPath(\"org.opensmartgridplatform.schemas.security.secretmanagement._2020._05\");\n+        return marshaller;\n+    }\n+\n+    @Bean\n+    public SoapConnector soapConnector(Jaxb2Marshaller marshaller) {\n+        SoapConnector client = new SoapConnector();\n+        client.setDefaultUri(\"http://localhost:8080/ws/SecretManagement\");", "originalCommit": "25adddc4a129c95cb5e571f6164e19c3a9534806", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "e0377bd4adc6c45a4de93764715961fd781a03ab", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/e0377bd4adc6c45a4de93764715961fd781a03ab", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-22T12:29:45Z", "type": "commit"}, {"oid": "7d3f6e7354717549f9aab0b23ae156ac087a4fc8", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/7d3f6e7354717549f9aab0b23ae156ac087a4fc8", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-22T14:28:32Z", "type": "commit"}, {"oid": "ca4077fc480ac8f0dd62f8634f7b907b54354e0f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/ca4077fc480ac8f0dd62f8634f7b907b54354e0f", "message": "SLIM-2253-use-secret-mangement-for-secure-keys", "committedDate": "2020-06-22T14:30:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAzODkzNQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444038935", "body": "remove?", "bodyText": "remove?", "bodyHTML": "<p dir=\"auto\">remove?</p>", "author": "jboon", "createdAt": "2020-06-23T08:06:11Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmgmt/application/SoapServiceSecretManagementIT.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.opensmartgridplatform.secretmgmt.application;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.springframework.ws.test.server.RequestCreators.withPayload;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmgmt.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n+import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;\n+import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;\n+import org.springframework.boot.test.autoconfigure.orm.jpa.AutoConfigureTestEntityManager;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.ws.test.server.MockWebServiceClient;\n+import org.springframework.ws.test.server.ResponseMatchers;\n+\n+@SpringBootTest\n+@Transactional\n+@EnableAutoConfiguration(exclude = FlywayAutoConfiguration.class)\n+@AutoConfigureTestDatabase\n+@AutoConfigureTestEntityManager\n+public class SoapServiceSecretManagementIT {\n+\n+    /**\n+     * The AES keys must be configured with the following values:\n+     * db key: hex:1cb340f6edab9d9b3f2912877c9ed161\n+     * soap key: hex:8ff36ab298aa8c240d1bb1185a138fe1\n+     *\n+     * The plantext secrets for meter 'E0054002019112319' are:\n+     *\n+     * hex: 72b8fc276644a60ccefdf219fbee1a49 (E_METER_AUTHENTICATION)\n+     * hex: a3d5883fe56cf12b1a7cb5a686da6064 (E_METER_ENCRYPTION_KEY_UNICAST)\n+     *\n+     * The db-encrypted secrets are: hex:35c6d2af323bd3c4a588692dfcf4235fd20c2bd39bcf8672b6e65d515940150f\n+     * (E_METER_AUTHENTICATION)\n+     * hex:7c737a402bdef7a0819f47ae9b625e2d8531e6c5d7603c4e4982c45175c4e063 (E_METER_ENCRYPTION_KEY_UNICAST)\n+     *\n+     * The soap-encrypted secrets are: hex:74efc062231e81c9e006bb56c5dec38631210c5073511606a203ba748fcdc794\n+     * (E_METER_AUTHENTICATION)\n+     * hex:3dca51832c70e372460796ca01acbab769fd330c9b936246a01d4e97f8c5bc26 (E_METER_ENCRYPTION_KEY_UNICAST)\n+     */\n+\n+    private static final String E_METER_AUTHENTICATION_KEY_ENCRYPTED_FOR_DB =\n+            \"35c6d2af323bd3c4a588692dfcf4235fd20c2bd39bcf8672b6e65d515940150f\";\n+    private static final String E_METER_ENCRYPTION_KEY_UNICAST_ENCRYPTED_FOR_DB =\n+            \"7c737a402bdef7a0819f47ae9b625e2d8531e6c5d7603c4e4982c45175c4e063\";\n+\n+    private static final String DEVICE_IDENTIFICATION = \"E0054002019112319\";\n+\n+    @Autowired\n+    private ApplicationContext applicationContext;\n+\n+    @Autowired\n+    private DbEncryptedSecretRepository secretRepository;\n+\n+    @Autowired\n+    private EntityManager testEntityManager;\n+\n+    private MockWebServiceClient mockWebServiceClient;\n+\n+    @BeforeEach\n+    public void setupTest() {\n+        this.mockWebServiceClient = MockWebServiceClient.createClient(this.applicationContext);\n+        this.createTestData();\n+    }\n+\n+    @Test\n+    public void getSecretsRequest() {\n+\n+        /**\n+         * Note that the output depends, besides the value of the keys, also on both the db key and the soap key.\n+         */\n+        assertThat(this.secretRepository.count()).isEqualTo(2);\n+        final Resource request = new ClassPathResource(\"test-requests/getSecrets.xml\");\n+        final Resource expectedResponse = new ClassPathResource(\"test-responses/getSecrets.xml\");\n+        try {\n+            this.mockWebServiceClient.sendRequest(withPayload(request))/*.andExpect\n+            (ResponseMatchers", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA0MzQwMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444043400", "body": "These @PropertySource annotations must be placed on @SpringBootApplication annotated class due to loading order problems", "bodyText": "These @propertysource annotations must be placed on @SpringBootApplication annotated class due to loading order problems", "bodyHTML": "<p dir=\"auto\">These <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/propertysource/hovercard\" href=\"https://github.com/propertysource\">@propertysource</a> annotations must be placed on <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SpringBootApplication/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SpringBootApplication\">@SpringBootApplication</a> annotated class due to loading order problems</p>", "author": "jboon", "createdAt": "2020-06-23T08:14:06Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/config/ApplicationConfig.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package org.opensmartgridplatform.secretmgmt.application.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n+\n+@Configuration\n+@PropertySource(\"classpath:secret-management.properties\")\n+@PropertySource(value = \"file:${osgp/Global/config}\", ignoreResourceNotFound = true)\n+@PropertySource(value = \"file:${osgp/SecretManagement/config}\", ignoreResourceNotFound = true)", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA0NjU3MA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444046570", "body": "@Slf4j ", "bodyText": "@slf4j", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/slf4j/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/slf4j\">@slf4j</a></p>", "author": "jboon", "createdAt": "2020-06-23T08:19:45Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package org.opensmartgridplatform.secretmgmt.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.OsgpResultType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TechnicalFault;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.secretmgmt.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmgmt.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.exception.TechnicalServiceFaultException;\n+import org.opensmartgridplatform.secretmgmt.application.services.SecretManagementService;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.opensmartgridplatform.secretmgmt.application.config.ApplicationConfig.COMPONENT_NAME;\n+\n+@Endpoint\n+public class SecretManagementEndpoint {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementEndpoint.class);", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA0NzIzMA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444047230", "body": "consider renaming to a more specific name", "bodyText": "consider renaming to a more specific name", "bodyHTML": "<p dir=\"auto\">consider renaming to a more specific name</p>", "author": "coendamen", "createdAt": "2020-06-23T08:20:53Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmgmt/serviceclient/SoapConnector.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.opensmartgridplatform.secretmgmt.serviceclient;\n+\n+import org.springframework.ws.client.core.support.WebServiceGatewaySupport;\n+\n+public class SoapConnector extends WebServiceGatewaySupport {", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA0NzUwOA==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444047508", "body": "callWebService could be more specific. which webservice ?", "bodyText": "callWebService could be more specific. which webservice ?", "bodyHTML": "<p dir=\"auto\">callWebService could be more specific. which webservice ?</p>", "author": "coendamen", "createdAt": "2020-06-23T08:21:21Z", "path": "osgp/platform/osgp-secret-management/src/integration-test/java/org/opensmartgridplatform/secretmgmt/serviceclient/SoapConnector.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.opensmartgridplatform.secretmgmt.serviceclient;\n+\n+import org.springframework.ws.client.core.support.WebServiceGatewaySupport;\n+\n+public class SoapConnector extends WebServiceGatewaySupport {\n+\n+    public Object callWebService(String url, Object request){", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA0OTc2Mg==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444049762", "body": "for an Endpoint, this method contains too much code, consider moving this to a service for better readability, maintenance and testability", "bodyText": "for an Endpoint, this method contains too much code, consider moving this to a service for better readability, maintenance and testability", "bodyHTML": "<p dir=\"auto\">for an Endpoint, this method contains too much code, consider moving this to a service for better readability, maintenance and testability</p>", "author": "coendamen", "createdAt": "2020-06-23T08:24:58Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package org.opensmartgridplatform.secretmgmt.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.OsgpResultType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TechnicalFault;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.secretmgmt.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmgmt.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.exception.TechnicalServiceFaultException;\n+import org.opensmartgridplatform.secretmgmt.application.services.SecretManagementService;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.opensmartgridplatform.secretmgmt.application.config.ApplicationConfig.COMPONENT_NAME;\n+\n+@Endpoint\n+public class SecretManagementEndpoint {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementEndpoint.class);\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement/2020/05\";\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+\n+    private final SecretManagementService secretManagementService;\n+    private final EncryptionProvider jreEncryptionProvider;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService, EncryptionProvider soapSecretEncryptionProvider) {\n+        this.secretManagementService = secretManagementService;\n+        this.jreEncryptionProvider = soapSecretEncryptionProvider;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) {\n+\n+        LOGGER.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        GetSecretsResponse response = new GetSecretsResponse();\n+\n+        try {\n+            SecretTypes soapSecretTypes = request.getSecretTypes();", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1MDExMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444050113", "body": "move code to separate service would improve the maintainability", "bodyText": "move code to separate service would improve the maintainability", "bodyHTML": "<p dir=\"auto\">move code to separate service would improve the maintainability</p>", "author": "coendamen", "createdAt": "2020-06-23T08:25:33Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/endpoints/SecretManagementEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package org.opensmartgridplatform.secretmgmt.application.endpoints;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.GetSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.OsgpResultType;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretTypes;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsRequest;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.StoreSecretsResponse;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TechnicalFault;\n+import org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecrets;\n+import org.opensmartgridplatform.secretmgmt.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmgmt.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.exception.TechnicalServiceFaultException;\n+import org.opensmartgridplatform.secretmgmt.application.services.SecretManagementService;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProvider;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.ws.server.endpoint.annotation.Endpoint;\n+import org.springframework.ws.server.endpoint.annotation.PayloadRoot;\n+import org.springframework.ws.server.endpoint.annotation.RequestPayload;\n+import org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.opensmartgridplatform.secretmgmt.application.config.ApplicationConfig.COMPONENT_NAME;\n+\n+@Endpoint\n+public class SecretManagementEndpoint {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SecretManagementEndpoint.class);\n+\n+    private static final String NAMESPACE_URI = \"http://www.opensmartgridplatform.org/schemas/security/secretmanagement/2020/05\";\n+    private static final String KEY_REFERENCE = \"1\"; //only one key in use\n+\n+    private final SecretManagementService secretManagementService;\n+    private final EncryptionProvider jreEncryptionProvider;\n+\n+    public SecretManagementEndpoint(SecretManagementService secretManagementService, EncryptionProvider soapSecretEncryptionProvider) {\n+        this.secretManagementService = secretManagementService;\n+        this.jreEncryptionProvider = soapSecretEncryptionProvider;\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"getSecretsRequest\")\n+    @ResponsePayload\n+    public GetSecretsResponse getSecretsRequest(@RequestPayload GetSecretsRequest request) {\n+\n+        LOGGER.info(\"Handling incoming SOAP request 'getSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        GetSecretsResponse response = new GetSecretsResponse();\n+\n+        try {\n+            SecretTypes soapSecretTypes = request.getSecretTypes();\n+\n+            if (soapSecretTypes == null) {\n+                throw new TechnicalServiceFaultException(\"Missing input: secret types\");\n+            }\n+\n+            List<org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType> soapSecretTypeList = soapSecretTypes.getSecretType();\n+            List<SecretType> secretTypeList = new ArrayList<>();\n+\n+            for (org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.SecretType soapSecretType: soapSecretTypeList) {\n+                SecretType secretType = convertToSecretType(soapSecretType);\n+                secretTypeList.add(secretType);\n+            }\n+\n+            List<TypedSecret> typedSecrets = secretManagementService.retrieveSecrets(request.getDeviceId(), secretTypeList);\n+            TypedSecrets soapTypedSecrets = new TypedSecrets();\n+\n+            List<org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret> soapTypedSecretList = soapTypedSecrets.getTypedSecret();\n+\n+            for (TypedSecret typedSecret : typedSecrets) {\n+                org.opensmartgridplatform.schemas.security.secretmanagement._2020._05.TypedSecret soapTypedSecret = encryptAndConvertSoapTypedSecret(typedSecret);\n+                soapTypedSecretList.add(soapTypedSecret);\n+            }\n+\n+            response.setTypedSecrets(soapTypedSecrets);\n+            response.setResult(OsgpResultType.OK);\n+\n+            return response;\n+        }\n+        catch (Exception e) {\n+            throw new TechnicalServiceFaultException(e.getMessage(), e, createTechnicalFaultFromException(e));\n+        }\n+    }\n+\n+    @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"storeSecretsRequest\")\n+    @ResponsePayload\n+    public StoreSecretsResponse storeSecretsRequest(@RequestPayload StoreSecretsRequest request) {\n+\n+        LOGGER.info(\"Handling incoming SOAP request 'storeSecretsRequest' for device {}\", request.getDeviceId());\n+\n+        StoreSecretsResponse response = new StoreSecretsResponse();\n+\n+        try {\n+            TypedSecrets soapTypedSecrets = request.getTypedSecrets();", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1NjcxMw==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444056713", "body": "As long as there is no presentation it's fine. Date is an epoch.", "bodyText": "As long as there is no presentation it's fine. Date is an epoch.", "bodyHTML": "<p dir=\"auto\">As long as there is no presentation it's fine. Date is an epoch.</p>", "author": "jboon", "createdAt": "2020-06-23T08:36:00Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/SecretManagementService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package org.opensmartgridplatform.secretmgmt.application.services;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tomcat.util.buf.HexUtils;\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.domain.DbEncryptionKeyReference;\n+import org.opensmartgridplatform.secretmgmt.application.domain.SecretType;\n+import org.opensmartgridplatform.secretmgmt.application.domain.TypedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.repository.DbEncryptedSecretRepository;\n+import org.opensmartgridplatform.secretmgmt.application.repository.DbEncryptionKeyRepository;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptionDelegate;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.providers.EncryptionProviderType;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class SecretManagementService implements SecretManagement {\n+    private final static int FIRST_PAGE = 0;\n+    private final EncryptionDelegate encryptionDelegate;\n+    private final EncryptionProviderType encryptionProviderType;\n+    private final DbEncryptedSecretRepository secretRepository;\n+    private final DbEncryptionKeyRepository keyRepository;\n+\n+    @Autowired\n+    public SecretManagementService(final EncryptionDelegate osgpEncryptionDelegate,\n+            final EncryptionProviderType encryptionProviderType, final DbEncryptedSecretRepository secretRepository,\n+            final DbEncryptionKeyRepository keyRepository) {\n+        this.encryptionDelegate = osgpEncryptionDelegate;\n+        this.encryptionProviderType = encryptionProviderType;\n+        this.secretRepository = secretRepository;\n+        this.keyRepository = keyRepository;\n+    }\n+\n+    @Override\n+    public void storeSecrets(final String deviceIdentification, final List<TypedSecret> secrets) throws Exception {\n+        //@formatter:off\n+        secrets.stream()\n+                .map(t -> this.validateSecret(deviceIdentification, t))\n+                .map(s -> this.createEncrypted(deviceIdentification, s, this.getKey(s)))\n+                .forEach(this.secretRepository::save);\n+        //@formatter:on\n+    }\n+\n+    private DbEncryptionKeyReference getKey(final TypedSecret typedSecret) {\n+        final Date now = new Date(); //TODO: UTC?", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2MDE1OQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444060159", "body": "@slf4j", "bodyText": "@slf4j", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/slf4j/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/slf4j\">@slf4j</a></p>", "author": "jboon", "createdAt": "2020-06-23T08:41:37Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/AbstractEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.EncryptedSecret;\n+import org.opensmartgridplatform.secretmgmt.application.services.encryption.Secret;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import java.io.File;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+import java.util.logging.Logger;\n+\n+public abstract class AbstractEncryptionProvider {\n+\n+    private static final Logger LOGGER = Logger.getLogger(AbstractEncryptionProvider.class.getName());", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA2NTQ1Ng==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r444065456", "body": "byte[] IV = new byte[16];", "bodyText": "byte[] IV = new byte[16];", "bodyHTML": "<p dir=\"auto\">byte[] IV = new byte[16];</p>", "author": "jboon", "createdAt": "2020-06-23T08:50:04Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmgmt/application/services/encryption/providers/HsmEncryptionProvider.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.opensmartgridplatform.secretmgmt.application.services.encryption.providers;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+public class HsmEncryptionProvider extends AbstractEncryptionProvider implements EncryptionProvider {\n+\n+    private static final String ALGORITHM = \"AES/CBC/NoPadding\";\n+    private static final String PROVIDER = \"nCipherKM\";\n+    private static final String TYPE = \"ncipher.sworld\";\n+    private static final byte[] IV = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };", "originalCommit": "e0377bd4adc6c45a4de93764715961fd781a03ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "bea803279342ba056c5d7d1ed440d94d809dd28a", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/bea803279342ba056c5d7d1ed440d94d809dd28a", "message": "SLIM-2253-use-secret-mangement-for-secure-keys-review-comments", "committedDate": "2020-06-23T11:23:58Z", "type": "commit"}, {"oid": "337adf5f2da703835c07416aa92d0079f0f8eb22", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/337adf5f2da703835c07416aa92d0079f0f8eb22", "message": "Code clean up flyway script", "committedDate": "2020-06-23T11:28:11Z", "type": "commit"}, {"oid": "5db6853d3a6cb94355cf81aa52dcafd499fdb5dc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/5db6853d3a6cb94355cf81aa52dcafd499fdb5dc", "message": "Merge branch 'SLIM-2077-Create-new-secret-mgmt-application' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-06-23T11:28:47Z", "type": "commit"}, {"oid": "22c1bda067bf1aebc6c6c54d91e991079cca0ed6", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/22c1bda067bf1aebc6c6c54d91e991079cca0ed6", "message": "Build fix", "committedDate": "2020-06-23T11:33:35Z", "type": "commit"}, {"oid": "f9727419135de5ab1372cf781bf5551ed9be5a28", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f9727419135de5ab1372cf781bf5551ed9be5a28", "message": "SLIM-2253-use-secret-mangement-for-secure-keys-review-comments", "committedDate": "2020-06-23T15:05:35Z", "type": "commit"}, {"oid": "a0b08a9c2c730840e041ce33f971280f883d9c37", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/a0b08a9c2c730840e041ce33f971280f883d9c37", "message": "SLIM-2253-use-secret-mangement-for-secure-keys-review-comments", "committedDate": "2020-06-23T15:40:38Z", "type": "commit"}, {"oid": "1ed3c5e7668045d6846f07c71a4bfc643a65bca7", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/1ed3c5e7668045d6846f07c71a4bfc643a65bca7", "message": "SLIM-2077-Create-new-secret-management-Improved-configuration", "committedDate": "2020-06-29T11:47:11Z", "type": "commit"}, {"oid": "12007bfbdb1ecbe673087489c59bbc2fb1a3fb55", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/12007bfbdb1ecbe673087489c59bbc2fb1a3fb55", "message": "SLIM-2077-Create-new-secret-management-Applied-New-Code-formatting-rules", "committedDate": "2020-06-29T11:55:46Z", "type": "commit"}, {"oid": "55f22ff736d13023e89e4ea789bd8b03a36b5847", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/55f22ff736d13023e89e4ea789bd8b03a36b5847", "message": "SLIM-2077-Create-new-secret-management-application-RandomizedTestKeys", "committedDate": "2020-06-30T09:10:42Z", "type": "commit"}, {"oid": "913bef393dc28d380dfed0041ed3ddb45041bcd4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/913bef393dc28d380dfed0041ed3ddb45041bcd4", "message": "Review comments processed", "committedDate": "2020-06-30T10:10:57Z", "type": "commit"}, {"oid": "0422cdce058532f0245a685f2d2030e78a8dc0d5", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/0422cdce058532f0245a685f2d2030e78a8dc0d5", "message": "SLIM-2077-Create-new-secret-management-review-comments-protocol-adapter", "committedDate": "2020-06-30T17:08:18Z", "type": "commit"}, {"oid": "8426e45af7b1241ef972078ea9996806107c4c6b", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/8426e45af7b1241ef972078ea9996806107c4c6b", "message": "SLIM-2512 exchange the shared secret AES with PKI (RSA)", "committedDate": "2020-07-01T14:46:00Z", "type": "commit"}, {"oid": "18c6cc045b6e20630541b95beff33113587ee28f", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/18c6cc045b6e20630541b95beff33113587ee28f", "message": "SLIM-2077-Create-new-secret-management-moved-encryption-to-shared-implemened-rsa-for-secret-management", "committedDate": "2020-07-02T13:35:07Z", "type": "commit"}, {"oid": "f81cf0f32e2c483a5b4a00808ede8fbe99da07dc", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/f81cf0f32e2c483a5b4a00808ede8fbe99da07dc", "message": "Merge branch 'development' of https://github.com/OSGP/open-smart-grid-platform into SLIM-2077-Create-new-secret-mgmt-application", "committedDate": "2020-07-03T16:00:31Z", "type": "commit"}, {"oid": "41b1e47ec7d78cb700489b512fc7f9e6b7f85d50", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/41b1e47ec7d78cb700489b512fc7f9e6b7f85d50", "message": "SLIM-2512-HSTN - exchange the shared secret AES with PKI (RSA)", "committedDate": "2020-07-06T07:15:52Z", "type": "commit"}, {"oid": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/3aeca558df16a07cbffbd6a90129aac8fa0810c4", "message": "SLIM-2077-improved-exception-handling-separated-soap-schema", "committedDate": "2020-07-06T18:08:58Z", "type": "commit"}, {"oid": "6f3d3f091ca71f541febdf5fd1b07d5eb633ca7d", "url": "https://github.com/OSGP/open-smart-grid-platform/commit/6f3d3f091ca71f541febdf5fd1b07d5eb633ca7d", "message": "SLIM-2077-fix-in-property-name", "committedDate": "2020-07-07T09:48:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyNTYzOQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450825639", "body": "@PropertySource annotations should be placed on Main.class. That class is annotated with @SpringBootApplication and will be loaded before @Configuration annotated classes (which need those properties!)", "bodyText": "@propertysource annotations should be placed on Main.class. That class is annotated with @SpringBootApplication and will be loaded before @configuration annotated classes (which need those properties!)", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/propertysource/hovercard\" href=\"https://github.com/propertysource\">@propertysource</a> annotations should be placed on Main.class. That class is annotated with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SpringBootApplication/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SpringBootApplication\">@SpringBootApplication</a> and will be loaded before <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/configuration/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/configuration\">@configuration</a> annotated classes (which need those properties!)</p>", "author": "jboon", "createdAt": "2020-07-07T12:27:45Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/ApplicationConfig.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n+\n+@Configuration\n+@PropertySource(\"classpath:osgp-secret-management.properties\")\n+@PropertySource(value = \"file:${osgp/Global/config}\", ignoreResourceNotFound = true)\n+@PropertySource(value = \"file:${osgp/SecretManagement/config}\", ignoreResourceNotFound = true)", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyODM5NQ==", "url": "https://github.com/OSGP/open-smart-grid-platform/pull/355#discussion_r450828395", "body": "Use @Value(\"${component.name:OSGP-SECRET-MANAGEMENT}\") to provide default value.\r\nAlso, final fields should be set through constructor only. Best to remove final and I would probably make this field private.", "bodyText": "Use @value(\"${component.name:OSGP-SECRET-MANAGEMENT}\") to provide default value.\nAlso, final fields should be set through constructor only. Best to remove final and I would probably make this field private.", "bodyHTML": "<p dir=\"auto\">Use <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/value/hovercard\" href=\"https://github.com/value\">@value</a>(\"${component.name:OSGP-SECRET-MANAGEMENT}\") to provide default value.<br>\nAlso, final fields should be set through constructor only. Best to remove final and I would probably make this field private.</p>", "author": "jboon", "createdAt": "2020-07-07T12:32:43Z", "path": "osgp/platform/osgp-secret-management/src/main/java/org/opensmartgridplatform/secretmanagement/application/config/ApplicationConfig.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/**\n+ * Copyright 2020 Smart Society Services B.V.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package org.opensmartgridplatform.secretmanagement.application.config;\n+\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n+\n+@Configuration\n+@PropertySource(\"classpath:osgp-secret-management.properties\")\n+@PropertySource(value = \"file:${osgp/Global/config}\", ignoreResourceNotFound = true)\n+@PropertySource(value = \"file:${osgp/SecretManagement/config}\", ignoreResourceNotFound = true)\n+public class ApplicationConfig {\n+    @Value(\"${component.name}\")\n+    public static final String COMPONENT_NAME = \"OSGP-SECRET-MANAGEMENT\";", "originalCommit": "3aeca558df16a07cbffbd6a90129aac8fa0810c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}