{"pr_number": 419, "pr_title": "Cbrune/bfd549 enrollmentdata", "pr_author": "cbrunefearless", "pr_createdAt": "2020-12-09T02:56:36Z", "pr_url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419", "merge_commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "timeline": [{"oid": "0ce3ef170c2cc2457fbee89ec8c57e8f55923626", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/0ce3ef170c2cc2457fbee89ec8c57e8f55923626", "message": "Added enrollment jpa and sql file", "committedDate": "2020-12-01T22:25:30Z", "type": "commit"}, {"oid": "86fe5b2a49cc669ad6085b70fe6ade174bd5613a", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/86fe5b2a49cc669ad6085b70fe6ade174bd5613a", "message": "Changed the primary key", "committedDate": "2020-12-03T14:46:25Z", "type": "commit"}, {"oid": "5df4baead5c5c18f16ba708126bfa9de41fc8e9e", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/5df4baead5c5c18f16ba708126bfa9de41fc8e9e", "message": "Changed my rif loader and sql files around", "committedDate": "2020-12-03T16:17:31Z", "type": "commit"}, {"oid": "92265c5b7b5737530adba2ad130318b1bb916c18", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/92265c5b7b5737530adba2ad130318b1bb916c18", "message": "changed date to yearMonth", "committedDate": "2020-12-04T03:33:26Z", "type": "commit"}, {"oid": "fc3138094524386f146bcbbc020288529eb41302", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/fc3138094524386f146bcbbc020288529eb41302", "message": "Fixed sql", "committedDate": "2020-12-05T01:55:22Z", "type": "commit"}, {"oid": "0cc117cee17cb8c611b8d4c4e1f00a9c17a9f147", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/0cc117cee17cb8c611b8d4c4e1f00a9c17a9f147", "message": "Changed jpa", "committedDate": "2020-12-05T02:12:32Z", "type": "commit"}, {"oid": "960d123bc2d6ee687b077333b498ccd20d80decc", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/960d123bc2d6ee687b077333b498ccd20d80decc", "message": "Added annotation to beneficiary", "committedDate": "2020-12-05T05:32:16Z", "type": "commit"}, {"oid": "a9a73c7ab3c9d359e94847967153f8f4a57f6f88", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/a9a73c7ab3c9d359e94847967153f8f4a57f6f88", "message": "Added code to riflayouts processor", "committedDate": "2020-12-07T16:47:41Z", "type": "commit"}, {"oid": "c73bb129806fa392b210f104fae1811d1581fdf3", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/c73bb129806fa392b210f104fae1811d1581fdf3", "message": "Changed to a different drug code", "committedDate": "2020-12-07T18:50:20Z", "type": "commit"}, {"oid": "47287a150180aa5db990bb5e7e7f100fad2e3415", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/47287a150180aa5db990bb5e7e7f100fad2e3415", "message": "Added function", "committedDate": "2020-12-07T22:25:27Z", "type": "commit"}, {"oid": "b93edb7d449855bd571d005c4ddf5aef616904d3", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/b93edb7d449855bd571d005c4ddf5aef616904d3", "message": "Added code to rif loader to take the different months", "committedDate": "2020-12-08T07:59:08Z", "type": "commit"}, {"oid": "8ea6ce2f202c8e7910d563c0ce7d861f0c795090", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/8ea6ce2f202c8e7910d563c0ce7d861f0c795090", "message": "Added integration tests for new schema", "committedDate": "2020-12-08T21:24:46Z", "type": "commit"}, {"oid": "ffbf7a4dc60e9c92ad4036533387eeca420ad48d", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/ffbf7a4dc60e9c92ad4036533387eeca420ad48d", "message": "Merge branch 'master' into cbrune/BFD549-enrollmentdata", "committedDate": "2020-12-09T02:56:50Z", "type": "commit"}, {"oid": "193a5a91734bd370f5025699d00caf24b47bb77a", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/193a5a91734bd370f5025699d00caf24b47bb77a", "message": "Changed the rif loader to take one record", "committedDate": "2020-12-14T23:20:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzMDczOQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r543630739", "body": "Not sure we want this to be lazy-loaded. Any thoughts?", "bodyText": "Not sure we want this to be lazy-loaded. Any thoughts?", "bodyHTML": "<p dir=\"auto\">Not sure we want this to be lazy-loaded. Any thoughts?</p>", "author": "karlmdavis", "createdAt": "2020-12-15T19:34:52Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -707,6 +982,47 @@ private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOExceptio\n       headerEntityClass.addMethod(childGetter);\n     }\n \n+    // Add the parent-to-child join field and accessor, if appropriate.\n+    if (mappingSpec.getHasEnrollments()) {\n+\n+      ParameterizedTypeName childFieldType =\n+          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getEnrollmentEntity());\n+\n+      FieldSpec.Builder childField =\n+          FieldSpec.builder(childFieldType, \"enrollments\", Modifier.PRIVATE)\n+              .initializer(\"new $T<>()\", LinkedList.class);\n+\n+      childField.addAnnotation(\n+          AnnotationSpec.builder(OneToMany.class)\n+              .addMember(\"mappedBy\", \"$S\", mappingSpec.getEnrollmentEntityParentField())\n+              .addMember(\"orphanRemoval\", \"$L\", true)\n+              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)", "originalCommit": "193a5a91734bd370f5025699d00caf24b47bb77a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5ODkxNw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r543898917", "bodyText": "Eager loaded", "author": "cbrunefearless", "createdAt": "2020-12-16T03:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzMDczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "82433ba67b93b06e00b8e2d9eee064fc8e81b259", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 056b4f23d..4486efd3c 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -996,7 +1055,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n           AnnotationSpec.builder(OneToMany.class)\n               .addMember(\"mappedBy\", \"$S\", mappingSpec.getEnrollmentEntityParentField())\n               .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n+              .addMember(\"fetch\", \"$T.EAGER\", FetchType.class)\n               .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n               .build());\n       childField.addAnnotation(\n", "next_change": {"commit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 4486efd3c..c15bfb93e 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1042,42 +1031,44 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     }\n \n     // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasEnrollments()) {\n+    if (mappingSpec.getHasBeneficiaryMonthly()) {\n \n       ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getEnrollmentEntity());\n+          ParameterizedTypeName.get(\n+              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n \n       FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"enrollments\", Modifier.PRIVATE)\n+          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n               .initializer(\"new $T<>()\", LinkedList.class);\n \n       childField.addAnnotation(\n           AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getEnrollmentEntityParentField())\n+              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n               .addMember(\"orphanRemoval\", \"$L\", true)\n               .addMember(\"fetch\", \"$T.EAGER\", FetchType.class)\n               .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n               .build());\n       childField.addAnnotation(\n           AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityEnrollmentField() + \" ASC\")\n+              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n               .build());\n       headerEntityClass.addField(childField.build());\n \n       MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getEnrollments\")\n+          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n               .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"enrollments\")\n+              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n               .returns(childFieldType)\n               .build();\n       headerEntityClass.addMethod(childGetter);\n \n       MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setEnrollments\")\n+          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n               .addModifiers(Modifier.PUBLIC)\n               .returns(void.class)\n-              .addParameter(childFieldType, \"enrollments\")\n-              .addStatement(\"this.$N = ($T)$N\", \"enrollments\", childFieldType, \"enrollments\")\n+              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n+              .addStatement(\n+                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n               .build();\n       headerEntityClass.addMethod(childSetter);\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 056b4f23d..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -983,42 +1031,44 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     }\n \n     // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasEnrollments()) {\n+    if (mappingSpec.getHasBeneficiaryMonthly()) {\n \n       ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getEnrollmentEntity());\n+          ParameterizedTypeName.get(\n+              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n \n       FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"enrollments\", Modifier.PRIVATE)\n+          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n               .initializer(\"new $T<>()\", LinkedList.class);\n \n       childField.addAnnotation(\n           AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getEnrollmentEntityParentField())\n+              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n               .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n+              .addMember(\"fetch\", \"$T.EAGER\", FetchType.class)\n               .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n               .build());\n       childField.addAnnotation(\n           AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityEnrollmentField() + \" ASC\")\n+              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n               .build());\n       headerEntityClass.addField(childField.build());\n \n       MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getEnrollments\")\n+          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n               .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"enrollments\")\n+              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n               .returns(childFieldType)\n               .build();\n       headerEntityClass.addMethod(childGetter);\n \n       MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setEnrollments\")\n+          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n               .addModifiers(Modifier.PUBLIC)\n               .returns(void.class)\n-              .addParameter(childFieldType, \"enrollments\")\n-              .addStatement(\"this.$N = ($T)$N\", \"enrollments\", childFieldType, \"enrollments\")\n+              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n+              .addStatement(\n+                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n               .build();\n       headerEntityClass.addMethod(childSetter);\n     }\n", "next_change": {"commit": "28cfe6ac219cb819818e78a10c46e9464754bf39", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..17a657520 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1073,6 +1144,35 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n       headerEntityClass.addMethod(childSetter);\n     }\n \n+    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n+    if (mappingSpec.isBeneficiaryEntity()) {\n+      ParameterizedTypeName childFieldType =\n+          ParameterizedTypeName.get(\n+              ClassName.get(Set.class),\n+              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n+\n+      FieldSpec.Builder childField =\n+          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n+              .initializer(\"new $T<>()\", HashSet.class);\n+\n+      childField.addAnnotation(\n+          AnnotationSpec.builder(OneToMany.class)\n+              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n+              .addMember(\"orphanRemoval\", \"$L\", false)\n+              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n+              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n+              .build());\n+      headerEntityClass.addField(childField.build());\n+\n+      MethodSpec childGetter =\n+          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n+              .addModifiers(Modifier.PUBLIC)\n+              .addStatement(\"return $N\", \"skippedRifRecords\")\n+              .returns(childFieldType)\n+              .build();\n+      headerEntityClass.addMethod(childGetter);\n+    }\n+\n     // Add the parent-to-child join field and accessor for an inner join\n     // relationship\n     if (mappingSpec.getHasInnerJoinRelationship()) {\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex 17a657520..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2169 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = false;\n-\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes() */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion() */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) spreadsheetWorkbook.close();\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(parentBeneficiaryIdFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make\n-    // it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(rifField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-        // Handle a String field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1) {\n-        // Handle a Character field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) > 0) {\n-        // Handle a Decimal field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Used in {@link #calculateCsvColumns(List<FieldSpec>, MappingSpec)} and generates the\n-   * field-to-CSV-value header.\n-   *\n-   * @param fields {@link List<FieldSpec>} to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * @param List<String> the {@link RifField} to create an additional Annotated database field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * @param rifField <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n-      return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n-      return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n-      return ClassName.get(BigDecimal.class);\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzMjczOQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r543632739", "body": "Can the pre-existing `selectJavaFieldType(...)` and `selectJavaPropertyType(...)` methods be refactored to call these under the hood? If so, we should definitely do that, to cut down on maintenance reqs.", "bodyText": "Can the pre-existing selectJavaFieldType(...) and selectJavaPropertyType(...) methods be refactored to call these under the hood? If so, we should definitely do that, to cut down on maintenance reqs.", "bodyHTML": "<p dir=\"auto\">Can the pre-existing <code>selectJavaFieldType(...)</code> and <code>selectJavaPropertyType(...)</code> methods be refactored to call these under the hood? If so, we should definitely do that, to cut down on maintenance reqs.</p>", "author": "karlmdavis", "createdAt": "2020-12-15T19:38:02Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1819,157 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  private static void createEnrollmentFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      TypeName fieldType,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createEnrollmentAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  private static List<AnnotationSpec> createEnrollmentAnnotations(\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+\n+    // Add an @Id annotation, if appropriate.\n+    if (isId) {\n+      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n+      annotations.add(idAnnotation.build());\n+    }\n+    // Add an @Column annotation to every non-transient column.\n+    if (!isTransient) {\n+      AnnotationSpec.Builder columnAnnotation =\n+          AnnotationSpec.builder(Column.class)\n+              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n+              .addMember(\"nullable\", \"$L\", isColumnOptional);\n+      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n+        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n+      } else if (type == RifColumnType.NUM) {\n+        /*\n+         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         */\n+\n+        if (columnLength.isPresent() && columnScale.isPresent()) {\n+          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n+          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n+        } else {\n+          /*\n+           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+           * handle SQL numeric datatypes that don't have a defined precision and scale.\n+           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+           * but what it does instead is insert a default precision and scale as\n+           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+           * (for different reasons), but fortunately that doesn't happen to cause\n+           * problems with our tests.\n+           */\n+          StringBuilder columnDefinition = new StringBuilder();\n+          columnDefinition.append(\"numeric\");\n+          if (columnLength.isPresent() || columnScale.isPresent()) {\n+            columnDefinition.append('(');\n+            if (columnLength.isPresent()) {\n+              columnDefinition.append(columnLength.get());\n+            }\n+            if (columnScale.isPresent()) {\n+              columnDefinition.append(\", \");\n+              columnDefinition.append(columnScale.get());\n+            }\n+            columnDefinition.append(')');\n+          }\n+          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+        }\n+      }\n+      annotations.add(columnAnnotation.build());\n+    } else {\n+      annotations.add(AnnotationSpec.builder(Transient.class).build());\n+    }\n+\n+    return annotations;\n+  }\n+\n+  private static TypeName selectJavaFieldType(\n+      RifColumnType type,\n+      boolean isColumnOptional,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    if (type == RifColumnType.CHAR\n+        && columnLength.orElse(Integer.MAX_VALUE) == 1\n+        && !isColumnOptional) return TypeName.CHAR;\n+    else if (type == RifColumnType.CHAR\n+        && columnLength.orElse(Integer.MAX_VALUE) == 1\n+        && isColumnOptional) return ClassName.get(Character.class);\n+    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n+    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+      return ClassName.get(LocalDate.class);\n+    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+      return ClassName.get(Instant.class);\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+      return ClassName.get(BigDecimal.class);\n+    else if (type == RifColumnType.NUM\n+        && columnScale.orElse(Integer.MAX_VALUE) == 0\n+        && !isColumnOptional) return TypeName.INT;\n+    else if (type == RifColumnType.NUM\n+        && columnScale.orElse(Integer.MAX_VALUE) == 0\n+        && isColumnOptional) return ClassName.get(Integer.class);\n+    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+  }\n+\n+  private static TypeName selectJavaPropertyType(\n+      RifColumnType type,\n+      boolean isColumnOptional,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    if (!isColumnOptional)\n+      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n+    else\n+      return ParameterizedTypeName.get(\n+          ClassName.get(Optional.class),\n+          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n+  }", "originalCommit": "193a5a91734bd370f5025699d00caf24b47bb77a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU3NTQxNg==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r544575416", "bodyText": "yes done..", "author": "cbrunefearless", "createdAt": "2020-12-16T19:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzMjczOQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex 056b4f23d..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,1975 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Temporal;\n-import javax.persistence.TemporalType;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes() */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion() */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"Beneficiaries\")\n-              .setHeaderEntityIdField(\"beneficiaryId\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"hicnUnhashed\", \"mbiHash\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setHasLines(false)\n-              .setHasEnrollments(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"BeneficiariesHistory\")\n-              .setHeaderEntityGeneratedIdField(\"beneficiaryHistoryId\")\n-              .setHeaderEntityTransientFields(\n-                  \"stateCode\",\n-                  \"countyCode\",\n-                  \"postalCode\",\n-                  \"race\",\n-                  \"entitlementCodeOriginal\",\n-                  \"entitlementCodeCurrent\",\n-                  \"endStageRenalDiseaseCode\",\n-                  \"medicareEnrollmentStatusCode\",\n-                  \"partATerminationCode\",\n-                  \"partBTerminationCode\",\n-                  \"nameSurname\",\n-                  \"nameGiven\",\n-                  \"nameMiddleInitial\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"hicnUnhashed\", \"mbiHash\")))\n-              .setHasLines(false)\n-              .setHasEnrollments(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderEntityIdField(\"medicareBeneficiaryIdKey\")\n-              .setHasLines(false)\n-              .setHasEnrollments(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"PartDEvents\")\n-              .setHeaderEntityIdField(\"eventId\")\n-              .setHasLines(false)\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"CarrierClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"CarrierClaimLines\")\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"InpatientClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"InpatientClaimLines\")\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"OutpatientClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"OutpatientClaimLines\")\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"HHAClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"HHAClaimLines\")\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"DMEClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"DMEClaimLines\")\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"HospiceClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"HospiceClaimLines\")\n-              .setHasEnrollments(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"SNFClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"SNFClaimLines\")\n-              .setHasEnrollments(false));\n-    } finally {\n-      if (spreadsheetWorkbook != null) spreadsheetWorkbook.close();\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'.\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) generateCode(mappingSpec);\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    logNote(\"Generated code for %s\", mappingSpec.getRifLayout().getName());\n-\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity = Optional.empty();\n-    if (mappingSpec.getHasLines()) {\n-      lineEntity = Optional.of(generateLineEntity(mappingSpec));\n-    }\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.getHasEnrollments()) {\n-      generateEnrollmentEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", \"`\" + mappingSpec.getLineTable() + \"`\")\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // Add a field to that @IdClass for the parent claim's ID.\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(f -> mappingSpec.getHeaderEntityIdField().equals(f.getJavaFieldName()))\n-            .findAny()\n-            .get();\n-    TypeName parentClaimIdFieldType = selectJavaFieldType(parentClaimRifField);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(\n-            parentClaimIdFieldType, mappingSpec.getLineEntityParentField(), Modifier.PRIVATE);\n-    lineIdClass.addField(parentIdField.build());\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", mappingSpec.getLineEntityParentField())\n-            .returns(parentClaimIdFieldType);\n-    lineIdClass.addMethod(parentGetter.build());\n-\n-    // Add a field to that @IdClass class for the line number.\n-    RifField rifLineNumberField =\n-        rifLayout.getRifFields().stream()\n-            .filter(f -> f.getJavaFieldName().equals(mappingSpec.getLineEntityLineNumberField()))\n-            .findFirst()\n-            .get();\n-    TypeName lineNumberFieldType = selectJavaFieldType(rifLineNumberField);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, mappingSpec.getLineEntityLineNumberField(), Modifier.PRIVATE);\n-    lineIdClass.addField(lineNumberIdField.build());\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"get\" + capitalize(mappingSpec.getLineEntityLineNumberField()))\n-            .addStatement(\"return $N\", mappingSpec.getLineEntityLineNumberField())\n-            .returns(lineNumberFieldType);\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(\n-                mappingSpec.getHeaderEntity(),\n-                mappingSpec.getLineEntityParentField(),\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"`\" + mappingSpec.getLineEntityParentField() + \"`\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                            \"%s_%s_to_%s\",\n-                            mappingSpec.getLineTable(),\n-                            mappingSpec.getLineEntityParentField(),\n-                            mappingSpec.getHeaderTable()))\n-                    .build())\n-            .build();\n-    lineEntity.addField(parentClaimField);\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", mappingSpec.getLineEntityParentField())\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(rifField), rifField.getJavaFieldName(), Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(selectJavaPropertyType(rifField));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(selectJavaPropertyType(rifField), lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  private TypeSpec generateEnrollmentEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"`Enrollments`\").build();\n-    TypeSpec.Builder enrollmentEntity =\n-        TypeSpec.classBuilder(\"Enrollment\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"Enrollment\")\n-                            .nestedClass(\"EnrollmentId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder enrollmentIdClass =\n-        TypeSpec.classBuilder(\"EnrollmentId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    enrollmentIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentClaimIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, \"parentBeneficiary\", Modifier.PRIVATE);\n-    enrollmentIdClass.addField(parentIdField.build());\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return $N\", \"parentBeneficiary\")\n-            .returns(parentClaimIdFieldType);\n-    enrollmentIdClass.addMethod(parentGetter.build());\n-    // Add a field to that @IdClass class for the line number.\n-\n-    TypeName lineNumberFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(lineNumberFieldType, \"yearMonth\", Modifier.PRIVATE);\n-    enrollmentIdClass.addField(lineNumberIdField.build());\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"get\" + capitalize(\"yearMonth\"))\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(lineNumberFieldType);\n-    enrollmentIdClass.addMethod(lineNumberGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    enrollmentIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    enrollmentIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getEnrollmentEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    enrollmentEntity.addType(enrollmentIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                \"parentBeneficiary\",\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"`parentBeneficiary`\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                            \"%s_%s_to_%s\", \"Enrollments\", \"parentBeneficiary\", \"Beneficiary\"))\n-                    .build())\n-            .build();\n-    enrollmentEntity.addField(parentClaimField);\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", \"parentBeneficiary\")\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    enrollmentEntity.addMethod(parentClaimGetter);\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentClaimField.name);\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    enrollmentEntity.addMethod(parentClaimSetter.build());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        true,\n-        false,\n-        false,\n-        TypeName.CHAR,\n-        \"yearMonth\",\n-        RifColumnType.CHAR,\n-        Optional.of(7),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"fipsStateCntyCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(5),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"medicareStatusCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(2),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"entitlementBuyInInd\",\n-        RifColumnType.CHAR,\n-        Optional.of(1),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"hmoIndicatorInd\",\n-        RifColumnType.CHAR,\n-        Optional.of(1),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partCContractNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(5),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partCPbpNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partCPlanTypeCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partDContractNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(5),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partDPbpNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partDSegmentNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partDRetireeDrugSubsidyInd\",\n-        RifColumnType.CHAR,\n-        Optional.of(1),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"medicaidDualEligibilityCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(2),\n-        Optional.empty());\n-\n-    createEnrollmentFields(\n-        enrollmentEntity,\n-        false,\n-        false,\n-        true,\n-        TypeName.CHAR,\n-        \"partDLowIncomeCostShareGroupCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(2),\n-        Optional.empty());\n-\n-    TypeSpec enrollmentEntityFinal = enrollmentEntity.build();\n-    JavaFile enrollmentEntityClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", enrollmentEntityFinal).build();\n-    enrollmentEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return enrollmentEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", \"`\" + mappingSpec.getHeaderTable() + \"`\")\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\n-                  \"name\",\n-                  \"$S\",\n-                  String.format(\"`%s`\", mappingSpec.getHeaderEntityGeneratedIdField()))\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-      String sequenceName =\n-          String.format(\n-              \"%s_%s_seq\",\n-              mappingSpec.getHeaderEntity().simpleName(),\n-              mappingSpec.getHeaderEntityGeneratedIdField());\n-      /*\n-       * FIXME For consistency, sequence names should be mixed-case, but can't be, due\n-       * to https://hibernate.atlassian.net/browse/HHH-9431.\n-       */\n-      sequenceName = sequenceName.toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    for (int fieldIndex = 0;\n-        fieldIndex <= mappingSpec.calculateLastHeaderFieldIndex();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(rifField), rifField.getJavaFieldName(), Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(selectJavaPropertyType(rifField));\n-      addGetterStatement(rifField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(selectJavaPropertyType(rifField), headerField.name);\n-      addSetterStatement(rifField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(addlDatabaseField),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(selectJavaPropertyType(addlDatabaseField));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(selectJavaPropertyType(addlDatabaseField), headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasEnrollments()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getEnrollmentEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"enrollments\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getEnrollmentEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityEnrollmentField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getEnrollments\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"enrollments\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setEnrollments\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"enrollments\")\n-              .addStatement(\"this.$N = ($T)$N\", \"enrollments\", childFieldType, \"enrollments\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-\n-    // Add a lastUpdated field.\n-    final FieldSpec lastUpdatedField =\n-        FieldSpec.builder(Date.class, \"lastUpdated\", Modifier.PRIVATE)\n-            .addAnnotation(\n-                AnnotationSpec.builder(Temporal.class)\n-                    .addMember(\"value\", \"$T.TIMESTAMP\", TemporalType.class)\n-                    .build())\n-            .build();\n-    headerEntityClass.addField(lastUpdatedField);\n-\n-    // Getter method\n-    final MethodSpec lastUpdatedGetter =\n-        MethodSpec.methodBuilder(\"getLastUpdated\")\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return Optional.ofNullable(lastUpdated)\")\n-            .returns(ParameterizedTypeName.get(Optional.class, Date.class))\n-            .build();\n-    headerEntityClass.addMethod(lastUpdatedGetter);\n-\n-    // Setter method which is useful for testing, but not needed in the main modules\n-    final MethodSpec lastUpdatedSetter =\n-        MethodSpec.methodBuilder(\"setLastUpdated\")\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(ParameterSpec.builder(Date.class, \"lastUpdated\").build())\n-            .addStatement(\"this.lastUpdated = lastUpdated\")\n-            .returns(TypeName.VOID)\n-            .build();\n-    headerEntityClass.addMethod(lastUpdatedSetter);\n-\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (mappingSpec.getHasLines() && fieldIndex == mappingSpec.calculateFirstLineFieldIndex()) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equals(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= mappingSpec.calculateFirstLineFieldIndex()) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-        // Handle a String field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1) {\n-        // Handle a Character field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) > 0) {\n-        // Handle a Decimal field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-    String headerColumnsList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> \"\\\"\" + f.name + \"\\\"\")\n-            .collect(Collectors.joining(\", \"));\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-      String lineColumnsList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(f -> \"\\\"\" + f.name + \"\\\"\")\n-              .collect(Collectors.joining(\", \"));\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getLineEntityParentField()))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityIdField()))\n-              .findAny()\n-              .get();\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder code = new StringBuilder();\n-    code.append(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField));\n-      code.append(\"().\");\n-      code.append(calculateGetterName(headerIdField));\n-      code.append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field));\n-      code.append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field));\n-      code.append(\"()\");\n-    }\n-\n-    return code.toString();\n-  }\n-\n-  /**\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to select the corresponding Java type for\n-   * @return the {@link TypeName} of the Java type that should be used to represent the specified\n-   *     {@link RifField} in a JPA entity\n-   */\n-  private static TypeName selectJavaFieldType(RifField rifField) {\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1\n-        && !rifField.isRifColumnOptional()) return TypeName.CHAR;\n-    else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1\n-        && rifField.isRifColumnOptional()) return ClassName.get(Character.class);\n-    else if (rifField.getRifColumnType() == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (rifField.getRifColumnType() == RifColumnType.DATE\n-        && rifField.getRifColumnLength().orElse(0) == 8) return ClassName.get(LocalDate.class);\n-    else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP\n-        && rifField.getRifColumnLength().orElse(0) == 20) return ClassName.get(Instant.class);\n-    else if (rifField.getRifColumnType() == RifColumnType.NUM\n-        && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) > 0)\n-      return ClassName.get(BigDecimal.class);\n-    else if (rifField.getRifColumnType() == RifColumnType.NUM\n-        && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0\n-        && !rifField.isRifColumnOptional()) return TypeName.INT;\n-    else if (rifField.getRifColumnType() == RifColumnType.NUM\n-        && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0\n-        && rifField.isRifColumnOptional()) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + rifField);\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to select the corresponding Java getter/setter type for\n-   * @return the {@link TypeName} of the Java type that should be used to represent the specified\n-   *     {@link RifField}'s getter/setter in a JPA entity\n-   */\n-  private static TypeName selectJavaPropertyType(RifField rifField) {\n-    if (!rifField.isRifColumnOptional()) return selectJavaFieldType(rifField);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class), selectJavaFieldType(rifField));\n-  }\n-\n-  /**\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getJavaFieldName().equals(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField.getJavaFieldName().equals(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getJavaFieldName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", \"`\" + rifField.getJavaFieldName() + \"`\")\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * @param List<String> the {@link RifField} to create an additional Annotated database field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"hicnUnhashed\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"BENE_CRNT_HIC_NUM\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"benecrnthicnum\"),\n-                \"BENE_CRNT_HIC_NUM\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"mbiHash\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_NUM\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_NUM\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    if (entityField.type.equals(TypeName.BOOLEAN)\n-        || entityField.type.equals(ClassName.get(Boolean.class)))\n-      return \"is\" + capitalize(entityField.name);\n-    else return \"get\" + capitalize(entityField.name);\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) entityGetter.addStatement(\"return $N\", entityField);\n-    else entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(entityField.name);\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * @param rifField <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    else entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-  }\n-\n-  /**\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    char first = name.charAt(0);\n-    return String.format(\"%s%s\", Character.toUpperCase(first), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  private static void createEnrollmentFields(\n-      TypeSpec.Builder lineEntity,\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      TypeName fieldType,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    FieldSpec lineField =\n-        FieldSpec.builder(\n-                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n-                fieldName,\n-                Modifier.PRIVATE)\n-            .addAnnotations(\n-                createEnrollmentAnnotations(\n-                    isId,\n-                    isTransient,\n-                    isColumnOptional,\n-                    fieldName,\n-                    type,\n-                    columnLength,\n-                    columnScale))\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n-    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n-                lineField.name);\n-    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  private static List<AnnotationSpec> createEnrollmentAnnotations(\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every non-transient column.\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n-              .addMember(\"nullable\", \"$L\", isColumnOptional);\n-      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n-      } else if (type == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (columnLength.isPresent() && columnScale.isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (columnLength.isPresent() || columnScale.isPresent()) {\n-            columnDefinition.append('(');\n-            if (columnLength.isPresent()) {\n-              columnDefinition.append(columnLength.get());\n-            }\n-            if (columnScale.isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(columnScale.get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n-      return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n-      return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n-      return ClassName.get(BigDecimal.class);\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNjI1OQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r543636259", "body": "I think this will overwrite **all** enrollment records, instead of just the current year's won't it? If you want to avoid that, you need to merge the new/current records into the existing list, avoiding duplicates (which would likely cause PK errors).\r\n\r\nMore importantly, if this wasn't caught by your tests, then I think you need more ITs to ensure that all of this is actually accomplishing the thing we need it to.", "bodyText": "I think this will overwrite all enrollment records, instead of just the current year's won't it? If you want to avoid that, you need to merge the new/current records into the existing list, avoiding duplicates (which would likely cause PK errors).\nMore importantly, if this wasn't caught by your tests, then I think you need more ITs to ensure that all of this is actually accomplishing the thing we need it to.", "bodyHTML": "<p dir=\"auto\">I think this will overwrite <strong>all</strong> enrollment records, instead of just the current year's won't it? If you want to avoid that, you need to merge the new/current records into the existing list, avoiding duplicates (which would likely cause PK errors).</p>\n<p dir=\"auto\">More importantly, if this wasn't caught by your tests, then I think you need more ITs to ensure that all of this is actually accomplishing the thing we need it to.</p>", "author": "karlmdavis", "createdAt": "2020-12-15T19:43:35Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java", "diffHunk": "@@ -596,6 +616,240 @@ private void processAsync(\n     }\n   }\n \n+  /**\n+   * Ensures that a {@link Enrollment} record is created or updated for the specified {@link\n+   * Beneficiary}, if that {@link Beneficiary} already exists and is just being updated.\n+   *\n+   * @param entityManager the {@link EntityManager} to use\n+   * @param loadAction the {@link Loadaction} record being processed\n+   * @param beneficiaryRecord the {@link Beneficiary} record being processed\n+   */\n+  private static void updateEnrollment(EntityManager entityManager, Beneficiary beneficiaryRecord) {\n+\n+    if (beneficiaryRecord.getBeneEnrollmentReferenceYear().isPresent()) {\n+      String date = beneficiaryRecord.getBeneEnrollmentReferenceYear().get().toString();\n+      List<Enrollment> enrollments = new LinkedList<Enrollment>();\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"01\"),\n+              beneficiaryRecord.getEntitlementBuyInJanInd(),\n+              beneficiaryRecord.getFipsStateCntyJanCode(),\n+              beneficiaryRecord.getHmoIndicatorJanInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJanCode(),\n+              beneficiaryRecord.getMedicareStatusJanCode(),\n+              beneficiaryRecord.getPartCContractNumberJanId(),\n+              beneficiaryRecord.getPartCPbpNumberJanId(),\n+              beneficiaryRecord.getPartCPlanTypeJanCode(),\n+              beneficiaryRecord.getPartDContractNumberJanId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJanCode(),\n+              beneficiaryRecord.getPartDPbpNumberJanId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJanInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJanId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"02\"),\n+              beneficiaryRecord.getEntitlementBuyInFebInd(),\n+              beneficiaryRecord.getFipsStateCntyFebCode(),\n+              beneficiaryRecord.getHmoIndicatorFebInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityFebCode(),\n+              beneficiaryRecord.getMedicareStatusFebCode(),\n+              beneficiaryRecord.getPartCContractNumberFebId(),\n+              beneficiaryRecord.getPartCPbpNumberFebId(),\n+              beneficiaryRecord.getPartCPlanTypeFebCode(),\n+              beneficiaryRecord.getPartDContractNumberFebId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupFebCode(),\n+              beneficiaryRecord.getPartDPbpNumberFebId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyFebInd(),\n+              beneficiaryRecord.getPartDSegmentNumberFebId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"03\"),\n+              beneficiaryRecord.getEntitlementBuyInMarInd(),\n+              beneficiaryRecord.getFipsStateCntyMarCode(),\n+              beneficiaryRecord.getHmoIndicatorMarInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityMarCode(),\n+              beneficiaryRecord.getMedicareStatusMarCode(),\n+              beneficiaryRecord.getPartCContractNumberMarId(),\n+              beneficiaryRecord.getPartCPbpNumberMarId(),\n+              beneficiaryRecord.getPartCPlanTypeMarCode(),\n+              beneficiaryRecord.getPartDContractNumberMarId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupMarCode(),\n+              beneficiaryRecord.getPartDPbpNumberMarId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyMarInd(),\n+              beneficiaryRecord.getPartDSegmentNumberMarId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"04\"),\n+              beneficiaryRecord.getEntitlementBuyInAprInd(),\n+              beneficiaryRecord.getFipsStateCntyAprCode(),\n+              beneficiaryRecord.getHmoIndicatorAprInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityAprCode(),\n+              beneficiaryRecord.getMedicareStatusAprCode(),\n+              beneficiaryRecord.getPartCContractNumberAprId(),\n+              beneficiaryRecord.getPartCPbpNumberAprId(),\n+              beneficiaryRecord.getPartCPlanTypeAprCode(),\n+              beneficiaryRecord.getPartDContractNumberAprId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupAprCode(),\n+              beneficiaryRecord.getPartDPbpNumberAprId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyAprInd(),\n+              beneficiaryRecord.getPartDSegmentNumberAprId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"05\"),\n+              beneficiaryRecord.getEntitlementBuyInMayInd(),\n+              beneficiaryRecord.getFipsStateCntyMayCode(),\n+              beneficiaryRecord.getHmoIndicatorMayInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityMayCode(),\n+              beneficiaryRecord.getMedicareStatusMayCode(),\n+              beneficiaryRecord.getPartCContractNumberMayId(),\n+              beneficiaryRecord.getPartCPbpNumberMayId(),\n+              beneficiaryRecord.getPartCPlanTypeMayCode(),\n+              beneficiaryRecord.getPartDContractNumberMayId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupMayCode(),\n+              beneficiaryRecord.getPartDPbpNumberMayId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyMayInd(),\n+              beneficiaryRecord.getPartDSegmentNumberMayId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"06\"),\n+              beneficiaryRecord.getEntitlementBuyInJunInd(),\n+              beneficiaryRecord.getFipsStateCntyJunCode(),\n+              beneficiaryRecord.getHmoIndicatorJunInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJunCode(),\n+              beneficiaryRecord.getMedicareStatusJunCode(),\n+              beneficiaryRecord.getPartCContractNumberJunId(),\n+              beneficiaryRecord.getPartCPbpNumberJunId(),\n+              beneficiaryRecord.getPartCPlanTypeJunCode(),\n+              beneficiaryRecord.getPartDContractNumberJunId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJunCode(),\n+              beneficiaryRecord.getPartDPbpNumberJunId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJunInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJunId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"07\"),\n+              beneficiaryRecord.getEntitlementBuyInJulInd(),\n+              beneficiaryRecord.getFipsStateCntyJulCode(),\n+              beneficiaryRecord.getHmoIndicatorJulInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJulCode(),\n+              beneficiaryRecord.getMedicareStatusJulCode(),\n+              beneficiaryRecord.getPartCContractNumberJulId(),\n+              beneficiaryRecord.getPartCPbpNumberJulId(),\n+              beneficiaryRecord.getPartCPlanTypeJulCode(),\n+              beneficiaryRecord.getPartDContractNumberJulId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJulCode(),\n+              beneficiaryRecord.getPartDPbpNumberJulId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJulInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJulId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"08\"),\n+              beneficiaryRecord.getEntitlementBuyInAugInd(),\n+              beneficiaryRecord.getFipsStateCntyAugCode(),\n+              beneficiaryRecord.getHmoIndicatorAugInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityAugCode(),\n+              beneficiaryRecord.getMedicareStatusAugCode(),\n+              beneficiaryRecord.getPartCContractNumberAugId(),\n+              beneficiaryRecord.getPartCPbpNumberAugId(),\n+              beneficiaryRecord.getPartCPlanTypeAugCode(),\n+              beneficiaryRecord.getPartDContractNumberAugId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupAugCode(),\n+              beneficiaryRecord.getPartDPbpNumberAugId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyAugInd(),\n+              beneficiaryRecord.getPartDSegmentNumberAugId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"09\"),\n+              beneficiaryRecord.getEntitlementBuyInSeptInd(),\n+              beneficiaryRecord.getFipsStateCntySeptCode(),\n+              beneficiaryRecord.getHmoIndicatorSeptInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilitySeptCode(),\n+              beneficiaryRecord.getMedicareStatusSeptCode(),\n+              beneficiaryRecord.getPartCContractNumberSeptId(),\n+              beneficiaryRecord.getPartCPbpNumberSeptId(),\n+              beneficiaryRecord.getPartCPlanTypeSeptCode(),\n+              beneficiaryRecord.getPartDContractNumberSeptId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupSeptCode(),\n+              beneficiaryRecord.getPartDPbpNumberSeptId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidySeptInd(),\n+              beneficiaryRecord.getPartDSegmentNumberSeptId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"10\"),\n+              beneficiaryRecord.getEntitlementBuyInOctInd(),\n+              beneficiaryRecord.getFipsStateCntyOctCode(),\n+              beneficiaryRecord.getHmoIndicatorOctInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityOctCode(),\n+              beneficiaryRecord.getMedicareStatusOctCode(),\n+              beneficiaryRecord.getPartCContractNumberOctId(),\n+              beneficiaryRecord.getPartCPbpNumberOctId(),\n+              beneficiaryRecord.getPartCPlanTypeOctCode(),\n+              beneficiaryRecord.getPartDContractNumberOctId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupOctCode(),\n+              beneficiaryRecord.getPartDPbpNumberOctId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyOctInd(),\n+              beneficiaryRecord.getPartDSegmentNumberOctId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"11\"),\n+              beneficiaryRecord.getEntitlementBuyInNovInd(),\n+              beneficiaryRecord.getFipsStateCntyNovCode(),\n+              beneficiaryRecord.getHmoIndicatorNovInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityNovCode(),\n+              beneficiaryRecord.getMedicareStatusNovCode(),\n+              beneficiaryRecord.getPartCContractNumberNovId(),\n+              beneficiaryRecord.getPartCPbpNumberNovId(),\n+              beneficiaryRecord.getPartCPlanTypeNovCode(),\n+              beneficiaryRecord.getPartDContractNumberNovId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupNovCode(),\n+              beneficiaryRecord.getPartDPbpNumberNovId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyNovInd(),\n+              beneficiaryRecord.getPartDSegmentNumberNovId()));\n+\n+      enrollments.add(\n+          getEnrollment(\n+              beneficiaryRecord,\n+              String.format(\"%s-%s\", date, \"12\"),\n+              beneficiaryRecord.getEntitlementBuyInDecInd(),\n+              beneficiaryRecord.getFipsStateCntyDecCode(),\n+              beneficiaryRecord.getHmoIndicatorDecInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityDecCode(),\n+              beneficiaryRecord.getMedicareStatusDecCode(),\n+              beneficiaryRecord.getPartCContractNumberDecId(),\n+              beneficiaryRecord.getPartCPbpNumberDecId(),\n+              beneficiaryRecord.getPartCPlanTypeDecCode(),\n+              beneficiaryRecord.getPartDContractNumberDecId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupDecCode(),\n+              beneficiaryRecord.getPartDPbpNumberDecId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyDecInd(),\n+              beneficiaryRecord.getPartDSegmentNumberDecId()));\n+\n+      beneficiaryRecord.setEnrollments(enrollments);", "originalCommit": "193a5a91734bd370f5025699d00caf24b47bb77a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5ODY4OA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r543898688", "bodyText": "Yea Changed the logic and adding more IT's", "author": "cbrunefearless", "createdAt": "2020-12-16T03:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNjI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "312dc84b400dbbbdaf26a3f66eaee3339c8ea621", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 9357b7770..590b43ee7 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -844,9 +889,25 @@ public final class RifLoader implements AutoCloseable {\n               beneficiaryRecord.getPartDLowIncomeCostShareGroupDecCode(),\n               beneficiaryRecord.getPartDPbpNumberDecId(),\n               beneficiaryRecord.getPartDRetireeDrugSubsidyDecInd(),\n-              beneficiaryRecord.getPartDSegmentNumberDecId()));\n+              beneficiaryRecord.getPartDSegmentNumberDecId());\n \n-      beneficiaryRecord.setEnrollments(enrollments);\n+      if (enrollmentMonthly != null) {\n+        currentYearEnrollments.add(enrollmentMonthly);\n+      }\n+\n+      if (currentYearEnrollments.size() >= 1) {\n+        List<Enrollment> currentYearEnrollmentsPrevious =\n+            beneficiaryRecord.getEnrollments().stream()\n+                .filter(e -> e.getYearMonth().contains(year + \"-\"))\n+                .collect(Collectors.toList());\n+        List<Enrollment> currentEnrollments = beneficiaryRecord.getEnrollments();\n+        for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n+          currentEnrollments.remove(previousEnrollment);\n+        }\n+\n+        currentEnrollments.addAll(currentYearEnrollments);\n+        beneficiaryRecord.setEnrollments(currentEnrollments);\n+      }\n     }\n   }\n \n", "next_change": {"commit": "82433ba67b93b06e00b8e2d9eee064fc8e81b259", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 590b43ee7..4247441ca 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -895,18 +892,20 @@ public final class RifLoader implements AutoCloseable {\n         currentYearEnrollments.add(enrollmentMonthly);\n       }\n \n-      if (currentYearEnrollments.size() >= 1) {\n+      if (currentYearEnrollments.size() > 0) {\n+        List<Enrollment> currentEnrollmentsWithUpdates = beneficiaryRecord.getEnrollments();\n         List<Enrollment> currentYearEnrollmentsPrevious =\n             beneficiaryRecord.getEnrollments().stream()\n                 .filter(e -> e.getYearMonth().contains(year + \"-\"))\n                 .collect(Collectors.toList());\n-        List<Enrollment> currentEnrollments = beneficiaryRecord.getEnrollments();\n-        for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n-          currentEnrollments.remove(previousEnrollment);\n-        }\n \n-        currentEnrollments.addAll(currentYearEnrollments);\n-        beneficiaryRecord.setEnrollments(currentEnrollments);\n+        if (currentYearEnrollmentsPrevious.size() > 0) {\n+          for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n+            currentEnrollmentsWithUpdates.remove(previousEnrollment);\n+          }\n+        }\n+        currentEnrollmentsWithUpdates.addAll(currentYearEnrollments);\n+        beneficiaryRecord.setEnrollments(currentEnrollmentsWithUpdates);\n       }\n     }\n   }\n", "next_change": {"commit": "cdf805a5a67b8bda8368c7390497f656dd65900f", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 4247441ca..a5703edc1 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -893,17 +893,27 @@ public final class RifLoader implements AutoCloseable {\n       }\n \n       if (currentYearEnrollments.size() > 0) {\n-        List<Enrollment> currentEnrollmentsWithUpdates = beneficiaryRecord.getEnrollments();\n-        List<Enrollment> currentYearEnrollmentsPrevious =\n-            beneficiaryRecord.getEnrollments().stream()\n-                .filter(e -> e.getYearMonth().contains(year + \"-\"))\n-                .collect(Collectors.toList());\n-\n-        if (currentYearEnrollmentsPrevious.size() > 0) {\n-          for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n-            currentEnrollmentsWithUpdates.remove(previousEnrollment);\n+        List<Enrollment> currentEnrollmentsWithUpdates;\n+\n+        Beneficiary beneficiaryFromDb =\n+            entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n+\n+        if (beneficiaryFromDb != null && beneficiaryFromDb.getEnrollments().size() > 0) {\n+          currentEnrollmentsWithUpdates = beneficiaryFromDb.getEnrollments();\n+          List<Enrollment> currentYearEnrollmentsPrevious =\n+              beneficiaryFromDb.getEnrollments().stream()\n+                  .filter(e -> e.getYearMonth().contains(year + \"-\"))\n+                  .collect(Collectors.toList());\n+\n+          if (currentYearEnrollmentsPrevious.size() > 0) {\n+            for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n+              currentEnrollmentsWithUpdates.remove(previousEnrollment);\n+            }\n           }\n+        } else {\n+          currentEnrollmentsWithUpdates = new LinkedList<Enrollment>();\n         }\n+\n         currentEnrollmentsWithUpdates.addAll(currentYearEnrollments);\n         beneficiaryRecord.setEnrollments(currentEnrollmentsWithUpdates);\n       }\n", "next_change": {"commit": "af3ad7d003a4305a817b1de55fa3a95e33685976", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex a5703edc1..e69917435 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -909,7 +909,7 @@ public final class RifLoader implements AutoCloseable {\n             for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n               currentEnrollmentsWithUpdates.remove(previousEnrollment);\n             }\n-          }\n+          } \n         } else {\n           currentEnrollmentsWithUpdates = new LinkedList<Enrollment>();\n         }\n", "next_change": {"commit": "c89ef7da0abef49a2f29eb9772c3ec951d9bc6e8", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex e69917435..975632f96 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -902,14 +902,14 @@ public final class RifLoader implements AutoCloseable {\n           currentEnrollmentsWithUpdates = beneficiaryFromDb.getEnrollments();\n           List<Enrollment> currentYearEnrollmentsPrevious =\n               beneficiaryFromDb.getEnrollments().stream()\n-                  .filter(e -> e.getYearMonth().contains(year + \"-\"))\n+                  .filter(e -> e.getYearMonth().contains(year))\n                   .collect(Collectors.toList());\n \n           if (currentYearEnrollmentsPrevious.size() > 0) {\n             for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n               currentEnrollmentsWithUpdates.remove(previousEnrollment);\n             }\n-          } \n+          }\n         } else {\n           currentEnrollmentsWithUpdates = new LinkedList<Enrollment>();\n         }\n", "next_change": {"commit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 975632f96..d428c53b9 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -888,34 +889,34 @@ public final class RifLoader implements AutoCloseable {\n               beneficiaryRecord.getPartDRetireeDrugSubsidyDecInd(),\n               beneficiaryRecord.getPartDSegmentNumberDecId());\n \n-      if (enrollmentMonthly != null) {\n-        currentYearEnrollments.add(enrollmentMonthly);\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n       }\n \n-      if (currentYearEnrollments.size() > 0) {\n-        List<Enrollment> currentEnrollmentsWithUpdates;\n+      if (currentYearBeneficiaryMonthly.size() > 0) {\n+        List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n \n         Beneficiary beneficiaryFromDb =\n             entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n \n-        if (beneficiaryFromDb != null && beneficiaryFromDb.getEnrollments().size() > 0) {\n-          currentEnrollmentsWithUpdates = beneficiaryFromDb.getEnrollments();\n-          List<Enrollment> currentYearEnrollmentsPrevious =\n-              beneficiaryFromDb.getEnrollments().stream()\n-                  .filter(e -> e.getYearMonth().contains(year))\n+        if (beneficiaryFromDb != null && beneficiaryFromDb.getBeneficiaryMonthlys().size() > 0) {\n+          currentBeneficiaryMonthlyWithUpdates = beneficiaryFromDb.getBeneficiaryMonthlys();\n+          List<BeneficiaryMonthly> currentYearBeneficiaryMonthlyPrevious =\n+              beneficiaryFromDb.getBeneficiaryMonthlys().stream()\n+                  .filter(e -> year == e.getYearMonth().getYear())\n                   .collect(Collectors.toList());\n \n-          if (currentYearEnrollmentsPrevious.size() > 0) {\n-            for (Enrollment previousEnrollment : currentYearEnrollmentsPrevious) {\n-              currentEnrollmentsWithUpdates.remove(previousEnrollment);\n+          if (currentYearBeneficiaryMonthlyPrevious.size() > 0) {\n+            for (BeneficiaryMonthly previousEnrollment : currentYearBeneficiaryMonthlyPrevious) {\n+              currentBeneficiaryMonthlyWithUpdates.remove(previousEnrollment);\n             }\n           }\n         } else {\n-          currentEnrollmentsWithUpdates = new LinkedList<Enrollment>();\n+          currentBeneficiaryMonthlyWithUpdates = new LinkedList<BeneficiaryMonthly>();\n         }\n \n-        currentEnrollmentsWithUpdates.addAll(currentYearEnrollments);\n-        beneficiaryRecord.setEnrollments(currentEnrollmentsWithUpdates);\n+        currentBeneficiaryMonthlyWithUpdates.addAll(currentYearBeneficiaryMonthly);\n+        beneficiaryRecord.setBeneficiaryMonthlys(currentBeneficiaryMonthlyWithUpdates);\n       }\n     }\n   }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 9357b7770..257d9724a 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -844,9 +887,37 @@ public final class RifLoader implements AutoCloseable {\n               beneficiaryRecord.getPartDLowIncomeCostShareGroupDecCode(),\n               beneficiaryRecord.getPartDPbpNumberDecId(),\n               beneficiaryRecord.getPartDRetireeDrugSubsidyDecInd(),\n-              beneficiaryRecord.getPartDSegmentNumberDecId()));\n+              beneficiaryRecord.getPartDSegmentNumberDecId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      if (currentYearBeneficiaryMonthly.size() > 0) {\n+        List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n+\n+        // TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file\n+        // allowed\n+        Beneficiary beneficiaryFromDb =\n+            entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n \n-      beneficiaryRecord.setEnrollments(enrollments);\n+        if (beneficiaryFromDb != null && beneficiaryFromDb.getBeneficiaryMonthlys().size() > 0) {\n+          currentBeneficiaryMonthlyWithUpdates = beneficiaryFromDb.getBeneficiaryMonthlys();\n+          List<BeneficiaryMonthly> currentYearBeneficiaryMonthlyPrevious =\n+              beneficiaryFromDb.getBeneficiaryMonthlys().stream()\n+                  .filter(e -> year == e.getYearMonth().getYear())\n+                  .collect(Collectors.toList());\n+\n+          for (BeneficiaryMonthly previousEnrollment : currentYearBeneficiaryMonthlyPrevious) {\n+            currentBeneficiaryMonthlyWithUpdates.remove(previousEnrollment);\n+          }\n+        } else {\n+          currentBeneficiaryMonthlyWithUpdates = new LinkedList<BeneficiaryMonthly>();\n+        }\n+\n+        currentBeneficiaryMonthlyWithUpdates.addAll(currentYearBeneficiaryMonthly);\n+        beneficiaryRecord.setBeneficiaryMonthlys(currentBeneficiaryMonthlyWithUpdates);\n+      }\n     }\n   }\n \n", "next_change": {"commit": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 257d9724a..3d79d64a9 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -916,7 +967,7 @@ public final class RifLoader implements AutoCloseable {\n         }\n \n         currentBeneficiaryMonthlyWithUpdates.addAll(currentYearBeneficiaryMonthly);\n-        beneficiaryRecord.setBeneficiaryMonthlys(currentBeneficiaryMonthlyWithUpdates);\n+        newBeneficiaryRecord.setBeneficiaryMonthlys(currentBeneficiaryMonthlyWithUpdates);\n       }\n     }\n   }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "1b0103ba4f25f43a6c5c5c92c73364dc17d2e5b0", "committedDate": "2020-12-30 16:03:00 -0500", "message": "Cbrune/bfd 549 validate hibernate (#426)"}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzOTE5NQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r543639195", "body": "As mentioned above, I think you'll want to have several test cases here, covering the following scenarios:\r\n1. If we insert a bene, do the resulting DB records have only the correct months' data populated, or does it end up with a lot of weird null-ish entries?\r\n2. If we update a bene with the current year's data and just more months filled in, does the resulting `Enrollments` data look as expected?\r\n3. If we update a bene with the current year's data and *less* months filled in (shouldn't happen but the schema allows it so we should ahndle it just in case), do the resulting DB records look as expected?\r\n4. If we update a bene with a new year's data, is it appended to the previous years' data, or does it overwrite it?", "bodyText": "As mentioned above, I think you'll want to have several test cases here, covering the following scenarios:\n\nIf we insert a bene, do the resulting DB records have only the correct months' data populated, or does it end up with a lot of weird null-ish entries?\nIf we update a bene with the current year's data and just more months filled in, does the resulting Enrollments data look as expected?\nIf we update a bene with the current year's data and less months filled in (shouldn't happen but the schema allows it so we should ahndle it just in case), do the resulting DB records look as expected?\nIf we update a bene with a new year's data, is it appended to the previous years' data, or does it overwrite it?", "bodyHTML": "<p dir=\"auto\">As mentioned above, I think you'll want to have several test cases here, covering the following scenarios:</p>\n<ol dir=\"auto\">\n<li>If we insert a bene, do the resulting DB records have only the correct months' data populated, or does it end up with a lot of weird null-ish entries?</li>\n<li>If we update a bene with the current year's data and just more months filled in, does the resulting <code>Enrollments</code> data look as expected?</li>\n<li>If we update a bene with the current year's data and <em>less</em> months filled in (shouldn't happen but the schema allows it so we should ahndle it just in case), do the resulting DB records look as expected?</li>\n<li>If we update a bene with a new year's data, is it appended to the previous years' data, or does it overwrite it?</li>\n</ol>", "author": "karlmdavis", "createdAt": "2020-12-15T19:48:09Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java", "diffHunk": "@@ -233,6 +234,8 @@ public void loadSampleU() {\n                     lastUpdated.after(Date.from(Instant.now().minus(1, ChronoUnit.MINUTES))));\n               });\n \n+      assertEnrollments(beneficiaryFromDb);", "originalCommit": "193a5a91734bd370f5025699d00caf24b47bb77a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "312dc84b400dbbbdaf26a3f66eaee3339c8ea621", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 73c098102..c9361ad71 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -234,7 +234,7 @@ public final class RifLoaderIT {\n                     lastUpdated.after(Date.from(Instant.now().minus(1, ChronoUnit.MINUTES))));\n               });\n \n-      assertEnrollments(beneficiaryFromDb);\n+      assertEnrollments(beneficiaryFromDb, 12);\n \n       CarrierClaim carrierRecordFromDb = entityManager.find(CarrierClaim.class, \"9991831999\");\n       Assert.assertEquals('N', carrierRecordFromDb.getFinalAction());\n", "next_change": {"commit": "cdf805a5a67b8bda8368c7390497f656dd65900f", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex c9361ad71..aee540edc 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -234,8 +234,6 @@ public final class RifLoaderIT {\n                     lastUpdated.after(Date.from(Instant.now().minus(1, ChronoUnit.MINUTES))));\n               });\n \n-      assertEnrollments(beneficiaryFromDb, 12);\n-\n       CarrierClaim carrierRecordFromDb = entityManager.find(CarrierClaim.class, \"9991831999\");\n       Assert.assertEquals('N', carrierRecordFromDb.getFinalAction());\n       // DateThrough inserted with value 10-27-1999\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 73c098102..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -234,8 +234,6 @@ public final class RifLoaderIT {\n                     lastUpdated.after(Date.from(Instant.now().minus(1, ChronoUnit.MINUTES))));\n               });\n \n-      assertEnrollments(beneficiaryFromDb);\n-\n       CarrierClaim carrierRecordFromDb = entityManager.find(CarrierClaim.class, \"9991831999\");\n       Assert.assertEquals('N', carrierRecordFromDb.getFinalAction());\n       // DateThrough inserted with value 10-27-1999\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"oid": "312dc84b400dbbbdaf26a3f66eaee3339c8ea621", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/312dc84b400dbbbdaf26a3f66eaee3339c8ea621", "message": "refactored some code", "committedDate": "2020-12-16T19:45:07Z", "type": "commit"}, {"oid": "82433ba67b93b06e00b8e2d9eee064fc8e81b259", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/82433ba67b93b06e00b8e2d9eee064fc8e81b259", "message": "CHanges to rifloader", "committedDate": "2020-12-18T19:05:59Z", "type": "commit"}, {"oid": "9b4ee865d3f1ebfd1327ed0821b947b80faac889", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/9b4ee865d3f1ebfd1327ed0821b947b80faac889", "message": "Changed year", "committedDate": "2020-12-18T19:48:10Z", "type": "commit"}, {"oid": "cdf805a5a67b8bda8368c7390497f656dd65900f", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/cdf805a5a67b8bda8368c7390497f656dd65900f", "message": "added benefiicary check", "committedDate": "2020-12-18T22:05:16Z", "type": "commit"}, {"oid": "af3ad7d003a4305a817b1de55fa3a95e33685976", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/af3ad7d003a4305a817b1de55fa3a95e33685976", "message": "added benefiicary check", "committedDate": "2020-12-18T22:09:00Z", "type": "commit"}, {"oid": "c89ef7da0abef49a2f29eb9772c3ec951d9bc6e8", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/c89ef7da0abef49a2f29eb9772c3ec951d9bc6e8", "message": "Added three integration tests", "committedDate": "2020-12-19T03:32:32Z", "type": "commit"}, {"oid": "e6b8b6ef44e33a316033f02da5f3c177b2e7c612", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/e6b8b6ef44e33a316033f02da5f3c177b2e7c612", "message": "UPdated json responses", "committedDate": "2020-12-19T03:59:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0OTA3Ng==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r546949076", "body": "Do you still have anything using this method?", "bodyText": "Do you still have anything using this method?", "bodyHTML": "<p dir=\"auto\">Do you still have anything using this method?</p>", "author": "karlmdavis", "createdAt": "2020-12-21T21:55:33Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java", "diffHunk": "@@ -680,6 +743,262 @@ private static RifLoader createLoader(DataSource dataSource, boolean fixupsEnabl\n             defaultOptions.getFixupThreads()));\n   }\n \n+  public static void assertEnrollments(Beneficiary beneficiaryFromDb, int enrollmentSize) {", "originalCommit": "e6b8b6ef44e33a316033f02da5f3c177b2e7c612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNDA5MA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549504090", "bodyText": "yes and added it in the test", "author": "cbrunefearless", "createdAt": "2020-12-28T22:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0OTA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "665bbc2645e50cc7669d7863118ebfcdae08fcbe", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex b83081cc0..feb3fe0d2 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -743,7 +745,7 @@ public final class RifLoaderIT {\n             defaultOptions.getFixupThreads()));\n   }\n \n-  public static void assertEnrollments(Beneficiary beneficiaryFromDb, int enrollmentSize) {\n+  public static void assertEnrollments(Beneficiary beneficiaryFromDb) {\n     List<Enrollment> enrollments = beneficiaryFromDb.getEnrollments();\n \n     checkEnrollments(\n", "next_change": {"commit": "02315889d45e6bde459c68591c18e215443f8be4", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex feb3fe0d2..56ec6b4f2 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -749,8 +750,8 @@ public final class RifLoaderIT {\n     List<Enrollment> enrollments = beneficiaryFromDb.getEnrollments();\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"01\",\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        1,\n         enrollments.get(0),\n         beneficiaryFromDb.getEntitlementBuyInJanInd().get(),\n         beneficiaryFromDb.getFipsStateCntyJanCode().get(),\n", "next_change": {"commit": "071f7b1669fe94eccdbc1e3cfc86df671e8b114d", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 56ec6b4f2..3cc9c5c60 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -753,254 +753,266 @@ public final class RifLoaderIT {\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         1,\n         enrollments.get(0),\n-        beneficiaryFromDb.getEntitlementBuyInJanInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJanCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJanInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJanCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJanCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJanCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJanId().get());\n+        beneficiaryFromDb.getEntitlementBuyInJanInd(),\n+        beneficiaryFromDb.getFipsStateCntyJanCode(),\n+        beneficiaryFromDb.getHmoIndicatorJanInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJanCode(),\n+        beneficiaryFromDb.getMedicareStatusJanCode(),\n+        beneficiaryFromDb.getPartCContractNumberJanId(),\n+        beneficiaryFromDb.getPartCPbpNumberJanId(),\n+        beneficiaryFromDb.getPartCPlanTypeJanCode(),\n+        beneficiaryFromDb.getPartDContractNumberJanId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJanId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJanId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         2,\n         enrollments.get(1),\n-        beneficiaryFromDb.getEntitlementBuyInFebInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyFebCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorFebInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityFebCode().get(),\n-        beneficiaryFromDb.getMedicareStatusFebCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeFebCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberFebId().get());\n+        beneficiaryFromDb.getEntitlementBuyInFebInd(),\n+        beneficiaryFromDb.getFipsStateCntyFebCode(),\n+        beneficiaryFromDb.getHmoIndicatorFebInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityFebCode(),\n+        beneficiaryFromDb.getMedicareStatusFebCode(),\n+        beneficiaryFromDb.getPartCContractNumberFebId(),\n+        beneficiaryFromDb.getPartCPbpNumberFebId(),\n+        beneficiaryFromDb.getPartCPlanTypeFebCode(),\n+        beneficiaryFromDb.getPartDContractNumberFebId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode(),\n+        beneficiaryFromDb.getPartDPbpNumberFebId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberFebId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         3,\n         enrollments.get(2),\n-        beneficiaryFromDb.getEntitlementBuyInMarInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMarCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMarInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMarCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMarCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMarCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMarId().get());\n+        beneficiaryFromDb.getEntitlementBuyInMarInd(),\n+        beneficiaryFromDb.getFipsStateCntyMarCode(),\n+        beneficiaryFromDb.getHmoIndicatorMarInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMarCode(),\n+        beneficiaryFromDb.getMedicareStatusMarCode(),\n+        beneficiaryFromDb.getPartCContractNumberMarId(),\n+        beneficiaryFromDb.getPartCPbpNumberMarId(),\n+        beneficiaryFromDb.getPartCPlanTypeMarCode(),\n+        beneficiaryFromDb.getPartDContractNumberMarId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMarId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMarId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         4,\n         enrollments.get(3),\n-        beneficiaryFromDb.getEntitlementBuyInAprInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAprCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAprInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAprCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAprCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAprCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAprId().get());\n+        beneficiaryFromDb.getEntitlementBuyInAprInd(),\n+        beneficiaryFromDb.getFipsStateCntyAprCode(),\n+        beneficiaryFromDb.getHmoIndicatorAprInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAprCode(),\n+        beneficiaryFromDb.getMedicareStatusAprCode(),\n+        beneficiaryFromDb.getPartCContractNumberAprId(),\n+        beneficiaryFromDb.getPartCPbpNumberAprId(),\n+        beneficiaryFromDb.getPartCPlanTypeAprCode(),\n+        beneficiaryFromDb.getPartDContractNumberAprId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAprId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAprId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         5,\n         enrollments.get(4),\n-        beneficiaryFromDb.getEntitlementBuyInMayInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMayCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMayInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMayCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMayCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMayCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMayId().get());\n+        beneficiaryFromDb.getEntitlementBuyInMayInd(),\n+        beneficiaryFromDb.getFipsStateCntyMayCode(),\n+        beneficiaryFromDb.getHmoIndicatorMayInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMayCode(),\n+        beneficiaryFromDb.getMedicareStatusMayCode(),\n+        beneficiaryFromDb.getPartCContractNumberMayId(),\n+        beneficiaryFromDb.getPartCPbpNumberMayId(),\n+        beneficiaryFromDb.getPartCPlanTypeMayCode(),\n+        beneficiaryFromDb.getPartDContractNumberMayId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMayId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMayId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         6,\n         enrollments.get(5),\n-        beneficiaryFromDb.getEntitlementBuyInJunInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJunCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJunInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJunCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJunCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJunCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJunId().get());\n+        beneficiaryFromDb.getEntitlementBuyInJunInd(),\n+        beneficiaryFromDb.getFipsStateCntyJunCode(),\n+        beneficiaryFromDb.getHmoIndicatorJunInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJunCode(),\n+        beneficiaryFromDb.getMedicareStatusJunCode(),\n+        beneficiaryFromDb.getPartCContractNumberJunId(),\n+        beneficiaryFromDb.getPartCPbpNumberJunId(),\n+        beneficiaryFromDb.getPartCPlanTypeJunCode(),\n+        beneficiaryFromDb.getPartDContractNumberJunId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJunId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJunId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         7,\n         enrollments.get(6),\n-        beneficiaryFromDb.getEntitlementBuyInJulInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJulCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJulInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJulCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJulCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJulCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJulId().get());\n+        beneficiaryFromDb.getEntitlementBuyInJulInd(),\n+        beneficiaryFromDb.getFipsStateCntyJulCode(),\n+        beneficiaryFromDb.getHmoIndicatorJulInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJulCode(),\n+        beneficiaryFromDb.getMedicareStatusJulCode(),\n+        beneficiaryFromDb.getPartCContractNumberJulId(),\n+        beneficiaryFromDb.getPartCPbpNumberJulId(),\n+        beneficiaryFromDb.getPartCPlanTypeJulCode(),\n+        beneficiaryFromDb.getPartDContractNumberJulId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJulId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJulId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         8,\n         enrollments.get(7),\n-        beneficiaryFromDb.getEntitlementBuyInAugInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAugCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAugInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAugCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAugCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAugCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAugId().get());\n+        beneficiaryFromDb.getEntitlementBuyInAugInd(),\n+        beneficiaryFromDb.getFipsStateCntyAugCode(),\n+        beneficiaryFromDb.getHmoIndicatorAugInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAugCode(),\n+        beneficiaryFromDb.getMedicareStatusAugCode(),\n+        beneficiaryFromDb.getPartCContractNumberAugId(),\n+        beneficiaryFromDb.getPartCPbpNumberAugId(),\n+        beneficiaryFromDb.getPartCPlanTypeAugCode(),\n+        beneficiaryFromDb.getPartDContractNumberAugId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAugId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAugId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         9,\n         enrollments.get(8),\n-        beneficiaryFromDb.getEntitlementBuyInSeptInd().get(),\n-        beneficiaryFromDb.getFipsStateCntySeptCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorSeptInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode().get(),\n-        beneficiaryFromDb.getMedicareStatusSeptCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeSeptCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberSeptId().get());\n+        beneficiaryFromDb.getEntitlementBuyInSeptInd(),\n+        beneficiaryFromDb.getFipsStateCntySeptCode(),\n+        beneficiaryFromDb.getHmoIndicatorSeptInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode(),\n+        beneficiaryFromDb.getMedicareStatusSeptCode(),\n+        beneficiaryFromDb.getPartCContractNumberSeptId(),\n+        beneficiaryFromDb.getPartCPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartCPlanTypeSeptCode(),\n+        beneficiaryFromDb.getPartDContractNumberSeptId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode(),\n+        beneficiaryFromDb.getPartDPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberSeptId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         10,\n         enrollments.get(9),\n-        beneficiaryFromDb.getEntitlementBuyInOctInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyOctCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorOctInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityOctCode().get(),\n-        beneficiaryFromDb.getMedicareStatusOctCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeOctCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberOctId().get());\n-    /*\n+        beneficiaryFromDb.getEntitlementBuyInOctInd(),\n+        beneficiaryFromDb.getFipsStateCntyOctCode(),\n+        beneficiaryFromDb.getHmoIndicatorOctInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityOctCode(),\n+        beneficiaryFromDb.getMedicareStatusOctCode(),\n+        beneficiaryFromDb.getPartCContractNumberOctId(),\n+        beneficiaryFromDb.getPartCPbpNumberOctId(),\n+        beneficiaryFromDb.getPartCPlanTypeOctCode(),\n+        beneficiaryFromDb.getPartDContractNumberOctId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode(),\n+        beneficiaryFromDb.getPartDPbpNumberOctId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberOctId());\n+\n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"11\",\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        11,\n         enrollments.get(10),\n-        beneficiaryFromDb.getEntitlementBuyInNovInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyNovCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorNovInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityNovCode().get(),\n-        beneficiaryFromDb.getMedicareStatusNovCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeNovCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberNovId().get());\n+        beneficiaryFromDb.getEntitlementBuyInNovInd(),\n+        beneficiaryFromDb.getFipsStateCntyNovCode(),\n+        beneficiaryFromDb.getHmoIndicatorNovInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityNovCode(),\n+        beneficiaryFromDb.getMedicareStatusNovCode(),\n+        beneficiaryFromDb.getPartCContractNumberNovId(),\n+        beneficiaryFromDb.getPartCPbpNumberNovId(),\n+        beneficiaryFromDb.getPartCPlanTypeNovCode(),\n+        beneficiaryFromDb.getPartDContractNumberNovId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode(),\n+        beneficiaryFromDb.getPartDPbpNumberNovId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberNovId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"12\",\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        12,\n         enrollments.get(11),\n-        beneficiaryFromDb.getEntitlementBuyInDecInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyDecCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorDecInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityDecCode().get(),\n-        beneficiaryFromDb.getMedicareStatusDecCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeDecCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberDecId().get());*/\n+        beneficiaryFromDb.getEntitlementBuyInDecInd(),\n+        beneficiaryFromDb.getFipsStateCntyDecCode(),\n+        beneficiaryFromDb.getHmoIndicatorDecInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityDecCode(),\n+        beneficiaryFromDb.getMedicareStatusDecCode(),\n+        beneficiaryFromDb.getPartCContractNumberDecId(),\n+        beneficiaryFromDb.getPartCPbpNumberDecId(),\n+        beneficiaryFromDb.getPartCPlanTypeDecCode(),\n+        beneficiaryFromDb.getPartDContractNumberDecId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode(),\n+        beneficiaryFromDb.getPartDPbpNumberDecId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberDecId());\n   }\n \n   public static void checkEnrollments(\n       int referenceYear,\n       int month,\n       Enrollment enrollment,\n-      Character entitlementBuyInInd,\n-      String fipsStateCntyCode,\n-      Character hmoIndicatorInd,\n-      String medicaidDualEligibilityCode,\n-      String medicareStatusCode,\n-      String partCContractNumberId,\n-      String partCPbpNumberId,\n-      String partCPlanTypeCode,\n-      String partDContractNumberId,\n-      String partDLowIncomeCostShareGroupCode,\n-      String partDPbpNumberId,\n-      Character partDRetireeDrugSubsidyInd,\n-      String partDSegmentNumberId) {\n+      Optional<Character> entitlementBuyInInd,\n+      Optional<String> fipsStateCntyCode,\n+      Optional<Character> hmoIndicatorInd,\n+      Optional<String> medicaidDualEligibilityCode,\n+      Optional<String> medicareStatusCode,\n+      Optional<String> partCContractNumberId,\n+      Optional<String> partCPbpNumberId,\n+      Optional<String> partCPlanTypeCode,\n+      Optional<String> partDContractNumberId,\n+      Optional<String> partDLowIncomeCostShareGroupCode,\n+      Optional<String> partDPbpNumberId,\n+      Optional<Character> partDRetireeDrugSubsidyInd,\n+      Optional<String> partDSegmentNumberId) {\n \n     Assert.assertEquals(LocalDate.of(referenceYear, month, 1), enrollment.getYearMonth());\n-    Assert.assertEquals(entitlementBuyInInd, enrollment.getEntitlementBuyInInd().get());\n-    Assert.assertEquals(fipsStateCntyCode, enrollment.getFipsStateCntyCode().get());\n-    Assert.assertEquals(hmoIndicatorInd, enrollment.getHmoIndicatorInd().get());\n     Assert.assertEquals(\n-        medicaidDualEligibilityCode, enrollment.getMedicaidDualEligibilityCode().get());\n-    Assert.assertEquals(medicareStatusCode, enrollment.getMedicareStatusCode().get());\n-    Assert.assertEquals(partCContractNumberId, enrollment.getPartCContractNumberId().get());\n-    Assert.assertEquals(partCPbpNumberId, enrollment.getPartCPbpNumberId().get());\n-    Assert.assertEquals(partCPlanTypeCode, enrollment.getPartCPlanTypeCode().get());\n-    Assert.assertEquals(partDContractNumberId, enrollment.getPartDContractNumberId().get());\n+        entitlementBuyInInd.orElse(null), enrollment.getEntitlementBuyInInd().orElse(null));\n+    Assert.assertEquals(\n+        fipsStateCntyCode.orElse(null), enrollment.getFipsStateCntyCode().orElse(null));\n+    Assert.assertEquals(hmoIndicatorInd.orElse(null), enrollment.getHmoIndicatorInd().orElse(null));\n+    Assert.assertEquals(\n+        medicaidDualEligibilityCode.orElse(null),\n+        enrollment.getMedicaidDualEligibilityCode().orElse(null));\n+    Assert.assertEquals(\n+        medicareStatusCode.orElse(null), enrollment.getMedicareStatusCode().orElse(null));\n+    Assert.assertEquals(\n+        partCContractNumberId.orElse(null), enrollment.getPartCContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPbpNumberId.orElse(null), enrollment.getPartCPbpNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPlanTypeCode.orElse(null), enrollment.getPartCPlanTypeCode().orElse(null));\n+    Assert.assertEquals(\n+        partDContractNumberId.orElse(null), enrollment.getPartDContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partDLowIncomeCostShareGroupCode.orElse(null),\n+        enrollment.getPartDLowIncomeCostShareGroupCode().orElse(null));\n+    Assert.assertEquals(\n+        partDPbpNumberId.orElse(null), enrollment.getPartDPbpNumberId().orElse(null));\n     Assert.assertEquals(\n-        partDLowIncomeCostShareGroupCode, enrollment.getPartDLowIncomeCostShareGroupCode().get());\n-    Assert.assertEquals(partDPbpNumberId, enrollment.getPartDPbpNumberId().get());\n+        partDRetireeDrugSubsidyInd.orElse(null),\n+        enrollment.getPartDRetireeDrugSubsidyInd().orElse(null));\n     Assert.assertEquals(\n-        partDRetireeDrugSubsidyInd, enrollment.getPartDRetireeDrugSubsidyInd().get());\n-    Assert.assertEquals(partDSegmentNumberId, enrollment.getPartDSegmentNumberId().get());\n+        partDSegmentNumberId.orElse(null), enrollment.getPartDSegmentNumberId().orElse(null));\n   }\n   /**\n    * Clear the MBI hash fields in the db\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex b83081cc0..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -743,261 +860,273 @@ public final class RifLoaderIT {\n             defaultOptions.getFixupThreads()));\n   }\n \n-  public static void assertEnrollments(Beneficiary beneficiaryFromDb, int enrollmentSize) {\n-    List<Enrollment> enrollments = beneficiaryFromDb.getEnrollments();\n+  public static void assertBeneficiaryMonthly(Beneficiary beneficiaryFromDb) {\n+    List<BeneficiaryMonthly> beneficiaryMonthly = beneficiaryFromDb.getBeneficiaryMonthlys();\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"01\",\n-        enrollments.get(0),\n-        beneficiaryFromDb.getEntitlementBuyInJanInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJanCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJanInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJanCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJanCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJanCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJanId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        1,\n+        beneficiaryMonthly.get(0),\n+        beneficiaryFromDb.getEntitlementBuyInJanInd(),\n+        beneficiaryFromDb.getFipsStateCntyJanCode(),\n+        beneficiaryFromDb.getHmoIndicatorJanInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJanCode(),\n+        beneficiaryFromDb.getMedicareStatusJanCode(),\n+        beneficiaryFromDb.getPartCContractNumberJanId(),\n+        beneficiaryFromDb.getPartCPbpNumberJanId(),\n+        beneficiaryFromDb.getPartCPlanTypeJanCode(),\n+        beneficiaryFromDb.getPartDContractNumberJanId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJanId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJanId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"02\",\n-        enrollments.get(1),\n-        beneficiaryFromDb.getEntitlementBuyInFebInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyFebCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorFebInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityFebCode().get(),\n-        beneficiaryFromDb.getMedicareStatusFebCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeFebCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberFebId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        2,\n+        beneficiaryMonthly.get(1),\n+        beneficiaryFromDb.getEntitlementBuyInFebInd(),\n+        beneficiaryFromDb.getFipsStateCntyFebCode(),\n+        beneficiaryFromDb.getHmoIndicatorFebInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityFebCode(),\n+        beneficiaryFromDb.getMedicareStatusFebCode(),\n+        beneficiaryFromDb.getPartCContractNumberFebId(),\n+        beneficiaryFromDb.getPartCPbpNumberFebId(),\n+        beneficiaryFromDb.getPartCPlanTypeFebCode(),\n+        beneficiaryFromDb.getPartDContractNumberFebId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode(),\n+        beneficiaryFromDb.getPartDPbpNumberFebId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberFebId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"03\",\n-        enrollments.get(2),\n-        beneficiaryFromDb.getEntitlementBuyInMarInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMarCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMarInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMarCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMarCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMarCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMarId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        3,\n+        beneficiaryMonthly.get(2),\n+        beneficiaryFromDb.getEntitlementBuyInMarInd(),\n+        beneficiaryFromDb.getFipsStateCntyMarCode(),\n+        beneficiaryFromDb.getHmoIndicatorMarInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMarCode(),\n+        beneficiaryFromDb.getMedicareStatusMarCode(),\n+        beneficiaryFromDb.getPartCContractNumberMarId(),\n+        beneficiaryFromDb.getPartCPbpNumberMarId(),\n+        beneficiaryFromDb.getPartCPlanTypeMarCode(),\n+        beneficiaryFromDb.getPartDContractNumberMarId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMarId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMarId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"04\",\n-        enrollments.get(3),\n-        beneficiaryFromDb.getEntitlementBuyInAprInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAprCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAprInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAprCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAprCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAprCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAprId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        4,\n+        beneficiaryMonthly.get(3),\n+        beneficiaryFromDb.getEntitlementBuyInAprInd(),\n+        beneficiaryFromDb.getFipsStateCntyAprCode(),\n+        beneficiaryFromDb.getHmoIndicatorAprInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAprCode(),\n+        beneficiaryFromDb.getMedicareStatusAprCode(),\n+        beneficiaryFromDb.getPartCContractNumberAprId(),\n+        beneficiaryFromDb.getPartCPbpNumberAprId(),\n+        beneficiaryFromDb.getPartCPlanTypeAprCode(),\n+        beneficiaryFromDb.getPartDContractNumberAprId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAprId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAprId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"05\",\n-        enrollments.get(4),\n-        beneficiaryFromDb.getEntitlementBuyInMayInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMayCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMayInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMayCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMayCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMayCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMayId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        5,\n+        beneficiaryMonthly.get(4),\n+        beneficiaryFromDb.getEntitlementBuyInMayInd(),\n+        beneficiaryFromDb.getFipsStateCntyMayCode(),\n+        beneficiaryFromDb.getHmoIndicatorMayInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMayCode(),\n+        beneficiaryFromDb.getMedicareStatusMayCode(),\n+        beneficiaryFromDb.getPartCContractNumberMayId(),\n+        beneficiaryFromDb.getPartCPbpNumberMayId(),\n+        beneficiaryFromDb.getPartCPlanTypeMayCode(),\n+        beneficiaryFromDb.getPartDContractNumberMayId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMayId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMayId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"06\",\n-        enrollments.get(5),\n-        beneficiaryFromDb.getEntitlementBuyInJunInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJunCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJunInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJunCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJunCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJunCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJunId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        6,\n+        beneficiaryMonthly.get(5),\n+        beneficiaryFromDb.getEntitlementBuyInJunInd(),\n+        beneficiaryFromDb.getFipsStateCntyJunCode(),\n+        beneficiaryFromDb.getHmoIndicatorJunInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJunCode(),\n+        beneficiaryFromDb.getMedicareStatusJunCode(),\n+        beneficiaryFromDb.getPartCContractNumberJunId(),\n+        beneficiaryFromDb.getPartCPbpNumberJunId(),\n+        beneficiaryFromDb.getPartCPlanTypeJunCode(),\n+        beneficiaryFromDb.getPartDContractNumberJunId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJunId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJunId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"07\",\n-        enrollments.get(6),\n-        beneficiaryFromDb.getEntitlementBuyInJulInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJulCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJulInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJulCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJulCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJulCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJulId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        7,\n+        beneficiaryMonthly.get(6),\n+        beneficiaryFromDb.getEntitlementBuyInJulInd(),\n+        beneficiaryFromDb.getFipsStateCntyJulCode(),\n+        beneficiaryFromDb.getHmoIndicatorJulInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJulCode(),\n+        beneficiaryFromDb.getMedicareStatusJulCode(),\n+        beneficiaryFromDb.getPartCContractNumberJulId(),\n+        beneficiaryFromDb.getPartCPbpNumberJulId(),\n+        beneficiaryFromDb.getPartCPlanTypeJulCode(),\n+        beneficiaryFromDb.getPartDContractNumberJulId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJulId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJulId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"08\",\n-        enrollments.get(7),\n-        beneficiaryFromDb.getEntitlementBuyInAugInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAugCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAugInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAugCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAugCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAugCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAugId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        8,\n+        beneficiaryMonthly.get(7),\n+        beneficiaryFromDb.getEntitlementBuyInAugInd(),\n+        beneficiaryFromDb.getFipsStateCntyAugCode(),\n+        beneficiaryFromDb.getHmoIndicatorAugInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAugCode(),\n+        beneficiaryFromDb.getMedicareStatusAugCode(),\n+        beneficiaryFromDb.getPartCContractNumberAugId(),\n+        beneficiaryFromDb.getPartCPbpNumberAugId(),\n+        beneficiaryFromDb.getPartCPlanTypeAugCode(),\n+        beneficiaryFromDb.getPartDContractNumberAugId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAugId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAugId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"09\",\n-        enrollments.get(8),\n-        beneficiaryFromDb.getEntitlementBuyInSeptInd().get(),\n-        beneficiaryFromDb.getFipsStateCntySeptCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorSeptInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode().get(),\n-        beneficiaryFromDb.getMedicareStatusSeptCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeSeptCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberSeptId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        9,\n+        beneficiaryMonthly.get(8),\n+        beneficiaryFromDb.getEntitlementBuyInSeptInd(),\n+        beneficiaryFromDb.getFipsStateCntySeptCode(),\n+        beneficiaryFromDb.getHmoIndicatorSeptInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode(),\n+        beneficiaryFromDb.getMedicareStatusSeptCode(),\n+        beneficiaryFromDb.getPartCContractNumberSeptId(),\n+        beneficiaryFromDb.getPartCPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartCPlanTypeSeptCode(),\n+        beneficiaryFromDb.getPartDContractNumberSeptId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode(),\n+        beneficiaryFromDb.getPartDPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberSeptId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"10\",\n-        enrollments.get(9),\n-        beneficiaryFromDb.getEntitlementBuyInOctInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyOctCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorOctInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityOctCode().get(),\n-        beneficiaryFromDb.getMedicareStatusOctCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeOctCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberOctId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        10,\n+        beneficiaryMonthly.get(9),\n+        beneficiaryFromDb.getEntitlementBuyInOctInd(),\n+        beneficiaryFromDb.getFipsStateCntyOctCode(),\n+        beneficiaryFromDb.getHmoIndicatorOctInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityOctCode(),\n+        beneficiaryFromDb.getMedicareStatusOctCode(),\n+        beneficiaryFromDb.getPartCContractNumberOctId(),\n+        beneficiaryFromDb.getPartCPbpNumberOctId(),\n+        beneficiaryFromDb.getPartCPlanTypeOctCode(),\n+        beneficiaryFromDb.getPartDContractNumberOctId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode(),\n+        beneficiaryFromDb.getPartDPbpNumberOctId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberOctId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"11\",\n-        enrollments.get(10),\n-        beneficiaryFromDb.getEntitlementBuyInNovInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyNovCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorNovInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityNovCode().get(),\n-        beneficiaryFromDb.getMedicareStatusNovCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeNovCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberNovId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        11,\n+        beneficiaryMonthly.get(10),\n+        beneficiaryFromDb.getEntitlementBuyInNovInd(),\n+        beneficiaryFromDb.getFipsStateCntyNovCode(),\n+        beneficiaryFromDb.getHmoIndicatorNovInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityNovCode(),\n+        beneficiaryFromDb.getMedicareStatusNovCode(),\n+        beneficiaryFromDb.getPartCContractNumberNovId(),\n+        beneficiaryFromDb.getPartCPbpNumberNovId(),\n+        beneficiaryFromDb.getPartCPlanTypeNovCode(),\n+        beneficiaryFromDb.getPartDContractNumberNovId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode(),\n+        beneficiaryFromDb.getPartDPbpNumberNovId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberNovId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"12\",\n-        enrollments.get(11),\n-        beneficiaryFromDb.getEntitlementBuyInDecInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyDecCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorDecInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityDecCode().get(),\n-        beneficiaryFromDb.getMedicareStatusDecCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeDecCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberDecId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        12,\n+        beneficiaryMonthly.get(11),\n+        beneficiaryFromDb.getEntitlementBuyInDecInd(),\n+        beneficiaryFromDb.getFipsStateCntyDecCode(),\n+        beneficiaryFromDb.getHmoIndicatorDecInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityDecCode(),\n+        beneficiaryFromDb.getMedicareStatusDecCode(),\n+        beneficiaryFromDb.getPartCContractNumberDecId(),\n+        beneficiaryFromDb.getPartCPbpNumberDecId(),\n+        beneficiaryFromDb.getPartCPlanTypeDecCode(),\n+        beneficiaryFromDb.getPartDContractNumberDecId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode(),\n+        beneficiaryFromDb.getPartDPbpNumberDecId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberDecId());\n   }\n \n   public static void checkEnrollments(\n-      String referenceYear,\n-      String month,\n-      Enrollment enrollment,\n-      Character entitlementBuyInInd,\n-      String fipsStateCntyCode,\n-      Character hmoIndicatorInd,\n-      String medicaidDualEligibilityCode,\n-      String medicareStatusCode,\n-      String partCContractNumberId,\n-      String partCPbpNumberId,\n-      String partCPlanTypeCode,\n-      String partDContractNumberId,\n-      String partDLowIncomeCostShareGroupCode,\n-      String partDPbpNumberId,\n-      Character partDRetireeDrugSubsidyInd,\n-      String partDSegmentNumberId) {\n-\n-    Assert.assertEquals(String.format(\"%s-%s\", referenceYear, month), enrollment.getYearMonth());\n-    Assert.assertEquals(entitlementBuyInInd, enrollment.getEntitlementBuyInInd().get());\n-    Assert.assertEquals(fipsStateCntyCode, enrollment.getFipsStateCntyCode().get());\n-    Assert.assertEquals(hmoIndicatorInd, enrollment.getHmoIndicatorInd().get());\n+      int referenceYear,\n+      int month,\n+      BeneficiaryMonthly enrollment,\n+      Optional<Character> entitlementBuyInInd,\n+      Optional<String> fipsStateCntyCode,\n+      Optional<Character> hmoIndicatorInd,\n+      Optional<String> medicaidDualEligibilityCode,\n+      Optional<String> medicareStatusCode,\n+      Optional<String> partCContractNumberId,\n+      Optional<String> partCPbpNumberId,\n+      Optional<String> partCPlanTypeCode,\n+      Optional<String> partDContractNumberId,\n+      Optional<String> partDLowIncomeCostShareGroupCode,\n+      Optional<String> partDPbpNumberId,\n+      Optional<Character> partDRetireeDrugSubsidyInd,\n+      Optional<String> partDSegmentNumberId) {\n+\n+    Assert.assertEquals(LocalDate.of(referenceYear, month, 1), enrollment.getYearMonth());\n+    Assert.assertEquals(\n+        entitlementBuyInInd.orElse(null), enrollment.getEntitlementBuyInInd().orElse(null));\n+    Assert.assertEquals(\n+        fipsStateCntyCode.orElse(null), enrollment.getFipsStateCntyCode().orElse(null));\n+    Assert.assertEquals(hmoIndicatorInd.orElse(null), enrollment.getHmoIndicatorInd().orElse(null));\n+    Assert.assertEquals(\n+        medicaidDualEligibilityCode.orElse(null),\n+        enrollment.getMedicaidDualEligibilityCode().orElse(null));\n+    Assert.assertEquals(\n+        medicareStatusCode.orElse(null), enrollment.getMedicareStatusCode().orElse(null));\n+    Assert.assertEquals(\n+        partCContractNumberId.orElse(null), enrollment.getPartCContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPbpNumberId.orElse(null), enrollment.getPartCPbpNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPlanTypeCode.orElse(null), enrollment.getPartCPlanTypeCode().orElse(null));\n+    Assert.assertEquals(\n+        partDContractNumberId.orElse(null), enrollment.getPartDContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partDLowIncomeCostShareGroupCode.orElse(null),\n+        enrollment.getPartDLowIncomeCostShareGroupCode().orElse(null));\n     Assert.assertEquals(\n-        medicaidDualEligibilityCode, enrollment.getMedicaidDualEligibilityCode().get());\n-    Assert.assertEquals(medicareStatusCode, enrollment.getMedicareStatusCode().get());\n-    Assert.assertEquals(partCContractNumberId, enrollment.getPartCContractNumberId().get());\n-    Assert.assertEquals(partCPbpNumberId, enrollment.getPartCPbpNumberId().get());\n-    Assert.assertEquals(partCPlanTypeCode, enrollment.getPartCPlanTypeCode().get());\n-    Assert.assertEquals(partDContractNumberId, enrollment.getPartDContractNumberId().get());\n+        partDPbpNumberId.orElse(null), enrollment.getPartDPbpNumberId().orElse(null));\n     Assert.assertEquals(\n-        partDLowIncomeCostShareGroupCode, enrollment.getPartDLowIncomeCostShareGroupCode().get());\n-    Assert.assertEquals(partDPbpNumberId, enrollment.getPartDPbpNumberId().get());\n+        partDRetireeDrugSubsidyInd.orElse(null),\n+        enrollment.getPartDRetireeDrugSubsidyInd().orElse(null));\n     Assert.assertEquals(\n-        partDRetireeDrugSubsidyInd, enrollment.getPartDRetireeDrugSubsidyInd().get());\n-    Assert.assertEquals(partDSegmentNumberId, enrollment.getPartDSegmentNumberId().get());\n+        partDSegmentNumberId.orElse(null), enrollment.getPartDSegmentNumberId().orElse(null));\n   }\n   /**\n    * Clear the MBI hash fields in the db\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0OTMwOQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r546949309", "body": "Other than `assertEnrollments(...)` above, do you have anything using this method?", "bodyText": "Other than assertEnrollments(...) above, do you have anything using this method?", "bodyHTML": "<p dir=\"auto\">Other than <code>assertEnrollments(...)</code> above, do you have anything using this method?</p>", "author": "karlmdavis", "createdAt": "2020-12-21T21:56:06Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java", "diffHunk": "@@ -680,6 +743,262 @@ private static RifLoader createLoader(DataSource dataSource, boolean fixupsEnabl\n             defaultOptions.getFixupThreads()));\n   }\n \n+  public static void assertEnrollments(Beneficiary beneficiaryFromDb, int enrollmentSize) {\n+    List<Enrollment> enrollments = beneficiaryFromDb.getEnrollments();\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"01\",\n+        enrollments.get(0),\n+        beneficiaryFromDb.getEntitlementBuyInJanInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyJanCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorJanInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJanCode().get(),\n+        beneficiaryFromDb.getMedicareStatusJanCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberJanId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberJanId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeJanCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberJanId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberJanId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberJanId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"02\",\n+        enrollments.get(1),\n+        beneficiaryFromDb.getEntitlementBuyInFebInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyFebCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorFebInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityFebCode().get(),\n+        beneficiaryFromDb.getMedicareStatusFebCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberFebId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberFebId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeFebCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberFebId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberFebId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberFebId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"03\",\n+        enrollments.get(2),\n+        beneficiaryFromDb.getEntitlementBuyInMarInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyMarCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorMarInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMarCode().get(),\n+        beneficiaryFromDb.getMedicareStatusMarCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberMarId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberMarId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeMarCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberMarId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberMarId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberMarId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"04\",\n+        enrollments.get(3),\n+        beneficiaryFromDb.getEntitlementBuyInAprInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyAprCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorAprInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAprCode().get(),\n+        beneficiaryFromDb.getMedicareStatusAprCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberAprId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberAprId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeAprCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberAprId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberAprId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberAprId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"05\",\n+        enrollments.get(4),\n+        beneficiaryFromDb.getEntitlementBuyInMayInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyMayCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorMayInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMayCode().get(),\n+        beneficiaryFromDb.getMedicareStatusMayCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberMayId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberMayId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeMayCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberMayId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberMayId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberMayId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"06\",\n+        enrollments.get(5),\n+        beneficiaryFromDb.getEntitlementBuyInJunInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyJunCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorJunInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJunCode().get(),\n+        beneficiaryFromDb.getMedicareStatusJunCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberJunId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberJunId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeJunCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberJunId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberJunId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberJunId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"07\",\n+        enrollments.get(6),\n+        beneficiaryFromDb.getEntitlementBuyInJulInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyJulCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorJulInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJulCode().get(),\n+        beneficiaryFromDb.getMedicareStatusJulCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberJulId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberJulId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeJulCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberJulId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberJulId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberJulId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"08\",\n+        enrollments.get(7),\n+        beneficiaryFromDb.getEntitlementBuyInAugInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyAugCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorAugInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAugCode().get(),\n+        beneficiaryFromDb.getMedicareStatusAugCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberAugId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberAugId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeAugCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberAugId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberAugId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberAugId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"09\",\n+        enrollments.get(8),\n+        beneficiaryFromDb.getEntitlementBuyInSeptInd().get(),\n+        beneficiaryFromDb.getFipsStateCntySeptCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorSeptInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode().get(),\n+        beneficiaryFromDb.getMedicareStatusSeptCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberSeptId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberSeptId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeSeptCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberSeptId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberSeptId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberSeptId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"10\",\n+        enrollments.get(9),\n+        beneficiaryFromDb.getEntitlementBuyInOctInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyOctCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorOctInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityOctCode().get(),\n+        beneficiaryFromDb.getMedicareStatusOctCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberOctId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberOctId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeOctCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberOctId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberOctId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberOctId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"11\",\n+        enrollments.get(10),\n+        beneficiaryFromDb.getEntitlementBuyInNovInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyNovCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorNovInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityNovCode().get(),\n+        beneficiaryFromDb.getMedicareStatusNovCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberNovId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberNovId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeNovCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberNovId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberNovId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberNovId().get());\n+\n+    checkEnrollments(\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n+        \"12\",\n+        enrollments.get(11),\n+        beneficiaryFromDb.getEntitlementBuyInDecInd().get(),\n+        beneficiaryFromDb.getFipsStateCntyDecCode().get(),\n+        beneficiaryFromDb.getHmoIndicatorDecInd().get(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityDecCode().get(),\n+        beneficiaryFromDb.getMedicareStatusDecCode().get(),\n+        beneficiaryFromDb.getPartCContractNumberDecId().get(),\n+        beneficiaryFromDb.getPartCPbpNumberDecId().get(),\n+        beneficiaryFromDb.getPartCPlanTypeDecCode().get(),\n+        beneficiaryFromDb.getPartDContractNumberDecId().get(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode().get(),\n+        beneficiaryFromDb.getPartDPbpNumberDecId().get(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd().get(),\n+        beneficiaryFromDb.getPartDSegmentNumberDecId().get());\n+  }\n+\n+  public static void checkEnrollments(", "originalCommit": "e6b8b6ef44e33a316033f02da5f3c177b2e7c612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0Nzg3MA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r547547870", "bodyText": "added it to the original 12 months", "author": "cbrunefearless", "createdAt": "2020-12-22T23:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0OTMwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "02315889d45e6bde459c68591c18e215443f8be4", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex b83081cc0..56ec6b4f2 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -960,12 +963,12 @@ public final class RifLoaderIT {\n         beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode().get(),\n         beneficiaryFromDb.getPartDPbpNumberDecId().get(),\n         beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberDecId().get());\n+        beneficiaryFromDb.getPartDSegmentNumberDecId().get());*/\n   }\n \n   public static void checkEnrollments(\n-      String referenceYear,\n-      String month,\n+      int referenceYear,\n+      int month,\n       Enrollment enrollment,\n       Character entitlementBuyInInd,\n       String fipsStateCntyCode,\n", "next_change": {"commit": "071f7b1669fe94eccdbc1e3cfc86df671e8b114d", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 56ec6b4f2..3cc9c5c60 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -753,254 +753,266 @@ public final class RifLoaderIT {\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         1,\n         enrollments.get(0),\n-        beneficiaryFromDb.getEntitlementBuyInJanInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJanCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJanInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJanCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJanCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJanCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJanId().get());\n+        beneficiaryFromDb.getEntitlementBuyInJanInd(),\n+        beneficiaryFromDb.getFipsStateCntyJanCode(),\n+        beneficiaryFromDb.getHmoIndicatorJanInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJanCode(),\n+        beneficiaryFromDb.getMedicareStatusJanCode(),\n+        beneficiaryFromDb.getPartCContractNumberJanId(),\n+        beneficiaryFromDb.getPartCPbpNumberJanId(),\n+        beneficiaryFromDb.getPartCPlanTypeJanCode(),\n+        beneficiaryFromDb.getPartDContractNumberJanId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJanId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJanId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         2,\n         enrollments.get(1),\n-        beneficiaryFromDb.getEntitlementBuyInFebInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyFebCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorFebInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityFebCode().get(),\n-        beneficiaryFromDb.getMedicareStatusFebCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeFebCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberFebId().get());\n+        beneficiaryFromDb.getEntitlementBuyInFebInd(),\n+        beneficiaryFromDb.getFipsStateCntyFebCode(),\n+        beneficiaryFromDb.getHmoIndicatorFebInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityFebCode(),\n+        beneficiaryFromDb.getMedicareStatusFebCode(),\n+        beneficiaryFromDb.getPartCContractNumberFebId(),\n+        beneficiaryFromDb.getPartCPbpNumberFebId(),\n+        beneficiaryFromDb.getPartCPlanTypeFebCode(),\n+        beneficiaryFromDb.getPartDContractNumberFebId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode(),\n+        beneficiaryFromDb.getPartDPbpNumberFebId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberFebId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         3,\n         enrollments.get(2),\n-        beneficiaryFromDb.getEntitlementBuyInMarInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMarCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMarInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMarCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMarCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMarCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMarId().get());\n+        beneficiaryFromDb.getEntitlementBuyInMarInd(),\n+        beneficiaryFromDb.getFipsStateCntyMarCode(),\n+        beneficiaryFromDb.getHmoIndicatorMarInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMarCode(),\n+        beneficiaryFromDb.getMedicareStatusMarCode(),\n+        beneficiaryFromDb.getPartCContractNumberMarId(),\n+        beneficiaryFromDb.getPartCPbpNumberMarId(),\n+        beneficiaryFromDb.getPartCPlanTypeMarCode(),\n+        beneficiaryFromDb.getPartDContractNumberMarId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMarId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMarId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         4,\n         enrollments.get(3),\n-        beneficiaryFromDb.getEntitlementBuyInAprInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAprCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAprInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAprCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAprCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAprCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAprId().get());\n+        beneficiaryFromDb.getEntitlementBuyInAprInd(),\n+        beneficiaryFromDb.getFipsStateCntyAprCode(),\n+        beneficiaryFromDb.getHmoIndicatorAprInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAprCode(),\n+        beneficiaryFromDb.getMedicareStatusAprCode(),\n+        beneficiaryFromDb.getPartCContractNumberAprId(),\n+        beneficiaryFromDb.getPartCPbpNumberAprId(),\n+        beneficiaryFromDb.getPartCPlanTypeAprCode(),\n+        beneficiaryFromDb.getPartDContractNumberAprId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAprId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAprId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         5,\n         enrollments.get(4),\n-        beneficiaryFromDb.getEntitlementBuyInMayInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMayCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMayInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMayCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMayCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMayCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMayId().get());\n+        beneficiaryFromDb.getEntitlementBuyInMayInd(),\n+        beneficiaryFromDb.getFipsStateCntyMayCode(),\n+        beneficiaryFromDb.getHmoIndicatorMayInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMayCode(),\n+        beneficiaryFromDb.getMedicareStatusMayCode(),\n+        beneficiaryFromDb.getPartCContractNumberMayId(),\n+        beneficiaryFromDb.getPartCPbpNumberMayId(),\n+        beneficiaryFromDb.getPartCPlanTypeMayCode(),\n+        beneficiaryFromDb.getPartDContractNumberMayId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMayId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMayId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         6,\n         enrollments.get(5),\n-        beneficiaryFromDb.getEntitlementBuyInJunInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJunCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJunInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJunCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJunCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJunCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJunId().get());\n+        beneficiaryFromDb.getEntitlementBuyInJunInd(),\n+        beneficiaryFromDb.getFipsStateCntyJunCode(),\n+        beneficiaryFromDb.getHmoIndicatorJunInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJunCode(),\n+        beneficiaryFromDb.getMedicareStatusJunCode(),\n+        beneficiaryFromDb.getPartCContractNumberJunId(),\n+        beneficiaryFromDb.getPartCPbpNumberJunId(),\n+        beneficiaryFromDb.getPartCPlanTypeJunCode(),\n+        beneficiaryFromDb.getPartDContractNumberJunId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJunId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJunId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         7,\n         enrollments.get(6),\n-        beneficiaryFromDb.getEntitlementBuyInJulInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJulCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJulInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJulCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJulCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJulCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJulId().get());\n+        beneficiaryFromDb.getEntitlementBuyInJulInd(),\n+        beneficiaryFromDb.getFipsStateCntyJulCode(),\n+        beneficiaryFromDb.getHmoIndicatorJulInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJulCode(),\n+        beneficiaryFromDb.getMedicareStatusJulCode(),\n+        beneficiaryFromDb.getPartCContractNumberJulId(),\n+        beneficiaryFromDb.getPartCPbpNumberJulId(),\n+        beneficiaryFromDb.getPartCPlanTypeJulCode(),\n+        beneficiaryFromDb.getPartDContractNumberJulId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJulId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJulId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         8,\n         enrollments.get(7),\n-        beneficiaryFromDb.getEntitlementBuyInAugInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAugCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAugInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAugCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAugCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAugCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAugId().get());\n+        beneficiaryFromDb.getEntitlementBuyInAugInd(),\n+        beneficiaryFromDb.getFipsStateCntyAugCode(),\n+        beneficiaryFromDb.getHmoIndicatorAugInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAugCode(),\n+        beneficiaryFromDb.getMedicareStatusAugCode(),\n+        beneficiaryFromDb.getPartCContractNumberAugId(),\n+        beneficiaryFromDb.getPartCPbpNumberAugId(),\n+        beneficiaryFromDb.getPartCPlanTypeAugCode(),\n+        beneficiaryFromDb.getPartDContractNumberAugId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAugId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAugId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         9,\n         enrollments.get(8),\n-        beneficiaryFromDb.getEntitlementBuyInSeptInd().get(),\n-        beneficiaryFromDb.getFipsStateCntySeptCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorSeptInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode().get(),\n-        beneficiaryFromDb.getMedicareStatusSeptCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeSeptCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberSeptId().get());\n+        beneficiaryFromDb.getEntitlementBuyInSeptInd(),\n+        beneficiaryFromDb.getFipsStateCntySeptCode(),\n+        beneficiaryFromDb.getHmoIndicatorSeptInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode(),\n+        beneficiaryFromDb.getMedicareStatusSeptCode(),\n+        beneficiaryFromDb.getPartCContractNumberSeptId(),\n+        beneficiaryFromDb.getPartCPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartCPlanTypeSeptCode(),\n+        beneficiaryFromDb.getPartDContractNumberSeptId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode(),\n+        beneficiaryFromDb.getPartDPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberSeptId());\n \n     checkEnrollments(\n         beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n         10,\n         enrollments.get(9),\n-        beneficiaryFromDb.getEntitlementBuyInOctInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyOctCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorOctInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityOctCode().get(),\n-        beneficiaryFromDb.getMedicareStatusOctCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeOctCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberOctId().get());\n-    /*\n+        beneficiaryFromDb.getEntitlementBuyInOctInd(),\n+        beneficiaryFromDb.getFipsStateCntyOctCode(),\n+        beneficiaryFromDb.getHmoIndicatorOctInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityOctCode(),\n+        beneficiaryFromDb.getMedicareStatusOctCode(),\n+        beneficiaryFromDb.getPartCContractNumberOctId(),\n+        beneficiaryFromDb.getPartCPbpNumberOctId(),\n+        beneficiaryFromDb.getPartCPlanTypeOctCode(),\n+        beneficiaryFromDb.getPartDContractNumberOctId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode(),\n+        beneficiaryFromDb.getPartDPbpNumberOctId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberOctId());\n+\n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"11\",\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        11,\n         enrollments.get(10),\n-        beneficiaryFromDb.getEntitlementBuyInNovInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyNovCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorNovInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityNovCode().get(),\n-        beneficiaryFromDb.getMedicareStatusNovCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeNovCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberNovId().get());\n+        beneficiaryFromDb.getEntitlementBuyInNovInd(),\n+        beneficiaryFromDb.getFipsStateCntyNovCode(),\n+        beneficiaryFromDb.getHmoIndicatorNovInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityNovCode(),\n+        beneficiaryFromDb.getMedicareStatusNovCode(),\n+        beneficiaryFromDb.getPartCContractNumberNovId(),\n+        beneficiaryFromDb.getPartCPbpNumberNovId(),\n+        beneficiaryFromDb.getPartCPlanTypeNovCode(),\n+        beneficiaryFromDb.getPartDContractNumberNovId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode(),\n+        beneficiaryFromDb.getPartDPbpNumberNovId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberNovId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"12\",\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        12,\n         enrollments.get(11),\n-        beneficiaryFromDb.getEntitlementBuyInDecInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyDecCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorDecInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityDecCode().get(),\n-        beneficiaryFromDb.getMedicareStatusDecCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeDecCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberDecId().get());*/\n+        beneficiaryFromDb.getEntitlementBuyInDecInd(),\n+        beneficiaryFromDb.getFipsStateCntyDecCode(),\n+        beneficiaryFromDb.getHmoIndicatorDecInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityDecCode(),\n+        beneficiaryFromDb.getMedicareStatusDecCode(),\n+        beneficiaryFromDb.getPartCContractNumberDecId(),\n+        beneficiaryFromDb.getPartCPbpNumberDecId(),\n+        beneficiaryFromDb.getPartCPlanTypeDecCode(),\n+        beneficiaryFromDb.getPartDContractNumberDecId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode(),\n+        beneficiaryFromDb.getPartDPbpNumberDecId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberDecId());\n   }\n \n   public static void checkEnrollments(\n       int referenceYear,\n       int month,\n       Enrollment enrollment,\n-      Character entitlementBuyInInd,\n-      String fipsStateCntyCode,\n-      Character hmoIndicatorInd,\n-      String medicaidDualEligibilityCode,\n-      String medicareStatusCode,\n-      String partCContractNumberId,\n-      String partCPbpNumberId,\n-      String partCPlanTypeCode,\n-      String partDContractNumberId,\n-      String partDLowIncomeCostShareGroupCode,\n-      String partDPbpNumberId,\n-      Character partDRetireeDrugSubsidyInd,\n-      String partDSegmentNumberId) {\n+      Optional<Character> entitlementBuyInInd,\n+      Optional<String> fipsStateCntyCode,\n+      Optional<Character> hmoIndicatorInd,\n+      Optional<String> medicaidDualEligibilityCode,\n+      Optional<String> medicareStatusCode,\n+      Optional<String> partCContractNumberId,\n+      Optional<String> partCPbpNumberId,\n+      Optional<String> partCPlanTypeCode,\n+      Optional<String> partDContractNumberId,\n+      Optional<String> partDLowIncomeCostShareGroupCode,\n+      Optional<String> partDPbpNumberId,\n+      Optional<Character> partDRetireeDrugSubsidyInd,\n+      Optional<String> partDSegmentNumberId) {\n \n     Assert.assertEquals(LocalDate.of(referenceYear, month, 1), enrollment.getYearMonth());\n-    Assert.assertEquals(entitlementBuyInInd, enrollment.getEntitlementBuyInInd().get());\n-    Assert.assertEquals(fipsStateCntyCode, enrollment.getFipsStateCntyCode().get());\n-    Assert.assertEquals(hmoIndicatorInd, enrollment.getHmoIndicatorInd().get());\n     Assert.assertEquals(\n-        medicaidDualEligibilityCode, enrollment.getMedicaidDualEligibilityCode().get());\n-    Assert.assertEquals(medicareStatusCode, enrollment.getMedicareStatusCode().get());\n-    Assert.assertEquals(partCContractNumberId, enrollment.getPartCContractNumberId().get());\n-    Assert.assertEquals(partCPbpNumberId, enrollment.getPartCPbpNumberId().get());\n-    Assert.assertEquals(partCPlanTypeCode, enrollment.getPartCPlanTypeCode().get());\n-    Assert.assertEquals(partDContractNumberId, enrollment.getPartDContractNumberId().get());\n+        entitlementBuyInInd.orElse(null), enrollment.getEntitlementBuyInInd().orElse(null));\n+    Assert.assertEquals(\n+        fipsStateCntyCode.orElse(null), enrollment.getFipsStateCntyCode().orElse(null));\n+    Assert.assertEquals(hmoIndicatorInd.orElse(null), enrollment.getHmoIndicatorInd().orElse(null));\n+    Assert.assertEquals(\n+        medicaidDualEligibilityCode.orElse(null),\n+        enrollment.getMedicaidDualEligibilityCode().orElse(null));\n+    Assert.assertEquals(\n+        medicareStatusCode.orElse(null), enrollment.getMedicareStatusCode().orElse(null));\n+    Assert.assertEquals(\n+        partCContractNumberId.orElse(null), enrollment.getPartCContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPbpNumberId.orElse(null), enrollment.getPartCPbpNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPlanTypeCode.orElse(null), enrollment.getPartCPlanTypeCode().orElse(null));\n+    Assert.assertEquals(\n+        partDContractNumberId.orElse(null), enrollment.getPartDContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partDLowIncomeCostShareGroupCode.orElse(null),\n+        enrollment.getPartDLowIncomeCostShareGroupCode().orElse(null));\n+    Assert.assertEquals(\n+        partDPbpNumberId.orElse(null), enrollment.getPartDPbpNumberId().orElse(null));\n     Assert.assertEquals(\n-        partDLowIncomeCostShareGroupCode, enrollment.getPartDLowIncomeCostShareGroupCode().get());\n-    Assert.assertEquals(partDPbpNumberId, enrollment.getPartDPbpNumberId().get());\n+        partDRetireeDrugSubsidyInd.orElse(null),\n+        enrollment.getPartDRetireeDrugSubsidyInd().orElse(null));\n     Assert.assertEquals(\n-        partDRetireeDrugSubsidyInd, enrollment.getPartDRetireeDrugSubsidyInd().get());\n-    Assert.assertEquals(partDSegmentNumberId, enrollment.getPartDSegmentNumberId().get());\n+        partDSegmentNumberId.orElse(null), enrollment.getPartDSegmentNumberId().orElse(null));\n   }\n   /**\n    * Clear the MBI hash fields in the db\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex b83081cc0..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -743,261 +860,273 @@ public final class RifLoaderIT {\n             defaultOptions.getFixupThreads()));\n   }\n \n-  public static void assertEnrollments(Beneficiary beneficiaryFromDb, int enrollmentSize) {\n-    List<Enrollment> enrollments = beneficiaryFromDb.getEnrollments();\n+  public static void assertBeneficiaryMonthly(Beneficiary beneficiaryFromDb) {\n+    List<BeneficiaryMonthly> beneficiaryMonthly = beneficiaryFromDb.getBeneficiaryMonthlys();\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"01\",\n-        enrollments.get(0),\n-        beneficiaryFromDb.getEntitlementBuyInJanInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJanCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJanInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJanCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJanCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJanCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJanId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJanId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJanId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        1,\n+        beneficiaryMonthly.get(0),\n+        beneficiaryFromDb.getEntitlementBuyInJanInd(),\n+        beneficiaryFromDb.getFipsStateCntyJanCode(),\n+        beneficiaryFromDb.getHmoIndicatorJanInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJanCode(),\n+        beneficiaryFromDb.getMedicareStatusJanCode(),\n+        beneficiaryFromDb.getPartCContractNumberJanId(),\n+        beneficiaryFromDb.getPartCPbpNumberJanId(),\n+        beneficiaryFromDb.getPartCPlanTypeJanCode(),\n+        beneficiaryFromDb.getPartDContractNumberJanId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJanCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJanId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJanInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJanId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"02\",\n-        enrollments.get(1),\n-        beneficiaryFromDb.getEntitlementBuyInFebInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyFebCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorFebInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityFebCode().get(),\n-        beneficiaryFromDb.getMedicareStatusFebCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeFebCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberFebId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberFebId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberFebId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        2,\n+        beneficiaryMonthly.get(1),\n+        beneficiaryFromDb.getEntitlementBuyInFebInd(),\n+        beneficiaryFromDb.getFipsStateCntyFebCode(),\n+        beneficiaryFromDb.getHmoIndicatorFebInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityFebCode(),\n+        beneficiaryFromDb.getMedicareStatusFebCode(),\n+        beneficiaryFromDb.getPartCContractNumberFebId(),\n+        beneficiaryFromDb.getPartCPbpNumberFebId(),\n+        beneficiaryFromDb.getPartCPlanTypeFebCode(),\n+        beneficiaryFromDb.getPartDContractNumberFebId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupFebCode(),\n+        beneficiaryFromDb.getPartDPbpNumberFebId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyFebInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberFebId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"03\",\n-        enrollments.get(2),\n-        beneficiaryFromDb.getEntitlementBuyInMarInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMarCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMarInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMarCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMarCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMarCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMarId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMarId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMarId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        3,\n+        beneficiaryMonthly.get(2),\n+        beneficiaryFromDb.getEntitlementBuyInMarInd(),\n+        beneficiaryFromDb.getFipsStateCntyMarCode(),\n+        beneficiaryFromDb.getHmoIndicatorMarInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMarCode(),\n+        beneficiaryFromDb.getMedicareStatusMarCode(),\n+        beneficiaryFromDb.getPartCContractNumberMarId(),\n+        beneficiaryFromDb.getPartCPbpNumberMarId(),\n+        beneficiaryFromDb.getPartCPlanTypeMarCode(),\n+        beneficiaryFromDb.getPartDContractNumberMarId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMarCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMarId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMarInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMarId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"04\",\n-        enrollments.get(3),\n-        beneficiaryFromDb.getEntitlementBuyInAprInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAprCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAprInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAprCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAprCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAprCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAprId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAprId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAprId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        4,\n+        beneficiaryMonthly.get(3),\n+        beneficiaryFromDb.getEntitlementBuyInAprInd(),\n+        beneficiaryFromDb.getFipsStateCntyAprCode(),\n+        beneficiaryFromDb.getHmoIndicatorAprInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAprCode(),\n+        beneficiaryFromDb.getMedicareStatusAprCode(),\n+        beneficiaryFromDb.getPartCContractNumberAprId(),\n+        beneficiaryFromDb.getPartCPbpNumberAprId(),\n+        beneficiaryFromDb.getPartCPlanTypeAprCode(),\n+        beneficiaryFromDb.getPartDContractNumberAprId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAprCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAprId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAprInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAprId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"05\",\n-        enrollments.get(4),\n-        beneficiaryFromDb.getEntitlementBuyInMayInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyMayCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorMayInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityMayCode().get(),\n-        beneficiaryFromDb.getMedicareStatusMayCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeMayCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberMayId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberMayId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberMayId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        5,\n+        beneficiaryMonthly.get(4),\n+        beneficiaryFromDb.getEntitlementBuyInMayInd(),\n+        beneficiaryFromDb.getFipsStateCntyMayCode(),\n+        beneficiaryFromDb.getHmoIndicatorMayInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityMayCode(),\n+        beneficiaryFromDb.getMedicareStatusMayCode(),\n+        beneficiaryFromDb.getPartCContractNumberMayId(),\n+        beneficiaryFromDb.getPartCPbpNumberMayId(),\n+        beneficiaryFromDb.getPartCPlanTypeMayCode(),\n+        beneficiaryFromDb.getPartDContractNumberMayId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupMayCode(),\n+        beneficiaryFromDb.getPartDPbpNumberMayId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyMayInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberMayId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"06\",\n-        enrollments.get(5),\n-        beneficiaryFromDb.getEntitlementBuyInJunInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJunCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJunInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJunCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJunCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJunCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJunId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJunId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJunId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        6,\n+        beneficiaryMonthly.get(5),\n+        beneficiaryFromDb.getEntitlementBuyInJunInd(),\n+        beneficiaryFromDb.getFipsStateCntyJunCode(),\n+        beneficiaryFromDb.getHmoIndicatorJunInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJunCode(),\n+        beneficiaryFromDb.getMedicareStatusJunCode(),\n+        beneficiaryFromDb.getPartCContractNumberJunId(),\n+        beneficiaryFromDb.getPartCPbpNumberJunId(),\n+        beneficiaryFromDb.getPartCPlanTypeJunCode(),\n+        beneficiaryFromDb.getPartDContractNumberJunId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJunCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJunId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJunInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJunId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"07\",\n-        enrollments.get(6),\n-        beneficiaryFromDb.getEntitlementBuyInJulInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyJulCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorJulInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityJulCode().get(),\n-        beneficiaryFromDb.getMedicareStatusJulCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeJulCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberJulId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberJulId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberJulId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        7,\n+        beneficiaryMonthly.get(6),\n+        beneficiaryFromDb.getEntitlementBuyInJulInd(),\n+        beneficiaryFromDb.getFipsStateCntyJulCode(),\n+        beneficiaryFromDb.getHmoIndicatorJulInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityJulCode(),\n+        beneficiaryFromDb.getMedicareStatusJulCode(),\n+        beneficiaryFromDb.getPartCContractNumberJulId(),\n+        beneficiaryFromDb.getPartCPbpNumberJulId(),\n+        beneficiaryFromDb.getPartCPlanTypeJulCode(),\n+        beneficiaryFromDb.getPartDContractNumberJulId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupJulCode(),\n+        beneficiaryFromDb.getPartDPbpNumberJulId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyJulInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberJulId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"08\",\n-        enrollments.get(7),\n-        beneficiaryFromDb.getEntitlementBuyInAugInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyAugCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorAugInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityAugCode().get(),\n-        beneficiaryFromDb.getMedicareStatusAugCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeAugCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberAugId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberAugId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberAugId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        8,\n+        beneficiaryMonthly.get(7),\n+        beneficiaryFromDb.getEntitlementBuyInAugInd(),\n+        beneficiaryFromDb.getFipsStateCntyAugCode(),\n+        beneficiaryFromDb.getHmoIndicatorAugInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityAugCode(),\n+        beneficiaryFromDb.getMedicareStatusAugCode(),\n+        beneficiaryFromDb.getPartCContractNumberAugId(),\n+        beneficiaryFromDb.getPartCPbpNumberAugId(),\n+        beneficiaryFromDb.getPartCPlanTypeAugCode(),\n+        beneficiaryFromDb.getPartDContractNumberAugId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupAugCode(),\n+        beneficiaryFromDb.getPartDPbpNumberAugId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyAugInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberAugId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"09\",\n-        enrollments.get(8),\n-        beneficiaryFromDb.getEntitlementBuyInSeptInd().get(),\n-        beneficiaryFromDb.getFipsStateCntySeptCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorSeptInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode().get(),\n-        beneficiaryFromDb.getMedicareStatusSeptCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeSeptCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberSeptId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberSeptId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        9,\n+        beneficiaryMonthly.get(8),\n+        beneficiaryFromDb.getEntitlementBuyInSeptInd(),\n+        beneficiaryFromDb.getFipsStateCntySeptCode(),\n+        beneficiaryFromDb.getHmoIndicatorSeptInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilitySeptCode(),\n+        beneficiaryFromDb.getMedicareStatusSeptCode(),\n+        beneficiaryFromDb.getPartCContractNumberSeptId(),\n+        beneficiaryFromDb.getPartCPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartCPlanTypeSeptCode(),\n+        beneficiaryFromDb.getPartDContractNumberSeptId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupSeptCode(),\n+        beneficiaryFromDb.getPartDPbpNumberSeptId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidySeptInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberSeptId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"10\",\n-        enrollments.get(9),\n-        beneficiaryFromDb.getEntitlementBuyInOctInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyOctCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorOctInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityOctCode().get(),\n-        beneficiaryFromDb.getMedicareStatusOctCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeOctCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberOctId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberOctId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberOctId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        10,\n+        beneficiaryMonthly.get(9),\n+        beneficiaryFromDb.getEntitlementBuyInOctInd(),\n+        beneficiaryFromDb.getFipsStateCntyOctCode(),\n+        beneficiaryFromDb.getHmoIndicatorOctInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityOctCode(),\n+        beneficiaryFromDb.getMedicareStatusOctCode(),\n+        beneficiaryFromDb.getPartCContractNumberOctId(),\n+        beneficiaryFromDb.getPartCPbpNumberOctId(),\n+        beneficiaryFromDb.getPartCPlanTypeOctCode(),\n+        beneficiaryFromDb.getPartDContractNumberOctId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupOctCode(),\n+        beneficiaryFromDb.getPartDPbpNumberOctId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyOctInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberOctId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"11\",\n-        enrollments.get(10),\n-        beneficiaryFromDb.getEntitlementBuyInNovInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyNovCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorNovInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityNovCode().get(),\n-        beneficiaryFromDb.getMedicareStatusNovCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeNovCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberNovId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberNovId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberNovId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        11,\n+        beneficiaryMonthly.get(10),\n+        beneficiaryFromDb.getEntitlementBuyInNovInd(),\n+        beneficiaryFromDb.getFipsStateCntyNovCode(),\n+        beneficiaryFromDb.getHmoIndicatorNovInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityNovCode(),\n+        beneficiaryFromDb.getMedicareStatusNovCode(),\n+        beneficiaryFromDb.getPartCContractNumberNovId(),\n+        beneficiaryFromDb.getPartCPbpNumberNovId(),\n+        beneficiaryFromDb.getPartCPlanTypeNovCode(),\n+        beneficiaryFromDb.getPartDContractNumberNovId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupNovCode(),\n+        beneficiaryFromDb.getPartDPbpNumberNovId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyNovInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberNovId());\n \n     checkEnrollments(\n-        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().toString(),\n-        \"12\",\n-        enrollments.get(11),\n-        beneficiaryFromDb.getEntitlementBuyInDecInd().get(),\n-        beneficiaryFromDb.getFipsStateCntyDecCode().get(),\n-        beneficiaryFromDb.getHmoIndicatorDecInd().get(),\n-        beneficiaryFromDb.getMedicaidDualEligibilityDecCode().get(),\n-        beneficiaryFromDb.getMedicareStatusDecCode().get(),\n-        beneficiaryFromDb.getPartCContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartCPlanTypeDecCode().get(),\n-        beneficiaryFromDb.getPartDContractNumberDecId().get(),\n-        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode().get(),\n-        beneficiaryFromDb.getPartDPbpNumberDecId().get(),\n-        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd().get(),\n-        beneficiaryFromDb.getPartDSegmentNumberDecId().get());\n+        beneficiaryFromDb.getBeneEnrollmentReferenceYear().get().intValue(),\n+        12,\n+        beneficiaryMonthly.get(11),\n+        beneficiaryFromDb.getEntitlementBuyInDecInd(),\n+        beneficiaryFromDb.getFipsStateCntyDecCode(),\n+        beneficiaryFromDb.getHmoIndicatorDecInd(),\n+        beneficiaryFromDb.getMedicaidDualEligibilityDecCode(),\n+        beneficiaryFromDb.getMedicareStatusDecCode(),\n+        beneficiaryFromDb.getPartCContractNumberDecId(),\n+        beneficiaryFromDb.getPartCPbpNumberDecId(),\n+        beneficiaryFromDb.getPartCPlanTypeDecCode(),\n+        beneficiaryFromDb.getPartDContractNumberDecId(),\n+        beneficiaryFromDb.getPartDLowIncomeCostShareGroupDecCode(),\n+        beneficiaryFromDb.getPartDPbpNumberDecId(),\n+        beneficiaryFromDb.getPartDRetireeDrugSubsidyDecInd(),\n+        beneficiaryFromDb.getPartDSegmentNumberDecId());\n   }\n \n   public static void checkEnrollments(\n-      String referenceYear,\n-      String month,\n-      Enrollment enrollment,\n-      Character entitlementBuyInInd,\n-      String fipsStateCntyCode,\n-      Character hmoIndicatorInd,\n-      String medicaidDualEligibilityCode,\n-      String medicareStatusCode,\n-      String partCContractNumberId,\n-      String partCPbpNumberId,\n-      String partCPlanTypeCode,\n-      String partDContractNumberId,\n-      String partDLowIncomeCostShareGroupCode,\n-      String partDPbpNumberId,\n-      Character partDRetireeDrugSubsidyInd,\n-      String partDSegmentNumberId) {\n-\n-    Assert.assertEquals(String.format(\"%s-%s\", referenceYear, month), enrollment.getYearMonth());\n-    Assert.assertEquals(entitlementBuyInInd, enrollment.getEntitlementBuyInInd().get());\n-    Assert.assertEquals(fipsStateCntyCode, enrollment.getFipsStateCntyCode().get());\n-    Assert.assertEquals(hmoIndicatorInd, enrollment.getHmoIndicatorInd().get());\n+      int referenceYear,\n+      int month,\n+      BeneficiaryMonthly enrollment,\n+      Optional<Character> entitlementBuyInInd,\n+      Optional<String> fipsStateCntyCode,\n+      Optional<Character> hmoIndicatorInd,\n+      Optional<String> medicaidDualEligibilityCode,\n+      Optional<String> medicareStatusCode,\n+      Optional<String> partCContractNumberId,\n+      Optional<String> partCPbpNumberId,\n+      Optional<String> partCPlanTypeCode,\n+      Optional<String> partDContractNumberId,\n+      Optional<String> partDLowIncomeCostShareGroupCode,\n+      Optional<String> partDPbpNumberId,\n+      Optional<Character> partDRetireeDrugSubsidyInd,\n+      Optional<String> partDSegmentNumberId) {\n+\n+    Assert.assertEquals(LocalDate.of(referenceYear, month, 1), enrollment.getYearMonth());\n+    Assert.assertEquals(\n+        entitlementBuyInInd.orElse(null), enrollment.getEntitlementBuyInInd().orElse(null));\n+    Assert.assertEquals(\n+        fipsStateCntyCode.orElse(null), enrollment.getFipsStateCntyCode().orElse(null));\n+    Assert.assertEquals(hmoIndicatorInd.orElse(null), enrollment.getHmoIndicatorInd().orElse(null));\n+    Assert.assertEquals(\n+        medicaidDualEligibilityCode.orElse(null),\n+        enrollment.getMedicaidDualEligibilityCode().orElse(null));\n+    Assert.assertEquals(\n+        medicareStatusCode.orElse(null), enrollment.getMedicareStatusCode().orElse(null));\n+    Assert.assertEquals(\n+        partCContractNumberId.orElse(null), enrollment.getPartCContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPbpNumberId.orElse(null), enrollment.getPartCPbpNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partCPlanTypeCode.orElse(null), enrollment.getPartCPlanTypeCode().orElse(null));\n+    Assert.assertEquals(\n+        partDContractNumberId.orElse(null), enrollment.getPartDContractNumberId().orElse(null));\n+    Assert.assertEquals(\n+        partDLowIncomeCostShareGroupCode.orElse(null),\n+        enrollment.getPartDLowIncomeCostShareGroupCode().orElse(null));\n     Assert.assertEquals(\n-        medicaidDualEligibilityCode, enrollment.getMedicaidDualEligibilityCode().get());\n-    Assert.assertEquals(medicareStatusCode, enrollment.getMedicareStatusCode().get());\n-    Assert.assertEquals(partCContractNumberId, enrollment.getPartCContractNumberId().get());\n-    Assert.assertEquals(partCPbpNumberId, enrollment.getPartCPbpNumberId().get());\n-    Assert.assertEquals(partCPlanTypeCode, enrollment.getPartCPlanTypeCode().get());\n-    Assert.assertEquals(partDContractNumberId, enrollment.getPartDContractNumberId().get());\n+        partDPbpNumberId.orElse(null), enrollment.getPartDPbpNumberId().orElse(null));\n     Assert.assertEquals(\n-        partDLowIncomeCostShareGroupCode, enrollment.getPartDLowIncomeCostShareGroupCode().get());\n-    Assert.assertEquals(partDPbpNumberId, enrollment.getPartDPbpNumberId().get());\n+        partDRetireeDrugSubsidyInd.orElse(null),\n+        enrollment.getPartDRetireeDrugSubsidyInd().orElse(null));\n     Assert.assertEquals(\n-        partDRetireeDrugSubsidyInd, enrollment.getPartDRetireeDrugSubsidyInd().get());\n-    Assert.assertEquals(partDSegmentNumberId, enrollment.getPartDSegmentNumberId().get());\n+        partDSegmentNumberId.orElse(null), enrollment.getPartDSegmentNumberId().orElse(null));\n   }\n   /**\n    * Clear the MBI hash fields in the db\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk1NDg1OQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r546954859", "body": "I can't quite work out in my head if your logic above will correctly handle adding a month or two of data to the current year correctly...\r\n\r\nYou don't really have test coverage for that, so I'd suggest adding it. Maybe just as another step in this test case: what happens when one of the fields moves up to having ten months of data?", "bodyText": "I can't quite work out in my head if your logic above will correctly handle adding a month or two of data to the current year correctly...\nYou don't really have test coverage for that, so I'd suggest adding it. Maybe just as another step in this test case: what happens when one of the fields moves up to having ten months of data?", "bodyHTML": "<p dir=\"auto\">I can't quite work out in my head if your logic above will correctly handle adding a month or two of data to the current year correctly...</p>\n<p dir=\"auto\">You don't really have test coverage for that, so I'd suggest adding it. Maybe just as another step in this test case: what happens when one of the fields moves up to having ten months of data?</p>", "author": "karlmdavis", "createdAt": "2020-12-21T22:10:43Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java", "diffHunk": "@@ -316,6 +317,68 @@ public void loadSampleUUnchanged() {\n       if (entityManager != null) entityManager.close();\n     }\n   }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount12() {\n+    DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+\n+    LoadAppOptions options = RifLoaderTestUtils.getLoadOptions(dataSource);\n+    EntityManagerFactory entityManagerFactory =\n+        RifLoaderTestUtils.createEntityManagerFactory(options);\n+    EntityManager entityManager = null;\n+    try {\n+      entityManager = entityManagerFactory.createEntityManager();\n+      Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      Assert.assertEquals(12, beneficiaryFromDb.getEnrollments().size());\n+\n+    } finally {\n+      if (entityManager != null) entityManager.close();\n+    }\n+  }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount24() {\n+    DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+\n+    LoadAppOptions options = RifLoaderTestUtils.getLoadOptions(dataSource);\n+    EntityManagerFactory entityManagerFactory =\n+        RifLoaderTestUtils.createEntityManagerFactory(options);\n+    EntityManager entityManager = null;\n+    try {\n+      entityManager = entityManagerFactory.createEntityManager();\n+\n+      Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      Assert.assertEquals(24, beneficiaryFromDb.getEnrollments().size());\n+    } finally {\n+      if (entityManager != null) entityManager.close();\n+    }\n+  }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount20SinceThereIsAUpdateOf8Months() {", "originalCommit": "e6b8b6ef44e33a316033f02da5f3c177b2e7c612", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNDI5Nw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549504297", "bodyText": "talked about if it makes sense to leave it this way with karl", "author": "cbrunefearless", "createdAt": "2020-12-28T22:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk1NDg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MjAwOQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549562009", "bodyText": "I think I said something like, \"if I were you and could reason my way to having a lot of confidence in the above logic, I might skip adding the test -- otherwise, I'd double-check myself by adding a test case for it: what happens when we go from having just monthly data for 2020-01 to also having the data for 2020-02?\"", "author": "karlmdavis", "createdAt": "2020-12-29T04:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk1NDg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU5NDE2Nw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549594167", "bodyText": "added an extra test for august to sept and how the file in sept could update fields in august.", "author": "cbrunefearless", "createdAt": "2020-12-29T07:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk1NDg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex b83081cc0..0e5b43f8f 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -351,7 +352,7 @@ public final class RifLoaderIT {\n       entityManager = entityManagerFactory.createEntityManager();\n \n       Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n-      Assert.assertEquals(24, beneficiaryFromDb.getEnrollments().size());\n+      Assert.assertEquals(24, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n     } finally {\n       if (entityManager != null) entityManager.close();\n     }\n", "next_change": {"commit": "d902e4d41a060ab4b5a11d24450924773e7607e8", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 0e5b43f8f..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -352,17 +365,25 @@ public final class RifLoaderIT {\n       entityManager = entityManagerFactory.createEntityManager();\n \n       Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      // Checks to make sure we have 2 years or 24 months of data\n       Assert.assertEquals(24, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n     } finally {\n       if (entityManager != null) entityManager.close();\n     }\n   }\n \n+  /*\n+   * This test checks that all enrollment data for 2 years has been loaded into the beneficiary\n+   * monthly table and than does an update of 8 years without the 4 other months for the year\n+   */\n   @Test\n   public void loadInitialEnrollmentShouldCount20SinceThereIsAUpdateOf8Months() {\n     DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    // Loads first year of data\n     loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+    // Loads second year of data\n     loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+    // Loads  second year of data with only 8 months\n     loadSample(\n         dataSource,\n         Arrays.asList(StaticRifResourceGroup.SAMPLE_U_BENES_CHANGED_WITH_8_MONTHS.getResources()));\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex b83081cc0..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -351,17 +365,25 @@ public final class RifLoaderIT {\n       entityManager = entityManagerFactory.createEntityManager();\n \n       Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n-      Assert.assertEquals(24, beneficiaryFromDb.getEnrollments().size());\n+      // Checks to make sure we have 2 years or 24 months of data\n+      Assert.assertEquals(24, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n     } finally {\n       if (entityManager != null) entityManager.close();\n     }\n   }\n \n+  /*\n+   * This test checks that all enrollment data for 2 years has been loaded into the beneficiary\n+   * monthly table and than does an update of 8 years without the 4 other months for the year\n+   */\n   @Test\n   public void loadInitialEnrollmentShouldCount20SinceThereIsAUpdateOf8Months() {\n     DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    // Loads first year of data\n     loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+    // Loads second year of data\n     loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+    // Loads  second year of data with only 8 months\n     loadSample(\n         dataSource,\n         Arrays.asList(StaticRifResourceGroup.SAMPLE_U_BENES_CHANGED_WITH_8_MONTHS.getResources()));\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"oid": "0f34efe64addf5fd899b01913c289c053bd96eed", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/0f34efe64addf5fd899b01913c289c053bd96eed", "message": "Changes to yearMonth", "committedDate": "2020-12-22T16:29:09Z", "type": "commit"}, {"oid": "665bbc2645e50cc7669d7863118ebfcdae08fcbe", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/665bbc2645e50cc7669d7863118ebfcdae08fcbe", "message": "Push changes", "committedDate": "2020-12-22T18:02:58Z", "type": "commit"}, {"oid": "9cfb811236d69505ae01b4a6d695dda28a105f00", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/9cfb811236d69505ae01b4a6d695dda28a105f00", "message": "Fixed Enrollment date types.\n\nBFD-549", "committedDate": "2020-12-22T18:43:08Z", "type": "commit"}, {"oid": "02315889d45e6bde459c68591c18e215443f8be4", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/02315889d45e6bde459c68591c18e215443f8be4", "message": "Added tests", "committedDate": "2020-12-22T21:56:18Z", "type": "commit"}, {"oid": "071f7b1669fe94eccdbc1e3cfc86df671e8b114d", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/071f7b1669fe94eccdbc1e3cfc86df671e8b114d", "message": "Added integration tests", "committedDate": "2020-12-22T22:32:08Z", "type": "commit"}, {"oid": "329c8fa55b30efc7c55bde08af758890f0fffafa", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/329c8fa55b30efc7c55bde08af758890f0fffafa", "message": "Deleted a test file i committed", "committedDate": "2020-12-22T22:40:10Z", "type": "commit"}, {"oid": "debc33cd5ea95d6af6c6de0962eaef8e03c84137", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/debc33cd5ea95d6af6c6de0962eaef8e03c84137", "message": "Changed database format", "committedDate": "2020-12-22T23:19:56Z", "type": "commit"}, {"oid": "ef59aff92a646a5321e7834cf1f69e10254b65ad", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/ef59aff92a646a5321e7834cf1f69e10254b65ad", "message": "Changed database format", "committedDate": "2020-12-22T23:26:22Z", "type": "commit"}, {"oid": "131f0868a23302d7618561539e04ebccb4fd6cca", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/131f0868a23302d7618561539e04ebccb4fd6cca", "message": "Merge branch 'master' into cbrune/BFD549-enrollmentdata", "committedDate": "2020-12-22T23:28:08Z", "type": "commit"}, {"oid": "5c9a4f5698899c47c1eb88a9b15e7932f86a63f2", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/5c9a4f5698899c47c1eb88a9b15e7932f86a63f2", "message": "Changed format of sql script", "committedDate": "2020-12-23T00:43:57Z", "type": "commit"}, {"oid": "5c9a4f5698899c47c1eb88a9b15e7932f86a63f2", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/5c9a4f5698899c47c1eb88a9b15e7932f86a63f2", "message": "Changed format of sql script", "committedDate": "2020-12-23T00:43:57Z", "type": "forcePushed"}, {"oid": "1af552ea61be2b064aef1a724cf091b9ce40ce2f", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/1af552ea61be2b064aef1a724cf091b9ce40ce2f", "message": "Changed format of sql script", "committedDate": "2020-12-23T00:45:25Z", "type": "commit"}, {"oid": "9dbcf3b3a1009899b9dec3d595ee22ac680a077a", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/9dbcf3b3a1009899b9dec3d595ee22ac680a077a", "message": "Reformatted sql", "committedDate": "2020-12-23T03:53:06Z", "type": "commit"}, {"oid": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "message": "Changed enrollments to BeneficiaryMonthly", "committedDate": "2020-12-23T22:46:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1Nzc2Ng==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549557766", "body": "Did the auto-formatter get run on this? If so, it behaved a bit goofy here.", "bodyText": "Did the auto-formatter get run on this? If so, it behaved a bit goofy here.", "bodyHTML": "<p dir=\"auto\">Did the auto-formatter get run on this? If so, it behaved a bit goofy here.</p>", "author": "karlmdavis", "createdAt": "2020-12-29T03:47:36Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -511,23 +536,40 @@ private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException\n \n       FieldSpec lineField =\n           FieldSpec.builder(\n-                  selectJavaFieldType(rifField), rifField.getJavaFieldName(), Modifier.PRIVATE)\n+                  selectJavaFieldType(\n+                      rifField.getRifColumnType(),\n+                      rifField.isRifColumnOptional(),\n+                      rifField.getRifColumnLength(),\n+                      rifField.getRifColumnScale()),\n+                  rifField.getJavaFieldName(),\n+                  Modifier.PRIVATE)", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MDg4MQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549880881", "bodyText": "yea it did", "author": "cbrunefearless", "createdAt": "2020-12-29T23:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1Nzc2Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex c15bfb93e..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,1983 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Temporal;\n-import javax.persistence.TemporalType;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes() */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion() */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"Beneficiaries\")\n-              .setHeaderEntityIdField(\"beneficiaryId\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"hicnUnhashed\", \"mbiHash\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setHasLines(false)\n-              .setHasBeneficiaryMonthly(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"BeneficiariesHistory\")\n-              .setHeaderEntityGeneratedIdField(\"beneficiaryHistoryId\")\n-              .setHeaderEntityTransientFields(\n-                  \"stateCode\",\n-                  \"countyCode\",\n-                  \"postalCode\",\n-                  \"race\",\n-                  \"entitlementCodeOriginal\",\n-                  \"entitlementCodeCurrent\",\n-                  \"endStageRenalDiseaseCode\",\n-                  \"medicareEnrollmentStatusCode\",\n-                  \"partATerminationCode\",\n-                  \"partBTerminationCode\",\n-                  \"nameSurname\",\n-                  \"nameGiven\",\n-                  \"nameMiddleInitial\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"hicnUnhashed\", \"mbiHash\")))\n-              .setHasLines(false)\n-              .setHasBeneficiaryMonthly(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderEntityIdField(\"medicareBeneficiaryIdKey\")\n-              .setHasLines(false)\n-              .setHasBeneficiaryMonthly(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"PartDEvents\")\n-              .setHeaderEntityIdField(\"eventId\")\n-              .setHasLines(false)\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"CarrierClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"CarrierClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"InpatientClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"InpatientClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"OutpatientClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"OutpatientClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"HHAClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"HHAClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"DMEClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"DMEClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"HospiceClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"HospiceClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"SNFClaims\")\n-              .setHeaderEntityIdField(\"claimId\")\n-              .setHasLines(true)\n-              .setLineTable(\"SNFClaimLines\")\n-              .setHasBeneficiaryMonthly(false));\n-    } finally {\n-      if (spreadsheetWorkbook != null) spreadsheetWorkbook.close();\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'.\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) generateCode(mappingSpec);\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    logNote(\"Generated code for %s\", mappingSpec.getRifLayout().getName());\n-\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity = Optional.empty();\n-    if (mappingSpec.getHasLines()) {\n-      lineEntity = Optional.of(generateLineEntity(mappingSpec));\n-    }\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.getHasBeneficiaryMonthly()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", \"`\" + mappingSpec.getLineTable() + \"`\")\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // Add a field to that @IdClass for the parent claim's ID.\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(f -> mappingSpec.getHeaderEntityIdField().equals(f.getJavaFieldName()))\n-            .findAny()\n-            .get();\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(\n-            parentClaimIdFieldType, mappingSpec.getLineEntityParentField(), Modifier.PRIVATE);\n-    lineIdClass.addField(parentIdField.build());\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", mappingSpec.getLineEntityParentField())\n-            .returns(parentClaimIdFieldType);\n-    lineIdClass.addMethod(parentGetter.build());\n-\n-    // Add a field to that @IdClass class for the line number.\n-    RifField rifLineNumberField =\n-        rifLayout.getRifFields().stream()\n-            .filter(f -> f.getJavaFieldName().equals(mappingSpec.getLineEntityLineNumberField()))\n-            .findFirst()\n-            .get();\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            rifLineNumberField.getRifColumnType(),\n-            rifLineNumberField.isRifColumnOptional(),\n-            rifLineNumberField.getRifColumnLength(),\n-            rifLineNumberField.getRifColumnScale());\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, mappingSpec.getLineEntityLineNumberField(), Modifier.PRIVATE);\n-    lineIdClass.addField(lineNumberIdField.build());\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"get\" + capitalize(mappingSpec.getLineEntityLineNumberField()))\n-            .addStatement(\"return $N\", mappingSpec.getLineEntityLineNumberField())\n-            .returns(lineNumberFieldType);\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(\n-                mappingSpec.getHeaderEntity(),\n-                mappingSpec.getLineEntityParentField(),\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"`\" + mappingSpec.getLineEntityParentField() + \"`\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                            \"%s_%s_to_%s\",\n-                            mappingSpec.getLineTable(),\n-                            mappingSpec.getLineEntityParentField(),\n-                            mappingSpec.getHeaderTable()))\n-                    .build())\n-            .build();\n-    lineEntity.addField(parentClaimField);\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", mappingSpec.getLineEntityParentField())\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"`BeneficiaryMonthly`\").build();\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, \"parentBeneficiary\", Modifier.PRIVATE);\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return $N\", \"parentBeneficiary\")\n-            .returns(parentBeneficiaryIdFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"get\" + capitalize(\"yearMonth\"))\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                \"parentBeneficiary\",\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"`parentBeneficiary`\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                            \"%s_%s_to_%s\",\n-                            \"BeneficiaryMonthly\", \"parentBeneficiary\", \"Beneficiary\"))\n-                    .build())\n-            .build();\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", \"parentBeneficiary\")\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        true,\n-        false,\n-        false,\n-        \"yearMonth\",\n-        RifColumnType.DATE,\n-        Optional.of(8),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"fipsStateCntyCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(5),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"medicareStatusCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(2),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"entitlementBuyInInd\",\n-        RifColumnType.CHAR,\n-        Optional.of(1),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"hmoIndicatorInd\",\n-        RifColumnType.CHAR,\n-        Optional.of(1),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partCContractNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(5),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partCPbpNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partCPlanTypeCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partDContractNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(5),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partDPbpNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partDSegmentNumberId\",\n-        RifColumnType.CHAR,\n-        Optional.of(3),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partDRetireeDrugSubsidyInd\",\n-        RifColumnType.CHAR,\n-        Optional.of(1),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"medicaidDualEligibilityCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(2),\n-        Optional.empty());\n-\n-    createBeneficiaryMonthlyFields(\n-        beneficiaryMonthlyEntity,\n-        false,\n-        false,\n-        true,\n-        \"partDLowIncomeCostShareGroupCode\",\n-        RifColumnType.CHAR,\n-        Optional.of(2),\n-        Optional.empty());\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", \"`\" + mappingSpec.getHeaderTable() + \"`\")\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\n-                  \"name\",\n-                  \"$S\",\n-                  String.format(\"`%s`\", mappingSpec.getHeaderEntityGeneratedIdField()))\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-      String sequenceName =\n-          String.format(\n-              \"%s_%s_seq\",\n-              mappingSpec.getHeaderEntity().simpleName(),\n-              mappingSpec.getHeaderEntityGeneratedIdField());\n-      /*\n-       * FIXME For consistency, sequence names should be mixed-case, but can't be, due\n-       * to https://hibernate.atlassian.net/browse/HHH-9431.\n-       */\n-      sequenceName = sequenceName.toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    for (int fieldIndex = 0;\n-        fieldIndex <= mappingSpec.calculateLastHeaderFieldIndex();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(rifField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasBeneficiaryMonthly()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.EAGER\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-\n-    // Add a lastUpdated field.\n-    final FieldSpec lastUpdatedField =\n-        FieldSpec.builder(Date.class, \"lastUpdated\", Modifier.PRIVATE)\n-            .addAnnotation(\n-                AnnotationSpec.builder(Temporal.class)\n-                    .addMember(\"value\", \"$T.TIMESTAMP\", TemporalType.class)\n-                    .build())\n-            .build();\n-    headerEntityClass.addField(lastUpdatedField);\n-\n-    // Getter method\n-    final MethodSpec lastUpdatedGetter =\n-        MethodSpec.methodBuilder(\"getLastUpdated\")\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return Optional.ofNullable(lastUpdated)\")\n-            .returns(ParameterizedTypeName.get(Optional.class, Date.class))\n-            .build();\n-    headerEntityClass.addMethod(lastUpdatedGetter);\n-\n-    // Setter method which is useful for testing, but not needed in the main modules\n-    final MethodSpec lastUpdatedSetter =\n-        MethodSpec.methodBuilder(\"setLastUpdated\")\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(ParameterSpec.builder(Date.class, \"lastUpdated\").build())\n-            .addStatement(\"this.lastUpdated = lastUpdated\")\n-            .returns(TypeName.VOID)\n-            .build();\n-    headerEntityClass.addMethod(lastUpdatedSetter);\n-\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (mappingSpec.getHasLines() && fieldIndex == mappingSpec.calculateFirstLineFieldIndex()) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equals(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= mappingSpec.calculateFirstLineFieldIndex()) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-        // Handle a String field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1) {\n-        // Handle a Character field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) > 0) {\n-        // Handle a Decimal field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-    String headerColumnsList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> \"\\\"\" + f.name + \"\\\"\")\n-            .collect(Collectors.joining(\", \"));\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-      String lineColumnsList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(f -> \"\\\"\" + f.name + \"\\\"\")\n-              .collect(Collectors.joining(\", \"));\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getLineEntityParentField()))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityIdField()))\n-              .findAny()\n-              .get();\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder code = new StringBuilder();\n-    code.append(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField));\n-      code.append(\"().\");\n-      code.append(calculateGetterName(headerIdField));\n-      code.append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field));\n-      code.append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field));\n-      code.append(\"()\");\n-    }\n-\n-    return code.toString();\n-  }\n-\n-  /**\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getJavaFieldName().equals(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField.getJavaFieldName().equals(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getJavaFieldName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", \"`\" + rifField.getJavaFieldName() + \"`\")\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * @param List<String> the {@link RifField} to create an additional Annotated database field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"hicnUnhashed\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"BENE_CRNT_HIC_NUM\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"benecrnthicnum\"),\n-                \"BENE_CRNT_HIC_NUM\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"mbiHash\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_NUM\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_NUM\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    if (entityField.type.equals(TypeName.BOOLEAN)\n-        || entityField.type.equals(ClassName.get(Boolean.class)))\n-      return \"is\" + capitalize(entityField.name);\n-    else return \"get\" + capitalize(entityField.name);\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) entityGetter.addStatement(\"return $N\", entityField);\n-    else entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(entityField.name);\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * @param rifField <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    else entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-  }\n-\n-  /**\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    char first = name.charAt(0);\n-    return String.format(\"%s%s\", Character.toUpperCase(first), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity,\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    FieldSpec lineField =\n-        FieldSpec.builder(\n-                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n-                fieldName,\n-                Modifier.PRIVATE)\n-            .addAnnotations(\n-                createBeneficiaryMonthlyAnnotations(\n-                    isId,\n-                    isTransient,\n-                    isColumnOptional,\n-                    fieldName,\n-                    type,\n-                    columnLength,\n-                    columnScale))\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n-    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n-                lineField.name);\n-    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every non-transient column.\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n-              .addMember(\"nullable\", \"$L\", isColumnOptional);\n-      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n-      } else if (type == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (columnLength.isPresent() && columnScale.isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (columnLength.isPresent() || columnScale.isPresent()) {\n-            columnDefinition.append('(');\n-            if (columnLength.isPresent()) {\n-              columnDefinition.append(columnLength.get());\n-            }\n-            if (columnScale.isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(columnScale.get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n-      return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n-      return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n-      return ClassName.get(BigDecimal.class);\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1Nzk4Mw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549557983", "body": "I think the JavaDoc links here are broken. I just `ctrl+f`'d for \"enroll\" to see what came up and found them.", "bodyText": "I think the JavaDoc links here are broken. I just ctrl+f'd for \"enroll\" to see what came up and found them.", "bodyHTML": "<p dir=\"auto\">I think the JavaDoc links here are broken. I just <code>ctrl+f</code>'d for \"enroll\" to see what came up and found them.</p>", "author": "karlmdavis", "createdAt": "2020-12-29T03:49:04Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java", "diffHunk": "@@ -218,6 +242,16 @@ public String getLineEntityParentField() {\n     return \"parentClaim\";\n   }\n \n+  /**\n+   * @return the name of the field in the {@link #getEnrollmentEntity()} {@link Entity} that should\n+   *     be used to store and refer to the child {@link #getEnrollmentEntity()} {@link Entity}s, if", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2ODU3MA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549568570", "bodyText": "Changed to parentbeneficiary", "author": "cbrunefearless", "createdAt": "2020-12-29T05:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1Nzk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 48a7937f1..bd22ffc67 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -243,9 +243,9 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return the name of the field in the {@link #getEnrollmentEntity()} {@link Entity} that should\n-   *     be used to store and refer to the child {@link #getEnrollmentEntity()} {@link Entity}s, if\n-   *     any\n+   * @return the name of the field in the {@link #getBeneficiaryMonthlyEntityParentField()} {@link\n+   *     Entity} that should be used to store and refer to the parentBeneficiary {@link\n+   *     #getBeneficiaryMonthlyEntityParentField()} {@link Entity}s, if any\n    */\n   public String getBeneficiaryMonthlyEntityParentField() {\n     if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 48a7937f1..bf706da1a 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -243,9 +243,9 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return the name of the field in the {@link #getEnrollmentEntity()} {@link Entity} that should\n-   *     be used to store and refer to the child {@link #getEnrollmentEntity()} {@link Entity}s, if\n-   *     any\n+   * @return the name of the field in the {@link #getBeneficiaryMonthlyEntityParentField()} {@link\n+   *     Entity} that should be used to store and refer to the parentBeneficiary {@link\n+   *     #getBeneficiaryMonthlyEntityParentField()} {@link Entity}s, if any\n    */\n   public String getBeneficiaryMonthlyEntityParentField() {\n     if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n", "next_change": {"commit": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex bf706da1a..d5653dd06 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -252,13 +268,24 @@ public final class MappingSpec {\n     return \"parentBeneficiary\";\n   }\n \n+  /**\n+   * @param the name of the field in the {@link #getLineEntity()} {@link Entity} that should be used\n+   *     for the identifying line number\n+   */\n+  public MappingSpec setLineEntityLineNumberField(String lineEntityLineNumberField) {\n+    if (!hasLines) throw new IllegalStateException();\n+    this.lineEntityLineNumberField = lineEntityLineNumberField;\n+    return this;\n+  }\n+\n   /**\n    * @return the name of the field in the {@link #getLineEntity()} {@link Entity} that should be\n    *     used for the identifying line number, if any\n    */\n   public String getLineEntityLineNumberField() {\n+    // use Java field name since there is no uniformity among column names for line #\n     if (!hasLines) throw new IllegalStateException();\n-    return \"lineNumber\";\n+    return lineEntityLineNumberField;\n   }\n \n   /**\n", "next_change": {"commit": "28cfe6ac219cb819818e78a10c46e9464754bf39", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex d5653dd06..1411bd1c1 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -293,7 +311,7 @@ public final class MappingSpec {\n    *     that should be used for the identifying yearMonth, if any\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n-    if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n+    if (!isBeneficiaryEntity) throw new IllegalStateException();\n     return \"YEAR_MONTH\";\n   }\n \n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 1411bd1c1..941015d5f 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -307,20 +392,28 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return the name of the field in the {@link #getEntityBeneficiaryMonthlyField()} {@link Entity}\n-   *     that should be used for the identifying yearMonth, if any\n+   * Gets the name of the field in the {@link Entity} that should be used for the identifying\n+   * yearMonth.\n+   *\n+   * @return the beneficiary monthly entity field\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n     if (!isBeneficiaryEntity) throw new IllegalStateException();\n     return \"YEAR_MONTH\";\n   }\n \n-  /** @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient} */\n+  /**\n+   * Gets the {@link #headerEntityTransientFields}.\n+   *\n+   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n+   */\n   public List<String> getHeaderEntityTransientFields() {\n     return headerEntityTransientFields;\n   }\n \n   /**\n+   * Sets the {@link #headerEntityTransientFields}.\n+   *\n    * @param headerEntityTransientFields the new value for {@link #getHeaderEntityTransientFields()}\n    * @return this {@link MappingSpec} instance, for call-chaining purposes\n    */\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\ndeleted file mode 100644\nindex 941015d5f..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ /dev/null\n", "chunk": "@@ -1,556 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.squareup.javapoet.ClassName;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import javax.persistence.Entity;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.Transient;\n-\n-/**\n- * Encapsulates the information that must be known upfront to drive a mapping from a {@link\n- * RifLayout} to Java code.\n- *\n- * <p>Each {@link RifLayout} will be mapped to either 1 or 2 JPA {@link Entity} classes: only 1 if\n- * the record type doesn't have separate header vs. line fields, and exactly 2 if it does (one\n- * {@link Entity} for the header fields and a second child {@link Entity} for the line fields).\n- */\n-public final class MappingSpec {\n-  /*\n-   * Design Note: This class' fields are mutable to allow for the more\n-   * readable chained-setter style of construction.\n-   */\n-\n-  /** The name of the Java package that the mapping is occurring for and in. */\n-  private String packageName;\n-  /** The {@link RifLayout} whose fields will be mapped. */\n-  private RifLayout rifLayout;\n-  /** The claim entity being mapped. */\n-  private String headerEntity;\n-  /** The name of the SQL table that the {@link #getHeaderEntity()} instances will be stored in. */\n-  private String headerTable;\n-  /**\n-   * The name of the {@link Entity} field that should be used as the {@link Id} in the {@link\n-   * #getHeaderEntity()} {@link Entity}.\n-   */\n-  private String headerEntityIdField;\n-  /**\n-   * The name of the {@link Entity} {@link GeneratedValue} field that should be used as the {@link\n-   * Id} in the {@link #getHeaderEntity()} {@link Entity}.\n-   */\n-  private String headerEntityGeneratedIdField;\n-  /**\n-   * If the RIF layout has child line fields that should be stored separately from its parent header\n-   * fields.\n-   */\n-  private boolean hasLines = false;\n-  /** If the RIF layout is for a Beneficiary entity. */\n-  private boolean isBeneficiaryEntity = false;\n-  /**\n-   * The name of the SQL table that the {@link #getLineEntity()} instances will be stored in, if\n-   * any.\n-   */\n-  private String lineTable;\n-  /**\n-   * The name of the field in the {@link #getLineEntity()} {@link Entity} that should be used for\n-   * the identifying line number, if any.\n-   */\n-  private String lineEntityLineNumberField;\n-  /** The db sequence number generator name. */\n-  private String sequenceNumberGeneratorName;\n-  /** The fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}. */\n-  private List<String> headerEntityTransientFields;\n-  /** The additional database fields for the {@link #getHeaderEntity()}. */\n-  private List<RifField> headerEntityAdditionalDatabaseFields;\n-  /** A list of {@link String} parameters defining the inner join relationship for the entity. */\n-  private List<InnerJoinRelationship> innerJoinRelationship;\n-\n-  /**\n-   * Constructs a new {@link MappingSpec} instance.\n-   *\n-   * @param packageName the value to use for {@link #getPackageName()}\n-   */\n-  public MappingSpec(String packageName) {\n-    Objects.requireNonNull(packageName);\n-    this.packageName = packageName;\n-    this.headerEntityTransientFields = new ArrayList<>();\n-    this.headerEntityAdditionalDatabaseFields = new ArrayList<RifField>();\n-    this.innerJoinRelationship = new ArrayList<InnerJoinRelationship>();\n-  }\n-\n-  /**\n-   * Gets the {@link #packageName}.\n-   *\n-   * @return the name of the Java package that the mapping is occurring for and in\n-   */\n-  public String getPackageName() {\n-    return packageName;\n-  }\n-\n-  /**\n-   * Gets the {@link #rifLayout}.\n-   *\n-   * @return the {@link RifLayout} whose fields will be mapped\n-   */\n-  public RifLayout getRifLayout() {\n-    return rifLayout;\n-  }\n-\n-  /**\n-   * Sets the {@link #rifLayout}.\n-   *\n-   * @param rifLayout the new value for {@link #getRifLayout()}\n-   * @return the {@link MappingSpec} whose rifLayout is set\n-   */\n-  public MappingSpec setRifLayout(RifLayout rifLayout) {\n-    this.rifLayout = rifLayout;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the ClassName of the Java {@link Enum} that all the RIF field definitions will be placed\n-   * in.\n-   *\n-   * @return the classname of the enum\n-   */\n-  public ClassName getColumnEnum() {\n-    return ClassName.get(packageName, headerEntity + \"Column\");\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} of the JPA {@link Entity} class that will be used to store data from\n-   * this RIF layout for the header fields.\n-   *\n-   * @return the classname of the entity\n-   */\n-  public ClassName getHeaderEntity() {\n-    return ClassName.get(packageName, headerEntity);\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntity}.\n-   *\n-   * @param headerEntity the new value for {@link #getHeaderEntity()}\n-   * @return the {@link MappingSpec} whose headerEntity is set\n-   */\n-  public MappingSpec setHeaderEntity(String headerEntity) {\n-    this.headerEntity = headerEntity;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerTable}.\n-   *\n-   * @return the name of the SQL table that the {@link #getHeaderEntity()} instances will be stored\n-   *     in\n-   */\n-  public String getHeaderTable() {\n-    return headerTable;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerTable}.\n-   *\n-   * @param headerTable the new value for {@link #getHeaderTable()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderTable(String headerTable) {\n-    this.headerTable = headerTable;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityIdField}.\n-   *\n-   * @return the name of the {@link Entity} field that should be used as the {@link Id} in the\n-   *     {@link #getHeaderEntity()} {@link Entity}\n-   */\n-  public String getHeaderEntityIdField() {\n-    return headerEntityIdField;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityIdField}.\n-   *\n-   * @param headerEntityIdField the new value for {@link #getHeaderEntityIdField()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityIdField(String headerEntityIdField) {\n-    this.headerEntityIdField = headerEntityIdField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityGeneratedIdField}.\n-   *\n-   * @return the name of the {@link Entity} {@link GeneratedValue} field that should be used as the\n-   *     {@link Id} in the {@link #getHeaderEntity()} {@link Entity}\n-   */\n-  public String getHeaderEntityGeneratedIdField() {\n-    return headerEntityGeneratedIdField;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityGeneratedIdField}.\n-   *\n-   * @param headerEntityGeneratedIdField the new value for {@link\n-   *     #getHeaderEntityGeneratedIdField()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityGeneratedIdField(String headerEntityGeneratedIdField) {\n-    this.headerEntityGeneratedIdField = headerEntityGeneratedIdField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link #getHeaderEntity()} {@link Entity} that should be used\n-   * to store and refer to the child {@link #getLineEntity()} {@link Entity}s.\n-   *\n-   * @return the name of the field for line entities\n-   */\n-  public String getHeaderEntityLinesField() {\n-    if (!hasLines) {\n-      throw new IllegalStateException();\n-    }\n-    return \"lines\";\n-  }\n-\n-  /**\n-   * Determines if {@link #hasLines}.\n-   *\n-   * @return <code>true</code> if the RIF layout has child line fields that should be stored\n-   *     separately from its parent header fields, <code>false</code> if not\n-   */\n-  public boolean getHasLines() {\n-    return hasLines;\n-  }\n-\n-  /**\n-   * Sets {@link #hasLines}.\n-   *\n-   * @param hasLines the new value for {@link #getHasLines()}\n-   * @return the {@link MappingSpec} whose hasLines is set\n-   */\n-  public MappingSpec setHasLines(boolean hasLines) {\n-    this.hasLines = hasLines;\n-    return this;\n-  }\n-\n-  /**\n-   * Determines if {@link #isBeneficiaryEntity}.\n-   *\n-   * @return <code>true</code> if the RIF layout is for the <code>Beneficiary</code> entity, <code>\n-   *     false</code> if it's not\n-   */\n-  public boolean isBeneficiaryEntity() {\n-    return isBeneficiaryEntity;\n-  }\n-\n-  /**\n-   * Sets {@link #isBeneficiaryEntity}.\n-   *\n-   * @param isBeneficiaryEntity the new value for {@link #isBeneficiaryEntity()}\n-   * @return this {@link MappingSpec}, for call chaining purposes\n-   */\n-  public MappingSpec setIsBeneficiaryEntity(boolean isBeneficiaryEntity) {\n-    this.isBeneficiaryEntity = isBeneficiaryEntity;\n-    return this;\n-  }\n-\n-  /**\n-   * Calculates the index of the last header field in {@link #getRifLayout()}.\n-   *\n-   * @return the index of the last header field\n-   */\n-  public int calculateLastHeaderFieldIndex() {\n-    return hasLines ? (calculateFirstLineFieldIndex() - 1) : (rifLayout.getRifFields().size() - 1);\n-  }\n-\n-  /**\n-   * Calculate the index of the first line field in {@link #getRifLayout()}.\n-   *\n-   * @return the index of the first line field\n-   */\n-  public int calculateFirstLineFieldIndex() {\n-    if (!hasLines) throw new IllegalStateException();\n-\n-    for (int fieldIndex = 0; fieldIndex < rifLayout.getRifFields().size(); fieldIndex++) {\n-      RifField field = rifLayout.getRifFields().get(fieldIndex);\n-      if (field.getRifColumnName().equalsIgnoreCase(getLineEntityLineNumberField())) {\n-        return fieldIndex;\n-      }\n-    }\n-\n-    throw new IllegalStateException();\n-  }\n-\n-  /**\n-   * Gets the name of the JPA {@link Entity} class that will be used to store data from this RIF\n-   * layout for the line fields, if any.\n-   *\n-   * @return the name of the JPA {@link Entity} class, if any\n-   */\n-  public ClassName getLineEntity() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return ClassName.get(packageName, headerEntity + \"Line\");\n-  }\n-\n-  /**\n-   * Gets the name of the JPA {@link Entity} class that will be used to store data from this RIF\n-   * layout for the line fields, if any.\n-   *\n-   * @return the name of the JPA {@link Entity} class, if any\n-   */\n-  public ClassName getBeneficiaryMonthlyEntity() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return ClassName.get(packageName, \"BeneficiaryMonthly\");\n-  }\n-\n-  /**\n-   * Gets the {@link #lineTable}.\n-   *\n-   * @return the name of the SQL table that the {@link #getLineEntity()} instances will be stored\n-   *     in, if any\n-   */\n-  public String getLineTable() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return lineTable;\n-  }\n-\n-  /**\n-   * Sets the {@link #lineTable}.\n-   *\n-   * @param lineTable the new value for {@link #getLineTable()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setLineTable(String lineTable) {\n-    if (!hasLines) throw new IllegalStateException();\n-    this.lineTable = lineTable;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the ClassName of the JPA {@link IdClass} for the {@link #getLineEntity()} {@link Entity}.\n-   *\n-   * @return the line entity id class name\n-   */\n-  public ClassName getLineEntityIdClass() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return getLineEntity().nestedClass(\"LineId\");\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link #getLineEntity()} {@link Entity} that should be used\n-   * to store and refer to the child {@link #getLineEntity()} {@link Entity}s.\n-   *\n-   * @return the name of the line entity parent field\n-   */\n-  public String getLineEntityParentField() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return \"parentClaim\";\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link Entity} that should be used to store and refer to the\n-   * parentBeneficiary {@link Entity}s.\n-   *\n-   * @return the beneficiary monthly entity parent field\n-   */\n-  public String getBeneficiaryMonthlyEntityParentField() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return \"parentBeneficiary\";\n-  }\n-\n-  /**\n-   * Sets the {@link #lineEntityLineNumberField}.\n-   *\n-   * @param lineEntityLineNumberField the name of the field in the {@link #getLineEntity()} {@link\n-   *     Entity} that should be used for the identifying line number\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setLineEntityLineNumberField(String lineEntityLineNumberField) {\n-    if (!hasLines) throw new IllegalStateException();\n-    this.lineEntityLineNumberField = lineEntityLineNumberField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #lineEntityLineNumberField}.\n-   *\n-   * @return the name of the field in the {@link #getLineEntity()} {@link Entity} that should be\n-   *     used for the identifying line number, if any\n-   */\n-  public String getLineEntityLineNumberField() {\n-    // use Java field name since there is no uniformity among column names for line #\n-    if (!hasLines) throw new IllegalStateException();\n-    return lineEntityLineNumberField;\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link Entity} that should be used for the identifying\n-   * yearMonth.\n-   *\n-   * @return the beneficiary monthly entity field\n-   */\n-  public String getEntityBeneficiaryMonthlyField() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return \"YEAR_MONTH\";\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityTransientFields}.\n-   *\n-   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n-   */\n-  public List<String> getHeaderEntityTransientFields() {\n-    return headerEntityTransientFields;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityTransientFields}.\n-   *\n-   * @param headerEntityTransientFields the new value for {@link #getHeaderEntityTransientFields()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityTransientFields(String... headerEntityTransientFields) {\n-    Objects.requireNonNull(headerEntityTransientFields);\n-    this.headerEntityTransientFields = Arrays.asList(headerEntityTransientFields);\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityAdditionalDatabaseFields}.\n-   *\n-   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n-   */\n-  public List<RifField> getHeaderEntityAdditionalDatabaseFields() {\n-    return headerEntityAdditionalDatabaseFields;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityAdditionalDatabaseFields}.\n-   *\n-   * @param headerEntityAdditionalDatabaseFields the new value for {@link\n-   *     #getHeaderEntityAdditionalDatabaseFields()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityAdditionalDatabaseFields(\n-      List<RifField> headerEntityAdditionalDatabaseFields) {\n-    Objects.requireNonNull(headerEntityAdditionalDatabaseFields);\n-    this.headerEntityAdditionalDatabaseFields = headerEntityAdditionalDatabaseFields;\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the {@link #sequenceNumberGeneratorName}.\n-   *\n-   * @param sequenceNumberGeneratorName the db sequence number generator name {@link\n-   *     #getSequenceNumberGeneratorName()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setSequenceNumberGeneratorName(String sequenceNumberGeneratorName) {\n-    this.sequenceNumberGeneratorName = sequenceNumberGeneratorName;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #sequenceNumberGeneratorName}.\n-   *\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public String getSequenceNumberGeneratorName() {\n-    return sequenceNumberGeneratorName;\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} for the class to be built that will contain parsing code for the\n-   * layout.\n-   *\n-   * @return the class name for the parser\n-   */\n-  public ClassName getParserClass() {\n-    return ClassName.get(packageName, headerEntity + \"Parser\");\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} for the class to be built that will contain CSV writing for the\n-   * layout.\n-   *\n-   * @return the csv writer class name\n-   */\n-  public ClassName getCsvWriterClass() {\n-    return ClassName.get(packageName, headerEntity + \"CsvWriter\");\n-  }\n-\n-  /** {@inheritDoc} */\n-  @Override\n-  public String toString() {\n-    StringBuilder builder = new StringBuilder();\n-    builder.append(\"MappingSpec [packageName=\");\n-    builder.append(packageName);\n-    builder.append(\", rifLayout=\");\n-    builder.append(rifLayout);\n-    builder.append(\", headerEntity=\");\n-    builder.append(headerEntity);\n-    builder.append(\", headerTable=\");\n-    builder.append(headerTable);\n-    builder.append(\", headerEntityIdField=\");\n-    builder.append(headerEntityIdField);\n-    builder.append(\", hasLines=\");\n-    builder.append(hasLines);\n-    builder.append(\", lineTable=\");\n-    builder.append(lineTable);\n-    if (hasLines) {\n-      builder.append(\", lineEntityLineNumber=\");\n-      builder.append(lineEntityLineNumberField);\n-    }\n-    builder.append(\"]\");\n-    return builder.toString();\n-  }\n-\n-  /**\n-   * Determines if there are any {@link #innerJoinRelationship}s.\n-   *\n-   * @return <code>true</code> if the RIF layout has an inner join relationship <code>false</code>\n-   *     if not\n-   */\n-  public Boolean getHasInnerJoinRelationship() {\n-    return this.innerJoinRelationship.size() != 0;\n-  }\n-\n-  /**\n-   * Sets the {@link #innerJoinRelationship}.\n-   *\n-   * @param innerJoinRelationship a list of {@link String} parameters defining the inner join\n-   *     relationship for the entity\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setInnerJoinRelationship(List<InnerJoinRelationship> innerJoinRelationship) {\n-    this.innerJoinRelationship = innerJoinRelationship;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #innerJoinRelationship}.\n-   *\n-   * @return the list of {@link #innerJoinRelationship}s\n-   */\n-  public List<InnerJoinRelationship> getInnerJoinRelationship() {\n-    return this.innerJoinRelationship;\n-  }\n-\n-  /**\n-   * Gets the class name for the specified entity name.\n-   *\n-   * @param entity the {@link String} entity for which to return the {@link ClassName} for\n-   * @return the {@link ClassName} of the provided {@link String} entity\n-   */\n-  public ClassName getClassName(String entity) {\n-    return ClassName.get(packageName, entity);\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "20caedd65963b799db11e56142081af2279daf75", "committedDate": "2021-02-02 17:54:12 -0800", "message": "BFD-379-Support-BB2-Address-Fields-Filtering-header-includeAddressFields (#390)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "86a2665d1f0252675f227f300fc0643ded7d9bfe", "committedDate": "2022-02-01 08:01:24 -0800", "message": "BFD-1514: Clean up javadoc errors in Model module (#929)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1ODA0MA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549558040", "body": "I think the JavaDoc link here is broken. I just `ctrl+f`'d for \"enroll\" to see what came up and found it.", "bodyText": "I think the JavaDoc link here is broken. I just ctrl+f'd for \"enroll\" to see what came up and found it.", "bodyHTML": "<p dir=\"auto\">I think the JavaDoc link here is broken. I just <code>ctrl+f</code>'d for \"enroll\" to see what came up and found it.</p>", "author": "karlmdavis", "createdAt": "2020-12-29T03:49:23Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java", "diffHunk": "@@ -227,6 +261,15 @@ public String getLineEntityLineNumberField() {\n     return \"lineNumber\";\n   }\n \n+  /**\n+   * @return the name of the field in the {@link #getEntityEnrollmentField()} {@link Entity} that", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3MDI0NQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549570245", "bodyText": "changed", "author": "cbrunefearless", "createdAt": "2020-12-29T05:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1ODA0MA=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 48a7937f1..bd22ffc67 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -262,8 +262,8 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return the name of the field in the {@link #getEntityEnrollmentField()} {@link Entity} that\n-   *     should be used for the identifying line number, if any\n+   * @return the name of the field in the {@link #getEntityBeneficiaryMonthlyField()} {@link Entity}\n+   *     that should be used for the identifying yearMonth, if any\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n     if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 48a7937f1..bf706da1a 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -262,8 +262,8 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return the name of the field in the {@link #getEntityEnrollmentField()} {@link Entity} that\n-   *     should be used for the identifying line number, if any\n+   * @return the name of the field in the {@link #getEntityBeneficiaryMonthlyField()} {@link Entity}\n+   *     that should be used for the identifying yearMonth, if any\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n     if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n", "next_change": {"commit": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex bf706da1a..d5653dd06 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -267,7 +294,7 @@ public final class MappingSpec {\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n     if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n-    return \"yearMonth\";\n+    return \"YEAR_MONTH\";\n   }\n \n   /** @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient} */\n", "next_change": {"commit": "28cfe6ac219cb819818e78a10c46e9464754bf39", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex d5653dd06..1411bd1c1 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -293,7 +311,7 @@ public final class MappingSpec {\n    *     that should be used for the identifying yearMonth, if any\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n-    if (!hasBeneficiaryMonthly) throw new IllegalStateException();\n+    if (!isBeneficiaryEntity) throw new IllegalStateException();\n     return \"YEAR_MONTH\";\n   }\n \n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 1411bd1c1..941015d5f 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -307,20 +392,28 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return the name of the field in the {@link #getEntityBeneficiaryMonthlyField()} {@link Entity}\n-   *     that should be used for the identifying yearMonth, if any\n+   * Gets the name of the field in the {@link Entity} that should be used for the identifying\n+   * yearMonth.\n+   *\n+   * @return the beneficiary monthly entity field\n    */\n   public String getEntityBeneficiaryMonthlyField() {\n     if (!isBeneficiaryEntity) throw new IllegalStateException();\n     return \"YEAR_MONTH\";\n   }\n \n-  /** @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient} */\n+  /**\n+   * Gets the {@link #headerEntityTransientFields}.\n+   *\n+   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n+   */\n   public List<String> getHeaderEntityTransientFields() {\n     return headerEntityTransientFields;\n   }\n \n   /**\n+   * Sets the {@link #headerEntityTransientFields}.\n+   *\n    * @param headerEntityTransientFields the new value for {@link #getHeaderEntityTransientFields()}\n    * @return this {@link MappingSpec} instance, for call-chaining purposes\n    */\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\ndeleted file mode 100644\nindex 941015d5f..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ /dev/null\n", "chunk": "@@ -1,556 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.squareup.javapoet.ClassName;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import javax.persistence.Entity;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.Transient;\n-\n-/**\n- * Encapsulates the information that must be known upfront to drive a mapping from a {@link\n- * RifLayout} to Java code.\n- *\n- * <p>Each {@link RifLayout} will be mapped to either 1 or 2 JPA {@link Entity} classes: only 1 if\n- * the record type doesn't have separate header vs. line fields, and exactly 2 if it does (one\n- * {@link Entity} for the header fields and a second child {@link Entity} for the line fields).\n- */\n-public final class MappingSpec {\n-  /*\n-   * Design Note: This class' fields are mutable to allow for the more\n-   * readable chained-setter style of construction.\n-   */\n-\n-  /** The name of the Java package that the mapping is occurring for and in. */\n-  private String packageName;\n-  /** The {@link RifLayout} whose fields will be mapped. */\n-  private RifLayout rifLayout;\n-  /** The claim entity being mapped. */\n-  private String headerEntity;\n-  /** The name of the SQL table that the {@link #getHeaderEntity()} instances will be stored in. */\n-  private String headerTable;\n-  /**\n-   * The name of the {@link Entity} field that should be used as the {@link Id} in the {@link\n-   * #getHeaderEntity()} {@link Entity}.\n-   */\n-  private String headerEntityIdField;\n-  /**\n-   * The name of the {@link Entity} {@link GeneratedValue} field that should be used as the {@link\n-   * Id} in the {@link #getHeaderEntity()} {@link Entity}.\n-   */\n-  private String headerEntityGeneratedIdField;\n-  /**\n-   * If the RIF layout has child line fields that should be stored separately from its parent header\n-   * fields.\n-   */\n-  private boolean hasLines = false;\n-  /** If the RIF layout is for a Beneficiary entity. */\n-  private boolean isBeneficiaryEntity = false;\n-  /**\n-   * The name of the SQL table that the {@link #getLineEntity()} instances will be stored in, if\n-   * any.\n-   */\n-  private String lineTable;\n-  /**\n-   * The name of the field in the {@link #getLineEntity()} {@link Entity} that should be used for\n-   * the identifying line number, if any.\n-   */\n-  private String lineEntityLineNumberField;\n-  /** The db sequence number generator name. */\n-  private String sequenceNumberGeneratorName;\n-  /** The fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}. */\n-  private List<String> headerEntityTransientFields;\n-  /** The additional database fields for the {@link #getHeaderEntity()}. */\n-  private List<RifField> headerEntityAdditionalDatabaseFields;\n-  /** A list of {@link String} parameters defining the inner join relationship for the entity. */\n-  private List<InnerJoinRelationship> innerJoinRelationship;\n-\n-  /**\n-   * Constructs a new {@link MappingSpec} instance.\n-   *\n-   * @param packageName the value to use for {@link #getPackageName()}\n-   */\n-  public MappingSpec(String packageName) {\n-    Objects.requireNonNull(packageName);\n-    this.packageName = packageName;\n-    this.headerEntityTransientFields = new ArrayList<>();\n-    this.headerEntityAdditionalDatabaseFields = new ArrayList<RifField>();\n-    this.innerJoinRelationship = new ArrayList<InnerJoinRelationship>();\n-  }\n-\n-  /**\n-   * Gets the {@link #packageName}.\n-   *\n-   * @return the name of the Java package that the mapping is occurring for and in\n-   */\n-  public String getPackageName() {\n-    return packageName;\n-  }\n-\n-  /**\n-   * Gets the {@link #rifLayout}.\n-   *\n-   * @return the {@link RifLayout} whose fields will be mapped\n-   */\n-  public RifLayout getRifLayout() {\n-    return rifLayout;\n-  }\n-\n-  /**\n-   * Sets the {@link #rifLayout}.\n-   *\n-   * @param rifLayout the new value for {@link #getRifLayout()}\n-   * @return the {@link MappingSpec} whose rifLayout is set\n-   */\n-  public MappingSpec setRifLayout(RifLayout rifLayout) {\n-    this.rifLayout = rifLayout;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the ClassName of the Java {@link Enum} that all the RIF field definitions will be placed\n-   * in.\n-   *\n-   * @return the classname of the enum\n-   */\n-  public ClassName getColumnEnum() {\n-    return ClassName.get(packageName, headerEntity + \"Column\");\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} of the JPA {@link Entity} class that will be used to store data from\n-   * this RIF layout for the header fields.\n-   *\n-   * @return the classname of the entity\n-   */\n-  public ClassName getHeaderEntity() {\n-    return ClassName.get(packageName, headerEntity);\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntity}.\n-   *\n-   * @param headerEntity the new value for {@link #getHeaderEntity()}\n-   * @return the {@link MappingSpec} whose headerEntity is set\n-   */\n-  public MappingSpec setHeaderEntity(String headerEntity) {\n-    this.headerEntity = headerEntity;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerTable}.\n-   *\n-   * @return the name of the SQL table that the {@link #getHeaderEntity()} instances will be stored\n-   *     in\n-   */\n-  public String getHeaderTable() {\n-    return headerTable;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerTable}.\n-   *\n-   * @param headerTable the new value for {@link #getHeaderTable()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderTable(String headerTable) {\n-    this.headerTable = headerTable;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityIdField}.\n-   *\n-   * @return the name of the {@link Entity} field that should be used as the {@link Id} in the\n-   *     {@link #getHeaderEntity()} {@link Entity}\n-   */\n-  public String getHeaderEntityIdField() {\n-    return headerEntityIdField;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityIdField}.\n-   *\n-   * @param headerEntityIdField the new value for {@link #getHeaderEntityIdField()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityIdField(String headerEntityIdField) {\n-    this.headerEntityIdField = headerEntityIdField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityGeneratedIdField}.\n-   *\n-   * @return the name of the {@link Entity} {@link GeneratedValue} field that should be used as the\n-   *     {@link Id} in the {@link #getHeaderEntity()} {@link Entity}\n-   */\n-  public String getHeaderEntityGeneratedIdField() {\n-    return headerEntityGeneratedIdField;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityGeneratedIdField}.\n-   *\n-   * @param headerEntityGeneratedIdField the new value for {@link\n-   *     #getHeaderEntityGeneratedIdField()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityGeneratedIdField(String headerEntityGeneratedIdField) {\n-    this.headerEntityGeneratedIdField = headerEntityGeneratedIdField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link #getHeaderEntity()} {@link Entity} that should be used\n-   * to store and refer to the child {@link #getLineEntity()} {@link Entity}s.\n-   *\n-   * @return the name of the field for line entities\n-   */\n-  public String getHeaderEntityLinesField() {\n-    if (!hasLines) {\n-      throw new IllegalStateException();\n-    }\n-    return \"lines\";\n-  }\n-\n-  /**\n-   * Determines if {@link #hasLines}.\n-   *\n-   * @return <code>true</code> if the RIF layout has child line fields that should be stored\n-   *     separately from its parent header fields, <code>false</code> if not\n-   */\n-  public boolean getHasLines() {\n-    return hasLines;\n-  }\n-\n-  /**\n-   * Sets {@link #hasLines}.\n-   *\n-   * @param hasLines the new value for {@link #getHasLines()}\n-   * @return the {@link MappingSpec} whose hasLines is set\n-   */\n-  public MappingSpec setHasLines(boolean hasLines) {\n-    this.hasLines = hasLines;\n-    return this;\n-  }\n-\n-  /**\n-   * Determines if {@link #isBeneficiaryEntity}.\n-   *\n-   * @return <code>true</code> if the RIF layout is for the <code>Beneficiary</code> entity, <code>\n-   *     false</code> if it's not\n-   */\n-  public boolean isBeneficiaryEntity() {\n-    return isBeneficiaryEntity;\n-  }\n-\n-  /**\n-   * Sets {@link #isBeneficiaryEntity}.\n-   *\n-   * @param isBeneficiaryEntity the new value for {@link #isBeneficiaryEntity()}\n-   * @return this {@link MappingSpec}, for call chaining purposes\n-   */\n-  public MappingSpec setIsBeneficiaryEntity(boolean isBeneficiaryEntity) {\n-    this.isBeneficiaryEntity = isBeneficiaryEntity;\n-    return this;\n-  }\n-\n-  /**\n-   * Calculates the index of the last header field in {@link #getRifLayout()}.\n-   *\n-   * @return the index of the last header field\n-   */\n-  public int calculateLastHeaderFieldIndex() {\n-    return hasLines ? (calculateFirstLineFieldIndex() - 1) : (rifLayout.getRifFields().size() - 1);\n-  }\n-\n-  /**\n-   * Calculate the index of the first line field in {@link #getRifLayout()}.\n-   *\n-   * @return the index of the first line field\n-   */\n-  public int calculateFirstLineFieldIndex() {\n-    if (!hasLines) throw new IllegalStateException();\n-\n-    for (int fieldIndex = 0; fieldIndex < rifLayout.getRifFields().size(); fieldIndex++) {\n-      RifField field = rifLayout.getRifFields().get(fieldIndex);\n-      if (field.getRifColumnName().equalsIgnoreCase(getLineEntityLineNumberField())) {\n-        return fieldIndex;\n-      }\n-    }\n-\n-    throw new IllegalStateException();\n-  }\n-\n-  /**\n-   * Gets the name of the JPA {@link Entity} class that will be used to store data from this RIF\n-   * layout for the line fields, if any.\n-   *\n-   * @return the name of the JPA {@link Entity} class, if any\n-   */\n-  public ClassName getLineEntity() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return ClassName.get(packageName, headerEntity + \"Line\");\n-  }\n-\n-  /**\n-   * Gets the name of the JPA {@link Entity} class that will be used to store data from this RIF\n-   * layout for the line fields, if any.\n-   *\n-   * @return the name of the JPA {@link Entity} class, if any\n-   */\n-  public ClassName getBeneficiaryMonthlyEntity() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return ClassName.get(packageName, \"BeneficiaryMonthly\");\n-  }\n-\n-  /**\n-   * Gets the {@link #lineTable}.\n-   *\n-   * @return the name of the SQL table that the {@link #getLineEntity()} instances will be stored\n-   *     in, if any\n-   */\n-  public String getLineTable() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return lineTable;\n-  }\n-\n-  /**\n-   * Sets the {@link #lineTable}.\n-   *\n-   * @param lineTable the new value for {@link #getLineTable()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setLineTable(String lineTable) {\n-    if (!hasLines) throw new IllegalStateException();\n-    this.lineTable = lineTable;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the ClassName of the JPA {@link IdClass} for the {@link #getLineEntity()} {@link Entity}.\n-   *\n-   * @return the line entity id class name\n-   */\n-  public ClassName getLineEntityIdClass() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return getLineEntity().nestedClass(\"LineId\");\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link #getLineEntity()} {@link Entity} that should be used\n-   * to store and refer to the child {@link #getLineEntity()} {@link Entity}s.\n-   *\n-   * @return the name of the line entity parent field\n-   */\n-  public String getLineEntityParentField() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return \"parentClaim\";\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link Entity} that should be used to store and refer to the\n-   * parentBeneficiary {@link Entity}s.\n-   *\n-   * @return the beneficiary monthly entity parent field\n-   */\n-  public String getBeneficiaryMonthlyEntityParentField() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return \"parentBeneficiary\";\n-  }\n-\n-  /**\n-   * Sets the {@link #lineEntityLineNumberField}.\n-   *\n-   * @param lineEntityLineNumberField the name of the field in the {@link #getLineEntity()} {@link\n-   *     Entity} that should be used for the identifying line number\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setLineEntityLineNumberField(String lineEntityLineNumberField) {\n-    if (!hasLines) throw new IllegalStateException();\n-    this.lineEntityLineNumberField = lineEntityLineNumberField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #lineEntityLineNumberField}.\n-   *\n-   * @return the name of the field in the {@link #getLineEntity()} {@link Entity} that should be\n-   *     used for the identifying line number, if any\n-   */\n-  public String getLineEntityLineNumberField() {\n-    // use Java field name since there is no uniformity among column names for line #\n-    if (!hasLines) throw new IllegalStateException();\n-    return lineEntityLineNumberField;\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link Entity} that should be used for the identifying\n-   * yearMonth.\n-   *\n-   * @return the beneficiary monthly entity field\n-   */\n-  public String getEntityBeneficiaryMonthlyField() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return \"YEAR_MONTH\";\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityTransientFields}.\n-   *\n-   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n-   */\n-  public List<String> getHeaderEntityTransientFields() {\n-    return headerEntityTransientFields;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityTransientFields}.\n-   *\n-   * @param headerEntityTransientFields the new value for {@link #getHeaderEntityTransientFields()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityTransientFields(String... headerEntityTransientFields) {\n-    Objects.requireNonNull(headerEntityTransientFields);\n-    this.headerEntityTransientFields = Arrays.asList(headerEntityTransientFields);\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityAdditionalDatabaseFields}.\n-   *\n-   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n-   */\n-  public List<RifField> getHeaderEntityAdditionalDatabaseFields() {\n-    return headerEntityAdditionalDatabaseFields;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityAdditionalDatabaseFields}.\n-   *\n-   * @param headerEntityAdditionalDatabaseFields the new value for {@link\n-   *     #getHeaderEntityAdditionalDatabaseFields()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityAdditionalDatabaseFields(\n-      List<RifField> headerEntityAdditionalDatabaseFields) {\n-    Objects.requireNonNull(headerEntityAdditionalDatabaseFields);\n-    this.headerEntityAdditionalDatabaseFields = headerEntityAdditionalDatabaseFields;\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the {@link #sequenceNumberGeneratorName}.\n-   *\n-   * @param sequenceNumberGeneratorName the db sequence number generator name {@link\n-   *     #getSequenceNumberGeneratorName()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setSequenceNumberGeneratorName(String sequenceNumberGeneratorName) {\n-    this.sequenceNumberGeneratorName = sequenceNumberGeneratorName;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #sequenceNumberGeneratorName}.\n-   *\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public String getSequenceNumberGeneratorName() {\n-    return sequenceNumberGeneratorName;\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} for the class to be built that will contain parsing code for the\n-   * layout.\n-   *\n-   * @return the class name for the parser\n-   */\n-  public ClassName getParserClass() {\n-    return ClassName.get(packageName, headerEntity + \"Parser\");\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} for the class to be built that will contain CSV writing for the\n-   * layout.\n-   *\n-   * @return the csv writer class name\n-   */\n-  public ClassName getCsvWriterClass() {\n-    return ClassName.get(packageName, headerEntity + \"CsvWriter\");\n-  }\n-\n-  /** {@inheritDoc} */\n-  @Override\n-  public String toString() {\n-    StringBuilder builder = new StringBuilder();\n-    builder.append(\"MappingSpec [packageName=\");\n-    builder.append(packageName);\n-    builder.append(\", rifLayout=\");\n-    builder.append(rifLayout);\n-    builder.append(\", headerEntity=\");\n-    builder.append(headerEntity);\n-    builder.append(\", headerTable=\");\n-    builder.append(headerTable);\n-    builder.append(\", headerEntityIdField=\");\n-    builder.append(headerEntityIdField);\n-    builder.append(\", hasLines=\");\n-    builder.append(hasLines);\n-    builder.append(\", lineTable=\");\n-    builder.append(lineTable);\n-    if (hasLines) {\n-      builder.append(\", lineEntityLineNumber=\");\n-      builder.append(lineEntityLineNumberField);\n-    }\n-    builder.append(\"]\");\n-    return builder.toString();\n-  }\n-\n-  /**\n-   * Determines if there are any {@link #innerJoinRelationship}s.\n-   *\n-   * @return <code>true</code> if the RIF layout has an inner join relationship <code>false</code>\n-   *     if not\n-   */\n-  public Boolean getHasInnerJoinRelationship() {\n-    return this.innerJoinRelationship.size() != 0;\n-  }\n-\n-  /**\n-   * Sets the {@link #innerJoinRelationship}.\n-   *\n-   * @param innerJoinRelationship a list of {@link String} parameters defining the inner join\n-   *     relationship for the entity\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setInnerJoinRelationship(List<InnerJoinRelationship> innerJoinRelationship) {\n-    this.innerJoinRelationship = innerJoinRelationship;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #innerJoinRelationship}.\n-   *\n-   * @return the list of {@link #innerJoinRelationship}s\n-   */\n-  public List<InnerJoinRelationship> getInnerJoinRelationship() {\n-    return this.innerJoinRelationship;\n-  }\n-\n-  /**\n-   * Gets the class name for the specified entity name.\n-   *\n-   * @param entity the {@link String} entity for which to return the {@link ClassName} for\n-   * @return the {@link ClassName} of the provided {@link String} entity\n-   */\n-  public ClassName getClassName(String entity) {\n-    return ClassName.get(packageName, entity);\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "20caedd65963b799db11e56142081af2279daf75", "committedDate": "2021-02-02 17:54:12 -0800", "message": "BFD-379-Support-BB2-Address-Fields-Filtering-header-includeAddressFields (#390)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "86a2665d1f0252675f227f300fc0643ded7d9bfe", "committedDate": "2022-02-01 08:01:24 -0800", "message": "BFD-1514: Clean up javadoc errors in Model module (#929)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDI1NA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549560254", "body": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyText": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyHTML": "<p dir=\"auto\">FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).</p>", "author": "karlmdavis", "createdAt": "2020-12-29T04:04:22Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,156 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  private static void createBeneficiaryMonthlyFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createBeneficiaryMonthlyAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+\n+    // Add an @Id annotation, if appropriate.\n+    if (isId) {\n+      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n+      annotations.add(idAnnotation.build());\n+    }\n+    // Add an @Column annotation to every non-transient column.\n+    if (!isTransient) {\n+      AnnotationSpec.Builder columnAnnotation =\n+          AnnotationSpec.builder(Column.class)\n+              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n+              .addMember(\"nullable\", \"$L\", isColumnOptional);\n+      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n+        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n+      } else if (type == RifColumnType.NUM) {\n+        /*\n+         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         */\n+\n+        if (columnLength.isPresent() && columnScale.isPresent()) {\n+          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n+          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n+        } else {\n+          /*\n+           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+           * handle SQL numeric datatypes that don't have a defined precision and scale.\n+           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+           * but what it does instead is insert a default precision and scale as\n+           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+           * (for different reasons), but fortunately that doesn't happen to cause\n+           * problems with our tests.\n+           */\n+          StringBuilder columnDefinition = new StringBuilder();\n+          columnDefinition.append(\"numeric\");\n+          if (columnLength.isPresent() || columnScale.isPresent()) {\n+            columnDefinition.append('(');\n+            if (columnLength.isPresent()) {\n+              columnDefinition.append(columnLength.get());\n+            }\n+            if (columnScale.isPresent()) {\n+              columnDefinition.append(\", \");\n+              columnDefinition.append(columnScale.get());\n+            }\n+            columnDefinition.append(')');\n+          }\n+          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+        }\n+      }\n+      annotations.add(columnAnnotation.build());\n+    } else {\n+      annotations.add(AnnotationSpec.builder(Transient.class).build());\n+    }\n+\n+    return annotations;\n+  }\n+\n+  private static TypeName selectJavaFieldType(", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3MDIzMA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549570230", "bodyText": "added", "author": "cbrunefearless", "createdAt": "2020-12-29T05:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1941,6 +1964,14 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     return annotations;\n   }\n \n+  /**\n+   * Selects the java field type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n       boolean isColumnOptional,\n", "next_change": {"commit": "61956e52e5c6f21c5f0c0e46b45676c25302cde4", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..c107a45b2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1969,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c107a45b2..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1969,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "52561a672c4494913b48b46416bae9d5da353181", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..c107a45b2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1969,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "dbf04f2800fa05f62631402ff7e532b8d6b39d29", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c107a45b2..5307df02d 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1972,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1941,6 +1970,17 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     return annotations;\n   }\n \n+  /**\n+   * Selects the java field type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n+   */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n       boolean isColumnOptional,\n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1980,6 +2205,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n+   * @return the java field type\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 9e64b5c55..63f878aff 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2205,33 +2237,47 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n-   * @return the java field type\n+   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n+   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n+   *     in fact needs to be a Java class type (i.e., Long)\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n       boolean isColumnOptional,\n       Optional<Integer> columnLength,\n       Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+    if (type == RifColumnType.CHAR) {\n+      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n+        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n+      } else {\n+        return ClassName.get(String.class);\n+      }\n+    } else if (type == RifColumnType.DATE) {\n       return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+    } else if (type == RifColumnType.TIMESTAMP) {\n       return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+    }\n+    // handle an inherited hack from the Excel spreadsheet in which a row entry\n+    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n+    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n       return ClassName.get(BigDecimal.class);\n+    }\n+    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n+    // not optional should be defined as a primitive integer.\n+    //\n     else if (type == RifColumnType.NUM\n         && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+        && !isColumnOptional) {\n+      return TypeName.INT;\n+    } else if (type == RifColumnType.SMALLINT) {\n+      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n+    } else if (type == RifColumnType.BIGINT) {\n+      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n+    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n+      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n+    }\n+    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n   }\n \n   /**\n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 63f878aff..a5a2598c2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2285,11 +2321,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n+   *     types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n+   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n+   *     the decimal point\n    * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex a5a2598c2..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2343 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  /** The link to the data dictionary. */\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  /** The name to use for a parent claim. */\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  /** The name to use for a parent beneficiary. */\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  /** The list of log messages to write out. */\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes()\n-   */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion()\n-   */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   *\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Generates source files from the provided annotated package.\n-   *\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\n-                          \"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\", \"BENE_ID_NUMERIC\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) {\n-        spreadsheetWorkbook.close();\n-      }\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"snf_claims\",\n-            \"partd_events\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR) {\n-\n-        if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-          parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-        } else if (rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-          // Handle a String field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-        } else {\n-          // Handle a Character field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-        }\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.BIGINT) {\n-        // Handle an BigInteger field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.SMALLINT) {\n-        // Handle an Short field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalShort\" : \"parseShort\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.INTEGER) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        if (rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-          // Handle an Integer field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-        } else {\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-        }\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields the list of {@link FieldSpec}s to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * Generates a hash code method.\n-   *\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Generates an equals method.\n-   *\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Creates an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   * annotations that should be applied to the specified {@link RifField}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"BENE_ID_NUMERIC\")) {\n-        RifField beneIdNumeric =\n-            new RifField(\n-                \"BENE_ID_NUMERIC\",\n-                RifColumnType.BIGINT,\n-                Optional.of(8),\n-                Optional.of(0),\n-                Boolean.FALSE,\n-                null,\n-                \"BENE_ID_NUMERIC\",\n-                \"beneficiaryIdNumeric\");\n-        addlDatabaseFields.add(beneIdNumeric);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * Converts the specified string from snake case to camel case.\n-   *\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * Calculates the getter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Calculates the setter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Capitalizes the first letter of a string.\n-   *\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n-   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n-   *     in fact needs to be a Java class type (i.e., Long)\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR) {\n-      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n-        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n-      } else {\n-        return ClassName.get(String.class);\n-      }\n-    } else if (type == RifColumnType.DATE) {\n-      return ClassName.get(LocalDate.class);\n-    } else if (type == RifColumnType.TIMESTAMP) {\n-      return ClassName.get(Instant.class);\n-    }\n-    // handle an inherited hack from the Excel spreadsheet in which a row entry\n-    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n-    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n-      return ClassName.get(BigDecimal.class);\n-    }\n-    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n-    // not optional should be defined as a primitive integer.\n-    //\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) {\n-      return TypeName.INT;\n-    } else if (type == RifColumnType.SMALLINT) {\n-      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n-    } else if (type == RifColumnType.BIGINT) {\n-      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n-    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n-      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n-    }\n-    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDI5OQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549560299", "body": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyText": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyHTML": "<p dir=\"auto\">FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).</p>", "author": "karlmdavis", "createdAt": "2020-12-29T04:04:37Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,156 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  private static void createBeneficiaryMonthlyFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createBeneficiaryMonthlyAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1873,6 +1885,17 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     lineEntity.addMethod(lineFieldSetter.build());\n   }\n \n+  /**\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   *\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n       boolean isTransient,\n", "next_change": {"commit": "8cd87a7a088d4f9fb1d09e0905505b3aec049a1c", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..20623a90f 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1893,8 +1896,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n", "next_change": {"commit": "2ea161ee2f878348bec572954d9221e7917d294e", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 20623a90f..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1896,8 +1896,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1873,6 +1888,20 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     lineEntity.addMethod(lineFieldSetter.build());\n   }\n \n+  /**\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   *\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n+   */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n       boolean isTransient,\n", "next_change": {"commit": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..15f56b2d8 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1892,81 +2019,60 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n    *\n    * @param isId determines if the field is an id field\n-   * @param isTransient determines if the field is transient {@link boolean}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param fieldName specifies the fieldname {@link String}\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param rifField {@link RifField} to create\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+      boolean isId, RifField rifField) {\n \n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n     // Add an @Id annotation, if appropriate.\n     if (isId) {\n       AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n       annotations.add(idAnnotation.build());\n     }\n-    // Add an @Column annotation to every non-transient column.\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n-              .addMember(\"nullable\", \"$L\", isColumnOptional);\n-      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n-      } else if (type == RifColumnType.NUM) {\n+    // Add an @Column annotation to every column.\n+    AnnotationSpec.Builder columnAnnotation =\n+        AnnotationSpec.builder(Column.class)\n+            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n+            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n+\n+    if (rifField.getRifColumnType() == RifColumnType.CHAR\n+        && rifField.getRifColumnLength().isPresent()) {\n+      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n+    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n+      /*\n+       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+       */\n+\n+      if (rifField.getRifColumnLength().isPresent()) {\n+        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n+        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n+      } else {\n         /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+         * handle SQL numeric datatypes that don't have a defined precision and scale.\n+         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+         * but what it does instead is insert a default precision and scale as\n+         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+         * (for different reasons), but fortunately that doesn't happen to cause\n+         * problems with our tests.\n          */\n+        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n+        if (rifField.getRifColumnLength().isPresent()) {\n+          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n \n-        if (columnLength.isPresent() && columnScale.isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (columnLength.isPresent() || columnScale.isPresent()) {\n-            columnDefinition.append('(');\n-            if (columnLength.isPresent()) {\n-              columnDefinition.append(columnLength.get());\n-            }\n-            if (columnScale.isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(columnScale.get());\n-            }\n-            columnDefinition.append(')');\n+          if (rifField.getRifColumnScale().isPresent()) {\n+            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n           }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+          columnDefinition.append(\")\");\n         }\n+        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n       }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n     }\n-\n+    annotations.add(columnAnnotation.build());\n     return annotations;\n   }\n \n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 15f56b2d8..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2077,7 +2196,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n   }\n \n   /**\n-   * Selects the java field type\n+   * Selects the java field type.\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n", "next_change": {"commit": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 9e64b5c55..63f878aff 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2205,33 +2237,47 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n-   * @return the java field type\n+   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n+   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n+   *     in fact needs to be a Java class type (i.e., Long)\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n       boolean isColumnOptional,\n       Optional<Integer> columnLength,\n       Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+    if (type == RifColumnType.CHAR) {\n+      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n+        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n+      } else {\n+        return ClassName.get(String.class);\n+      }\n+    } else if (type == RifColumnType.DATE) {\n       return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+    } else if (type == RifColumnType.TIMESTAMP) {\n       return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+    }\n+    // handle an inherited hack from the Excel spreadsheet in which a row entry\n+    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n+    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n       return ClassName.get(BigDecimal.class);\n+    }\n+    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n+    // not optional should be defined as a primitive integer.\n+    //\n     else if (type == RifColumnType.NUM\n         && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+        && !isColumnOptional) {\n+      return TypeName.INT;\n+    } else if (type == RifColumnType.SMALLINT) {\n+      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n+    } else if (type == RifColumnType.BIGINT) {\n+      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n+    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n+      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n+    }\n+    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n   }\n \n   /**\n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 63f878aff..a5a2598c2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2285,11 +2321,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n+   *     types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n+   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n+   *     the decimal point\n    * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex a5a2598c2..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2343 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  /** The link to the data dictionary. */\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  /** The name to use for a parent claim. */\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  /** The name to use for a parent beneficiary. */\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  /** The list of log messages to write out. */\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes()\n-   */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion()\n-   */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   *\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Generates source files from the provided annotated package.\n-   *\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\n-                          \"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\", \"BENE_ID_NUMERIC\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) {\n-        spreadsheetWorkbook.close();\n-      }\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"snf_claims\",\n-            \"partd_events\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR) {\n-\n-        if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-          parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-        } else if (rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-          // Handle a String field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-        } else {\n-          // Handle a Character field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-        }\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.BIGINT) {\n-        // Handle an BigInteger field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.SMALLINT) {\n-        // Handle an Short field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalShort\" : \"parseShort\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.INTEGER) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        if (rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-          // Handle an Integer field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-        } else {\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-        }\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields the list of {@link FieldSpec}s to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * Generates a hash code method.\n-   *\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Generates an equals method.\n-   *\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Creates an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   * annotations that should be applied to the specified {@link RifField}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"BENE_ID_NUMERIC\")) {\n-        RifField beneIdNumeric =\n-            new RifField(\n-                \"BENE_ID_NUMERIC\",\n-                RifColumnType.BIGINT,\n-                Optional.of(8),\n-                Optional.of(0),\n-                Boolean.FALSE,\n-                null,\n-                \"BENE_ID_NUMERIC\",\n-                \"beneficiaryIdNumeric\");\n-        addlDatabaseFields.add(beneIdNumeric);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * Converts the specified string from snake case to camel case.\n-   *\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * Calculates the getter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Calculates the setter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Capitalizes the first letter of a string.\n-   *\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n-   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n-   *     in fact needs to be a Java class type (i.e., Long)\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR) {\n-      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n-        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n-      } else {\n-        return ClassName.get(String.class);\n-      }\n-    } else if (type == RifColumnType.DATE) {\n-      return ClassName.get(LocalDate.class);\n-    } else if (type == RifColumnType.TIMESTAMP) {\n-      return ClassName.get(Instant.class);\n-    }\n-    // handle an inherited hack from the Excel spreadsheet in which a row entry\n-    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n-    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n-      return ClassName.get(BigDecimal.class);\n-    }\n-    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n-    // not optional should be defined as a primitive integer.\n-    //\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) {\n-      return TypeName.INT;\n-    } else if (type == RifColumnType.SMALLINT) {\n-      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n-    } else if (type == RifColumnType.BIGINT) {\n-      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n-    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n-      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n-    }\n-    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDMxMw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549560313", "body": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyText": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyHTML": "<p dir=\"auto\">FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).</p>", "author": "karlmdavis", "createdAt": "2020-12-29T04:04:48Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,156 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  private static void createBeneficiaryMonthlyFields(", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2OTgxNQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549569815", "bodyText": "added", "author": "cbrunefearless", "createdAt": "2020-12-29T05:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3MTk5Ng==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r550271996", "bodyText": "This is helpful.", "author": "jzulim", "createdAt": "2020-12-30T17:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1829,6 +1829,18 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     }\n   }\n \n+  /**\n+   * Creates the fields for the BeneficiaryMonthly class in the model rif\n+   *\n+   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n       boolean isId,\n", "next_change": {"commit": "148d2587022acbf516a4a2ff5e98cbbd7c70ebe2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..0e33235de 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 0e33235de..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "52561a672c4494913b48b46416bae9d5da353181", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..c107a45b2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "dbf04f2800fa05f62631402ff7e532b8d6b39d29", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c107a45b2..5307df02d 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1829,6 +1829,21 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     }\n   }\n \n+  /**\n+   * Creates the fields for the BeneficiaryMonthly class in the model rif\n+   *\n+   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n+   */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n       boolean isId,\n", "next_change": {"commit": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..15f56b2d8 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1834,57 +1979,39 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n    * @param isId determines if the field is an id field\n-   * @param isTransient determines if the field is transient {@link boolean}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param fieldName specifies the fieldname {@link String}\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param rifField {@link RifField} to create\n    */\n   private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity,\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n+      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n+\n+    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n+    TypeName javaFieldType =\n+        selectJavaFieldType(\n+            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n+            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n+    TypeName javaPropType =\n+        selectJavaPropertyType(\n+            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n+            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n     FieldSpec lineField =\n-        FieldSpec.builder(\n-                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n-                fieldName,\n-                Modifier.PRIVATE)\n-            .addAnnotations(\n-                createBeneficiaryMonthlyAnnotations(\n-                    isId,\n-                    isTransient,\n-                    isColumnOptional,\n-                    fieldName,\n-                    type,\n-                    columnLength,\n-                    columnScale))\n+        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n+            .addAnnotations(annotSpecs)\n             .build();\n     lineEntity.addField(lineField);\n \n     MethodSpec.Builder lineFieldGetter =\n         MethodSpec.methodBuilder(calculateGetterName(lineField))\n             .addModifiers(Modifier.PUBLIC)\n-            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n-    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+            .returns(javaPropType);\n+    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n     lineEntity.addMethod(lineFieldGetter.build());\n \n     MethodSpec.Builder lineFieldSetter =\n         MethodSpec.methodBuilder(calculateSetterName(lineField))\n             .addModifiers(Modifier.PUBLIC)\n             .returns(void.class)\n-            .addParameter(\n-                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n-                lineField.name);\n-    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+            .addParameter(javaPropType, lineField.name);\n+    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n     lineEntity.addMethod(lineFieldSetter.build());\n   }\n \n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 15f56b2d8..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2016,10 +2134,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n   }\n \n   /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n    *\n    * @param isId determines if the field is an id field\n    * @param rifField {@link RifField} to create\n+   * @return the created annotation specs\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId, RifField rifField) {\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex 9e64b5c55..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2261 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes() */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion() */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) spreadsheetWorkbook.close();\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make\n-    // it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"partd_events\",\n-            \"snf_claims\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-        // Handle a String field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1) {\n-        // Handle a Character field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) > 0) {\n-        // Handle a Decimal field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields {@link List<FieldSpec>} to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n-      return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n-      return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n-      return ClassName.get(BigDecimal.class);\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDM0Nw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549560347", "body": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyText": "FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).", "bodyHTML": "<p dir=\"auto\">FWIW, I'd suggest JavaDoc'ing this, as it's not entirely obvious what some of those parameters mean (I can never quite remember what scale means, for instance).</p>", "author": "karlmdavis", "createdAt": "2020-12-29T04:05:00Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,156 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  private static void createBeneficiaryMonthlyFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createBeneficiaryMonthlyAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+\n+    // Add an @Id annotation, if appropriate.\n+    if (isId) {\n+      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n+      annotations.add(idAnnotation.build());\n+    }\n+    // Add an @Column annotation to every non-transient column.\n+    if (!isTransient) {\n+      AnnotationSpec.Builder columnAnnotation =\n+          AnnotationSpec.builder(Column.class)\n+              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n+              .addMember(\"nullable\", \"$L\", isColumnOptional);\n+      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n+        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n+      } else if (type == RifColumnType.NUM) {\n+        /*\n+         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         */\n+\n+        if (columnLength.isPresent() && columnScale.isPresent()) {\n+          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n+          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n+        } else {\n+          /*\n+           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+           * handle SQL numeric datatypes that don't have a defined precision and scale.\n+           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+           * but what it does instead is insert a default precision and scale as\n+           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+           * (for different reasons), but fortunately that doesn't happen to cause\n+           * problems with our tests.\n+           */\n+          StringBuilder columnDefinition = new StringBuilder();\n+          columnDefinition.append(\"numeric\");\n+          if (columnLength.isPresent() || columnScale.isPresent()) {\n+            columnDefinition.append('(');\n+            if (columnLength.isPresent()) {\n+              columnDefinition.append(columnLength.get());\n+            }\n+            if (columnScale.isPresent()) {\n+              columnDefinition.append(\", \");\n+              columnDefinition.append(columnScale.get());\n+            }\n+            columnDefinition.append(')');\n+          }\n+          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+        }\n+      }\n+      annotations.add(columnAnnotation.build());\n+    } else {\n+      annotations.add(AnnotationSpec.builder(Transient.class).build());\n+    }\n+\n+    return annotations;\n+  }\n+\n+  private static TypeName selectJavaFieldType(\n+      RifColumnType type,\n+      boolean isColumnOptional,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    if (type == RifColumnType.CHAR\n+        && columnLength.orElse(Integer.MAX_VALUE) == 1\n+        && !isColumnOptional) return TypeName.CHAR;\n+    else if (type == RifColumnType.CHAR\n+        && columnLength.orElse(Integer.MAX_VALUE) == 1\n+        && isColumnOptional) return ClassName.get(Character.class);\n+    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n+    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+      return ClassName.get(LocalDate.class);\n+    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+      return ClassName.get(Instant.class);\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+      return ClassName.get(BigDecimal.class);\n+    else if (type == RifColumnType.NUM\n+        && columnScale.orElse(Integer.MAX_VALUE) == 0\n+        && !isColumnOptional) return TypeName.INT;\n+    else if (type == RifColumnType.NUM\n+        && columnScale.orElse(Integer.MAX_VALUE) == 0\n+        && isColumnOptional) return ClassName.get(Integer.class);\n+    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+  }\n+\n+  private static TypeName selectJavaPropertyType(", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3MDI5OA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549570298", "bodyText": "added", "author": "cbrunefearless", "createdAt": "2020-12-29T05:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1968,6 +1999,14 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n   }\n \n+  /**\n+   * Selects the java property type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n       boolean isColumnOptional,\n", "next_change": {"commit": "49ad5b80ad13a006c340af8d9632c054d4178e23", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..2234c5e42 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2004,8 +2010,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": {"commit": "0db992f302646824a41c835342a05e971e1bc151", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 2234c5e42..1b90f6caa 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2010,8 +2010,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c15bfb93e..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1968,6 +2008,17 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n     else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n   }\n \n+  /**\n+   * Selects the java property type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n+   */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n       boolean isColumnOptional,\n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2018,6 +2244,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n+   * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 9e64b5c55..a5a2598c2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2239,11 +2321,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n+   *     types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n+   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n+   *     the decimal point\n    * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex a5a2598c2..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2343 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  /** The link to the data dictionary. */\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  /** The name to use for a parent claim. */\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  /** The name to use for a parent beneficiary. */\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  /** The list of log messages to write out. */\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes()\n-   */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion()\n-   */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   *\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Generates source files from the provided annotated package.\n-   *\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\n-                          \"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\", \"BENE_ID_NUMERIC\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) {\n-        spreadsheetWorkbook.close();\n-      }\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"snf_claims\",\n-            \"partd_events\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR) {\n-\n-        if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-          parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-        } else if (rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-          // Handle a String field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-        } else {\n-          // Handle a Character field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-        }\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.BIGINT) {\n-        // Handle an BigInteger field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.SMALLINT) {\n-        // Handle an Short field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalShort\" : \"parseShort\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.INTEGER) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        if (rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-          // Handle an Integer field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-        } else {\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-        }\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields the list of {@link FieldSpec}s to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * Generates a hash code method.\n-   *\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Generates an equals method.\n-   *\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Creates an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   * annotations that should be applied to the specified {@link RifField}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"BENE_ID_NUMERIC\")) {\n-        RifField beneIdNumeric =\n-            new RifField(\n-                \"BENE_ID_NUMERIC\",\n-                RifColumnType.BIGINT,\n-                Optional.of(8),\n-                Optional.of(0),\n-                Boolean.FALSE,\n-                null,\n-                \"BENE_ID_NUMERIC\",\n-                \"beneficiaryIdNumeric\");\n-        addlDatabaseFields.add(beneIdNumeric);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * Converts the specified string from snake case to camel case.\n-   *\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * Calculates the getter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Calculates the setter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Capitalizes the first letter of a string.\n-   *\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n-   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n-   *     in fact needs to be a Java class type (i.e., Long)\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR) {\n-      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n-        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n-      } else {\n-        return ClassName.get(String.class);\n-      }\n-    } else if (type == RifColumnType.DATE) {\n-      return ClassName.get(LocalDate.class);\n-    } else if (type == RifColumnType.TIMESTAMP) {\n-      return ClassName.get(Instant.class);\n-    }\n-    // handle an inherited hack from the Excel spreadsheet in which a row entry\n-    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n-    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n-      return ClassName.get(BigDecimal.class);\n-    }\n-    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n-    // not optional should be defined as a primitive integer.\n-    //\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) {\n-      return TypeName.INT;\n-    } else if (type == RifColumnType.SMALLINT) {\n-      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n-    } else if (type == RifColumnType.BIGINT) {\n-      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n-    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n-      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n-    }\n-    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTAyMQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549561021", "body": "FWIW, you don't need this `if` -- the for loop just won't run if the list is empty.", "bodyText": "FWIW, you don't need this if -- the for loop just won't run if the list is empty.", "bodyHTML": "<p dir=\"auto\">FWIW, you don't need this <code>if</code> -- the for loop just won't run if the list is empty.</p>", "author": "karlmdavis", "createdAt": "2020-12-29T04:09:11Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java", "diffHunk": "@@ -596,6 +614,313 @@ private void processAsync(\n     }\n   }\n \n+  /**\n+   * Ensures that a {@link BeneficiaryMonthly} record is created or updated for the specified {@link\n+   * Beneficiary}, if that {@link Beneficiary} already exists and is just being updated.\n+   *\n+   * @param entityManager the {@link EntityManager} to use\n+   * @param loadAction the {@link Loadaction} record being processed\n+   * @param beneficiaryRecord the {@link Beneficiary} record being processed\n+   */\n+  private static void updateBeneficiaryMonthly(\n+      EntityManager entityManager, Beneficiary beneficiaryRecord) {\n+\n+    if (beneficiaryRecord.getBeneEnrollmentReferenceYear().isPresent()) {\n+\n+      int year = beneficiaryRecord.getBeneEnrollmentReferenceYear().get().intValue();\n+      List<BeneficiaryMonthly> currentYearBeneficiaryMonthly = new ArrayList<BeneficiaryMonthly>();\n+\n+      BeneficiaryMonthly beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 1, 1),\n+              beneficiaryRecord.getEntitlementBuyInJanInd(),\n+              beneficiaryRecord.getFipsStateCntyJanCode(),\n+              beneficiaryRecord.getHmoIndicatorJanInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJanCode(),\n+              beneficiaryRecord.getMedicareStatusJanCode(),\n+              beneficiaryRecord.getPartCContractNumberJanId(),\n+              beneficiaryRecord.getPartCPbpNumberJanId(),\n+              beneficiaryRecord.getPartCPlanTypeJanCode(),\n+              beneficiaryRecord.getPartDContractNumberJanId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJanCode(),\n+              beneficiaryRecord.getPartDPbpNumberJanId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJanInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJanId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 2, 1),\n+              beneficiaryRecord.getEntitlementBuyInFebInd(),\n+              beneficiaryRecord.getFipsStateCntyFebCode(),\n+              beneficiaryRecord.getHmoIndicatorFebInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityFebCode(),\n+              beneficiaryRecord.getMedicareStatusFebCode(),\n+              beneficiaryRecord.getPartCContractNumberFebId(),\n+              beneficiaryRecord.getPartCPbpNumberFebId(),\n+              beneficiaryRecord.getPartCPlanTypeFebCode(),\n+              beneficiaryRecord.getPartDContractNumberFebId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupFebCode(),\n+              beneficiaryRecord.getPartDPbpNumberFebId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyFebInd(),\n+              beneficiaryRecord.getPartDSegmentNumberFebId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 3, 1),\n+              beneficiaryRecord.getEntitlementBuyInMarInd(),\n+              beneficiaryRecord.getFipsStateCntyMarCode(),\n+              beneficiaryRecord.getHmoIndicatorMarInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityMarCode(),\n+              beneficiaryRecord.getMedicareStatusMarCode(),\n+              beneficiaryRecord.getPartCContractNumberMarId(),\n+              beneficiaryRecord.getPartCPbpNumberMarId(),\n+              beneficiaryRecord.getPartCPlanTypeMarCode(),\n+              beneficiaryRecord.getPartDContractNumberMarId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupMarCode(),\n+              beneficiaryRecord.getPartDPbpNumberMarId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyMarInd(),\n+              beneficiaryRecord.getPartDSegmentNumberMarId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 4, 1),\n+              beneficiaryRecord.getEntitlementBuyInAprInd(),\n+              beneficiaryRecord.getFipsStateCntyAprCode(),\n+              beneficiaryRecord.getHmoIndicatorAprInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityAprCode(),\n+              beneficiaryRecord.getMedicareStatusAprCode(),\n+              beneficiaryRecord.getPartCContractNumberAprId(),\n+              beneficiaryRecord.getPartCPbpNumberAprId(),\n+              beneficiaryRecord.getPartCPlanTypeAprCode(),\n+              beneficiaryRecord.getPartDContractNumberAprId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupAprCode(),\n+              beneficiaryRecord.getPartDPbpNumberAprId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyAprInd(),\n+              beneficiaryRecord.getPartDSegmentNumberAprId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 5, 1),\n+              beneficiaryRecord.getEntitlementBuyInMayInd(),\n+              beneficiaryRecord.getFipsStateCntyMayCode(),\n+              beneficiaryRecord.getHmoIndicatorMayInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityMayCode(),\n+              beneficiaryRecord.getMedicareStatusMayCode(),\n+              beneficiaryRecord.getPartCContractNumberMayId(),\n+              beneficiaryRecord.getPartCPbpNumberMayId(),\n+              beneficiaryRecord.getPartCPlanTypeMayCode(),\n+              beneficiaryRecord.getPartDContractNumberMayId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupMayCode(),\n+              beneficiaryRecord.getPartDPbpNumberMayId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyMayInd(),\n+              beneficiaryRecord.getPartDSegmentNumberMayId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 6, 1),\n+              beneficiaryRecord.getEntitlementBuyInJunInd(),\n+              beneficiaryRecord.getFipsStateCntyJunCode(),\n+              beneficiaryRecord.getHmoIndicatorJunInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJunCode(),\n+              beneficiaryRecord.getMedicareStatusJunCode(),\n+              beneficiaryRecord.getPartCContractNumberJunId(),\n+              beneficiaryRecord.getPartCPbpNumberJunId(),\n+              beneficiaryRecord.getPartCPlanTypeJunCode(),\n+              beneficiaryRecord.getPartDContractNumberJunId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJunCode(),\n+              beneficiaryRecord.getPartDPbpNumberJunId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJunInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJunId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 7, 1),\n+              beneficiaryRecord.getEntitlementBuyInJulInd(),\n+              beneficiaryRecord.getFipsStateCntyJulCode(),\n+              beneficiaryRecord.getHmoIndicatorJulInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJulCode(),\n+              beneficiaryRecord.getMedicareStatusJulCode(),\n+              beneficiaryRecord.getPartCContractNumberJulId(),\n+              beneficiaryRecord.getPartCPbpNumberJulId(),\n+              beneficiaryRecord.getPartCPlanTypeJulCode(),\n+              beneficiaryRecord.getPartDContractNumberJulId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJulCode(),\n+              beneficiaryRecord.getPartDPbpNumberJulId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJulInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJulId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 8, 1),\n+              beneficiaryRecord.getEntitlementBuyInAugInd(),\n+              beneficiaryRecord.getFipsStateCntyAugCode(),\n+              beneficiaryRecord.getHmoIndicatorAugInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityAugCode(),\n+              beneficiaryRecord.getMedicareStatusAugCode(),\n+              beneficiaryRecord.getPartCContractNumberAugId(),\n+              beneficiaryRecord.getPartCPbpNumberAugId(),\n+              beneficiaryRecord.getPartCPlanTypeAugCode(),\n+              beneficiaryRecord.getPartDContractNumberAugId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupAugCode(),\n+              beneficiaryRecord.getPartDPbpNumberAugId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyAugInd(),\n+              beneficiaryRecord.getPartDSegmentNumberAugId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 9, 1),\n+              beneficiaryRecord.getEntitlementBuyInSeptInd(),\n+              beneficiaryRecord.getFipsStateCntySeptCode(),\n+              beneficiaryRecord.getHmoIndicatorSeptInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilitySeptCode(),\n+              beneficiaryRecord.getMedicareStatusSeptCode(),\n+              beneficiaryRecord.getPartCContractNumberSeptId(),\n+              beneficiaryRecord.getPartCPbpNumberSeptId(),\n+              beneficiaryRecord.getPartCPlanTypeSeptCode(),\n+              beneficiaryRecord.getPartDContractNumberSeptId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupSeptCode(),\n+              beneficiaryRecord.getPartDPbpNumberSeptId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidySeptInd(),\n+              beneficiaryRecord.getPartDSegmentNumberSeptId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 10, 1),\n+              beneficiaryRecord.getEntitlementBuyInOctInd(),\n+              beneficiaryRecord.getFipsStateCntyOctCode(),\n+              beneficiaryRecord.getHmoIndicatorOctInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityOctCode(),\n+              beneficiaryRecord.getMedicareStatusOctCode(),\n+              beneficiaryRecord.getPartCContractNumberOctId(),\n+              beneficiaryRecord.getPartCPbpNumberOctId(),\n+              beneficiaryRecord.getPartCPlanTypeOctCode(),\n+              beneficiaryRecord.getPartDContractNumberOctId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupOctCode(),\n+              beneficiaryRecord.getPartDPbpNumberOctId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyOctInd(),\n+              beneficiaryRecord.getPartDSegmentNumberOctId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 11, 1),\n+              beneficiaryRecord.getEntitlementBuyInNovInd(),\n+              beneficiaryRecord.getFipsStateCntyNovCode(),\n+              beneficiaryRecord.getHmoIndicatorNovInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityNovCode(),\n+              beneficiaryRecord.getMedicareStatusNovCode(),\n+              beneficiaryRecord.getPartCContractNumberNovId(),\n+              beneficiaryRecord.getPartCPbpNumberNovId(),\n+              beneficiaryRecord.getPartCPlanTypeNovCode(),\n+              beneficiaryRecord.getPartDContractNumberNovId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupNovCode(),\n+              beneficiaryRecord.getPartDPbpNumberNovId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyNovInd(),\n+              beneficiaryRecord.getPartDSegmentNumberNovId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 12, 1),\n+              beneficiaryRecord.getEntitlementBuyInDecInd(),\n+              beneficiaryRecord.getFipsStateCntyDecCode(),\n+              beneficiaryRecord.getHmoIndicatorDecInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityDecCode(),\n+              beneficiaryRecord.getMedicareStatusDecCode(),\n+              beneficiaryRecord.getPartCContractNumberDecId(),\n+              beneficiaryRecord.getPartCPbpNumberDecId(),\n+              beneficiaryRecord.getPartCPlanTypeDecCode(),\n+              beneficiaryRecord.getPartDContractNumberDecId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupDecCode(),\n+              beneficiaryRecord.getPartDPbpNumberDecId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyDecInd(),\n+              beneficiaryRecord.getPartDSegmentNumberDecId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      if (currentYearBeneficiaryMonthly.size() > 0) {\n+        List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n+\n+        Beneficiary beneficiaryFromDb =\n+            entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n+\n+        if (beneficiaryFromDb != null && beneficiaryFromDb.getBeneficiaryMonthlys().size() > 0) {\n+          currentBeneficiaryMonthlyWithUpdates = beneficiaryFromDb.getBeneficiaryMonthlys();\n+          List<BeneficiaryMonthly> currentYearBeneficiaryMonthlyPrevious =\n+              beneficiaryFromDb.getBeneficiaryMonthlys().stream()\n+                  .filter(e -> year == e.getYearMonth().getYear())\n+                  .collect(Collectors.toList());\n+\n+          if (currentYearBeneficiaryMonthlyPrevious.size() > 0) {", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NzY4MQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549567681", "bodyText": "Changed", "author": "cbrunefearless", "createdAt": "2020-12-29T04:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTAyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex d428c53b9..5797f9281 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -906,10 +908,8 @@ public final class RifLoader implements AutoCloseable {\n                   .filter(e -> year == e.getYearMonth().getYear())\n                   .collect(Collectors.toList());\n \n-          if (currentYearBeneficiaryMonthlyPrevious.size() > 0) {\n-            for (BeneficiaryMonthly previousEnrollment : currentYearBeneficiaryMonthlyPrevious) {\n-              currentBeneficiaryMonthlyWithUpdates.remove(previousEnrollment);\n-            }\n+          for (BeneficiaryMonthly previousEnrollment : currentYearBeneficiaryMonthlyPrevious) {\n+            currentBeneficiaryMonthlyWithUpdates.remove(previousEnrollment);\n           }\n         } else {\n           currentBeneficiaryMonthlyWithUpdates = new LinkedList<BeneficiaryMonthly>();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex d428c53b9..257d9724a 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -906,10 +908,8 @@ public final class RifLoader implements AutoCloseable {\n                   .filter(e -> year == e.getYearMonth().getYear())\n                   .collect(Collectors.toList());\n \n-          if (currentYearBeneficiaryMonthlyPrevious.size() > 0) {\n-            for (BeneficiaryMonthly previousEnrollment : currentYearBeneficiaryMonthlyPrevious) {\n-              currentBeneficiaryMonthlyWithUpdates.remove(previousEnrollment);\n-            }\n+          for (BeneficiaryMonthly previousEnrollment : currentYearBeneficiaryMonthlyPrevious) {\n+            currentBeneficiaryMonthlyWithUpdates.remove(previousEnrollment);\n           }\n         } else {\n           currentBeneficiaryMonthlyWithUpdates = new LinkedList<BeneficiaryMonthly>();\n", "next_change": {"commit": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 257d9724a..3d79d64a9 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -916,7 +967,7 @@ public final class RifLoader implements AutoCloseable {\n         }\n \n         currentBeneficiaryMonthlyWithUpdates.addAll(currentYearBeneficiaryMonthly);\n-        beneficiaryRecord.setBeneficiaryMonthlys(currentBeneficiaryMonthlyWithUpdates);\n+        newBeneficiaryRecord.setBeneficiaryMonthlys(currentBeneficiaryMonthlyWithUpdates);\n       }\n     }\n   }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "1b0103ba4f25f43a6c5c5c92c73364dc17d2e5b0", "committedDate": "2020-12-30 16:03:00 -0500", "message": "Cbrune/bfd 549 validate hibernate (#426)"}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTQ0Ng==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549561446", "body": "I'm tired and can't quite think my way through it, but I think this might open us up to a race condition if we ever got a RIF file that listed the same bene multiople times? CSV records are processed in parallel, so there's a chance that you have two threads working on and trying to update the same bene record at the same time.\r\n\r\nThat'd be weird and bad, but perhaps worth thinking about and at least adding a \"`TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file allowed`\".", "bodyText": "I'm tired and can't quite think my way through it, but I think this might open us up to a race condition if we ever got a RIF file that listed the same bene multiople times? CSV records are processed in parallel, so there's a chance that you have two threads working on and trying to update the same bene record at the same time.\nThat'd be weird and bad, but perhaps worth thinking about and at least adding a \"TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file allowed\".", "bodyHTML": "<p dir=\"auto\">I'm tired and can't quite think my way through it, but I think this might open us up to a race condition if we ever got a RIF file that listed the same bene multiople times? CSV records are processed in parallel, so there's a chance that you have two threads working on and trying to update the same bene record at the same time.</p>\n<p dir=\"auto\">That'd be weird and bad, but perhaps worth thinking about and at least adding a \"<code>TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file allowed</code>\".</p>", "author": "karlmdavis", "createdAt": "2020-12-29T04:12:36Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java", "diffHunk": "@@ -596,6 +614,313 @@ private void processAsync(\n     }\n   }\n \n+  /**\n+   * Ensures that a {@link BeneficiaryMonthly} record is created or updated for the specified {@link\n+   * Beneficiary}, if that {@link Beneficiary} already exists and is just being updated.\n+   *\n+   * @param entityManager the {@link EntityManager} to use\n+   * @param loadAction the {@link Loadaction} record being processed\n+   * @param beneficiaryRecord the {@link Beneficiary} record being processed\n+   */\n+  private static void updateBeneficiaryMonthly(\n+      EntityManager entityManager, Beneficiary beneficiaryRecord) {\n+\n+    if (beneficiaryRecord.getBeneEnrollmentReferenceYear().isPresent()) {\n+\n+      int year = beneficiaryRecord.getBeneEnrollmentReferenceYear().get().intValue();\n+      List<BeneficiaryMonthly> currentYearBeneficiaryMonthly = new ArrayList<BeneficiaryMonthly>();\n+\n+      BeneficiaryMonthly beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 1, 1),\n+              beneficiaryRecord.getEntitlementBuyInJanInd(),\n+              beneficiaryRecord.getFipsStateCntyJanCode(),\n+              beneficiaryRecord.getHmoIndicatorJanInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJanCode(),\n+              beneficiaryRecord.getMedicareStatusJanCode(),\n+              beneficiaryRecord.getPartCContractNumberJanId(),\n+              beneficiaryRecord.getPartCPbpNumberJanId(),\n+              beneficiaryRecord.getPartCPlanTypeJanCode(),\n+              beneficiaryRecord.getPartDContractNumberJanId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJanCode(),\n+              beneficiaryRecord.getPartDPbpNumberJanId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJanInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJanId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 2, 1),\n+              beneficiaryRecord.getEntitlementBuyInFebInd(),\n+              beneficiaryRecord.getFipsStateCntyFebCode(),\n+              beneficiaryRecord.getHmoIndicatorFebInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityFebCode(),\n+              beneficiaryRecord.getMedicareStatusFebCode(),\n+              beneficiaryRecord.getPartCContractNumberFebId(),\n+              beneficiaryRecord.getPartCPbpNumberFebId(),\n+              beneficiaryRecord.getPartCPlanTypeFebCode(),\n+              beneficiaryRecord.getPartDContractNumberFebId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupFebCode(),\n+              beneficiaryRecord.getPartDPbpNumberFebId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyFebInd(),\n+              beneficiaryRecord.getPartDSegmentNumberFebId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 3, 1),\n+              beneficiaryRecord.getEntitlementBuyInMarInd(),\n+              beneficiaryRecord.getFipsStateCntyMarCode(),\n+              beneficiaryRecord.getHmoIndicatorMarInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityMarCode(),\n+              beneficiaryRecord.getMedicareStatusMarCode(),\n+              beneficiaryRecord.getPartCContractNumberMarId(),\n+              beneficiaryRecord.getPartCPbpNumberMarId(),\n+              beneficiaryRecord.getPartCPlanTypeMarCode(),\n+              beneficiaryRecord.getPartDContractNumberMarId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupMarCode(),\n+              beneficiaryRecord.getPartDPbpNumberMarId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyMarInd(),\n+              beneficiaryRecord.getPartDSegmentNumberMarId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 4, 1),\n+              beneficiaryRecord.getEntitlementBuyInAprInd(),\n+              beneficiaryRecord.getFipsStateCntyAprCode(),\n+              beneficiaryRecord.getHmoIndicatorAprInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityAprCode(),\n+              beneficiaryRecord.getMedicareStatusAprCode(),\n+              beneficiaryRecord.getPartCContractNumberAprId(),\n+              beneficiaryRecord.getPartCPbpNumberAprId(),\n+              beneficiaryRecord.getPartCPlanTypeAprCode(),\n+              beneficiaryRecord.getPartDContractNumberAprId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupAprCode(),\n+              beneficiaryRecord.getPartDPbpNumberAprId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyAprInd(),\n+              beneficiaryRecord.getPartDSegmentNumberAprId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 5, 1),\n+              beneficiaryRecord.getEntitlementBuyInMayInd(),\n+              beneficiaryRecord.getFipsStateCntyMayCode(),\n+              beneficiaryRecord.getHmoIndicatorMayInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityMayCode(),\n+              beneficiaryRecord.getMedicareStatusMayCode(),\n+              beneficiaryRecord.getPartCContractNumberMayId(),\n+              beneficiaryRecord.getPartCPbpNumberMayId(),\n+              beneficiaryRecord.getPartCPlanTypeMayCode(),\n+              beneficiaryRecord.getPartDContractNumberMayId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupMayCode(),\n+              beneficiaryRecord.getPartDPbpNumberMayId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyMayInd(),\n+              beneficiaryRecord.getPartDSegmentNumberMayId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 6, 1),\n+              beneficiaryRecord.getEntitlementBuyInJunInd(),\n+              beneficiaryRecord.getFipsStateCntyJunCode(),\n+              beneficiaryRecord.getHmoIndicatorJunInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJunCode(),\n+              beneficiaryRecord.getMedicareStatusJunCode(),\n+              beneficiaryRecord.getPartCContractNumberJunId(),\n+              beneficiaryRecord.getPartCPbpNumberJunId(),\n+              beneficiaryRecord.getPartCPlanTypeJunCode(),\n+              beneficiaryRecord.getPartDContractNumberJunId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJunCode(),\n+              beneficiaryRecord.getPartDPbpNumberJunId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJunInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJunId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 7, 1),\n+              beneficiaryRecord.getEntitlementBuyInJulInd(),\n+              beneficiaryRecord.getFipsStateCntyJulCode(),\n+              beneficiaryRecord.getHmoIndicatorJulInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityJulCode(),\n+              beneficiaryRecord.getMedicareStatusJulCode(),\n+              beneficiaryRecord.getPartCContractNumberJulId(),\n+              beneficiaryRecord.getPartCPbpNumberJulId(),\n+              beneficiaryRecord.getPartCPlanTypeJulCode(),\n+              beneficiaryRecord.getPartDContractNumberJulId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupJulCode(),\n+              beneficiaryRecord.getPartDPbpNumberJulId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyJulInd(),\n+              beneficiaryRecord.getPartDSegmentNumberJulId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 8, 1),\n+              beneficiaryRecord.getEntitlementBuyInAugInd(),\n+              beneficiaryRecord.getFipsStateCntyAugCode(),\n+              beneficiaryRecord.getHmoIndicatorAugInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityAugCode(),\n+              beneficiaryRecord.getMedicareStatusAugCode(),\n+              beneficiaryRecord.getPartCContractNumberAugId(),\n+              beneficiaryRecord.getPartCPbpNumberAugId(),\n+              beneficiaryRecord.getPartCPlanTypeAugCode(),\n+              beneficiaryRecord.getPartDContractNumberAugId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupAugCode(),\n+              beneficiaryRecord.getPartDPbpNumberAugId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyAugInd(),\n+              beneficiaryRecord.getPartDSegmentNumberAugId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 9, 1),\n+              beneficiaryRecord.getEntitlementBuyInSeptInd(),\n+              beneficiaryRecord.getFipsStateCntySeptCode(),\n+              beneficiaryRecord.getHmoIndicatorSeptInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilitySeptCode(),\n+              beneficiaryRecord.getMedicareStatusSeptCode(),\n+              beneficiaryRecord.getPartCContractNumberSeptId(),\n+              beneficiaryRecord.getPartCPbpNumberSeptId(),\n+              beneficiaryRecord.getPartCPlanTypeSeptCode(),\n+              beneficiaryRecord.getPartDContractNumberSeptId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupSeptCode(),\n+              beneficiaryRecord.getPartDPbpNumberSeptId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidySeptInd(),\n+              beneficiaryRecord.getPartDSegmentNumberSeptId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 10, 1),\n+              beneficiaryRecord.getEntitlementBuyInOctInd(),\n+              beneficiaryRecord.getFipsStateCntyOctCode(),\n+              beneficiaryRecord.getHmoIndicatorOctInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityOctCode(),\n+              beneficiaryRecord.getMedicareStatusOctCode(),\n+              beneficiaryRecord.getPartCContractNumberOctId(),\n+              beneficiaryRecord.getPartCPbpNumberOctId(),\n+              beneficiaryRecord.getPartCPlanTypeOctCode(),\n+              beneficiaryRecord.getPartDContractNumberOctId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupOctCode(),\n+              beneficiaryRecord.getPartDPbpNumberOctId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyOctInd(),\n+              beneficiaryRecord.getPartDSegmentNumberOctId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 11, 1),\n+              beneficiaryRecord.getEntitlementBuyInNovInd(),\n+              beneficiaryRecord.getFipsStateCntyNovCode(),\n+              beneficiaryRecord.getHmoIndicatorNovInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityNovCode(),\n+              beneficiaryRecord.getMedicareStatusNovCode(),\n+              beneficiaryRecord.getPartCContractNumberNovId(),\n+              beneficiaryRecord.getPartCPbpNumberNovId(),\n+              beneficiaryRecord.getPartCPlanTypeNovCode(),\n+              beneficiaryRecord.getPartDContractNumberNovId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupNovCode(),\n+              beneficiaryRecord.getPartDPbpNumberNovId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyNovInd(),\n+              beneficiaryRecord.getPartDSegmentNumberNovId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      beneficiaryMonthly =\n+          getBeneficiaryMonthly(\n+              beneficiaryRecord,\n+              LocalDate.of(year, 12, 1),\n+              beneficiaryRecord.getEntitlementBuyInDecInd(),\n+              beneficiaryRecord.getFipsStateCntyDecCode(),\n+              beneficiaryRecord.getHmoIndicatorDecInd(),\n+              beneficiaryRecord.getMedicaidDualEligibilityDecCode(),\n+              beneficiaryRecord.getMedicareStatusDecCode(),\n+              beneficiaryRecord.getPartCContractNumberDecId(),\n+              beneficiaryRecord.getPartCPbpNumberDecId(),\n+              beneficiaryRecord.getPartCPlanTypeDecCode(),\n+              beneficiaryRecord.getPartDContractNumberDecId(),\n+              beneficiaryRecord.getPartDLowIncomeCostShareGroupDecCode(),\n+              beneficiaryRecord.getPartDPbpNumberDecId(),\n+              beneficiaryRecord.getPartDRetireeDrugSubsidyDecInd(),\n+              beneficiaryRecord.getPartDSegmentNumberDecId());\n+\n+      if (beneficiaryMonthly != null) {\n+        currentYearBeneficiaryMonthly.add(beneficiaryMonthly);\n+      }\n+\n+      if (currentYearBeneficiaryMonthly.size() > 0) {\n+        List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n+\n+        Beneficiary beneficiaryFromDb =\n+            entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());", "originalCommit": "f8fb96e5b45b3dfaadbf7e7bc8223c3b681a7f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3MDUxMg==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549570512", "bodyText": "added to do", "author": "cbrunefearless", "createdAt": "2020-12-29T05:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ccf6dbc202b796476de5e622f717f034d66c1711", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex d428c53b9..5797f9281 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -896,6 +896,8 @@ public final class RifLoader implements AutoCloseable {\n       if (currentYearBeneficiaryMonthly.size() > 0) {\n         List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n \n+        // TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file\n+        // allowed\n         Beneficiary beneficiaryFromDb =\n             entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex d428c53b9..257d9724a 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -896,6 +896,8 @@ public final class RifLoader implements AutoCloseable {\n       if (currentYearBeneficiaryMonthly.size() > 0) {\n         List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n \n+        // TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file\n+        // allowed\n         Beneficiary beneficiaryFromDb =\n             entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n \n", "next_change": {"commit": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 257d9724a..3d79d64a9 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -896,15 +950,12 @@ public final class RifLoader implements AutoCloseable {\n       if (currentYearBeneficiaryMonthly.size() > 0) {\n         List<BeneficiaryMonthly> currentBeneficiaryMonthlyWithUpdates;\n \n-        // TODO enforce RIF invariant elsewhere: no repeats of same record/PK in same RIF file\n-        // allowed\n-        Beneficiary beneficiaryFromDb =\n-            entityManager.find(Beneficiary.class, beneficiaryRecord.getBeneficiaryId());\n-\n-        if (beneficiaryFromDb != null && beneficiaryFromDb.getBeneficiaryMonthlys().size() > 0) {\n-          currentBeneficiaryMonthlyWithUpdates = beneficiaryFromDb.getBeneficiaryMonthlys();\n+        if (oldBeneficiaryRecord.isPresent()\n+            && oldBeneficiaryRecord.get().getBeneficiaryMonthlys().size() > 0) {\n+          currentBeneficiaryMonthlyWithUpdates =\n+              oldBeneficiaryRecord.get().getBeneficiaryMonthlys();\n           List<BeneficiaryMonthly> currentYearBeneficiaryMonthlyPrevious =\n-              beneficiaryFromDb.getBeneficiaryMonthlys().stream()\n+              oldBeneficiaryRecord.get().getBeneficiaryMonthlys().stream()\n                   .filter(e -> year == e.getYearMonth().getYear())\n                   .collect(Collectors.toList());\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "1b0103ba4f25f43a6c5c5c92c73364dc17d2e5b0", "committedDate": "2020-12-30 16:03:00 -0500", "message": "Cbrune/bfd 549 validate hibernate (#426)"}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"oid": "ccf6dbc202b796476de5e622f717f034d66c1711", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/ccf6dbc202b796476de5e622f717f034d66c1711", "message": "Added extra test to test monthly updates", "committedDate": "2020-12-29T07:07:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNDQyNw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549814427", "body": "Would you mind applying this suggestion?\r\n```suggestion\r\n   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\r\n   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\r\n```", "bodyText": "Would you mind applying this suggestion?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}\n          \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point", "bodyHTML": "<p dir=\"auto\">Would you mind applying this suggestion?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents the total number of digits that can be stored</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents how many of the total digits (see `columnLength`) are to the right of the decimal point</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "karlmdavis", "createdAt": "2020-12-29T19:02:19Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,195 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly class in the model rif\n+   *\n+   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}", "originalCommit": "ccf6dbc202b796476de5e622f717f034d66c1711", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "148d2587022acbf516a4a2ff5e98cbbd7c70ebe2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..0e33235de 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 0e33235de..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "52561a672c4494913b48b46416bae9d5da353181", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..c107a45b2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "dbf04f2800fa05f62631402ff7e532b8d6b39d29", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c107a45b2..5307df02d 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1838,8 +1838,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static void createBeneficiaryMonthlyFields(\n       TypeSpec.Builder lineEntity,\n", "next_change": {"commit": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..15f56b2d8 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1834,57 +1979,39 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n    * @param isId determines if the field is an id field\n-   * @param isTransient determines if the field is transient {@link boolean}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param fieldName specifies the fieldname {@link String}\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param rifField {@link RifField} to create\n    */\n   private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity,\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n+      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n+\n+    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n+    TypeName javaFieldType =\n+        selectJavaFieldType(\n+            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n+            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n+    TypeName javaPropType =\n+        selectJavaPropertyType(\n+            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n+            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n     FieldSpec lineField =\n-        FieldSpec.builder(\n-                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n-                fieldName,\n-                Modifier.PRIVATE)\n-            .addAnnotations(\n-                createBeneficiaryMonthlyAnnotations(\n-                    isId,\n-                    isTransient,\n-                    isColumnOptional,\n-                    fieldName,\n-                    type,\n-                    columnLength,\n-                    columnScale))\n+        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n+            .addAnnotations(annotSpecs)\n             .build();\n     lineEntity.addField(lineField);\n \n     MethodSpec.Builder lineFieldGetter =\n         MethodSpec.methodBuilder(calculateGetterName(lineField))\n             .addModifiers(Modifier.PUBLIC)\n-            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n-    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+            .returns(javaPropType);\n+    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n     lineEntity.addMethod(lineFieldGetter.build());\n \n     MethodSpec.Builder lineFieldSetter =\n         MethodSpec.methodBuilder(calculateSetterName(lineField))\n             .addModifiers(Modifier.PUBLIC)\n             .returns(void.class)\n-            .addParameter(\n-                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n-                lineField.name);\n-    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+            .addParameter(javaPropType, lineField.name);\n+    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n     lineEntity.addMethod(lineFieldSetter.build());\n   }\n \n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 15f56b2d8..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2016,10 +2134,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n   }\n \n   /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n    *\n    * @param isId determines if the field is an id field\n    * @param rifField {@link RifField} to create\n+   * @return the created annotation specs\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId, RifField rifField) {\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex 9e64b5c55..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2261 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes() */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /** @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion() */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) spreadsheetWorkbook.close();\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make\n-    // it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"partd_events\",\n-            \"snf_claims\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-        // Handle a String field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) == 1) {\n-        // Handle a Character field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM\n-          && rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) > 0) {\n-        // Handle a Decimal field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields {@link List<FieldSpec>} to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n-      return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n-      return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n-      return ClassName.get(BigDecimal.class);\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNDY5Mw==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549814693", "body": "Would you mind applying this suggestion?\r\n```suggestion\r\n   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\r\n   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\r\n```", "bodyText": "Would you mind applying this suggestion?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}\n          \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point", "bodyHTML": "<p dir=\"auto\">Would you mind applying this suggestion?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents the total number of digits that can be stored</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents how many of the total digits (see `columnLength`) are to the right of the decimal point</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "karlmdavis", "createdAt": "2020-12-29T19:03:21Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,195 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly class in the model rif\n+   *\n+   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n+  private static void createBeneficiaryMonthlyFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createBeneficiaryMonthlyAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   *\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}", "originalCommit": "ccf6dbc202b796476de5e622f717f034d66c1711", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8cd87a7a088d4f9fb1d09e0905505b3aec049a1c", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..20623a90f 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1893,8 +1896,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n", "next_change": {"commit": "2ea161ee2f878348bec572954d9221e7917d294e", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 20623a90f..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1896,8 +1896,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1893,8 +1896,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n    * @param fieldName specifies the fieldname {@link String}\n    * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n       boolean isId,\n", "next_change": {"commit": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..15f56b2d8 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1892,81 +2019,60 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n    *\n    * @param isId determines if the field is an id field\n-   * @param isTransient determines if the field is transient {@link boolean}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param fieldName specifies the fieldname {@link String}\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param rifField {@link RifField} to create\n    */\n   private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId,\n-      boolean isTransient,\n-      boolean isColumnOptional,\n-      String fieldName,\n-      RifColumnType type,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+      boolean isId, RifField rifField) {\n \n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n     // Add an @Id annotation, if appropriate.\n     if (isId) {\n       AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n       annotations.add(idAnnotation.build());\n     }\n-    // Add an @Column annotation to every non-transient column.\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n-              .addMember(\"nullable\", \"$L\", isColumnOptional);\n-      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n-      } else if (type == RifColumnType.NUM) {\n+    // Add an @Column annotation to every column.\n+    AnnotationSpec.Builder columnAnnotation =\n+        AnnotationSpec.builder(Column.class)\n+            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n+            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n+\n+    if (rifField.getRifColumnType() == RifColumnType.CHAR\n+        && rifField.getRifColumnLength().isPresent()) {\n+      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n+    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n+      /*\n+       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+       */\n+\n+      if (rifField.getRifColumnLength().isPresent()) {\n+        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n+        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n+      } else {\n         /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+         * handle SQL numeric datatypes that don't have a defined precision and scale.\n+         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+         * but what it does instead is insert a default precision and scale as\n+         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+         * (for different reasons), but fortunately that doesn't happen to cause\n+         * problems with our tests.\n          */\n+        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n+        if (rifField.getRifColumnLength().isPresent()) {\n+          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n \n-        if (columnLength.isPresent() && columnScale.isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (columnLength.isPresent() || columnScale.isPresent()) {\n-            columnDefinition.append('(');\n-            if (columnLength.isPresent()) {\n-              columnDefinition.append(columnLength.get());\n-            }\n-            if (columnScale.isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(columnScale.get());\n-            }\n-            columnDefinition.append(')');\n+          if (rifField.getRifColumnScale().isPresent()) {\n+            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n           }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+          columnDefinition.append(\")\");\n         }\n+        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n       }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n     }\n-\n+    annotations.add(columnAnnotation.build());\n     return annotations;\n   }\n \n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 15f56b2d8..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2077,7 +2196,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n   }\n \n   /**\n-   * Selects the java field type\n+   * Selects the java field type.\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n", "next_change": {"commit": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 9e64b5c55..63f878aff 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2205,33 +2237,47 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n-   * @return the java field type\n+   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n+   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n+   *     in fact needs to be a Java class type (i.e., Long)\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n       boolean isColumnOptional,\n       Optional<Integer> columnLength,\n       Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+    if (type == RifColumnType.CHAR) {\n+      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n+        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n+      } else {\n+        return ClassName.get(String.class);\n+      }\n+    } else if (type == RifColumnType.DATE) {\n       return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+    } else if (type == RifColumnType.TIMESTAMP) {\n       return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+    }\n+    // handle an inherited hack from the Excel spreadsheet in which a row entry\n+    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n+    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n       return ClassName.get(BigDecimal.class);\n+    }\n+    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n+    // not optional should be defined as a primitive integer.\n+    //\n     else if (type == RifColumnType.NUM\n         && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+        && !isColumnOptional) {\n+      return TypeName.INT;\n+    } else if (type == RifColumnType.SMALLINT) {\n+      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n+    } else if (type == RifColumnType.BIGINT) {\n+      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n+    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n+      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n+    }\n+    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n   }\n \n   /**\n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 63f878aff..a5a2598c2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2285,11 +2321,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n+   *     types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n+   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n+   *     the decimal point\n    * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex a5a2598c2..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2343 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  /** The link to the data dictionary. */\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  /** The name to use for a parent claim. */\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  /** The name to use for a parent beneficiary. */\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  /** The list of log messages to write out. */\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes()\n-   */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion()\n-   */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   *\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Generates source files from the provided annotated package.\n-   *\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\n-                          \"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\", \"BENE_ID_NUMERIC\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) {\n-        spreadsheetWorkbook.close();\n-      }\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"snf_claims\",\n-            \"partd_events\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR) {\n-\n-        if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-          parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-        } else if (rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-          // Handle a String field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-        } else {\n-          // Handle a Character field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-        }\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.BIGINT) {\n-        // Handle an BigInteger field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.SMALLINT) {\n-        // Handle an Short field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalShort\" : \"parseShort\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.INTEGER) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        if (rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-          // Handle an Integer field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-        } else {\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-        }\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields the list of {@link FieldSpec}s to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * Generates a hash code method.\n-   *\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Generates an equals method.\n-   *\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Creates an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   * annotations that should be applied to the specified {@link RifField}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"BENE_ID_NUMERIC\")) {\n-        RifField beneIdNumeric =\n-            new RifField(\n-                \"BENE_ID_NUMERIC\",\n-                RifColumnType.BIGINT,\n-                Optional.of(8),\n-                Optional.of(0),\n-                Boolean.FALSE,\n-                null,\n-                \"BENE_ID_NUMERIC\",\n-                \"beneficiaryIdNumeric\");\n-        addlDatabaseFields.add(beneIdNumeric);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * Converts the specified string from snake case to camel case.\n-   *\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * Calculates the getter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Calculates the setter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Capitalizes the first letter of a string.\n-   *\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n-   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n-   *     in fact needs to be a Java class type (i.e., Long)\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR) {\n-      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n-        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n-      } else {\n-        return ClassName.get(String.class);\n-      }\n-    } else if (type == RifColumnType.DATE) {\n-      return ClassName.get(LocalDate.class);\n-    } else if (type == RifColumnType.TIMESTAMP) {\n-      return ClassName.get(Instant.class);\n-    }\n-    // handle an inherited hack from the Excel spreadsheet in which a row entry\n-    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n-    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n-      return ClassName.get(BigDecimal.class);\n-    }\n-    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n-    // not optional should be defined as a primitive integer.\n-    //\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) {\n-      return TypeName.INT;\n-    } else if (type == RifColumnType.SMALLINT) {\n-      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n-    } else if (type == RifColumnType.BIGINT) {\n-      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n-    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n-      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n-    }\n-    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNDgzOQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549814839", "body": "Would you mind applying this suggestion?\r\n```suggestion\r\n   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\r\n   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\r\n```", "bodyText": "Would you mind applying this suggestion?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}\n          \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point", "bodyHTML": "<p dir=\"auto\">Would you mind applying this suggestion?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents the total number of digits that can be stored</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents how many of the total digits (see `columnLength`) are to the right of the decimal point</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "karlmdavis", "createdAt": "2020-12-29T19:03:55Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,195 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly class in the model rif\n+   *\n+   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n+  private static void createBeneficiaryMonthlyFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createBeneficiaryMonthlyAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   *\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n+  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+\n+    // Add an @Id annotation, if appropriate.\n+    if (isId) {\n+      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n+      annotations.add(idAnnotation.build());\n+    }\n+    // Add an @Column annotation to every non-transient column.\n+    if (!isTransient) {\n+      AnnotationSpec.Builder columnAnnotation =\n+          AnnotationSpec.builder(Column.class)\n+              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n+              .addMember(\"nullable\", \"$L\", isColumnOptional);\n+      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n+        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n+      } else if (type == RifColumnType.NUM) {\n+        /*\n+         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         */\n+\n+        if (columnLength.isPresent() && columnScale.isPresent()) {\n+          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n+          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n+        } else {\n+          /*\n+           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+           * handle SQL numeric datatypes that don't have a defined precision and scale.\n+           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+           * but what it does instead is insert a default precision and scale as\n+           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+           * (for different reasons), but fortunately that doesn't happen to cause\n+           * problems with our tests.\n+           */\n+          StringBuilder columnDefinition = new StringBuilder();\n+          columnDefinition.append(\"numeric\");\n+          if (columnLength.isPresent() || columnScale.isPresent()) {\n+            columnDefinition.append('(');\n+            if (columnLength.isPresent()) {\n+              columnDefinition.append(columnLength.get());\n+            }\n+            if (columnScale.isPresent()) {\n+              columnDefinition.append(\", \");\n+              columnDefinition.append(columnScale.get());\n+            }\n+            columnDefinition.append(')');\n+          }\n+          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+        }\n+      }\n+      annotations.add(columnAnnotation.build());\n+    } else {\n+      annotations.add(AnnotationSpec.builder(Transient.class).build());\n+    }\n+\n+    return annotations;\n+  }\n+\n+  /**\n+   * Selects the java field type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}", "originalCommit": "ccf6dbc202b796476de5e622f717f034d66c1711", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61956e52e5c6f21c5f0c0e46b45676c25302cde4", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..c107a45b2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1969,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c107a45b2..91c86daca 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1969,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "52561a672c4494913b48b46416bae9d5da353181", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..c107a45b2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1969,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "dbf04f2800fa05f62631402ff7e532b8d6b39d29", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex c107a45b2..5307df02d 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1972,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1969,8 +1975,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -1980,6 +2205,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n+   * @return the java field type\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n", "next_change": {"commit": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 9e64b5c55..63f878aff 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2205,33 +2237,47 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n-   * @return the java field type\n+   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n+   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n+   *     in fact needs to be a Java class type (i.e., Long)\n    */\n   private static TypeName selectJavaFieldType(\n       RifColumnType type,\n       boolean isColumnOptional,\n       Optional<Integer> columnLength,\n       Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && !isColumnOptional) return TypeName.CHAR;\n-    else if (type == RifColumnType.CHAR\n-        && columnLength.orElse(Integer.MAX_VALUE) == 1\n-        && isColumnOptional) return ClassName.get(Character.class);\n-    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n-    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+    if (type == RifColumnType.CHAR) {\n+      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n+        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n+      } else {\n+        return ClassName.get(String.class);\n+      }\n+    } else if (type == RifColumnType.DATE) {\n       return ClassName.get(LocalDate.class);\n-    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+    } else if (type == RifColumnType.TIMESTAMP) {\n       return ClassName.get(Instant.class);\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+    }\n+    // handle an inherited hack from the Excel spreadsheet in which a row entry\n+    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n+    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n       return ClassName.get(BigDecimal.class);\n+    }\n+    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n+    // not optional should be defined as a primitive integer.\n+    //\n     else if (type == RifColumnType.NUM\n         && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) return TypeName.INT;\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && isColumnOptional) return ClassName.get(Integer.class);\n-    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+        && !isColumnOptional) {\n+      return TypeName.INT;\n+    } else if (type == RifColumnType.SMALLINT) {\n+      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n+    } else if (type == RifColumnType.BIGINT) {\n+      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n+    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n+      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n+    }\n+    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n   }\n \n   /**\n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 63f878aff..a5a2598c2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2285,11 +2321,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n+   *     types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n+   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n+   *     the decimal point\n    * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex a5a2598c2..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2343 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  /** The link to the data dictionary. */\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  /** The name to use for a parent claim. */\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  /** The name to use for a parent beneficiary. */\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  /** The list of log messages to write out. */\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes()\n-   */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion()\n-   */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   *\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Generates source files from the provided annotated package.\n-   *\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\n-                          \"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\", \"BENE_ID_NUMERIC\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) {\n-        spreadsheetWorkbook.close();\n-      }\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"snf_claims\",\n-            \"partd_events\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR) {\n-\n-        if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-          parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-        } else if (rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-          // Handle a String field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-        } else {\n-          // Handle a Character field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-        }\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.BIGINT) {\n-        // Handle an BigInteger field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.SMALLINT) {\n-        // Handle an Short field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalShort\" : \"parseShort\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.INTEGER) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        if (rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-          // Handle an Integer field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-        } else {\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-        }\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields the list of {@link FieldSpec}s to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * Generates a hash code method.\n-   *\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Generates an equals method.\n-   *\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Creates an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   * annotations that should be applied to the specified {@link RifField}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"BENE_ID_NUMERIC\")) {\n-        RifField beneIdNumeric =\n-            new RifField(\n-                \"BENE_ID_NUMERIC\",\n-                RifColumnType.BIGINT,\n-                Optional.of(8),\n-                Optional.of(0),\n-                Boolean.FALSE,\n-                null,\n-                \"BENE_ID_NUMERIC\",\n-                \"beneficiaryIdNumeric\");\n-        addlDatabaseFields.add(beneIdNumeric);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * Converts the specified string from snake case to camel case.\n-   *\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * Calculates the getter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Calculates the setter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Capitalizes the first letter of a string.\n-   *\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n-   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n-   *     in fact needs to be a Java class type (i.e., Long)\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR) {\n-      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n-        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n-      } else {\n-        return ClassName.get(String.class);\n-      }\n-    } else if (type == RifColumnType.DATE) {\n-      return ClassName.get(LocalDate.class);\n-    } else if (type == RifColumnType.TIMESTAMP) {\n-      return ClassName.get(Instant.class);\n-    }\n-    // handle an inherited hack from the Excel spreadsheet in which a row entry\n-    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n-    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n-      return ClassName.get(BigDecimal.class);\n-    }\n-    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n-    // not optional should be defined as a primitive integer.\n-    //\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) {\n-      return TypeName.INT;\n-    } else if (type == RifColumnType.SMALLINT) {\n-      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n-    } else if (type == RifColumnType.BIGINT) {\n-      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n-    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n-      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n-    }\n-    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNDkyNA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549814924", "body": "Would you mind applying this suggestion?\r\n```suggestion\r\n   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\r\n   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\r\n```", "bodyText": "Would you mind applying this suggestion?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}\n          \n          \n            \n               * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n          \n          \n            \n               * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point", "bodyHTML": "<p dir=\"auto\">Would you mind applying this suggestion?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnLength specifies the column length {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents the total number of digits that can be stored</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> columnScale specifies the column scale {<span class=\"pl-k\">@link</span> <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">Integer</span>&gt;</span>}<span class=\"x x-first\">, </span><span class=\"pl-k x\">for</span><span class=\"x\"> numeric types </span><span class=\"pl-c1 x\">this</span><span class=\"x x-last\"> represents how many of the total digits (see `columnLength`) are to the right of the decimal point</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "karlmdavis", "createdAt": "2020-12-29T19:04:13Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java", "diffHunk": "@@ -1503,4 +1828,195 @@ private void writeDebugLogMessages() {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly class in the model rif\n+   *\n+   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n+  private static void createBeneficiaryMonthlyFields(\n+      TypeSpec.Builder lineEntity,\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    FieldSpec lineField =\n+        FieldSpec.builder(\n+                selectJavaFieldType(type, isColumnOptional, columnLength, columnScale),\n+                fieldName,\n+                Modifier.PRIVATE)\n+            .addAnnotations(\n+                createBeneficiaryMonthlyAnnotations(\n+                    isId,\n+                    isTransient,\n+                    isColumnOptional,\n+                    fieldName,\n+                    type,\n+                    columnLength,\n+                    columnScale))\n+            .build();\n+    lineEntity.addField(lineField);\n+\n+    MethodSpec.Builder lineFieldGetter =\n+        MethodSpec.methodBuilder(calculateGetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale));\n+    addGetterStatement(isColumnOptional, lineField, lineFieldGetter);\n+    lineEntity.addMethod(lineFieldGetter.build());\n+\n+    MethodSpec.Builder lineFieldSetter =\n+        MethodSpec.methodBuilder(calculateSetterName(lineField))\n+            .addModifiers(Modifier.PUBLIC)\n+            .returns(void.class)\n+            .addParameter(\n+                selectJavaPropertyType(type, isColumnOptional, columnLength, columnScale),\n+                lineField.name);\n+    addSetterStatement(isColumnOptional, lineField, lineFieldSetter);\n+    lineEntity.addMethod(lineFieldSetter.build());\n+  }\n+\n+  /**\n+   * Creates the fields for the BeneficiaryMonthly annotations in the model rif\n+   *\n+   * @param isId determines if the field is an id field\n+   * @param isTransient determines if the field is transient {@link boolean}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param fieldName specifies the fieldname {@link String}\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n+  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n+      boolean isId,\n+      boolean isTransient,\n+      boolean isColumnOptional,\n+      String fieldName,\n+      RifColumnType type,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n+\n+    // Add an @Id annotation, if appropriate.\n+    if (isId) {\n+      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n+      annotations.add(idAnnotation.build());\n+    }\n+    // Add an @Column annotation to every non-transient column.\n+    if (!isTransient) {\n+      AnnotationSpec.Builder columnAnnotation =\n+          AnnotationSpec.builder(Column.class)\n+              .addMember(\"name\", \"$S\", \"`\" + fieldName + \"`\")\n+              .addMember(\"nullable\", \"$L\", isColumnOptional);\n+      if (type == RifColumnType.CHAR && columnLength.isPresent()) {\n+        columnAnnotation.addMember(\"length\", \"$L\", columnLength.get());\n+      } else if (type == RifColumnType.NUM) {\n+        /*\n+         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n+         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n+         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n+         */\n+\n+        if (columnLength.isPresent() && columnScale.isPresent()) {\n+          columnAnnotation.addMember(\"precision\", \"$L\", columnLength.get());\n+          columnAnnotation.addMember(\"scale\", \"$L\", columnScale.get());\n+        } else {\n+          /*\n+           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n+           * handle SQL numeric datatypes that don't have a defined precision and scale.\n+           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n+           * but what it does instead is insert a default precision and scale as\n+           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n+           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n+           * (for different reasons), but fortunately that doesn't happen to cause\n+           * problems with our tests.\n+           */\n+          StringBuilder columnDefinition = new StringBuilder();\n+          columnDefinition.append(\"numeric\");\n+          if (columnLength.isPresent() || columnScale.isPresent()) {\n+            columnDefinition.append('(');\n+            if (columnLength.isPresent()) {\n+              columnDefinition.append(columnLength.get());\n+            }\n+            if (columnScale.isPresent()) {\n+              columnDefinition.append(\", \");\n+              columnDefinition.append(columnScale.get());\n+            }\n+            columnDefinition.append(')');\n+          }\n+          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n+        }\n+      }\n+      annotations.add(columnAnnotation.build());\n+    } else {\n+      annotations.add(AnnotationSpec.builder(Transient.class).build());\n+    }\n+\n+    return annotations;\n+  }\n+\n+  /**\n+   * Selects the java field type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   */\n+  private static TypeName selectJavaFieldType(\n+      RifColumnType type,\n+      boolean isColumnOptional,\n+      Optional<Integer> columnLength,\n+      Optional<Integer> columnScale) {\n+    if (type == RifColumnType.CHAR\n+        && columnLength.orElse(Integer.MAX_VALUE) == 1\n+        && !isColumnOptional) return TypeName.CHAR;\n+    else if (type == RifColumnType.CHAR\n+        && columnLength.orElse(Integer.MAX_VALUE) == 1\n+        && isColumnOptional) return ClassName.get(Character.class);\n+    else if (type == RifColumnType.CHAR) return ClassName.get(String.class);\n+    else if (type == RifColumnType.DATE && columnLength.orElse(0) == 8)\n+      return ClassName.get(LocalDate.class);\n+    else if (type == RifColumnType.TIMESTAMP && columnLength.orElse(0) == 20)\n+      return ClassName.get(Instant.class);\n+    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0)\n+      return ClassName.get(BigDecimal.class);\n+    else if (type == RifColumnType.NUM\n+        && columnScale.orElse(Integer.MAX_VALUE) == 0\n+        && !isColumnOptional) return TypeName.INT;\n+    else if (type == RifColumnType.NUM\n+        && columnScale.orElse(Integer.MAX_VALUE) == 0\n+        && isColumnOptional) return ClassName.get(Integer.class);\n+    else throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n+  }\n+\n+  /**\n+   * Selects the java property type\n+   *\n+   * @param type specifies the field type {@link RifColumnType}\n+   * @param isColumnOptional determines if the field is optional {@link boolean}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}", "originalCommit": "ccf6dbc202b796476de5e622f717f034d66c1711", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49ad5b80ad13a006c340af8d9632c054d4178e23", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..2234c5e42 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2004,8 +2010,8 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": {"commit": "0db992f302646824a41c835342a05e971e1bc151", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 2234c5e42..1b90f6caa 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2010,8 +2010,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this represents how many of the total digits (see `columnLength`) are to the right of the decimal point\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 91c86daca..b9f319190 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2004,8 +2013,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}\n+   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n+   *     this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n+   *     represents how many of the total digits (see `columnLength`) are to the right of the\n+   *     decimal point\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": {"commit": "e155114227f50da33198b97845c8db8cfeb5661a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex b9f319190..9e64b5c55 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2018,6 +2244,7 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n    *     represents how many of the total digits (see `columnLength`) are to the right of the\n    *     decimal point\n+   * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n       RifColumnType type,\n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\nindex 9e64b5c55..a5a2598c2 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n", "chunk": "@@ -2239,11 +2321,11 @@ public final class RifLayoutsProcessor extends AbstractProcessor {\n    *\n    * @param type specifies the field type {@link RifColumnType}\n    * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional<Integer>}, for numeric types\n-   *     this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional<Integer>}, for numeric types this\n-   *     represents how many of the total digits (see `columnLength`) are to the right of the\n-   *     decimal point\n+   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n+   *     types this represents the total number of digits that can be stored\n+   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n+   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n+   *     the decimal point\n    * @return the java field type\n    */\n   private static TypeName selectJavaPropertyType(\n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\ndeleted file mode 100644\nindex a5a2598c2..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,2343 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.google.auto.service.AutoService;\n-import com.google.common.collect.ImmutableSet;\n-import com.squareup.javapoet.AnnotationSpec;\n-import com.squareup.javapoet.ArrayTypeName;\n-import com.squareup.javapoet.ClassName;\n-import com.squareup.javapoet.CodeBlock;\n-import com.squareup.javapoet.FieldSpec;\n-import com.squareup.javapoet.JavaFile;\n-import com.squareup.javapoet.MethodSpec;\n-import com.squareup.javapoet.ParameterizedTypeName;\n-import com.squareup.javapoet.TypeName;\n-import com.squareup.javapoet.TypeSpec;\n-import gov.cms.bfd.model.codegen.RifLayout.RifColumnType;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import gov.cms.bfd.model.codegen.annotations.RifLayoutsGenerator;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.io.StringWriter;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.math.BigDecimal;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.annotation.processing.AbstractProcessor;\n-import javax.annotation.processing.Processor;\n-import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.ForeignKey;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.GenerationType;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.JoinColumn;\n-import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.persistence.OrderBy;\n-import javax.persistence.SequenceGenerator;\n-import javax.persistence.Table;\n-import javax.persistence.Transient;\n-import javax.tools.Diagnostic;\n-import javax.tools.FileObject;\n-import javax.tools.StandardLocation;\n-import org.apache.poi.ss.usermodel.Workbook;\n-import org.apache.poi.xssf.usermodel.XSSFWorkbook;\n-\n-/**\n- * This <code>javac</code> annotation {@link Processor} reads in an Excel file that details a RIF\n- * field layout, and then generates the Java code required to work with that layout.\n- */\n-@AutoService(Processor.class)\n-public final class RifLayoutsProcessor extends AbstractProcessor {\n-  /**\n-   * Both Maven and Eclipse hide compiler messages, so setting this constant to <code>true</code>\n-   * will also log messages out to a new source file.\n-   */\n-  private static final boolean DEBUG = true;\n-\n-  /** The link to the data dictionary. */\n-  private static final String DATA_DICTIONARY_LINK =\n-      \"https://bluebutton.cms.gov/resources/variables/\";\n-\n-  /** The name to use for a parent claim. */\n-  private static final String PARENT_CLAIM = \"parentClaim\";\n-  /** The name to use for a parent beneficiary. */\n-  private static final String PARENT_BENEFICIARY = \"parentBeneficiary\";\n-\n-  /** The list of log messages to write out. */\n-  private final List<String> logMessages = new LinkedList<>();\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedAnnotationTypes()\n-   */\n-  @Override\n-  public Set<String> getSupportedAnnotationTypes() {\n-    return ImmutableSet.of(RifLayoutsGenerator.class.getName());\n-  }\n-\n-  /**\n-   * {@inheritDoc} @see javax.annotation.processing.AbstractProcessor#getSupportedSourceVersion()\n-   */\n-  @Override\n-  public SourceVersion getSupportedSourceVersion() {\n-    return SourceVersion.latestSupported();\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   *\n-   * @see javax.annotation.processing.AbstractProcessor#process(java.util.Set,\n-   *     javax.annotation.processing.RoundEnvironment)\n-   */\n-  @Override\n-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n-    try {\n-      logNote(\n-          \"Processing triggered for '%s' on root elements '%s'.\",\n-          annotations, roundEnv.getRootElements());\n-\n-      Set<? extends Element> annotatedElements =\n-          roundEnv.getElementsAnnotatedWith(RifLayoutsGenerator.class);\n-      for (Element annotatedElement : annotatedElements) {\n-        if (annotatedElement.getKind() != ElementKind.PACKAGE)\n-          throw new RifLayoutProcessingException(\n-              annotatedElement,\n-              \"The %s annotation is only valid on packages (i.e. in package-info.java).\",\n-              RifLayoutsGenerator.class.getName());\n-        process((PackageElement) annotatedElement);\n-      }\n-    } catch (RifLayoutProcessingException e) {\n-      log(Diagnostic.Kind.ERROR, e.getMessage(), e.getElement());\n-    } catch (Exception e) {\n-      /*\n-       * Don't allow exceptions of any type to propagate to the compiler.\n-       * Log a warning and return, instead.\n-       */\n-      StringWriter writer = new StringWriter();\n-      e.printStackTrace(new PrintWriter(writer));\n-      log(Diagnostic.Kind.ERROR, \"FATAL ERROR: \" + writer.toString());\n-    }\n-\n-    if (roundEnv.processingOver()) writeDebugLogMessages();\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Generates source files from the provided annotated package.\n-   *\n-   * @param annotatedPackage the {@link PackageElement} to process that has been annotated with\n-   *     {@link RifLayoutsGenerator}\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void process(PackageElement annotatedPackage) throws IOException {\n-    RifLayoutsGenerator annotation = annotatedPackage.getAnnotation(RifLayoutsGenerator.class);\n-    logNote(annotatedPackage, \"Processing package annotated with: '%s'.\", annotation);\n-\n-    /*\n-     * Find the spreadsheet referenced by the annotation. It will define the\n-     * RIF layouts.\n-     */\n-    FileObject spreadsheetResource;\n-    try {\n-      spreadsheetResource =\n-          processingEnv\n-              .getFiler()\n-              .getResource(\n-                  StandardLocation.SOURCE_PATH,\n-                  annotatedPackage.getQualifiedName().toString(),\n-                  annotation.spreadsheetResource());\n-    } catch (IOException | IllegalArgumentException e) {\n-      throw new RifLayoutProcessingException(\n-          annotatedPackage,\n-          \"Unable to find or open specified spreadsheet: '%s'.\",\n-          annotation.spreadsheetResource());\n-    }\n-    logNote(annotatedPackage, \"Found spreadsheet: '%s'.\", annotation.spreadsheetResource());\n-\n-    /*\n-     * Parse the spreadsheet, extracting the layouts from it. Also: define\n-     * the layouts that we expect to parse and generate code for.\n-     */\n-    List<MappingSpec> mappingSpecs = new LinkedList<>();\n-    Workbook spreadsheetWorkbook = null;\n-    try {\n-      spreadsheetWorkbook = new XSSFWorkbook(spreadsheetResource.openInputStream());\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.beneficiarySheet()))\n-              .setHeaderEntity(\"Beneficiary\")\n-              .setHeaderTable(\"beneficiaries\")\n-              .setHeaderEntityIdField(\"BENE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\n-                          \"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\", \"BENE_ID_NUMERIC\")))\n-              .setInnerJoinRelationship(\n-                  Arrays.asList(\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\", null, \"BeneficiaryHistory\", \"beneficiaryHistories\"),\n-                      new InnerJoinRelationship(\n-                          \"beneficiaryId\",\n-                          null,\n-                          \"MedicareBeneficiaryIdHistory\",\n-                          \"medicareBeneficiaryIdHistories\")))\n-              .setIsBeneficiaryEntity(true));\n-      /*\n-       * FIXME Many BeneficiaryHistory fields are marked transient (i.e. not saved to\n-       * DB), as they won't ever have changed data. We should change the RIF layout to\n-       * exclude them, but this was implemented in a bit of a rush, and there wasn't\n-       * time to fix that.\n-       */\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.beneficiaryHistorySheet()))\n-              .setHeaderEntity(\"BeneficiaryHistory\")\n-              .setHeaderTable(\"beneficiaries_history\")\n-              .setHeaderEntityGeneratedIdField(\"bene_history_id\")\n-              .setSequenceNumberGeneratorName(\"beneficiaryhistory_beneficiaryhistoryid_seq\")\n-              .setHeaderEntityTransientFields(\n-                  \"STATE_CODE\",\n-                  \"BENE_COUNTY_CD\",\n-                  \"BENE_ZIP_CD\",\n-                  \"BENE_RACE_CD\",\n-                  \"BENE_ENTLMT_RSN_ORIG\",\n-                  \"BENE_ENTLMT_RSN_CURR\",\n-                  \"BENE_ESRD_IND\",\n-                  \"BENE_MDCR_STATUS_CD\",\n-                  \"BENE_PTA_TRMNTN_CD\",\n-                  \"BENE_PTB_TRMNTN_CD\",\n-                  \"BENE_SRNM_NAME\",\n-                  \"BENE_GVN_NAME\",\n-                  \"BENE_MDL_NAME\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(\n-                      Arrays.asList(\"HICN_UNHASHED\", \"MBI_HASH\", \"LAST_UPDATED\")))\n-              .setIsBeneficiaryEntity(false));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(\n-                  RifLayout.parse(spreadsheetWorkbook, annotation.medicareBeneficiaryIdSheet()))\n-              .setHeaderEntity(\"MedicareBeneficiaryIdHistory\")\n-              .setHeaderTable(\"medicare_beneficiaryid_history\")\n-              .setHeaderEntityIdField(\"bene_mbi_id\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.pdeSheet()))\n-              .setHeaderEntity(\"PartDEvent\")\n-              .setHeaderTable(\"partd_events\")\n-              .setHeaderEntityIdField(\"PDE_ID\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.carrierSheet()))\n-              .setHeaderEntity(\"CarrierClaim\")\n-              .setHeaderTable(\"carrier_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"carrier_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.inpatientSheet()))\n-              .setHeaderEntity(\"InpatientClaim\")\n-              .setHeaderTable(\"inpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"inpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.outpatientSheet()))\n-              .setHeaderEntity(\"OutpatientClaim\")\n-              .setHeaderTable(\"outpatient_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"outpatient_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hhaSheet()))\n-              .setHeaderEntity(\"HHAClaim\")\n-              .setHeaderTable(\"hha_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hha_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.dmeSheet()))\n-              .setHeaderEntity(\"DMEClaim\")\n-              .setHeaderTable(\"dme_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"dme_claim_lines\")\n-              .setLineEntityLineNumberField(\"LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.hospiceSheet()))\n-              .setHeaderEntity(\"HospiceClaim\")\n-              .setHeaderTable(\"hospice_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"hospice_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-\n-      mappingSpecs.add(\n-          new MappingSpec(annotatedPackage.getQualifiedName().toString())\n-              .setRifLayout(RifLayout.parse(spreadsheetWorkbook, annotation.snfSheet()))\n-              .setHeaderEntity(\"SNFClaim\")\n-              .setHeaderTable(\"snf_claims\")\n-              .setHeaderEntityIdField(\"CLM_ID\")\n-              .setHasLines(true)\n-              .setLineTable(\"snf_claim_lines\")\n-              .setLineEntityLineNumberField(\"CLM_LINE_NUM\")\n-              .setHeaderEntityAdditionalDatabaseFields(\n-                  createDetailsForAdditionalDatabaseFields(Arrays.asList(\"LAST_UPDATED\"))));\n-    } finally {\n-      if (spreadsheetWorkbook != null) {\n-        spreadsheetWorkbook.close();\n-      }\n-    }\n-    logNote(annotatedPackage, \"Generated mapping specification: '%s'\", mappingSpecs);\n-\n-    /* Generate the code for each layout. */\n-    for (MappingSpec mappingSpec : mappingSpecs) {\n-      generateCode(mappingSpec);\n-    }\n-  }\n-\n-  /**\n-   * Generates the code for the specified {@link RifLayout}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} to generate code for\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private void generateCode(MappingSpec mappingSpec) throws IOException {\n-    /*\n-     * First, create the Java enum for the RIF columns.\n-     */\n-    TypeSpec columnEnum = generateColumnEnum(mappingSpec);\n-\n-    /*\n-     * Then, create the JPA Entity for the \"line\" fields, containing: fields\n-     * and accessors.\n-     */\n-    Optional<TypeSpec> lineEntity =\n-        mappingSpec.getHasLines() ? Optional.of(generateLineEntity(mappingSpec)) : Optional.empty();\n-\n-    /*\n-     * Then, create the JPA Entity for the \"grouped\" fields, containing:\n-     * fields, accessors, and a RIF-to-JPA-Entity parser.\n-     */\n-    TypeSpec headerEntity = generateHeaderEntity(mappingSpec);\n-\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      generateBeneficiaryMonthlyEntity(mappingSpec);\n-    }\n-\n-    /*\n-     * Then, create code that can be used to parse incoming RIF rows into\n-     * instances of those entities.\n-     */\n-    generateParser(mappingSpec, columnEnum, headerEntity, lineEntity);\n-\n-    /*\n-     * Then, create code that can be used to write the JPA Entity out to CSV\n-     * files, for use with PostgreSQL's copy APIs.\n-     */\n-    generateCsvWriter(mappingSpec, headerEntity, lineEntity);\n-  }\n-\n-  /**\n-   * Generates a Java {@link Enum} with entries for each {@link RifField} in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Enum} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateColumnEnum(MappingSpec mappingSpec) throws IOException {\n-    TypeSpec.Builder columnEnum =\n-        TypeSpec.enumBuilder(mappingSpec.getColumnEnum()).addModifiers(Modifier.PUBLIC);\n-    for (int fieldIndex = 0;\n-        fieldIndex < mappingSpec.getRifLayout().getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-      columnEnum.addEnumConstant(rifField.getRifColumnName());\n-    }\n-\n-    TypeSpec columnEnumFinal = columnEnum.build();\n-    JavaFile columnsEnumFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), columnEnumFinal).build();\n-    columnsEnumFile.writeTo(processingEnv.getFiler());\n-\n-    return columnEnumFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the line {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateLineEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating LineEntity code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getLineTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-    RifLayout rifLayout = mappingSpec.getRifLayout();\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getLineTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder lineEntity =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\"value\", \"$T.class\", mappingSpec.getLineEntityIdClass())\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder lineIdClass =\n-        TypeSpec.classBuilder(mappingSpec.getLineEntityIdClass())\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    lineIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    // find associated RifField(s) to imbue into @IdClass\n-    RifField parentClaimRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getHeaderEntityIdField().toLowerCase()))\n-            .findAny()\n-            .get();\n-    RifField lineNumberRifField =\n-        rifLayout.getRifFields().stream()\n-            .filter(\n-                f ->\n-                    f.getRifColumnName()\n-                        .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField().toLowerCase()))\n-            .findFirst()\n-            .get();\n-\n-    // setup field types for associated RifField(s)\n-    TypeName parentClaimIdFieldType =\n-        selectJavaFieldType(\n-            parentClaimRifField.getRifColumnType(),\n-            parentClaimRifField.isRifColumnOptional(),\n-            parentClaimRifField.getRifColumnLength(),\n-            parentClaimRifField.getRifColumnScale());\n-    TypeName lineNumberFieldType =\n-        selectJavaFieldType(\n-            lineNumberRifField.getRifColumnType(),\n-            lineNumberRifField.isRifColumnOptional(),\n-            lineNumberRifField.getRifColumnLength(),\n-            lineNumberRifField.getRifColumnScale());\n-\n-    // create fields to be added to the @IdClass object\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentClaimIdFieldType, PARENT_CLAIM, Modifier.PRIVATE);\n-    FieldSpec.Builder lineNumberIdField =\n-        FieldSpec.builder(\n-            lineNumberFieldType, lineNumberRifField.getJavaFieldName(), Modifier.PRIVATE);\n-\n-    // Add fields to that @IdClass class\n-    lineIdClass.addField(parentIdField.build());\n-    lineIdClass.addField(lineNumberIdField.build());\n-\n-    // add getter methods to access the ID fields\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentClaim\")\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(parentClaimIdFieldType);\n-    MethodSpec.Builder lineNumberGetter =\n-        MethodSpec.methodBuilder(\"getLineNumber\")\n-            .addStatement(\"return $N\", lineNumberRifField.getJavaFieldName())\n-            .returns(lineNumberFieldType);\n-\n-    // Add getter, hashCode() and equals(...) to @IdClass.\n-    lineIdClass.addMethod(parentGetter.build());\n-    lineIdClass.addMethod(lineNumberGetter.build());\n-    lineIdClass.addMethod(generateHashCodeMethod(parentIdField.build(), lineNumberIdField.build()));\n-    lineIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getLineEntity(), parentIdField.build(), lineNumberIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    lineEntity.addType(lineIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentClaimField =\n-        FieldSpec.builder(mappingSpec.getHeaderEntity(), PARENT_CLAIM, Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityIdField().toLowerCase())\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\",\n-                                mappingSpec.getLineTable(),\n-                                mappingSpec.getHeaderEntityIdField().toLowerCase(),\n-                                mappingSpec.getHeaderTable())\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    lineEntity.addField(parentClaimField);\n-\n-    // setup parentClaim setter/getter\n-    MethodSpec parentClaimGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_CLAIM)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .build();\n-    lineEntity.addMethod(parentClaimGetter);\n-\n-    MethodSpec.Builder parentClaimSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentClaimField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(mappingSpec.getHeaderEntity(), parentClaimField.name);\n-\n-    addSetterStatement(false, parentClaimField, parentClaimSetter);\n-    lineEntity.addMethod(parentClaimSetter.build());\n-\n-    // For each \"line\" RIF field, create an Entity field with accessors.\n-    for (int fieldIndex = mappingSpec.calculateFirstLineFieldIndex();\n-        fieldIndex < rifLayout.getRifFields().size();\n-        fieldIndex++) {\n-      RifField rifField = rifLayout.getRifFields().get(fieldIndex);\n-\n-      FieldSpec lineField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      lineEntity.addField(lineField);\n-\n-      MethodSpec.Builder lineFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()));\n-      addGetterStatement(rifField, lineField, lineFieldGetter);\n-      lineEntity.addMethod(lineFieldGetter.build());\n-\n-      MethodSpec.Builder lineFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(lineField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  lineField.name);\n-      addSetterStatement(rifField, lineField, lineFieldSetter);\n-      lineEntity.addMethod(lineFieldSetter.build());\n-    }\n-\n-    TypeSpec lineEntityFinal = lineEntity.build();\n-    JavaFile lineEntityClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), lineEntityFinal).build();\n-    lineEntityClassFile.writeTo(processingEnv.getFiler());\n-\n-    return lineEntityFinal;\n-  }\n-\n-  /**\n-   * Generate beneficiary monthly entity.\n-   *\n-   * @param mappingSpec the mapping spec\n-   * @return the type spec generated\n-   * @throws IOException the io exception\n-   */\n-  private TypeSpec generateBeneficiaryMonthlyEntity(MappingSpec mappingSpec) throws IOException {\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class).addMember(\"name\", \"$S\", \"beneficiary_monthly\").build();\n-\n-    TypeSpec.Builder beneficiaryMonthlyEntity =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthly\")\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(\n-                AnnotationSpec.builder(IdClass.class)\n-                    .addMember(\n-                        \"value\",\n-                        \"$T.class\",\n-                        ClassName.get(\"gov.cms.bfd.model.rif\", \"BeneficiaryMonthly\")\n-                            .nestedClass(\"BeneficiaryMonthlyId\"))\n-                    .build())\n-            .addAnnotation(tableAnnotation)\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create the @IdClass needed for the composite primary key.\n-    TypeSpec.Builder beneficiaryMonthlyIdClass =\n-        TypeSpec.classBuilder(\"BeneficiaryMonthlyId\")\n-            .addSuperinterface(Serializable.class)\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC);\n-    beneficiaryMonthlyIdClass.addField(\n-        FieldSpec.builder(\n-                long.class, \"serialVersionUID\", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)\n-            .initializer(\"$L\", 1L)\n-            .build());\n-\n-    TypeName parentBeneficiaryIdFieldType = ClassName.get(String.class);\n-    FieldSpec.Builder parentIdField =\n-        FieldSpec.builder(parentBeneficiaryIdFieldType, PARENT_BENEFICIARY, Modifier.PRIVATE);\n-\n-    // Add a field to that @IdClass class for the month.\n-    TypeName yearMonthFieldType = ClassName.get(LocalDate.class);\n-    FieldSpec.Builder yearMonthIdField =\n-        FieldSpec.builder(yearMonthFieldType, \"yearMonth\", Modifier.PRIVATE);\n-\n-    beneficiaryMonthlyIdClass.addField(parentIdField.build());\n-    beneficiaryMonthlyIdClass.addField(yearMonthIdField.build());\n-\n-    MethodSpec.Builder parentGetter =\n-        MethodSpec.methodBuilder(\"getParentBeneficiary\")\n-            .addStatement(\"return Long.parseLong($N)\", PARENT_BENEFICIARY)\n-            .returns(TypeName.LONG);\n-    beneficiaryMonthlyIdClass.addMethod(parentGetter.build());\n-    MethodSpec.Builder yearMonthGetter =\n-        MethodSpec.methodBuilder(\"getYearMonth\")\n-            .addStatement(\"return $N\", \"yearMonth\")\n-            .returns(yearMonthFieldType);\n-    beneficiaryMonthlyIdClass.addMethod(yearMonthGetter.build());\n-\n-    // Add hashCode() and equals(...) to that @IdClass.\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateHashCodeMethod(parentIdField.build(), yearMonthIdField.build()));\n-    beneficiaryMonthlyIdClass.addMethod(\n-        generateEqualsMethod(\n-            mappingSpec.getBeneficiaryMonthlyEntity(),\n-            parentIdField.build(),\n-            yearMonthIdField.build()));\n-\n-    // Finalize the @IdClass and nest it inside the Entity class.\n-    beneficiaryMonthlyEntity.addType(beneficiaryMonthlyIdClass.build());\n-\n-    // Add a field and accessor to the \"line\" Entity for the parent.\n-    FieldSpec parentBeneficiaryField =\n-        FieldSpec.builder(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"),\n-                PARENT_BENEFICIARY,\n-                Modifier.PRIVATE)\n-            .addAnnotation(Id.class)\n-            .addAnnotation(AnnotationSpec.builder(ManyToOne.class).build())\n-            .addAnnotation(\n-                AnnotationSpec.builder(JoinColumn.class)\n-                    .addMember(\"name\", \"$S\", \"bene_id\")\n-                    .addMember(\n-                        \"foreignKey\",\n-                        \"@$T(name = $S)\",\n-                        ForeignKey.class,\n-                        String.format(\n-                                \"%s_%s_to_%s\", \"beneficiary_monthly\", \"bene_id\", \"beneficiary\")\n-                            .toLowerCase())\n-                    .build())\n-            .build();\n-\n-    beneficiaryMonthlyEntity.addField(parentBeneficiaryField);\n-\n-    MethodSpec parentBeneficiaryGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .addStatement(\"return $N\", PARENT_BENEFICIARY)\n-            .returns(ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"))\n-            .build();\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiaryGetter);\n-\n-    MethodSpec.Builder parentBeneficiarySetter =\n-        MethodSpec.methodBuilder(calculateSetterName(parentBeneficiaryField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(\n-                ClassName.get(\"gov.cms.bfd.model.rif\", \"Beneficiary\"), parentBeneficiaryField.name);\n-    addSetterStatement(false, parentBeneficiaryField, parentBeneficiarySetter);\n-    beneficiaryMonthlyEntity.addMethod(parentBeneficiarySetter.build());\n-\n-    // These aren't \"real\" RifFields, as they're not in the spreadsheet; representing them here as\n-    // such, to make it easier to add them into the spreadsheet in the future.\n-    RifField rifField =\n-        new RifField(\n-            \"YEAR_MONTH\",\n-            RifColumnType.DATE,\n-            Optional.of(8),\n-            Optional.empty(),\n-            false,\n-            null,\n-            null,\n-            \"yearMonth\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, true, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"FIPS_STATE_CNTY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"fipsStateCntyCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICARE_STATUS_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicareStatusCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"ENTITLEMENT_BUY_IN_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"entitlementBuyInInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"HMO_INDICATOR_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"hmoIndicatorInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTC_PLAN_TYPE_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partCPlanTypeCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_CONTRACT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(5),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDContractNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_PBP_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDPbpNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_SEGMENT_NUMBER_ID\",\n-            RifColumnType.CHAR,\n-            Optional.of(3),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDSegmentNumberId\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_RETIREE_DRUG_SUBSIDY_IND\",\n-            RifColumnType.CHAR,\n-            Optional.of(1),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDRetireeDrugSubsidyInd\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"MEDICAID_DUAL_ELIGIBILITY_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"medicaidDualEligibilityCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    rifField =\n-        new RifField(\n-            \"PARTD_LOW_INCOME_COST_SHARE_GROUP_CODE\",\n-            RifColumnType.CHAR,\n-            Optional.of(2),\n-            Optional.empty(),\n-            true,\n-            null,\n-            null,\n-            \"partDLowIncomeCostShareGroupCode\");\n-    createBeneficiaryMonthlyFields(beneficiaryMonthlyEntity, false, rifField);\n-\n-    TypeSpec beneficiaryMonthlyEntityFinal = beneficiaryMonthlyEntity.build();\n-    JavaFile beneficiaryMonthlyClassFile =\n-        JavaFile.builder(\"gov.cms.bfd.model.rif\", beneficiaryMonthlyEntityFinal).build();\n-    beneficiaryMonthlyClassFile.writeTo(processingEnv.getFiler());\n-\n-    return beneficiaryMonthlyEntityFinal;\n-  }\n-\n-  /**\n-   * Generates a Java {@link Entity} for the header {@link RifField}s in the specified {@link\n-   * MappingSpec}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @return the Java {@link Entity} that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateHeaderEntity(MappingSpec mappingSpec) throws IOException {\n-    logNote(\n-        \"\\n%s\\nGenerating code for %s\\n%s\\n%s\",\n-        \"===============================================\",\n-        mappingSpec.getHeaderTable(),\n-        mappingSpec.toString(),\n-        \"===============================================\");\n-\n-    // Create the Entity class.\n-    AnnotationSpec entityAnnotation = AnnotationSpec.builder(Entity.class).build();\n-    AnnotationSpec tableAnnotation =\n-        AnnotationSpec.builder(Table.class)\n-            .addMember(\"name\", \"$S\", mappingSpec.getHeaderTable().toLowerCase())\n-            .build();\n-    TypeSpec.Builder headerEntityClass =\n-        TypeSpec.classBuilder(mappingSpec.getHeaderEntity())\n-            .addAnnotation(entityAnnotation)\n-            .addAnnotation(tableAnnotation)\n-            .addSuperinterface(ClassName.get(\"gov.cms.bfd.model.rif\", \"RifRecordBase\"))\n-            .addModifiers(Modifier.PUBLIC);\n-\n-    // Create an Entity field with accessors for the generated-ID field (if any).\n-    if (mappingSpec.getHeaderEntityGeneratedIdField() != null) {\n-      FieldSpec.Builder idFieldBuilder =\n-          FieldSpec.builder(\n-              TypeName.LONG, mappingSpec.getHeaderEntityGeneratedIdField(), Modifier.PRIVATE);\n-      idFieldBuilder.addAnnotation(Id.class);\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", mappingSpec.getHeaderEntityGeneratedIdField().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", false)\n-              .addMember(\"updatable\", \"$L\", false)\n-              .build());\n-\n-      String sequenceName = mappingSpec.getSequenceNumberGeneratorName().toLowerCase();\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(GeneratedValue.class)\n-              .addMember(\"strategy\", \"$T.SEQUENCE\", GenerationType.class)\n-              .addMember(\"generator\", \"$S\", sequenceName)\n-              .build());\n-      idFieldBuilder.addAnnotation(\n-          AnnotationSpec.builder(SequenceGenerator.class)\n-              .addMember(\"name\", \"$S\", sequenceName)\n-              .addMember(\"sequenceName\", \"$S\", sequenceName)\n-              .addMember(\"allocationSize\", \"$L\", 50)\n-              .build());\n-      FieldSpec idField = idFieldBuilder.build();\n-      headerEntityClass.addField(idField);\n-\n-      MethodSpec.Builder idFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(idField.type);\n-      addGetterStatement(false, idField, idFieldGetter);\n-      headerEntityClass.addMethod(idFieldGetter.build());\n-\n-      MethodSpec.Builder idFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(idField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(idField.type, idField.name);\n-      addSetterStatement(false, idField, idFieldSetter);\n-      headerEntityClass.addMethod(idFieldSetter.build());\n-    }\n-\n-    // Create an Entity field with accessors for each RIF field.\n-    int entityLastHeaderFieldIx = mappingSpec.calculateLastHeaderFieldIndex();\n-    logNote(\"entityLastHeaderFieldIx=%d\", entityLastHeaderFieldIx);\n-    for (int fieldIndex = 0; fieldIndex <= entityLastHeaderFieldIx; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      rifField.getRifColumnType(),\n-                      rifField.isRifColumnOptional(),\n-                      rifField.getRifColumnLength(),\n-                      rifField.getRifColumnScale()),\n-                  rifField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, rifField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter;\n-\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Optional.of(Long.parseLong($N))\", headerField.name)\n-                  .returns(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)));\n-        } else {\n-          headerFieldGetter =\n-              MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .addStatement(\"return Long.parseLong($N)\", headerField.name)\n-                  .returns(TypeName.LONG);\n-        }\n-      } else {\n-        headerFieldGetter =\n-            MethodSpec.methodBuilder(calculateGetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()));\n-        addGetterStatement(rifField, headerField, headerFieldGetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter;\n-      if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-        if (rifField.isRifColumnOptional()) {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(\n-                      ParameterizedTypeName.get(\n-                          ClassName.get(Optional.class), ClassName.get(Long.class)),\n-                      headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N.orElse(null))\", headerField.name, headerField.name);\n-        } else {\n-          headerFieldSetter =\n-              MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                  .addModifiers(Modifier.PUBLIC)\n-                  .returns(void.class)\n-                  .addParameter(TypeName.LONG, headerField.name);\n-          headerFieldSetter.addStatement(\n-              \"this.$N = String.valueOf($N)\", headerField.name, headerField.name);\n-        }\n-      } else {\n-        headerFieldSetter =\n-            MethodSpec.methodBuilder(calculateSetterName(headerField))\n-                .addModifiers(Modifier.PUBLIC)\n-                .returns(void.class)\n-                .addParameter(\n-                    selectJavaPropertyType(\n-                        rifField.getRifColumnType(),\n-                        rifField.isRifColumnOptional(),\n-                        rifField.getRifColumnLength(),\n-                        rifField.getRifColumnScale()),\n-                    headerField.name);\n-        addSetterStatement(rifField, headerField, headerFieldSetter);\n-      }\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-    }\n-\n-    /*\n-     * Create an Entity field for additional database fields that we need to store\n-     * data for whereas there isn't a corresponding RIF input field.\n-     */\n-    for (RifField addlDatabaseField : mappingSpec.getHeaderEntityAdditionalDatabaseFields()) {\n-      FieldSpec headerField =\n-          FieldSpec.builder(\n-                  selectJavaFieldType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  addlDatabaseField.getJavaFieldName(),\n-                  Modifier.PRIVATE)\n-              .addAnnotations(createAnnotations(mappingSpec, addlDatabaseField))\n-              .build();\n-      headerEntityClass.addField(headerField);\n-\n-      MethodSpec.Builder headerFieldGetter =\n-          MethodSpec.methodBuilder(calculateGetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()));\n-      addGetterStatement(addlDatabaseField, headerField, headerFieldGetter);\n-      headerEntityClass.addMethod(headerFieldGetter.build());\n-\n-      MethodSpec.Builder headerFieldSetter =\n-          MethodSpec.methodBuilder(calculateSetterName(headerField))\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(\n-                  selectJavaPropertyType(\n-                      addlDatabaseField.getRifColumnType(),\n-                      addlDatabaseField.isRifColumnOptional(),\n-                      addlDatabaseField.getRifColumnLength(),\n-                      addlDatabaseField.getRifColumnScale()),\n-                  headerField.name);\n-      addSetterStatement(addlDatabaseField, headerField, headerFieldSetter);\n-      headerEntityClass.addMethod(headerFieldSetter.build());\n-      logNote(\"addlDatabaseField added, %s\", addlDatabaseField);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.getHasLines()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(ClassName.get(List.class), mappingSpec.getLineEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"lines\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getLineEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getLineEntityLineNumberField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getLines\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"lines\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(List.class), mappingSpec.getBeneficiaryMonthlyEntity());\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"beneficiaryMonthlys\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", LinkedList.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", mappingSpec.getBeneficiaryMonthlyEntityParentField())\n-              .addMember(\"orphanRemoval\", \"$L\", true)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OrderBy.class)\n-              .addMember(\"value\", \"$S\", mappingSpec.getEntityBeneficiaryMonthlyField() + \" ASC\")\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"beneficiaryMonthlys\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-\n-      MethodSpec childSetter =\n-          MethodSpec.methodBuilder(\"setBeneficiaryMonthlys\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .returns(void.class)\n-              .addParameter(childFieldType, \"beneficiaryMonthlys\")\n-              .addStatement(\n-                  \"this.$N = ($T)$N\", \"beneficiaryMonthlys\", childFieldType, \"beneficiaryMonthlys\")\n-              .build();\n-      headerEntityClass.addMethod(childSetter);\n-    }\n-\n-    // Add a hardcoded \"Beneficiary.skippedRifRecords\" field, if appropriate.\n-    if (mappingSpec.isBeneficiaryEntity()) {\n-      ParameterizedTypeName childFieldType =\n-          ParameterizedTypeName.get(\n-              ClassName.get(Set.class),\n-              ClassName.get(mappingSpec.getPackageName(), \"SkippedRifRecord\"));\n-\n-      FieldSpec.Builder childField =\n-          FieldSpec.builder(childFieldType, \"skippedRifRecords\", Modifier.PRIVATE)\n-              .initializer(\"new $T<>()\", HashSet.class);\n-\n-      childField.addAnnotation(\n-          AnnotationSpec.builder(OneToMany.class)\n-              .addMember(\"mappedBy\", \"$S\", \"beneId\")\n-              .addMember(\"orphanRemoval\", \"$L\", false)\n-              .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-              .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-              .build());\n-      headerEntityClass.addField(childField.build());\n-\n-      MethodSpec childGetter =\n-          MethodSpec.methodBuilder(\"getSkippedRifRecords\")\n-              .addModifiers(Modifier.PUBLIC)\n-              .addStatement(\"return $N\", \"skippedRifRecords\")\n-              .returns(childFieldType)\n-              .build();\n-      headerEntityClass.addMethod(childGetter);\n-    }\n-\n-    // Add the parent-to-child join field and accessor for an inner join\n-    // relationship\n-    if (mappingSpec.getHasInnerJoinRelationship()) {\n-      for (InnerJoinRelationship relationship : mappingSpec.getInnerJoinRelationship()) {\n-        String mappedBy = relationship.getMappedBy();\n-        String orderBy = relationship.getOrderBy();\n-        ClassName childEntity = mappingSpec.getClassName(relationship.getChildEntity());\n-        String childFieldName = relationship.getChildField();\n-\n-        Class<?> fieldDeclaredType;\n-        Class<?> fieldActualType;\n-        if (orderBy != null) {\n-          fieldDeclaredType = List.class;\n-          fieldActualType = LinkedList.class;\n-        } else {\n-          fieldDeclaredType = Set.class;\n-          fieldActualType = HashSet.class;\n-        }\n-\n-        ParameterizedTypeName childFieldType =\n-            ParameterizedTypeName.get(ClassName.get(fieldDeclaredType), childEntity);\n-        FieldSpec.Builder childField =\n-            FieldSpec.builder(childFieldType, childFieldName, Modifier.PRIVATE)\n-                .initializer(\"new $T<>()\", fieldActualType);\n-        childField.addAnnotation(\n-            AnnotationSpec.builder(OneToMany.class)\n-                .addMember(\"mappedBy\", \"$S\", mappedBy)\n-                .addMember(\"orphanRemoval\", \"$L\", false)\n-                .addMember(\"fetch\", \"$T.LAZY\", FetchType.class)\n-                .addMember(\"cascade\", \"$T.ALL\", CascadeType.class)\n-                .build());\n-        if (orderBy != null)\n-          childField.addAnnotation(\n-              AnnotationSpec.builder(OrderBy.class)\n-                  .addMember(\"value\", \"$S\", orderBy + \" ASC\")\n-                  .build());\n-        headerEntityClass.addField(childField.build());\n-\n-        MethodSpec childGetter =\n-            MethodSpec.methodBuilder(\"get\" + capitalize(childFieldName))\n-                .addModifiers(Modifier.PUBLIC)\n-                .addStatement(\"return $N\", childFieldName)\n-                .returns(childFieldType)\n-                .build();\n-        headerEntityClass.addMethod(childGetter);\n-      }\n-    }\n-    TypeSpec headerEntityFinal = headerEntityClass.build();\n-    JavaFile headerEntityFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), headerEntityFinal).build();\n-    headerEntityFile.writeTo(processingEnv.getFiler());\n-\n-    return headerEntityFinal;\n-  }\n-  /**\n-   * Support method for the varchar to bigint transition that identifies the columns that are\n-   * planned to be converted.\n-   *\n-   * <p>TODO: BFD-1583 This is a temporary method that should be removed along with all code blocks\n-   * that are conditional on this method once all beneficiary and claim tables IDs have completed\n-   * the transition from varchar to bigint.\n-   *\n-   * @param tableName the table name\n-   * @param rifField the field model\n-   * @return true if the field specified is one that will be converted to a bigint in the near\n-   *     future\n-   */\n-  private boolean isFutureBigint(String tableName, RifField rifField) {\n-    /*\n-     * Remove elements from these arrays as they are converted. When everything is removed, remove\n-     * the method and all blocks that are conditional on this method.\n-     */\n-    final List<String> futureBigIntColumns = Arrays.asList(\"bene_id\", \"clm_id\", \"pde_id\");\n-    final List<String> futureBigIntTables =\n-        Arrays.asList(\n-            \"beneficiaries\",\n-            \"beneficiaries_history\",\n-            \"medicare_beneficiaryid_history\",\n-            \"carrier_claims\",\n-            \"dme_claims\",\n-            \"hha_claims\",\n-            \"hospice_claims\",\n-            \"inpatient_claims\",\n-            \"outpatient_claims\",\n-            \"snf_claims\",\n-            \"partd_events\");\n-\n-    return futureBigIntColumns.contains(rifField.getRifColumnName().toLowerCase())\n-        && futureBigIntTables.contains(tableName.toLowerCase());\n-  }\n-\n-  /**\n-   * Generates a Java class that can handle RIF-to-Entity parsing.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param columnEnum the RIF column {@link Enum} that was generated for the layout\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java parsing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateParser(\n-      MappingSpec mappingSpec,\n-      TypeSpec columnEnum,\n-      TypeSpec headerEntity,\n-      Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-    int rifFieldsSize = mappingSpec.getRifLayout().getRifFields().size();\n-    int firstLineFieldIx =\n-        mappingSpec.getHasLines() ? mappingSpec.calculateFirstLineFieldIndex() : -1;\n-    logNote(\n-        \"generateParser, # of RifFields: %d, line field starts at: %d\",\n-        rifFieldsSize, firstLineFieldIx);\n-\n-    TypeSpec.Builder parsingClass =\n-        TypeSpec.classBuilder(mappingSpec.getParserClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ClassName csvRecordType = ClassName.get(\"org.apache.commons.csv\", \"CSVRecord\");\n-    ClassName parseUtilsType = ClassName.get(\"gov.cms.bfd.model.rif.parse\", \"RifParsingUtils\");\n-\n-    MethodSpec.Builder parseMethod =\n-        MethodSpec.methodBuilder(\"parseRif\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(mappingSpec.getHeaderEntity())\n-            .addParameter(\n-                ParameterizedTypeName.get(ClassName.get(List.class), csvRecordType), \"csvRecords\");\n-\n-    parseMethod.addComment(\"Verify the inputs.\");\n-    parseMethod.addStatement(\"$T.requireNonNull(csvRecords)\", Objects.class);\n-    parseMethod\n-        .beginControlFlow(\"if (csvRecords.size() < 1)\")\n-        .addStatement(\"throw new $T()\", IllegalArgumentException.class)\n-        .endControlFlow();\n-\n-    parseMethod.addCode(\"\\n$1T header = new $1T();\\n\", mappingSpec.getHeaderEntity());\n-\n-    // Loop over each field and generate the code needed to parse it.\n-    for (int fieldIndex = 0; fieldIndex < rifFieldsSize; fieldIndex++) {\n-      RifField rifField = mappingSpec.getRifLayout().getRifFields().get(fieldIndex);\n-\n-      // Find the Entity field for the RifField.\n-      Stream<FieldSpec> entitiesFieldsStream =\n-          mappingSpec.getHasLines()\n-              ? Stream.concat(\n-                  headerEntity.fieldSpecs.stream(), lineEntity.get().fieldSpecs.stream())\n-              : headerEntity.fieldSpecs.stream();\n-      FieldSpec entityField =\n-          entitiesFieldsStream\n-              .filter(f -> f.name.equals(rifField.getJavaFieldName()))\n-              .findAny()\n-              .get();\n-      // logNote(\"create code for: %s\", entityField.toString());\n-\n-      // Are we starting the header parsing?\n-      if (fieldIndex == 0) {\n-        parseMethod.addCode(\"\\n// Parse the header fields.\\n\");\n-        parseMethod.addCode(\"$T headerRecord = csvRecords.get(0);\\n\", csvRecordType);\n-      }\n-\n-      // Are we starting the line parsing?\n-      if (fieldIndex == firstLineFieldIx) {\n-        parseMethod.addCode(\"\\n// Parse the line fields.\\n\");\n-        parseMethod.beginControlFlow(\n-            \"for (int lineIndex = 0; lineIndex < csvRecords.size(); lineIndex++)\");\n-        parseMethod.addStatement(\"$T lineRecord = csvRecords.get(lineIndex)\", csvRecordType);\n-        parseMethod.addStatement(\"$1T line = new $1T()\", mappingSpec.getLineEntity());\n-\n-        FieldSpec lineEntityParentField =\n-            lineEntity.get().fieldSpecs.stream()\n-                .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getLineEntityParentField()))\n-                .findAny()\n-                .get();\n-        parseMethod.addCode(\"line.$L(header);\\n\\n\", calculateSetterName(lineEntityParentField));\n-      }\n-\n-      // Determine which variables to use in assignment statement.\n-      String entityName;\n-      String recordName;\n-      if (mappingSpec.getHasLines() && fieldIndex >= firstLineFieldIx) {\n-        entityName = \"line\";\n-        recordName = \"lineRecord\";\n-      } else {\n-        entityName = \"header\";\n-        recordName = \"headerRecord\";\n-      }\n-\n-      // Determine which parsing utility method to use.\n-      String parseUtilsMethodName;\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR) {\n-\n-        if (isFutureBigint(mappingSpec.getHeaderTable(), rifField)) {\n-          parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-        } else if (rifField.getRifColumnLength().orElse(Integer.MAX_VALUE) > 1) {\n-          // Handle a String field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalString\" : \"parseString\";\n-        } else {\n-          // Handle a Character field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalCharacter\" : \"parseCharacter\";\n-        }\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.BIGINT) {\n-        // Handle an BigInteger field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalLong\" : \"parseLong\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.SMALLINT) {\n-        // Handle an Short field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalShort\" : \"parseShort\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.INTEGER) {\n-        // Handle an Integer field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        if (rifField.getRifColumnScale().orElse(Integer.MAX_VALUE) == 0) {\n-          // Handle an Integer field.\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalInteger\" : \"parseInteger\";\n-\n-        } else {\n-          parseUtilsMethodName =\n-              rifField.isRifColumnOptional() ? \"parseOptionalDecimal\" : \"parseDecimal\";\n-        }\n-      } else if (rifField.getRifColumnType() == RifColumnType.DATE) {\n-        // Handle a LocalDate field.\n-        parseUtilsMethodName = rifField.isRifColumnOptional() ? \"parseOptionalDate\" : \"parseDate\";\n-\n-      } else if (rifField.getRifColumnType() == RifColumnType.TIMESTAMP) {\n-        // Handle an Instant field.\n-        parseUtilsMethodName =\n-            rifField.isRifColumnOptional() ? \"parseOptionalTimestamp\" : \"parseTimestamp\";\n-      } else {\n-        throw new IllegalStateException();\n-      }\n-\n-      Map<String, Object> valueAssignmentArgs = new LinkedHashMap<>();\n-      valueAssignmentArgs.put(\"entity\", entityName);\n-      valueAssignmentArgs.put(\"entitySetter\", calculateSetterName(entityField));\n-      valueAssignmentArgs.put(\"record\", recordName);\n-      valueAssignmentArgs.put(\"parseUtilsType\", parseUtilsType);\n-      valueAssignmentArgs.put(\"parseUtilsMethod\", parseUtilsMethodName);\n-      valueAssignmentArgs.put(\"columnEnumType\", mappingSpec.getColumnEnum());\n-      valueAssignmentArgs.put(\"columnEnumConstant\", rifField.getRifColumnName());\n-      parseMethod.addCode(\n-          CodeBlock.builder()\n-              .addNamed(\n-                  \"$entity:L.$entitySetter:L(\"\n-                      + \"$parseUtilsType:T.$parseUtilsMethod:L(\"\n-                      + \"$record:L.get(\"\n-                      + \"$columnEnumType:T.$columnEnumConstant:L)));\\n\",\n-                  valueAssignmentArgs)\n-              .build());\n-    }\n-\n-    // Did we just finish line parsing?\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equals(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      parseMethod.addStatement(\"header.$L().add(line)\", calculateGetterName(linesField));\n-      parseMethod.endControlFlow();\n-    }\n-\n-    parseMethod.addStatement(\"return header\");\n-    parsingClass.addMethod(parseMethod.build());\n-\n-    TypeSpec parsingClassFinal = parsingClass.build();\n-    logNote(\"parsingClass: %s\", parsingClassFinal.name);\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Generates a Java class that can be used to write the JPA Entity out to CSV files, for use with\n-   * PostgreSQL's copy APIs.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} of the layout to generate code for\n-   * @param headerEntity the Java {@link Entity} that was generated for the header fields\n-   * @param lineEntity the Java {@link Entity} that was generated for the line fields, if any\n-   * @return the Java CSV writing class that was generated\n-   * @throws IOException An {@link IOException} may be thrown if errors are encountered trying to\n-   *     generate source files.\n-   */\n-  private TypeSpec generateCsvWriter(\n-      MappingSpec mappingSpec, TypeSpec headerEntity, Optional<TypeSpec> lineEntity)\n-      throws IOException {\n-\n-    TypeSpec.Builder csvWriterClass =\n-        TypeSpec.classBuilder(mappingSpec.getCsvWriterClass())\n-            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);\n-\n-    // Grab some common types we'll need.\n-    ArrayTypeName recordType = ArrayTypeName.of(Object.class);\n-    ArrayTypeName recordsListType = ArrayTypeName.of(recordType);\n-    ParameterizedTypeName returnType =\n-        ParameterizedTypeName.get(\n-            ClassName.get(Map.class), ClassName.get(String.class), recordsListType);\n-\n-    MethodSpec.Builder csvWriterMethod =\n-        MethodSpec.methodBuilder(\"toCsvRecordsByTable\")\n-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-            .returns(returnType)\n-            .addParameter(mappingSpec.getHeaderEntity(), \"entity\");\n-\n-    csvWriterMethod.addComment(\"Verify the input.\");\n-    csvWriterMethod.addStatement(\"$T.requireNonNull(entity)\", Objects.class);\n-\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addStatement(\"$T csvRecordsByTable = new $T<>(2)\", returnType, HashMap.class);\n-\n-    // Generate the header conversion.\n-    csvWriterMethod.addCode(\"\\n\");\n-    csvWriterMethod.addComment(\"Convert the header fields.\");\n-    csvWriterMethod.addStatement(\"$T headerRecords = new $T[2][]\", recordsListType, Object.class);\n-\n-    String headerColumnsList = calculateCsvColumns(headerEntity.fieldSpecs, mappingSpec);\n-\n-    if (DEBUG) {\n-      logNote(\n-          \"headerColumnsList\\n=====================\\n%s\",\n-          headerColumnsList.replaceAll(\", \", \",\\n\"));\n-    }\n-    csvWriterMethod.addStatement(\n-        \"headerRecords[0] = new $1T{ $2L }\", recordType, headerColumnsList);\n-\n-    String headerGettersList =\n-        headerEntity.fieldSpecs.stream()\n-            .filter(\n-                f -> {\n-                  if (mappingSpec.getHasLines()\n-                      && f.name.equals(mappingSpec.getHeaderEntityLinesField())) return false;\n-                  return true;\n-                })\n-            .map(f -> calculateFieldToCsvValueCode(\"entity\", f, mappingSpec, null, null))\n-            .collect(Collectors.joining(\", \"));\n-\n-    csvWriterMethod.addStatement(\n-        \"$1T headerRecord = new $1T{ $2L }\", recordType, headerGettersList);\n-    csvWriterMethod.addStatement(\"headerRecords[1] = headerRecord\");\n-    csvWriterMethod.addStatement(\n-        \"csvRecordsByTable.put($S, headerRecords)\", mappingSpec.getHeaderTable());\n-\n-    // Generate the line conversion.\n-    if (mappingSpec.getHasLines()) {\n-      FieldSpec linesField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(mappingSpec.getHeaderEntityLinesField()))\n-              .findAny()\n-              .get();\n-      String linesFieldGetter = calculateGetterName(linesField);\n-      csvWriterMethod.addCode(\"\\n\");\n-      csvWriterMethod.addComment(\"Convert the line fields.\");\n-      csvWriterMethod.addStatement(\n-          \"$T lineRecords = new $T[entity.$L().size() + 1][]\",\n-          recordsListType,\n-          Object.class,\n-          linesFieldGetter);\n-\n-      csvWriterMethod.addStatement(\n-          \"csvRecordsByTable.put($S, lineRecords)\", mappingSpec.getLineTable());\n-\n-      String lineColumnsList = calculateCsvColumns(lineEntity.get().fieldSpecs, mappingSpec);\n-\n-      if (DEBUG) {\n-        logNote(\n-            \"lineColumnsList\\n=====================\\n%s\", lineColumnsList.replaceAll(\", \", \",\\n\"));\n-      }\n-\n-      csvWriterMethod.addStatement(\"lineRecords[0] = new $1T{ $2L }\", recordType, lineColumnsList);\n-      csvWriterMethod.beginControlFlow(\n-          \"for (int lineIndex = 0; lineIndex < entity.$L().size();lineIndex++)\", linesFieldGetter);\n-      csvWriterMethod.addStatement(\n-          \"$T lineEntity = entity.$L().get(lineIndex)\",\n-          mappingSpec.getLineEntity(),\n-          linesFieldGetter);\n-\n-      FieldSpec parentField =\n-          lineEntity.get().fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(PARENT_CLAIM))\n-              .findAny()\n-              .get();\n-      FieldSpec headerIdField =\n-          headerEntity.fieldSpecs.stream()\n-              .filter(f -> f.name.equalsIgnoreCase(\"claimId\"))\n-              .findAny()\n-              .get();\n-\n-      String lineGettersList =\n-          lineEntity.get().fieldSpecs.stream()\n-              .map(\n-                  f -> {\n-                    return calculateFieldToCsvValueCode(\n-                        \"lineEntity\", f, mappingSpec, parentField, headerIdField);\n-                  })\n-              .collect(Collectors.joining(\", \"));\n-\n-      csvWriterMethod.addStatement(\"$1T lineRecord = new $1T{ $2L }\", recordType, lineGettersList);\n-      csvWriterMethod.addStatement(\"lineRecords[lineIndex + 1] = lineRecord\");\n-      csvWriterMethod.endControlFlow();\n-    }\n-\n-    csvWriterMethod.addStatement(\"return csvRecordsByTable\");\n-    csvWriterClass.addMethod(csvWriterMethod.build());\n-\n-    TypeSpec parsingClassFinal = csvWriterClass.build();\n-    JavaFile parsingClassFile =\n-        JavaFile.builder(mappingSpec.getPackageName(), parsingClassFinal).build();\n-    parsingClassFile.writeTo(processingEnv.getFiler());\n-    return parsingClassFinal;\n-  }\n-\n-  /**\n-   * Used in {@link #generateCsvWriter(MappingSpec, TypeSpec, Optional)} and generates the\n-   * field-to-CSV-value conversion code for the specified field.\n-   *\n-   * @param instanceName the name of the object that the value will be pulled from\n-   * @param field the field to generate conversion code for\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @param parentField the {@link MappingSpec#getLineEntityParentField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @param headerIdField the {@link MappingSpec#getHeaderEntityIdField()} field, or <code>null\n-   *     </code> if this is a header field\n-   * @return the field-to-CSV-value conversion code for the specified field\n-   */\n-  private String calculateFieldToCsvValueCode(\n-      String instanceName,\n-      FieldSpec field,\n-      MappingSpec mappingSpec,\n-      FieldSpec parentField,\n-      FieldSpec headerIdField) {\n-    StringBuilder sb = new StringBuilder();\n-    if (DEBUG) {\n-      sb.append(\"calculateFieldToCsvValueCode: [ \")\n-          .append(\"instanceName=\")\n-          .append(instanceName)\n-          .append(\", field=\")\n-          .append(field.name);\n-      if (parentField != null) {\n-        sb.append(\", parentField=\").append(parentField.name);\n-      }\n-      if (headerIdField != null) {\n-        sb.append(\", headerIdField=\").append(headerIdField.name);\n-      }\n-    }\n-    StringBuilder code = new StringBuilder(instanceName);\n-    code.append(\".\");\n-\n-    Optional<RifField> rifField =\n-        mappingSpec.getRifLayout().getRifFields().stream()\n-            .filter(f -> field.name.equals(f.getJavaFieldName()))\n-            .findAny();\n-\n-    if (field == parentField) {\n-      // This is the line-level \"parent\" field.\n-      code.append(calculateGetterName(parentField)).append(\"().\");\n-      code.append(calculateGetterName(headerIdField)).append(\"()\");\n-    } else if (rifField.isPresent() && rifField.get().isRifColumnOptional()) {\n-      code.append(calculateGetterName(field)).append(\"().orElse(null)\");\n-    } else {\n-      code.append(calculateGetterName(field)).append(\"()\");\n-    }\n-    sb.append(\", code=\").append(code).append(\" ]\");\n-    logNote(\"%s\", sb.toString());\n-    return code.toString();\n-  }\n-\n-  /**\n-   * Generates the field-to-CSV-value header.\n-   *\n-   * @param fields the list of {@link FieldSpec}s to process\n-   * @param mappingSpec the {@link MappingSpec} of the field to generate conversion code for\n-   * @return the string header of column names\n-   */\n-  private String calculateCsvColumns(List<FieldSpec> fields, MappingSpec mappingSpec) {\n-    StringBuilder sb = new StringBuilder();\n-    int cnt = 0;\n-    for (FieldSpec field : fields) {\n-      Optional<RifField> rifField =\n-          mappingSpec.getRifLayout().getRifFields().stream()\n-              .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-              .findAny();\n-\n-      if (!rifField.isPresent()) {\n-        rifField =\n-            mappingSpec.getHeaderEntityAdditionalDatabaseFields().stream()\n-                .filter(f -> field.name.equalsIgnoreCase(f.getJavaFieldName()))\n-                .findAny();\n-      }\n-      if (rifField.isPresent()) {\n-        sb.append(cnt > 0 ? \", \\\"\" : \"\\\"\").append(rifField.get().getRifColumnName()).append(\"\\\"\");\n-        cnt++;\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  /**\n-   * Generates a hash code method.\n-   *\n-   * @param fields the fields that should be hashed\n-   * @return a new <code>hashCode()</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateHashCodeMethod(FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"hashCode\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(int.class)\n-            .addStatement(\n-                \"return $T.hash($L)\",\n-                Objects.class,\n-                Arrays.stream(fields).map(f -> f.name).collect(Collectors.joining(\", \")));\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Generates an equals method.\n-   *\n-   * @param typeName the {@link TypeName} of the class to add this method for\n-   * @param fields the fields that should be compared\n-   * @return a new <code>equals(...)</code> implementation that uses the specified fields\n-   */\n-  private static MethodSpec generateEqualsMethod(TypeName typeName, FieldSpec... fields) {\n-    MethodSpec.Builder hashCodeMethod =\n-        MethodSpec.methodBuilder(\"equals\")\n-            .addAnnotation(Override.class)\n-            .addModifiers(Modifier.PUBLIC)\n-            .addParameter(Object.class, \"obj\")\n-            .returns(boolean.class);\n-\n-    hashCodeMethod\n-        .beginControlFlow(\"if (this == obj)\")\n-        .addStatement(\"return true\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (obj == null)\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod\n-        .beginControlFlow(\"if (getClass() != obj.getClass())\")\n-        .addStatement(\"return false\")\n-        .endControlFlow();\n-    hashCodeMethod.addStatement(\"$T other = ($T) obj\", typeName, typeName);\n-    for (FieldSpec field : fields) {\n-      hashCodeMethod\n-          .beginControlFlow(\"if ($T.deepEquals($N, other.$N))\", Objects.class, field, field)\n-          .addStatement(\"return false\")\n-          .endControlFlow();\n-    }\n-    hashCodeMethod.addStatement(\"return true\");\n-\n-    return hashCodeMethod.build();\n-  }\n-\n-  /**\n-   * Creates an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   * annotations that should be applied to the specified {@link RifField}.\n-   *\n-   * @param mappingSpec the {@link MappingSpec} for the specified {@link RifField}\n-   * @param rifField the {@link RifField} to create the corresponding {@link AnnotationSpec}s for\n-   * @return an ordered {@link List} of {@link AnnotationSpec}s representing the JPA, etc.\n-   *     annotations that should be applied to the specified {@link RifField}\n-   */\n-  private static List<AnnotationSpec> createAnnotations(\n-      MappingSpec mappingSpec, RifField rifField) {\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-\n-    // Add an @Id annotation, if appropriate.\n-    if (rifField.getRifColumnName().equalsIgnoreCase(mappingSpec.getHeaderEntityIdField())\n-        || (mappingSpec.getHasLines()\n-            && rifField\n-                .getRifColumnName()\n-                .equalsIgnoreCase(mappingSpec.getLineEntityLineNumberField()))) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-\n-    // Add an @Column annotation to every non-transient column.\n-    boolean isTransient =\n-        mappingSpec.getHeaderEntityTransientFields().contains(rifField.getRifColumnName());\n-    if (!isTransient) {\n-      AnnotationSpec.Builder columnAnnotation =\n-          AnnotationSpec.builder(Column.class)\n-              .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-              .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-      if (rifField.getRifColumnType() == RifColumnType.CHAR\n-          && rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-      } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-        /*\n-         * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-         * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-         * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-         */\n-\n-        if (rifField.getRifColumnLength().isPresent() && rifField.getRifColumnScale().isPresent()) {\n-          columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-          columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-        } else {\n-          /*\n-           * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-           * handle SQL numeric datatypes that don't have a defined precision and scale.\n-           * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-           * but what it does instead is insert a default precision and scale as\n-           * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-           * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-           * (for different reasons), but fortunately that doesn't happen to cause\n-           * problems with our tests.\n-           */\n-          StringBuilder columnDefinition = new StringBuilder();\n-          columnDefinition.append(\"numeric\");\n-          if (rifField.getRifColumnLength().isPresent()\n-              || rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append('(');\n-            if (rifField.getRifColumnLength().isPresent()) {\n-              columnDefinition.append(rifField.getRifColumnLength().get());\n-            }\n-            if (rifField.getRifColumnScale().isPresent()) {\n-              columnDefinition.append(\", \");\n-              columnDefinition.append(rifField.getRifColumnScale().get());\n-            }\n-            columnDefinition.append(')');\n-          }\n-          columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-        }\n-      }\n-      annotations.add(columnAnnotation.build());\n-    } else {\n-      annotations.add(AnnotationSpec.builder(Transient.class).build());\n-    }\n-\n-    return annotations;\n-  }\n-\n-  /**\n-   * Creates details for additional annotated database fields.\n-   *\n-   * @param additionalDatabaseFields the {@link RifField} to create an additional Annotated database\n-   *     field for\n-   * @return an ordered {@link List} of {@link RifField}s representing the additional fields that\n-   *     need to be stored to the database via JPA\n-   * @throws MalformedURLException if there is an issue creating the field url\n-   */\n-  private static List<RifField> createDetailsForAdditionalDatabaseFields(\n-      List<String> additionalDatabaseFields) throws MalformedURLException {\n-    List<RifField> addlDatabaseFields = new ArrayList<RifField>();\n-\n-    for (String additionalDatabaseField : additionalDatabaseFields) {\n-      if (additionalDatabaseField.contentEquals(\"HICN_UNHASHED\")) {\n-        RifField hicnUnhashed =\n-            new RifField(\n-                \"HICN_UNHASHED\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"hicnUnhashed\"),\n-                \"HICN_UNHASHED\",\n-                \"hicnUnhashed\");\n-        addlDatabaseFields.add(hicnUnhashed);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"MBI_HASH\")) {\n-        RifField mbiHash =\n-            new RifField(\n-                \"MBI_HASH\",\n-                RifColumnType.CHAR,\n-                Optional.of(64),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"mbiHash\"),\n-                \"MBI_HASH\",\n-                \"mbiHash\");\n-        addlDatabaseFields.add(mbiHash);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"LAST_UPDATED\")) {\n-        RifField lastUpdated =\n-            new RifField(\n-                \"LAST_UPDATED\",\n-                RifColumnType.TIMESTAMP,\n-                Optional.of(20),\n-                Optional.of(0),\n-                Boolean.TRUE,\n-                new URL(DATA_DICTIONARY_LINK + \"lastUpdated\"),\n-                \"LAST_UPDATED\",\n-                \"lastUpdated\");\n-        addlDatabaseFields.add(lastUpdated);\n-        continue;\n-      }\n-      if (additionalDatabaseField.contentEquals(\"BENE_ID_NUMERIC\")) {\n-        RifField beneIdNumeric =\n-            new RifField(\n-                \"BENE_ID_NUMERIC\",\n-                RifColumnType.BIGINT,\n-                Optional.of(8),\n-                Optional.of(0),\n-                Boolean.FALSE,\n-                null,\n-                \"BENE_ID_NUMERIC\",\n-                \"beneficiaryIdNumeric\");\n-        addlDatabaseFields.add(beneIdNumeric);\n-        continue;\n-      }\n-    }\n-    return addlDatabaseFields;\n-  }\n-\n-  /**\n-   * Converts the specified string from snake case to camel case.\n-   *\n-   * @param fieldName the JPA entity field name to convert from snake case to camel case\n-   * @return the input string converted to camel case\n-   */\n-  public static String convertToCamelCase(String fieldName) {\n-    if (!fieldName.contains(\"_\")) {\n-      return fieldName;\n-    }\n-    // Capitalize first letter of string\n-    String camelCaseResult = fieldName.toLowerCase();\n-    camelCaseResult = camelCaseResult.substring(0, 1).toUpperCase() + camelCaseResult.substring(1);\n-\n-    // iterate over string looking for '_' (underscore)\n-    while (camelCaseResult.contains(\"_\")) {\n-      camelCaseResult =\n-          camelCaseResult.replaceFirst(\n-              \"_[a-z]\",\n-              String.valueOf(\n-                  Character.toUpperCase(camelCaseResult.charAt(camelCaseResult.indexOf(\"_\") + 1))));\n-    }\n-    return camelCaseResult;\n-  }\n-\n-  /**\n-   * Calculates the getter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired getter will\n-   *     wrap\n-   * @return the name of the Java \"getter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateGetterName(FieldSpec entityField) {\n-    String name = capitalize(convertToCamelCase(entityField.name));\n-\n-    return entityField.type.equals(TypeName.BOOLEAN)\n-            || entityField.type.equals(ClassName.get(Boolean.class))\n-        ? \"is\" + name\n-        : \"get\" + name;\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"getter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    addGetterStatement(rifField.isRifColumnOptional(), entityField, entityGetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified getter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"getter\"\n-   * @param entityGetter the \"getter\" method to generate the statement in\n-   */\n-  private static void addGetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entityGetter) {\n-    if (!optional) {\n-      entityGetter.addStatement(\"return $N\", entityField);\n-    } else {\n-      entityGetter.addStatement(\"return $T.ofNullable($N)\", Optional.class, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Calculates the setter name for the specified entity field.\n-   *\n-   * @param entityField the JPA entity {@link FieldSpec} for the field that the desired setter will\n-   *     wrap @Param overrideName allow flexibility in not using JPA entity name as the basis for\n-   *     setter\n-   * @return the name of the Java \"setter\" for the specified {@link FieldSpec}\n-   */\n-  private static String calculateSetterName(FieldSpec entityField) {\n-    return \"set\" + capitalize(convertToCamelCase(entityField.name));\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param rifField the {@link RifField} to generate the \"setter\" statement for\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      RifField rifField, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    addSetterStatement(rifField.isRifColumnOptional(), entityField, entitySetter);\n-  }\n-\n-  /**\n-   * Adds a statement to a specified setter method.\n-   *\n-   * @param optional <code>true</code> if the property is an {@link Optional} one, <code>false\n-   *     </code> otherwise\n-   * @param entityField the {@link FieldSpec} for the field being wrapped by the \"setter\"\n-   * @param entitySetter the \"setter\" method to generate the statement in\n-   */\n-  private static void addSetterStatement(\n-      boolean optional, FieldSpec entityField, MethodSpec.Builder entitySetter) {\n-    if (!optional) {\n-      entitySetter.addStatement(\"this.$N = $N\", entityField, entityField);\n-    } else {\n-      entitySetter.addStatement(\"this.$N = $N.orElse(null)\", entityField, entityField);\n-    }\n-  }\n-\n-  /**\n-   * Capitalizes the first letter of a string.\n-   *\n-   * @param name the {@link String} to capitalize the first letter of\n-   * @return a capitalized {@link String}\n-   */\n-  private static String capitalize(String name) {\n-    return String.format(\"%s%s\", Character.toUpperCase(name.charAt(0)), name.substring(1));\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(\n-      Diagnostic.Kind logEntryKind,\n-      Element associatedElement,\n-      String messageFormat,\n-      Object... messageArguments) {\n-    String logMessage = String.format(messageFormat, messageArguments);\n-    processingEnv.getMessager().printMessage(logEntryKind, logMessage, associatedElement);\n-\n-    String logMessageFull;\n-    if (associatedElement != null)\n-      logMessageFull =\n-          String.format(\"[%s] at '%s': %s\", logEntryKind, associatedElement, logMessage);\n-    else logMessageFull = String.format(\"[%s]: %s\", logEntryKind, logMessage);\n-    logMessages.add(logMessageFull);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param logEntryKind the {@link Diagnostic.Kind} of log entry to add\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void log(Diagnostic.Kind logEntryKind, String messageFormat, Object... messageArguments) {\n-    log(logEntryKind, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param associatedElement the Java AST {@link Element} that the log entry should be associated\n-   *     with, or <code>null</code>\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(\n-      Element associatedElement, String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, associatedElement, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Reports the specified log message.\n-   *\n-   * @param messageFormat the log message format {@link String}\n-   * @param messageArguments the log message format arguments\n-   */\n-  private void logNote(String messageFormat, Object... messageArguments) {\n-    log(Diagnostic.Kind.NOTE, null, messageFormat, messageArguments);\n-  }\n-\n-  /**\n-   * Writes out all of the messages in {@link #logMessages} to a log file in the\n-   * annotation-generated source directory.\n-   */\n-  private void writeDebugLogMessages() {\n-    if (!DEBUG) return;\n-\n-    try {\n-      FileObject logResource =\n-          processingEnv\n-              .getFiler()\n-              .createResource(StandardLocation.SOURCE_OUTPUT, \"\", \"rif-layout-processor-log.txt\");\n-      Writer logWriter = logResource.openWriter();\n-      for (String logMessage : logMessages) {\n-        logWriter.write(logMessage);\n-        logWriter.write('\\n');\n-      }\n-      logWriter.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly class in the model rif.\n-   *\n-   * @param lineEntity helps build the entity {@link TypeSpec.Builder}\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   */\n-  private static void createBeneficiaryMonthlyFields(\n-      TypeSpec.Builder lineEntity, boolean isId, RifField rifField) {\n-\n-    List<AnnotationSpec> annotSpecs = createBeneficiaryMonthlyAnnotations(isId, rifField);\n-    TypeName javaFieldType =\n-        selectJavaFieldType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    TypeName javaPropType =\n-        selectJavaPropertyType(\n-            rifField.getRifColumnType(), rifField.isRifColumnOptional(),\n-            rifField.getRifColumnLength(), rifField.getRifColumnScale());\n-    FieldSpec lineField =\n-        FieldSpec.builder(javaFieldType, rifField.getJavaFieldName(), Modifier.PRIVATE)\n-            .addAnnotations(annotSpecs)\n-            .build();\n-    lineEntity.addField(lineField);\n-\n-    MethodSpec.Builder lineFieldGetter =\n-        MethodSpec.methodBuilder(calculateGetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(javaPropType);\n-    addGetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldGetter);\n-    lineEntity.addMethod(lineFieldGetter.build());\n-\n-    MethodSpec.Builder lineFieldSetter =\n-        MethodSpec.methodBuilder(calculateSetterName(lineField))\n-            .addModifiers(Modifier.PUBLIC)\n-            .returns(void.class)\n-            .addParameter(javaPropType, lineField.name);\n-    addSetterStatement(rifField.isRifColumnOptional(), lineField, lineFieldSetter);\n-    lineEntity.addMethod(lineFieldSetter.build());\n-  }\n-\n-  /**\n-   * Creates the fields for the BeneficiaryMonthly annotations in the model rif.\n-   *\n-   * @param isId determines if the field is an id field\n-   * @param rifField {@link RifField} to create\n-   * @return the created annotation specs\n-   */\n-  private static List<AnnotationSpec> createBeneficiaryMonthlyAnnotations(\n-      boolean isId, RifField rifField) {\n-\n-    LinkedList<AnnotationSpec> annotations = new LinkedList<>();\n-    // Add an @Id annotation, if appropriate.\n-    if (isId) {\n-      AnnotationSpec.Builder idAnnotation = AnnotationSpec.builder(Id.class);\n-      annotations.add(idAnnotation.build());\n-    }\n-    // Add an @Column annotation to every column.\n-    AnnotationSpec.Builder columnAnnotation =\n-        AnnotationSpec.builder(Column.class)\n-            .addMember(\"name\", \"$S\", rifField.getRifColumnName().toLowerCase())\n-            .addMember(\"nullable\", \"$L\", rifField.isRifColumnOptional());\n-\n-    if (rifField.getRifColumnType() == RifColumnType.CHAR\n-        && rifField.getRifColumnLength().isPresent()) {\n-      columnAnnotation.addMember(\"length\", \"$L\", rifField.getRifColumnLength().get());\n-    } else if (rifField.getRifColumnType() == RifColumnType.NUM) {\n-      /*\n-       * In SQL, the precision is the number of digits in the unscaled value, e.g.\n-       * \"123.45\" has a precision of 5. The scale is the number of digits to the right\n-       * of the decimal point, e.g. \"123.45\" has a scale of 2.\n-       */\n-\n-      if (rifField.getRifColumnLength().isPresent()) {\n-        columnAnnotation.addMember(\"precision\", \"$L\", rifField.getRifColumnLength().get());\n-        columnAnnotation.addMember(\"scale\", \"$L\", rifField.getRifColumnScale().get());\n-      } else {\n-        /*\n-         * Unfortunately, Hibernate's SQL schema generation (HBM2DDL) doesn't correctly\n-         * handle SQL numeric datatypes that don't have a defined precision and scale.\n-         * What it _should_ do is represent those types in PostgreSQL as a \"NUMERIC\",\n-         * but what it does instead is insert a default precision and scale as\n-         * \"NUMBER(19, 2)\". The only way to force the correct behavior is to specify a\n-         * columnDefinition, so we do that. This leads to incorrect behavior with HSQL\n-         * (for different reasons), but fortunately that doesn't happen to cause\n-         * problems with our tests.\n-         */\n-        StringBuilder columnDefinition = new StringBuilder(\"numeric\");\n-        if (rifField.getRifColumnLength().isPresent()) {\n-          columnDefinition.append(\"(\").append(rifField.getRifColumnLength().get());\n-\n-          if (rifField.getRifColumnScale().isPresent()) {\n-            columnDefinition.append(\", \").append(rifField.getRifColumnScale().get());\n-          }\n-          columnDefinition.append(\")\");\n-        }\n-        columnAnnotation.addMember(\"columnDefinition\", \"$S\", columnDefinition.toString());\n-      }\n-    }\n-    annotations.add(columnAnnotation.build());\n-    return annotations;\n-  }\n-\n-  /**\n-   * Selects the java field type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return a Java poet {@link TypeName} that will be applied to the entity column; the use of the\n-   *     {@link boolean} isColumnOptional determines if the type can be a primitive (i.e., long) or\n-   *     in fact needs to be a Java class type (i.e., Long)\n-   */\n-  private static TypeName selectJavaFieldType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (type == RifColumnType.CHAR) {\n-      if (columnLength.orElse(Integer.MAX_VALUE) == 1) {\n-        return isColumnOptional ? ClassName.get(Character.class) : TypeName.CHAR;\n-      } else {\n-        return ClassName.get(String.class);\n-      }\n-    } else if (type == RifColumnType.DATE) {\n-      return ClassName.get(LocalDate.class);\n-    } else if (type == RifColumnType.TIMESTAMP) {\n-      return ClassName.get(Instant.class);\n-    }\n-    // handle an inherited hack from the Excel spreadsheet in which a row entry\n-    // was defined as a NUM and had an associated scale; for example (12,2) denotes\n-    // a numeric data types of up to 12 digits, with two digits of scale (i.e., 55.45).\n-    else if (type == RifColumnType.NUM && columnScale.orElse(Integer.MAX_VALUE) > 0) {\n-      return ClassName.get(BigDecimal.class);\n-    }\n-    // some entries in Excel spreadsheet defined as NUM with a zero scale that are\n-    // not optional should be defined as a primitive integer.\n-    //\n-    else if (type == RifColumnType.NUM\n-        && columnScale.orElse(Integer.MAX_VALUE) == 0\n-        && !isColumnOptional) {\n-      return TypeName.INT;\n-    } else if (type == RifColumnType.SMALLINT) {\n-      return isColumnOptional ? ClassName.get(Short.class) : TypeName.SHORT;\n-    } else if (type == RifColumnType.BIGINT) {\n-      return isColumnOptional ? ClassName.get(Long.class) : TypeName.LONG;\n-    } else if (type == RifColumnType.INTEGER || type == RifColumnType.NUM) {\n-      return isColumnOptional ? ClassName.get(Integer.class) : TypeName.INT;\n-    }\n-    throw new IllegalArgumentException(\"Unhandled field type: \" + type.name());\n-  }\n-\n-  /**\n-   * Selects the java property type.\n-   *\n-   * @param type specifies the field type {@link RifColumnType}\n-   * @param isColumnOptional determines if the field is optional {@link boolean}\n-   * @param columnLength specifies the column length {@link Optional} {@link Integer}, for numeric\n-   *     types this represents the total number of digits that can be stored\n-   * @param columnScale specifies the column scale {@link Optional} {@link Integer}, for numeric\n-   *     types this represents how many of the total digits (see `columnLength`) are to the right of\n-   *     the decimal point\n-   * @return the java field type\n-   */\n-  private static TypeName selectJavaPropertyType(\n-      RifColumnType type,\n-      boolean isColumnOptional,\n-      Optional<Integer> columnLength,\n-      Optional<Integer> columnScale) {\n-    if (!isColumnOptional)\n-      return selectJavaFieldType(type, isColumnOptional, columnLength, columnScale);\n-    else\n-      return ParameterizedTypeName.get(\n-          ClassName.get(Optional.class),\n-          selectJavaFieldType(type, isColumnOptional, columnLength, columnScale));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "bb3814d926641ecfe5b0063d522d050e97583e3e", "committedDate": "2021-06-21 18:03:54 -0400", "message": "BFD-826: Fix Patient Search by Part D Contract ID (#647)"}, {"oid": "660f0a8f7d78bab9bfcdf190b13142432e918d22", "committedDate": "2021-07-14 16:13:03 -0700", "message": "[BFD-878] Reduce Java Util Date Use (#693)"}, {"oid": "5d2bc515cf6fda01367daa4256bac36da574a657", "committedDate": "2021-07-20 10:41:27 -0700", "message": "Revert \"[BFD-878] Reduce Java Util Date Use (#693)\" (#709)"}, {"oid": "6a556739bbdbca3f5c5ec8a7e72359a4da966152", "committedDate": "2021-07-26 09:00:34 -0700", "message": "[BFD-878] Reduce Java Util Date Use W/ Bug Fix (#712)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "4e09f32f0ccd926ce30f38075e55aa493ba9393c", "committedDate": "2022-03-14 12:17:03 -0400", "message": "BFD-1535 - Use longs instead of strings for entity IDs (#984)"}, {"oid": "7dc37087eb841ef8320bad5252cbbf73175a5834", "committedDate": "2022-03-16 15:14:49 -0400", "message": "Revert \"BFD-1535 - Use longs instead of strings for entity IDs (#984)\" (#1013)"}, {"oid": "1c241de1d77904a325f71231702d063d0831343b", "committedDate": "2022-03-21 14:33:24 -0400", "message": "BFD-1535: Use longs instead of strings for entity IDs (#1015)"}, {"oid": "e155114227f50da33198b97845c8db8cfeb5661a", "committedDate": "2022-04-13 12:22:26 -0400", "message": "BFD-1671: Add checkstyle and javadoc style guide (#1052)"}, {"oid": "a2312b601ef0ebd8bf28b03c0c1ea7513f2d5480", "committedDate": "2022-04-18 13:46:34 -0400", "message": "BFD-1596: code change to work with new schema: snf_claims_new and snf_claim_lines_new (#1043)"}, {"oid": "b4c31c6a6680d269c4b0509b2462fe9af1107079", "committedDate": "2022-04-26 17:55:33 -0400", "message": "BFD-1704 Revert SNF Claims table pre-APR18 (#1078)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "b27b2c4125d24b09462dbfeba12e2bff0787d8ff", "committedDate": "2022-05-10 13:31:52 -0400", "message": "BFD-1744: migrate dme claims new schema (#1105)"}, {"oid": "4dc348f7a17c92c7b9b6ee6c3732655493ea0a52", "committedDate": "2022-05-11 14:45:29 -0400", "message": "BFD-1745 code changes for dme claims new schema (#1110)"}, {"oid": "9b49194712ac64353a78e75ba8bcaa4af884f4ef", "committedDate": "2022-05-18 12:18:26 -0400", "message": "code changes for Hospice claims, new schema tables (#1120)"}, {"oid": "e70c0189f4cfb2eb28230ee1fa82c97d73067269", "committedDate": "2022-05-19 11:11:29 -0400", "message": "code changes for HHA claims, new schema (#1126)"}, {"oid": "6e34cd367e8b3d9d15234f2badc0a46c13615311", "committedDate": "2022-05-26 11:06:44 -0400", "message": "BFD-1681 - code changes to support new carrier claims tables (#1133)"}, {"oid": "008a35713f66b0971bb9dad759bc29dcb7db2b31", "committedDate": "2022-06-01 13:14:01 -0400", "message": "BFD-1694 - code changes to match new INPATIENT claims tables (#1141)"}, {"oid": "6bb308a6b8f9b94092ac63d36b2936f8901827f1", "committedDate": "2022-06-07 08:18:13 -0400", "message": "BFD-1805: code changes for OUTPATIENTS new schema (#1151)"}, {"oid": "373bee9729f83dd8cd17dee70580ab02e6518350", "committedDate": "2022-06-08 09:57:37 -0400", "message": "BFD-1808: code changes for modified PartD Events table (#1139)"}, {"oid": "b5aa318d4e526b7ad475817a8d9a62659f71fcb9", "committedDate": "2022-07-05 15:13:57 -0400", "message": "BFD-1876: New schema beneficiary related table migration and code (#1183)"}, {"oid": "795c223d56d90eba26b3ebbed05fce9af8ba5a2d", "committedDate": "2022-07-13 11:53:23 -0400", "message": "bfd services using db views (#1215)"}, {"oid": "9b96e7390ca294f68f879831b1d877ebbdc84f03", "committedDate": "2023-02-14 09:29:29 -0500", "message": "PACA-656: Use DSL to generate all RIF entities (Part 1/2) (#1546)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNTcxOA==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549815718", "body": "What is this assertion doing?", "bodyText": "What is this assertion doing?", "bodyHTML": "<p dir=\"auto\">What is this assertion doing?</p>", "author": "karlmdavis", "createdAt": "2020-12-29T19:06:59Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java", "diffHunk": "@@ -532,6 +685,7 @@ private void loadSample(DataSource dataSource, List<StaticRifResource> sampleRes\n           rifFileRecords,\n           error -> {\n             failureCount.incrementAndGet();\n+            Assert.assertEquals(\"\", error.getMessage());", "originalCommit": "ccf6dbc202b796476de5e622f717f034d66c1711", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MTE5MQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549881191", "bodyText": "Crap forgot to remove this..", "author": "cbrunefearless", "createdAt": "2020-12-29T23:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNTcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 6bc672cc9..a9cf0613b 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -685,7 +685,6 @@ public final class RifLoaderIT {\n           rifFileRecords,\n           error -> {\n             failureCount.incrementAndGet();\n-            Assert.assertEquals(\"\", error.getMessage());\n             LOGGER.warn(\"Record(s) failed to load.\", error);\n           },\n           result -> {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 6bc672cc9..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -685,7 +712,6 @@ public final class RifLoaderIT {\n           rifFileRecords,\n           error -> {\n             failureCount.incrementAndGet();\n-            Assert.assertEquals(\"\", error.getMessage());\n             LOGGER.warn(\"Record(s) failed to load.\", error);\n           },\n           result -> {\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNjA2MQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549816061", "body": "Great! Glad this passes, too!", "bodyText": "Great! Glad this passes, too!", "bodyHTML": "<p dir=\"auto\">Great! Glad this passes, too!</p>", "author": "karlmdavis", "createdAt": "2020-12-29T19:08:12Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java", "diffHunk": "@@ -316,6 +317,158 @@ public void loadSampleUUnchanged() {\n       if (entityManager != null) entityManager.close();\n     }\n   }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount12() {\n+    DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+\n+    LoadAppOptions options = RifLoaderTestUtils.getLoadOptions(dataSource);\n+    EntityManagerFactory entityManagerFactory =\n+        RifLoaderTestUtils.createEntityManagerFactory(options);\n+    EntityManager entityManager = null;\n+    try {\n+      entityManager = entityManagerFactory.createEntityManager();\n+      Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      Assert.assertEquals(12, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n+      assertBeneficiaryMonthly(beneficiaryFromDb);\n+\n+    } finally {\n+      if (entityManager != null) entityManager.close();\n+    }\n+  }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount24() {\n+    DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+\n+    LoadAppOptions options = RifLoaderTestUtils.getLoadOptions(dataSource);\n+    EntityManagerFactory entityManagerFactory =\n+        RifLoaderTestUtils.createEntityManagerFactory(options);\n+    EntityManager entityManager = null;\n+    try {\n+      entityManager = entityManagerFactory.createEntityManager();\n+\n+      Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      Assert.assertEquals(24, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n+    } finally {\n+      if (entityManager != null) entityManager.close();\n+    }\n+  }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount20SinceThereIsAUpdateOf8Months() {\n+    DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n+    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+    loadSample(\n+        dataSource,\n+        Arrays.asList(StaticRifResourceGroup.SAMPLE_U_BENES_CHANGED_WITH_8_MONTHS.getResources()));\n+\n+    LoadAppOptions options = RifLoaderTestUtils.getLoadOptions(dataSource);\n+    EntityManagerFactory entityManagerFactory =\n+        RifLoaderTestUtils.createEntityManagerFactory(options);\n+    EntityManager entityManager = null;\n+    try {\n+      entityManager = entityManagerFactory.createEntityManager();\n+\n+      Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      Assert.assertEquals(20, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n+    } finally {\n+      if (entityManager != null) entityManager.close();\n+    }\n+  }\n+\n+  @Test\n+  public void loadInitialEnrollmentShouldCount21SinceThereIsAUpdateOf8MonthsAndAUpdateOf9Months() {", "originalCommit": "ccf6dbc202b796476de5e622f717f034d66c1711", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d902e4d41a060ab4b5a11d24450924773e7607e8", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 6bc672cc9..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -375,17 +396,23 @@ public final class RifLoaderIT {\n       entityManager = entityManagerFactory.createEntityManager();\n \n       Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      // Checks to make sure we only have 20 months of data\n       Assert.assertEquals(20, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n     } finally {\n       if (entityManager != null) entityManager.close();\n     }\n   }\n \n+  /*\n+   * This test checks that all enrollment data for month july in its 2 year is updated when there is data\n+   * for august that comes in.\n+   */\n   @Test\n   public void loadInitialEnrollmentShouldCount21SinceThereIsAUpdateOf8MonthsAndAUpdateOf9Months() {\n     DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    // Load first year of data\n     loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n-    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+    // Load 8 months of data in year two\n     loadSample(\n         dataSource,\n         Arrays.asList(StaticRifResourceGroup.SAMPLE_U_BENES_CHANGED_WITH_8_MONTHS.getResources()));\n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\nindex 6bc672cc9..0489efd00 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/test/java/gov/cms/bfd/pipeline/rif/load/RifLoaderIT.java\n", "chunk": "@@ -375,17 +396,23 @@ public final class RifLoaderIT {\n       entityManager = entityManagerFactory.createEntityManager();\n \n       Beneficiary beneficiaryFromDb = entityManager.find(Beneficiary.class, \"567834\");\n+      // Checks to make sure we only have 20 months of data\n       Assert.assertEquals(20, beneficiaryFromDb.getBeneficiaryMonthlys().size());\n     } finally {\n       if (entityManager != null) entityManager.close();\n     }\n   }\n \n+  /*\n+   * This test checks that all enrollment data for month july in its 2 year is updated when there is data\n+   * for august that comes in.\n+   */\n   @Test\n   public void loadInitialEnrollmentShouldCount21SinceThereIsAUpdateOf8MonthsAndAUpdateOf9Months() {\n     DataSource dataSource = DatabaseTestHelper.getTestDatabaseAfterClean();\n+    // Load first year of data\n     loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_A.getResources()));\n-    loadSample(dataSource, Arrays.asList(StaticRifResourceGroup.SAMPLE_U.getResources()));\n+    // Load 8 months of data in year two\n     loadSample(\n         dataSource,\n         Arrays.asList(StaticRifResourceGroup.SAMPLE_U_BENES_CHANGED_WITH_8_MONTHS.getResources()));\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"oid": "3345d93b28ff70dd1c1ed6820c0910941724115e", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/3345d93b28ff70dd1c1ed6820c0910941724115e", "message": "Merge branch 'master' into cbrune/BFD549-enrollmentdata", "committedDate": "2020-12-29T22:28:10Z", "type": "commit"}, {"oid": "148d2587022acbf516a4a2ff5e98cbbd7c70ebe2", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/148d2587022acbf516a4a2ff5e98cbbd7c70ebe2", "message": "Update apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n\nCo-authored-by: Karl M. Davis <karl@justdavis.com>", "committedDate": "2020-12-29T23:01:22Z", "type": "commit"}, {"oid": "61956e52e5c6f21c5f0c0e46b45676c25302cde4", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/61956e52e5c6f21c5f0c0e46b45676c25302cde4", "message": "Update apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n\nCo-authored-by: Karl M. Davis <karl@justdavis.com>", "committedDate": "2020-12-29T23:01:41Z", "type": "commit"}, {"oid": "176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/176aefd628e91b5b7352c6a4ba6cb784a8ef97b1", "message": "Pr changes", "committedDate": "2020-12-29T23:07:10Z", "type": "commit"}, {"oid": "52561a672c4494913b48b46416bae9d5da353181", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/52561a672c4494913b48b46416bae9d5da353181", "message": "Pr changes", "committedDate": "2020-12-29T23:08:34Z", "type": "commit"}, {"oid": "dbf04f2800fa05f62631402ff7e532b8d6b39d29", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/dbf04f2800fa05f62631402ff7e532b8d6b39d29", "message": "Pr changes", "committedDate": "2020-12-29T23:09:03Z", "type": "commit"}, {"oid": "49ad5b80ad13a006c340af8d9632c054d4178e23", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/49ad5b80ad13a006c340af8d9632c054d4178e23", "message": "Update apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n\nCo-authored-by: Karl M. Davis <karl@justdavis.com>", "committedDate": "2020-12-29T23:35:13Z", "type": "commit"}, {"oid": "d8391763a4991ec98894f3e40d6f39884b4235f5", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/d8391763a4991ec98894f3e40d6f39884b4235f5", "message": ".sql file formatting", "committedDate": "2020-12-29T23:37:59Z", "type": "commit"}, {"oid": "0db992f302646824a41c835342a05e971e1bc151", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/0db992f302646824a41c835342a05e971e1bc151", "message": ".sql file formatting", "committedDate": "2020-12-29T23:40:20Z", "type": "commit"}, {"oid": "e61466a6a2fb5c675f77be1bad5c49c70822ed31", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/e61466a6a2fb5c675f77be1bad5c49c70822ed31", "message": "Sql formatted", "committedDate": "2020-12-29T23:44:01Z", "type": "commit"}, {"oid": "8cd87a7a088d4f9fb1d09e0905505b3aec049a1c", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/8cd87a7a088d4f9fb1d09e0905505b3aec049a1c", "message": "Update apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/RifLayoutsProcessor.java\n\nCo-authored-by: Karl M. Davis <karl@justdavis.com>", "committedDate": "2020-12-29T23:45:35Z", "type": "commit"}, {"oid": "2ea161ee2f878348bec572954d9221e7917d294e", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/2ea161ee2f878348bec572954d9221e7917d294e", "message": "Ran mvn format", "committedDate": "2020-12-30T03:20:53Z", "type": "commit"}, {"oid": "d902e4d41a060ab4b5a11d24450924773e7607e8", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/d902e4d41a060ab4b5a11d24450924773e7607e8", "message": "Added comments to rifloaderit test", "committedDate": "2020-12-30T18:58:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg4MzU3Mg==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r549883572", "body": "```suggestion\r\n  /** @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly()} */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** @param hasLines the new value for {@link #setHasBeneficiaryMonthly()} */\n          \n          \n            \n              /** @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly()} */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">  <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @param <span class=\"x x-first x-last\">hasLines</span> the new value for {@link #setHasBeneficiaryMonthly()} <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">  <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @param <span class=\"x x-first x-last\">hasBeneficiaryMonthly</span> the new value for {@link #setHasBeneficiaryMonthly()} <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "jzulim", "createdAt": "2020-12-29T23:14:18Z", "path": "apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java", "diffHunk": "@@ -158,6 +159,20 @@ public MappingSpec setHasLines(boolean hasLines) {\n     return this;\n   }\n \n+  /**\n+   * @return <code>true</code> if the RIF layout has child line fields that should be stored\n+   *     separately from its parent header fields, <code>false</code> if not\n+   */\n+  public boolean getHasBeneficiaryMonthly() {\n+    return hasBeneficiaryMonthly;\n+  }\n+\n+  /** @param hasLines the new value for {@link #setHasBeneficiaryMonthly()} */", "originalCommit": "dbf04f2800fa05f62631402ff7e532b8d6b39d29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fb9fb76d1d69b3dca512700dc0465dc287276e2", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex bd22ffc67..bf706da1a 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -167,7 +167,7 @@ public final class MappingSpec {\n     return hasBeneficiaryMonthly;\n   }\n \n-  /** @param hasLines the new value for {@link #setHasBeneficiaryMonthly()} */\n+  /** @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly()} */\n   public MappingSpec setHasBeneficiaryMonthly(boolean hasBeneficiaryMonthly) {\n     this.hasBeneficiaryMonthly = hasBeneficiaryMonthly;\n     return this;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex bd22ffc67..bf706da1a 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -167,7 +167,7 @@ public final class MappingSpec {\n     return hasBeneficiaryMonthly;\n   }\n \n-  /** @param hasLines the new value for {@link #setHasBeneficiaryMonthly()} */\n+  /** @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly()} */\n   public MappingSpec setHasBeneficiaryMonthly(boolean hasBeneficiaryMonthly) {\n     this.hasBeneficiaryMonthly = hasBeneficiaryMonthly;\n     return this;\n", "next_change": {"commit": "20caedd65963b799db11e56142081af2279daf75", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex bf706da1a..7c351c7b4 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -167,7 +176,10 @@ public final class MappingSpec {\n     return hasBeneficiaryMonthly;\n   }\n \n-  /** @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly()} */\n+  /**\n+   * @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly(boolean)}\n+   * @return the {@link MappingSpec} whose hasBeneficiaryMonthly will be set\n+   */\n   public MappingSpec setHasBeneficiaryMonthly(boolean hasBeneficiaryMonthly) {\n     this.hasBeneficiaryMonthly = hasBeneficiaryMonthly;\n     return this;\n", "next_change": {"commit": "28cfe6ac219cb819818e78a10c46e9464754bf39", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 7c351c7b4..1411bd1c1 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -169,19 +181,19 @@ public final class MappingSpec {\n   }\n \n   /**\n-   * @return <code>true</code> if the RIF layout has child line fields that should be stored\n-   *     separately from its parent header fields, <code>false</code> if not\n+   * @return <code>true</code> if the RIF layout is for the <code>Beneficiary</code> entity, <code>\n+   *     false</code> if it's not\n    */\n-  public boolean getHasBeneficiaryMonthly() {\n-    return hasBeneficiaryMonthly;\n+  public boolean isBeneficiaryEntity() {\n+    return isBeneficiaryEntity;\n   }\n \n   /**\n-   * @param hasBeneficiaryMonthly the new value for {@link #setHasBeneficiaryMonthly(boolean)}\n-   * @return the {@link MappingSpec} whose hasBeneficiaryMonthly will be set\n+   * @param isBeneficiaryEntity the new value for {@link #isBeneficiaryEntity()}\n+   * @return this {@link MappingSpec}, for call chaining purposes\n    */\n-  public MappingSpec setHasBeneficiaryMonthly(boolean hasBeneficiaryMonthly) {\n-    this.hasBeneficiaryMonthly = hasBeneficiaryMonthly;\n+  public MappingSpec setIsBeneficiaryEntity(boolean isBeneficiaryEntity) {\n+    this.isBeneficiaryEntity = isBeneficiaryEntity;\n     return this;\n   }\n \n", "next_change": {"commit": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\nindex 1411bd1c1..941015d5f 100644\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n", "chunk": "@@ -197,12 +262,20 @@ public final class MappingSpec {\n     return this;\n   }\n \n-  /** @return the index of the last header field in {@link #getRifLayout()} */\n+  /**\n+   * Calculates the index of the last header field in {@link #getRifLayout()}.\n+   *\n+   * @return the index of the last header field\n+   */\n   public int calculateLastHeaderFieldIndex() {\n     return hasLines ? (calculateFirstLineFieldIndex() - 1) : (rifLayout.getRifFields().size() - 1);\n   }\n \n-  /** @return the index of the first line field in {@link #getRifLayout()} */\n+  /**\n+   * Calculate the index of the first line field in {@link #getRifLayout()}.\n+   *\n+   * @return the index of the first line field\n+   */\n   public int calculateFirstLineFieldIndex() {\n     if (!hasLines) throw new IllegalStateException();\n \n", "next_change": {"commit": "906a51708f91524da0f21a88fb27b26afdec6984", "changed_code": [{"header": "diff --git a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java b/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\ndeleted file mode 100644\nindex 941015d5f..000000000\n--- a/apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n+++ /dev/null\n", "chunk": "@@ -1,556 +0,0 @@\n-package gov.cms.bfd.model.codegen;\n-\n-import com.squareup.javapoet.ClassName;\n-import gov.cms.bfd.model.codegen.RifLayout.RifField;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import javax.persistence.Entity;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.Id;\n-import javax.persistence.IdClass;\n-import javax.persistence.Transient;\n-\n-/**\n- * Encapsulates the information that must be known upfront to drive a mapping from a {@link\n- * RifLayout} to Java code.\n- *\n- * <p>Each {@link RifLayout} will be mapped to either 1 or 2 JPA {@link Entity} classes: only 1 if\n- * the record type doesn't have separate header vs. line fields, and exactly 2 if it does (one\n- * {@link Entity} for the header fields and a second child {@link Entity} for the line fields).\n- */\n-public final class MappingSpec {\n-  /*\n-   * Design Note: This class' fields are mutable to allow for the more\n-   * readable chained-setter style of construction.\n-   */\n-\n-  /** The name of the Java package that the mapping is occurring for and in. */\n-  private String packageName;\n-  /** The {@link RifLayout} whose fields will be mapped. */\n-  private RifLayout rifLayout;\n-  /** The claim entity being mapped. */\n-  private String headerEntity;\n-  /** The name of the SQL table that the {@link #getHeaderEntity()} instances will be stored in. */\n-  private String headerTable;\n-  /**\n-   * The name of the {@link Entity} field that should be used as the {@link Id} in the {@link\n-   * #getHeaderEntity()} {@link Entity}.\n-   */\n-  private String headerEntityIdField;\n-  /**\n-   * The name of the {@link Entity} {@link GeneratedValue} field that should be used as the {@link\n-   * Id} in the {@link #getHeaderEntity()} {@link Entity}.\n-   */\n-  private String headerEntityGeneratedIdField;\n-  /**\n-   * If the RIF layout has child line fields that should be stored separately from its parent header\n-   * fields.\n-   */\n-  private boolean hasLines = false;\n-  /** If the RIF layout is for a Beneficiary entity. */\n-  private boolean isBeneficiaryEntity = false;\n-  /**\n-   * The name of the SQL table that the {@link #getLineEntity()} instances will be stored in, if\n-   * any.\n-   */\n-  private String lineTable;\n-  /**\n-   * The name of the field in the {@link #getLineEntity()} {@link Entity} that should be used for\n-   * the identifying line number, if any.\n-   */\n-  private String lineEntityLineNumberField;\n-  /** The db sequence number generator name. */\n-  private String sequenceNumberGeneratorName;\n-  /** The fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}. */\n-  private List<String> headerEntityTransientFields;\n-  /** The additional database fields for the {@link #getHeaderEntity()}. */\n-  private List<RifField> headerEntityAdditionalDatabaseFields;\n-  /** A list of {@link String} parameters defining the inner join relationship for the entity. */\n-  private List<InnerJoinRelationship> innerJoinRelationship;\n-\n-  /**\n-   * Constructs a new {@link MappingSpec} instance.\n-   *\n-   * @param packageName the value to use for {@link #getPackageName()}\n-   */\n-  public MappingSpec(String packageName) {\n-    Objects.requireNonNull(packageName);\n-    this.packageName = packageName;\n-    this.headerEntityTransientFields = new ArrayList<>();\n-    this.headerEntityAdditionalDatabaseFields = new ArrayList<RifField>();\n-    this.innerJoinRelationship = new ArrayList<InnerJoinRelationship>();\n-  }\n-\n-  /**\n-   * Gets the {@link #packageName}.\n-   *\n-   * @return the name of the Java package that the mapping is occurring for and in\n-   */\n-  public String getPackageName() {\n-    return packageName;\n-  }\n-\n-  /**\n-   * Gets the {@link #rifLayout}.\n-   *\n-   * @return the {@link RifLayout} whose fields will be mapped\n-   */\n-  public RifLayout getRifLayout() {\n-    return rifLayout;\n-  }\n-\n-  /**\n-   * Sets the {@link #rifLayout}.\n-   *\n-   * @param rifLayout the new value for {@link #getRifLayout()}\n-   * @return the {@link MappingSpec} whose rifLayout is set\n-   */\n-  public MappingSpec setRifLayout(RifLayout rifLayout) {\n-    this.rifLayout = rifLayout;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the ClassName of the Java {@link Enum} that all the RIF field definitions will be placed\n-   * in.\n-   *\n-   * @return the classname of the enum\n-   */\n-  public ClassName getColumnEnum() {\n-    return ClassName.get(packageName, headerEntity + \"Column\");\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} of the JPA {@link Entity} class that will be used to store data from\n-   * this RIF layout for the header fields.\n-   *\n-   * @return the classname of the entity\n-   */\n-  public ClassName getHeaderEntity() {\n-    return ClassName.get(packageName, headerEntity);\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntity}.\n-   *\n-   * @param headerEntity the new value for {@link #getHeaderEntity()}\n-   * @return the {@link MappingSpec} whose headerEntity is set\n-   */\n-  public MappingSpec setHeaderEntity(String headerEntity) {\n-    this.headerEntity = headerEntity;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerTable}.\n-   *\n-   * @return the name of the SQL table that the {@link #getHeaderEntity()} instances will be stored\n-   *     in\n-   */\n-  public String getHeaderTable() {\n-    return headerTable;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerTable}.\n-   *\n-   * @param headerTable the new value for {@link #getHeaderTable()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderTable(String headerTable) {\n-    this.headerTable = headerTable;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityIdField}.\n-   *\n-   * @return the name of the {@link Entity} field that should be used as the {@link Id} in the\n-   *     {@link #getHeaderEntity()} {@link Entity}\n-   */\n-  public String getHeaderEntityIdField() {\n-    return headerEntityIdField;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityIdField}.\n-   *\n-   * @param headerEntityIdField the new value for {@link #getHeaderEntityIdField()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityIdField(String headerEntityIdField) {\n-    this.headerEntityIdField = headerEntityIdField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityGeneratedIdField}.\n-   *\n-   * @return the name of the {@link Entity} {@link GeneratedValue} field that should be used as the\n-   *     {@link Id} in the {@link #getHeaderEntity()} {@link Entity}\n-   */\n-  public String getHeaderEntityGeneratedIdField() {\n-    return headerEntityGeneratedIdField;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityGeneratedIdField}.\n-   *\n-   * @param headerEntityGeneratedIdField the new value for {@link\n-   *     #getHeaderEntityGeneratedIdField()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityGeneratedIdField(String headerEntityGeneratedIdField) {\n-    this.headerEntityGeneratedIdField = headerEntityGeneratedIdField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link #getHeaderEntity()} {@link Entity} that should be used\n-   * to store and refer to the child {@link #getLineEntity()} {@link Entity}s.\n-   *\n-   * @return the name of the field for line entities\n-   */\n-  public String getHeaderEntityLinesField() {\n-    if (!hasLines) {\n-      throw new IllegalStateException();\n-    }\n-    return \"lines\";\n-  }\n-\n-  /**\n-   * Determines if {@link #hasLines}.\n-   *\n-   * @return <code>true</code> if the RIF layout has child line fields that should be stored\n-   *     separately from its parent header fields, <code>false</code> if not\n-   */\n-  public boolean getHasLines() {\n-    return hasLines;\n-  }\n-\n-  /**\n-   * Sets {@link #hasLines}.\n-   *\n-   * @param hasLines the new value for {@link #getHasLines()}\n-   * @return the {@link MappingSpec} whose hasLines is set\n-   */\n-  public MappingSpec setHasLines(boolean hasLines) {\n-    this.hasLines = hasLines;\n-    return this;\n-  }\n-\n-  /**\n-   * Determines if {@link #isBeneficiaryEntity}.\n-   *\n-   * @return <code>true</code> if the RIF layout is for the <code>Beneficiary</code> entity, <code>\n-   *     false</code> if it's not\n-   */\n-  public boolean isBeneficiaryEntity() {\n-    return isBeneficiaryEntity;\n-  }\n-\n-  /**\n-   * Sets {@link #isBeneficiaryEntity}.\n-   *\n-   * @param isBeneficiaryEntity the new value for {@link #isBeneficiaryEntity()}\n-   * @return this {@link MappingSpec}, for call chaining purposes\n-   */\n-  public MappingSpec setIsBeneficiaryEntity(boolean isBeneficiaryEntity) {\n-    this.isBeneficiaryEntity = isBeneficiaryEntity;\n-    return this;\n-  }\n-\n-  /**\n-   * Calculates the index of the last header field in {@link #getRifLayout()}.\n-   *\n-   * @return the index of the last header field\n-   */\n-  public int calculateLastHeaderFieldIndex() {\n-    return hasLines ? (calculateFirstLineFieldIndex() - 1) : (rifLayout.getRifFields().size() - 1);\n-  }\n-\n-  /**\n-   * Calculate the index of the first line field in {@link #getRifLayout()}.\n-   *\n-   * @return the index of the first line field\n-   */\n-  public int calculateFirstLineFieldIndex() {\n-    if (!hasLines) throw new IllegalStateException();\n-\n-    for (int fieldIndex = 0; fieldIndex < rifLayout.getRifFields().size(); fieldIndex++) {\n-      RifField field = rifLayout.getRifFields().get(fieldIndex);\n-      if (field.getRifColumnName().equalsIgnoreCase(getLineEntityLineNumberField())) {\n-        return fieldIndex;\n-      }\n-    }\n-\n-    throw new IllegalStateException();\n-  }\n-\n-  /**\n-   * Gets the name of the JPA {@link Entity} class that will be used to store data from this RIF\n-   * layout for the line fields, if any.\n-   *\n-   * @return the name of the JPA {@link Entity} class, if any\n-   */\n-  public ClassName getLineEntity() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return ClassName.get(packageName, headerEntity + \"Line\");\n-  }\n-\n-  /**\n-   * Gets the name of the JPA {@link Entity} class that will be used to store data from this RIF\n-   * layout for the line fields, if any.\n-   *\n-   * @return the name of the JPA {@link Entity} class, if any\n-   */\n-  public ClassName getBeneficiaryMonthlyEntity() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return ClassName.get(packageName, \"BeneficiaryMonthly\");\n-  }\n-\n-  /**\n-   * Gets the {@link #lineTable}.\n-   *\n-   * @return the name of the SQL table that the {@link #getLineEntity()} instances will be stored\n-   *     in, if any\n-   */\n-  public String getLineTable() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return lineTable;\n-  }\n-\n-  /**\n-   * Sets the {@link #lineTable}.\n-   *\n-   * @param lineTable the new value for {@link #getLineTable()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setLineTable(String lineTable) {\n-    if (!hasLines) throw new IllegalStateException();\n-    this.lineTable = lineTable;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the ClassName of the JPA {@link IdClass} for the {@link #getLineEntity()} {@link Entity}.\n-   *\n-   * @return the line entity id class name\n-   */\n-  public ClassName getLineEntityIdClass() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return getLineEntity().nestedClass(\"LineId\");\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link #getLineEntity()} {@link Entity} that should be used\n-   * to store and refer to the child {@link #getLineEntity()} {@link Entity}s.\n-   *\n-   * @return the name of the line entity parent field\n-   */\n-  public String getLineEntityParentField() {\n-    if (!hasLines) throw new IllegalStateException();\n-    return \"parentClaim\";\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link Entity} that should be used to store and refer to the\n-   * parentBeneficiary {@link Entity}s.\n-   *\n-   * @return the beneficiary monthly entity parent field\n-   */\n-  public String getBeneficiaryMonthlyEntityParentField() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return \"parentBeneficiary\";\n-  }\n-\n-  /**\n-   * Sets the {@link #lineEntityLineNumberField}.\n-   *\n-   * @param lineEntityLineNumberField the name of the field in the {@link #getLineEntity()} {@link\n-   *     Entity} that should be used for the identifying line number\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setLineEntityLineNumberField(String lineEntityLineNumberField) {\n-    if (!hasLines) throw new IllegalStateException();\n-    this.lineEntityLineNumberField = lineEntityLineNumberField;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #lineEntityLineNumberField}.\n-   *\n-   * @return the name of the field in the {@link #getLineEntity()} {@link Entity} that should be\n-   *     used for the identifying line number, if any\n-   */\n-  public String getLineEntityLineNumberField() {\n-    // use Java field name since there is no uniformity among column names for line #\n-    if (!hasLines) throw new IllegalStateException();\n-    return lineEntityLineNumberField;\n-  }\n-\n-  /**\n-   * Gets the name of the field in the {@link Entity} that should be used for the identifying\n-   * yearMonth.\n-   *\n-   * @return the beneficiary monthly entity field\n-   */\n-  public String getEntityBeneficiaryMonthlyField() {\n-    if (!isBeneficiaryEntity) throw new IllegalStateException();\n-    return \"YEAR_MONTH\";\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityTransientFields}.\n-   *\n-   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n-   */\n-  public List<String> getHeaderEntityTransientFields() {\n-    return headerEntityTransientFields;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityTransientFields}.\n-   *\n-   * @param headerEntityTransientFields the new value for {@link #getHeaderEntityTransientFields()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityTransientFields(String... headerEntityTransientFields) {\n-    Objects.requireNonNull(headerEntityTransientFields);\n-    this.headerEntityTransientFields = Arrays.asList(headerEntityTransientFields);\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #headerEntityAdditionalDatabaseFields}.\n-   *\n-   * @return the fields in {@link #getHeaderEntity()} that should be marked as {@link Transient}\n-   */\n-  public List<RifField> getHeaderEntityAdditionalDatabaseFields() {\n-    return headerEntityAdditionalDatabaseFields;\n-  }\n-\n-  /**\n-   * Sets the {@link #headerEntityAdditionalDatabaseFields}.\n-   *\n-   * @param headerEntityAdditionalDatabaseFields the new value for {@link\n-   *     #getHeaderEntityAdditionalDatabaseFields()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setHeaderEntityAdditionalDatabaseFields(\n-      List<RifField> headerEntityAdditionalDatabaseFields) {\n-    Objects.requireNonNull(headerEntityAdditionalDatabaseFields);\n-    this.headerEntityAdditionalDatabaseFields = headerEntityAdditionalDatabaseFields;\n-    return this;\n-  }\n-\n-  /**\n-   * Sets the {@link #sequenceNumberGeneratorName}.\n-   *\n-   * @param sequenceNumberGeneratorName the db sequence number generator name {@link\n-   *     #getSequenceNumberGeneratorName()}\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setSequenceNumberGeneratorName(String sequenceNumberGeneratorName) {\n-    this.sequenceNumberGeneratorName = sequenceNumberGeneratorName;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #sequenceNumberGeneratorName}.\n-   *\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public String getSequenceNumberGeneratorName() {\n-    return sequenceNumberGeneratorName;\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} for the class to be built that will contain parsing code for the\n-   * layout.\n-   *\n-   * @return the class name for the parser\n-   */\n-  public ClassName getParserClass() {\n-    return ClassName.get(packageName, headerEntity + \"Parser\");\n-  }\n-\n-  /**\n-   * Gets the {@link ClassName} for the class to be built that will contain CSV writing for the\n-   * layout.\n-   *\n-   * @return the csv writer class name\n-   */\n-  public ClassName getCsvWriterClass() {\n-    return ClassName.get(packageName, headerEntity + \"CsvWriter\");\n-  }\n-\n-  /** {@inheritDoc} */\n-  @Override\n-  public String toString() {\n-    StringBuilder builder = new StringBuilder();\n-    builder.append(\"MappingSpec [packageName=\");\n-    builder.append(packageName);\n-    builder.append(\", rifLayout=\");\n-    builder.append(rifLayout);\n-    builder.append(\", headerEntity=\");\n-    builder.append(headerEntity);\n-    builder.append(\", headerTable=\");\n-    builder.append(headerTable);\n-    builder.append(\", headerEntityIdField=\");\n-    builder.append(headerEntityIdField);\n-    builder.append(\", hasLines=\");\n-    builder.append(hasLines);\n-    builder.append(\", lineTable=\");\n-    builder.append(lineTable);\n-    if (hasLines) {\n-      builder.append(\", lineEntityLineNumber=\");\n-      builder.append(lineEntityLineNumberField);\n-    }\n-    builder.append(\"]\");\n-    return builder.toString();\n-  }\n-\n-  /**\n-   * Determines if there are any {@link #innerJoinRelationship}s.\n-   *\n-   * @return <code>true</code> if the RIF layout has an inner join relationship <code>false</code>\n-   *     if not\n-   */\n-  public Boolean getHasInnerJoinRelationship() {\n-    return this.innerJoinRelationship.size() != 0;\n-  }\n-\n-  /**\n-   * Sets the {@link #innerJoinRelationship}.\n-   *\n-   * @param innerJoinRelationship a list of {@link String} parameters defining the inner join\n-   *     relationship for the entity\n-   * @return this {@link MappingSpec} instance, for call-chaining purposes\n-   */\n-  public MappingSpec setInnerJoinRelationship(List<InnerJoinRelationship> innerJoinRelationship) {\n-    this.innerJoinRelationship = innerJoinRelationship;\n-    return this;\n-  }\n-\n-  /**\n-   * Gets the {@link #innerJoinRelationship}.\n-   *\n-   * @return the list of {@link #innerJoinRelationship}s\n-   */\n-  public List<InnerJoinRelationship> getInnerJoinRelationship() {\n-    return this.innerJoinRelationship;\n-  }\n-\n-  /**\n-   * Gets the class name for the specified entity name.\n-   *\n-   * @param entity the {@link String} entity for which to return the {@link ClassName} for\n-   * @return the {@link ClassName} of the provided {@link String} entity\n-   */\n-  public ClassName getClassName(String entity) {\n-    return ClassName.get(packageName, entity);\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "20caedd65963b799db11e56142081af2279daf75", "committedDate": "2021-02-02 17:54:12 -0800", "message": "BFD-379-Support-BB2-Address-Fields-Filtering-header-includeAddressFields (#390)"}, {"oid": "163e1cb21f138cbbcf68e8ef4ce730bd1a1881d2", "committedDate": "2022-01-27 17:36:19 -0500", "message": "BFD-1399: Rename db table and column names (#878)"}, {"oid": "86a2665d1f0252675f227f300fc0643ded7d9bfe", "committedDate": "2022-02-01 08:01:24 -0800", "message": "BFD-1514: Clean up javadoc errors in Model module (#929)"}, {"oid": "28cfe6ac219cb819818e78a10c46e9464754bf39", "committedDate": "2022-03-04 19:09:19 +0000", "message": "BFD-1566: Implement CCW RIF Filtering for 2022 Enrollment Issues (#980)"}, {"oid": "c6bd43f4140f2d6350dd6f0eec9b91e082dfc3a0", "committedDate": "2022-05-02 08:11:30 -0700", "message": "BFD-1703: Cleanup more projects for checkstyle (#1081)"}, {"oid": "906a51708f91524da0f21a88fb27b26afdec6984", "committedDate": "2023-02-14 10:54:00 -0500", "message": "PACA-920: Use DSL to generate all RIF parsers (Part 2/2) (#1566)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3NDc3Ng==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r550274776", "body": "this definition makes the code easier to read down the line. thx. ", "bodyText": "this definition makes the code easier to read down the line. thx.", "bodyHTML": "<p dir=\"auto\">this definition makes the code easier to read down the line. thx.</p>", "author": "jzulim", "createdAt": "2020-12-30T17:45:44Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java", "diffHunk": "@@ -506,6 +508,9 @@ private void processAsync(\n \n         LoadStrategy strategy = selectStrategy(recordAction);\n         LoadAction loadAction;\n+\n+        boolean recordsIsBeneficiary = (record instanceof Beneficiary) ? true : false;", "originalCommit": "2ea161ee2f878348bec572954d9221e7917d294e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 257d9724a..3d79d64a9 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -509,8 +503,6 @@ public final class RifLoader implements AutoCloseable {\n         LoadStrategy strategy = selectStrategy(recordAction);\n         LoadAction loadAction;\n \n-        boolean recordsIsBeneficiary = (record instanceof Beneficiary) ? true : false;\n-\n         if (strategy == LoadStrategy.INSERT_IDEMPOTENT) {\n           // Check to see if record already exists.\n           Timer.Context timerIdempotencyQuery =\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "1b0103ba4f25f43a6c5c5c92c73364dc17d2e5b0", "committedDate": "2020-12-30 16:03:00 -0500", "message": "Cbrune/bfd 549 validate hibernate (#426)"}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4MDIzNQ==", "url": "https://github.com/CMSgov/beneficiary-fhir-data/pull/419#discussion_r550280235", "body": "Would you consider also JavaDoc'ing this?", "bodyText": "Would you consider also JavaDoc'ing this?", "bodyHTML": "<p dir=\"auto\">Would you consider also JavaDoc'ing this?</p>", "author": "jzulim", "createdAt": "2020-12-30T18:05:00Z", "path": "apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java", "diffHunk": "@@ -657,6 +982,59 @@ static boolean isBeneficiaryHistoryEqual(\n     return false;\n   }\n \n+  public static BeneficiaryMonthly getBeneficiaryMonthly(", "originalCommit": "2ea161ee2f878348bec572954d9221e7917d294e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "changed_code": [{"header": "diff --git a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\nindex 257d9724a..3d79d64a9 100644\n--- a/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n+++ b/apps/bfd-pipeline/bfd-pipeline-rif-load/src/main/java/gov/cms/bfd/pipeline/rif/load/RifLoader.java\n", "chunk": "@@ -961,25 +1014,27 @@ public final class RifLoader implements AutoCloseable {\n    */\n   static boolean isBeneficiaryHistoryEqual(\n       Beneficiary newBeneficiaryRecord, Beneficiary oldBeneficiaryRecord) {\n-\n-    if (newBeneficiaryRecord.getBirthDate().equals(oldBeneficiaryRecord.getBirthDate())\n-        && newBeneficiaryRecord.getHicn().equals(oldBeneficiaryRecord.getHicn())\n-        && newBeneficiaryRecord.getHicnUnhashed().equals(oldBeneficiaryRecord.getHicnUnhashed())\n-        && newBeneficiaryRecord.getSex() == oldBeneficiaryRecord.getSex()\n-        && newBeneficiaryRecord.getMbiHash().equals(oldBeneficiaryRecord.getMbiHash())\n-        && newBeneficiaryRecord\n-            .getMbiEffectiveDate()\n-            .equals(oldBeneficiaryRecord.getMbiEffectiveDate())\n-        && newBeneficiaryRecord\n-            .getMbiObsoleteDate()\n-            .equals(oldBeneficiaryRecord.getMbiObsoleteDate())\n-        && newBeneficiaryRecord\n-            .getMedicareBeneficiaryId()\n-            .equals(oldBeneficiaryRecord.getMedicareBeneficiaryId())) {\n-      return true;\n-    }\n-\n-    return false;\n+    if (!Objects.equals(newBeneficiaryRecord.getBirthDate(), oldBeneficiaryRecord.getBirthDate()))\n+      return false;\n+    if (!Objects.equals(newBeneficiaryRecord.getHicn(), oldBeneficiaryRecord.getHicn()))\n+      return false;\n+    if (!Objects.equals(\n+        newBeneficiaryRecord.getHicnUnhashed(), oldBeneficiaryRecord.getHicnUnhashed()))\n+      return false;\n+    if (!Objects.equals(newBeneficiaryRecord.getSex(), oldBeneficiaryRecord.getSex())) return false;\n+    if (!Objects.equals(newBeneficiaryRecord.getMbiHash(), oldBeneficiaryRecord.getMbiHash()))\n+      return false;\n+    if (!Objects.equals(\n+        newBeneficiaryRecord.getMbiEffectiveDate(), oldBeneficiaryRecord.getMbiEffectiveDate()))\n+      return false;\n+    if (!Objects.equals(\n+        newBeneficiaryRecord.getMbiObsoleteDate(), oldBeneficiaryRecord.getMbiObsoleteDate()))\n+      return false;\n+    if (!Objects.equals(\n+        newBeneficiaryRecord.getMedicareBeneficiaryId(),\n+        oldBeneficiaryRecord.getMedicareBeneficiaryId())) return false;\n+\n+    return true;\n   }\n \n   public static BeneficiaryMonthly getBeneficiaryMonthly(\n", "next_change": null}]}, "commits_in_main": [{"oid": "f52165e3f3455dde704ffd72dbf227f31f349e5a", "message": "Merge commit", "committedDate": null}, {"oid": "1b0103ba4f25f43a6c5c5c92c73364dc17d2e5b0", "committedDate": "2020-12-30 16:03:00 -0500", "message": "Cbrune/bfd 549 validate hibernate (#426)"}, {"oid": "8f84f76e15ef11f5c511433f1b977ff0b471cc08", "committedDate": "2021-02-24 12:37:45 -0800", "message": "BFD-606: Refactor bene ETL to avoid unnecessary hashing (#436)"}, {"oid": "c781a92ad0b3726d250bb989c4fe91b1d964c86c", "committedDate": "2021-03-12 11:46:24 -0500", "message": "BFD-652: Initial RFC draft for Pipeline orchestration (#462)"}]}, {"oid": "1fb9fb76d1d69b3dca512700dc0465dc287276e2", "url": "https://github.com/CMSgov/beneficiary-fhir-data/commit/1fb9fb76d1d69b3dca512700dc0465dc287276e2", "message": "Update apps/bfd-model/bfd-model-codegen/src/main/java/gov/cms/bfd/model/codegen/MappingSpec.java\n\nCo-authored-by: John Zulim <john.zulim@adhocteam.us>", "committedDate": "2020-12-30T19:10:24Z", "type": "commit"}]}