{"pr_number": 3244, "pr_title": "[STORM-3600] Add caching in Cluster.calculateSharedOffHeapNodeMemory", "pr_author": "bipinprasad", "pr_createdAt": "2020-04-06T22:10:34Z", "pr_url": "https://github.com/apache/storm/pull/3244", "timeline": [{"oid": "7c5fdc3cbab49e7f3e42d9ae68bbd841c2fa191b", "url": "https://github.com/apache/storm/commit/7c5fdc3cbab49e7f3e42d9ae68bbd841c2fa191b", "message": "[STORM-3600] Add caching in Cluster.calculateSharedOffHeapNodeMemory to yield 4 fourfold increase in speed when scheduling large cluster.", "committedDate": "2020-04-06T22:00:01Z", "type": "commit"}, {"oid": "db4182f7f3e2fe1f071b0ba7f0c97005fd61426b", "url": "https://github.com/apache/storm/commit/db4182f7f3e2fe1f071b0ba7f0c97005fd61426b", "message": "[STORM-3600] TopologyDetails may not contain stormTopology in some tests.", "committedDate": "2020-04-08T12:04:50Z", "type": "commit"}, {"oid": "ee02bb2630d9c506735d0d8336d721936cecb970", "url": "https://github.com/apache/storm/commit/ee02bb2630d9c506735d0d8336d721936cecb970", "message": "[STORM-3600] Cache executors as in YSTORM-7378 pull request 1556. Approx 5% speedup.", "committedDate": "2020-04-09T02:47:59Z", "type": "commit"}, {"oid": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "url": "https://github.com/apache/storm/commit/4515a40cfeb391d62910f5f32951abe9f7b5277a", "message": "[STORM-3600] Checkstyle fix and remove commented code.", "committedDate": "2020-04-09T18:31:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NTUyOA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406445528", "body": "We should be able to simplify this with \r\n\r\n```\r\n        StormTopology topology = td.getTopology();\r\n        if (topology.is_set_shared_memory()) {\r\n            for (SharedMemory sharedMemory : topology.get_shared_memory().values()) {\r\n                double val = sharedMemory.get_off_heap_node();\r\n                if (val > 0.0) {\r\n                    topoSharedOffHeapMemoryNodeFlag.put(topoId, true);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        \r\n```\r\n\r\n", "bodyText": "We should be able to simplify this with\n        StormTopology topology = td.getTopology();\n        if (topology.is_set_shared_memory()) {\n            for (SharedMemory sharedMemory : topology.get_shared_memory().values()) {\n                double val = sharedMemory.get_off_heap_node();\n                if (val > 0.0) {\n                    topoSharedOffHeapMemoryNodeFlag.put(topoId, true);\n                    return;\n                }\n            }\n        }", "bodyHTML": "<p dir=\"auto\">We should be able to simplify this with</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        StormTopology topology = td.getTopology();\n        if (topology.is_set_shared_memory()) {\n            for (SharedMemory sharedMemory : topology.get_shared_memory().values()) {\n                double val = sharedMemory.get_off_heap_node();\n                if (val &gt; 0.0) {\n                    topoSharedOffHeapMemoryNodeFlag.put(topoId, true);\n                    return;\n                }\n            }\n        }\n        \n\"><pre><code>        StormTopology topology = td.getTopology();\n        if (topology.is_set_shared_memory()) {\n            for (SharedMemory sharedMemory : topology.get_shared_memory().values()) {\n                double val = sharedMemory.get_off_heap_node();\n                if (val &gt; 0.0) {\n                    topoSharedOffHeapMemoryNodeFlag.put(topoId, true);\n                    return;\n                }\n            }\n        }\n        \n</code></pre></div>", "author": "Ethanlm", "createdAt": "2020-04-09T20:02:34Z", "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -709,6 +720,33 @@ public void assign(SchedulerAssignment assignment, boolean ignoreSingleException\n         }\n     }\n \n+    /**\n+     * Initialize the flag to true if specified topology uses SharedOffHeapNodeMemory, false otherwise.\n+     *\n+     * @param td TopologyDetails to examine\n+     */\n+    private void initializeTopoSharedOffHeapNodeMemoryFlag(TopologyDetails td) {\n+        String topoId = td.getId();\n+        topoSharedOffHeapMemoryNodeFlag.put(topoId, false);\n+        StormTopology topology = td.getTopology();\n+        if (topology == null) {\n+            return; // accomodate multitenant_scheduler_test.clj\n+        }\n+        if (topology.is_set_component_to_shared_memory()) {", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTI1Mg==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406481252", "bodyText": "(1) topology == null check is required weirdly enough due to some other tests failure (later I also found note in TopologyDetails.getSharedMemoryRequests()\n(2) In StormTopology shared_memory and component_to_shared_memory are two different thrift fields. And setters don't seem to cross set. If I change this code then this will change the prior logic in Cluster.java. How are these two different fields equivalent?", "author": "bipinprasad", "createdAt": "2020-04-09T21:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwODM3NA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406508374", "bodyText": "I agree with (1). Sorry I didn't copy that part of the code.\n(2)\nThese two fields are equivalent.\nThere is a 1-to-1 mapping between SharedMemory name to SharedMemory object.\nshared_memory and component_to_shared_memory are different structures to keep SharedMemory object but they essentially keep the whole mapping of SharedMemory name to SharedMemory object\nhttps://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/topology/TopologyBuilder.java#L631-L638", "author": "Ethanlm", "createdAt": "2020-04-09T22:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwOTQ2OQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406509469", "bodyText": "They are designed this way. For example\nI can have two SharedMemory with name as sharedMemory1 and sharedMemory2.\nAnd I can add  sharedMemory1 to comp1 and sharedMemory2 to comp2.\nNow shared_memory is\nobject1 (name=sharedMemory1),  object2 (name=sharedMemory2);\ncomponent_to_shared_memory is\ncomp1 -> object1 (name=sharedMemory1), comp2 -> object2 (name=sharedMemory2);", "author": "Ethanlm", "createdAt": "2020-04-09T22:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxODU4Ng==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406518586", "bodyText": "Thanks for explanation. Looks like TopologyBuilder.createTopology() makes the only to call to set_component_to_shared_memory() and set_shared_memory() and thus ensuring this consistency.\nChanged code.", "author": "bipinprasad", "createdAt": "2020-04-09T22:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NTUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java b/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\nindex 61a25d13d..06b922cae 100644\n--- a/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\n+++ b/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\n", "chunk": "@@ -730,18 +730,14 @@ public class Cluster implements ISchedulingState {\n         topoSharedOffHeapMemoryNodeFlag.put(topoId, false);\n         StormTopology topology = td.getTopology();\n         if (topology == null) {\n-            return; // accomodate multitenant_scheduler_test.clj\n+            return; // accommodate multitenant_scheduler_test.clj\n         }\n-        if (topology.is_set_component_to_shared_memory()) {\n-            for (Set<String> sharedNames : topology.get_component_to_shared_memory().values()) {\n-                if (sharedNames != null) {\n-                    for (String name : sharedNames) {\n-                        double val = topology.get_shared_memory().get(name).get_off_heap_node();\n-                        if (val > 0.0) {\n-                            topoSharedOffHeapMemoryNodeFlag.put(topoId, true);\n-                            return;\n-                        }\n-                    }\n+        if (topology.is_set_shared_memory()) {\n+            for (SharedMemory sharedMemory : topology.get_shared_memory().values()) {\n+                double val = sharedMemory.get_off_heap_node();\n+                if (val > 0.0) {\n+                    topoSharedOffHeapMemoryNodeFlag.put(topoId, true);\n+                    return;\n                 }\n             }\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0Njk2Ng==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406446966", "body": "Since this is added, Line 808 can be updated to use `nodeId` instead of `slot.getNodeId()`", "bodyText": "Since this is added, Line 808 can be updated to use nodeId instead of slot.getNodeId()", "bodyHTML": "<p dir=\"auto\">Since this is added, Line 808 can be updated to use <code>nodeId</code> instead of <code>slot.getNodeId()</code></p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:05:27Z", "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -749,12 +792,16 @@ private double calculateSharedOffHeapNodeMemory(\n      */\n     public void freeSlot(WorkerSlot slot) {\n         // remove the slot from the existing assignments\n+        String nodeId = slot.getNodeId();", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4Mjc0Mg==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406482742", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-04-09T21:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0Njk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java b/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\nindex 61a25d13d..06b922cae 100644\n--- a/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\n+++ b/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\n", "chunk": "@@ -792,10 +788,10 @@ public class Cluster implements ISchedulingState {\n      */\n     public void freeSlot(WorkerSlot slot) {\n         // remove the slot from the existing assignments\n-        String nodeId = slot.getNodeId();\n+        final String nodeId = slot.getNodeId();\n         for (SchedulerAssignmentImpl assignment : assignments.values()) {\n             if (assignment.isSlotOccupied(slot)) {\n-                String topologyId = assignment.getTopologyId();\n+                final String topologyId = assignment.getTopologyId();\n                 assertValidTopologyForModification(topologyId);\n                 assignment.unassignBySlot(slot);\n                 topoIdToNodeIdToSlotIdToExecutors.computeIfAbsent(topologyId, Cluster::makeMap).computeIfAbsent(nodeId, Cluster::makeMap)\n", "next_change": {"commit": "6e2e46bcf21584cb111bd5254912b2a6410eccb7", "changed_code": [{"header": "diff --git a/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java b/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\nindex 06b922cae..b1f62b139 100644\n--- a/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\n+++ b/storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java\n", "chunk": "@@ -799,7 +822,7 @@ public class Cluster implements ISchedulingState {\n                         .clear();\n                 TopologyDetails td = topologies.getById(topologyId);\n                 assignment.setTotalSharedOffHeapNodeMemory(\n-                    nodeId, calculateSharedOffHeapNodeMemory(nodeId, assignment, td));\n+                    nodeId, calculateSharedOffHeapNodeMemory(nodeId, td));\n                 nodeToScheduledResourcesCache.computeIfAbsent(nodeId, Cluster::makeMap).put(slot, new NormalizedResourceRequest());\n                 nodeToUsedSlotsCache.computeIfAbsent(nodeId, Cluster::makeSet).remove(slot);\n             }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1MDUyOA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406450528", "body": "I was wondering if `return` within the try-with-resources block will close the resources or not. And I found this https://stackoverflow.com/questions/22947755/try-with-resources-and-return-statements-in-java/22947904\r\n\r\nSo it should be fine. ", "bodyText": "I was wondering if return within the try-with-resources block will close the resources or not. And I found this https://stackoverflow.com/questions/22947755/try-with-resources-and-return-statements-in-java/22947904\nSo it should be fine.", "bodyHTML": "<p dir=\"auto\">I was wondering if <code>return</code> within the try-with-resources block will close the resources or not. And I found this <a href=\"https://stackoverflow.com/questions/22947755/try-with-resources-and-return-statements-in-java/22947904\" rel=\"nofollow\">https://stackoverflow.com/questions/22947755/try-with-resources-and-return-statements-in-java/22947904</a></p>\n<p dir=\"auto\">So it should be fine.</p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:12:23Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1NjkzMA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406556930", "bodyText": "Yes. Pretty cool JDK 8 feature. Here is more authoritative info - which actually uses return as an example too: https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html", "author": "bipinprasad", "createdAt": "2020-04-10T01:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1MDUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjI4NQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r407732285", "bodyText": "Agreed - try with resources will close as part of the \"destructor\"", "author": "govind-menon", "createdAt": "2020-04-13T21:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1MDUyOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NDAwOQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406454009", "body": "It looks like `nm` is actually `topoId`? What does `nm` stand for?", "bodyText": "It looks like nm is actually topoId? What does nm stand for?", "bodyHTML": "<p dir=\"auto\">It looks like <code>nm</code> is actually <code>topoId</code>? What does <code>nm</code> stand for?</p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:19:29Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    public static ClassLoader getContextClassLoader() {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n+     * resource path.\n+     *\n+     * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n+     * @return An array of TopologyDetails representing resource files.\n+     * @throws Exception\n+     */\n+    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+        List<TopologyDetails> topoDetailsList = new ArrayList<>();\n+        List<String> errors = new ArrayList<>();\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Map<String, String> codeResourceMap = new TreeMap<>();\n+        Map<String, String> confResourceMap = new HashMap<>();\n+        for (int i = 0 ; i < resources.size() ; i++) {\n+            String resource = resources.get(i);\n+            int idxOfSlash = resource.lastIndexOf(\"/\");\n+            int idxOfDash = resource.lastIndexOf(\"-\");\n+            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n+            if (resource.endsWith(\"code.ser\")) {\n+                codeResourceMap.put(nm, resource);\n+            } else if (resource.endsWith(\"conf.ser\")) {\n+                confResourceMap.put(nm, resource);\n+            } else {\n+                LOG.info(\"Ignoring unsupported resource file \" + resource);\n+            }\n+        }\n+        String[] examinedConfParams = {\n+                Config.TOPOLOGY_NAME,\n+                Config.TOPOLOGY_SCHEDULER_STRATEGY,\n+                Config.TOPOLOGY_PRIORITY,\n+                Config.TOPOLOGY_WORKERS,\n+                Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB,\n+                Config.TOPOLOGY_SUBMITTER_USER,\n+                Config.TOPOLOGY_ACKER_CPU_PCORE_PERCENT,\n+                Config.TOPOLOGY_ACKER_RESOURCES_OFFHEAP_MEMORY_MB,\n+                Config.TOPOLOGY_ACKER_RESOURCES_ONHEAP_MEMORY_MB,\n+        };\n+\n+        for (String nm : codeResourceMap.keySet()) {", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NzY2OA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406487668", "bodyText": "nm (name) is the crud that stands in from of the code.ser and conf.ser in the file name and is the same for two topology and config files for the same topology. The code is expecting/assuming topology name to be embedded in the file names.", "author": "bipinprasad", "createdAt": "2020-04-09T21:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDAxMg==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406510012", "bodyText": "Thanks.  I was confused about nm variable. Maybe name is more clear. But that's fine.", "author": "Ethanlm", "createdAt": "2020-04-09T22:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NDAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex ed7d84be0..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -183,15 +205,15 @@ public class TestLargeCluster {\n                 Config.TOPOLOGY_ACKER_RESOURCES_ONHEAP_MEMORY_MB,\n         };\n \n-        for (String nm : codeResourceMap.keySet()) {\n-            String codeResource = codeResourceMap.get(nm);\n-            if (!confResourceMap.containsKey(nm)) {\n-                String err = String.format(\"Ignoring topology file %s because of missing config file for %s\", codeResource, nm);\n+        for (String topoId : codeResourceMap.keySet()) {\n+            String codeResource = codeResourceMap.get(topoId);\n+            if (!confResourceMap.containsKey(topoId)) {\n+                String err = String.format(\"Ignoring topology file %s because of missing config file for %s\", codeResource, topoId);\n                 errors.add(err);\n                 LOG.error(err);\n                 continue;\n             }\n-            String confResource = confResourceMap.get(nm);\n+            String confResource = confResourceMap.get(topoId);\n             LOG.info(\"Found matching topology and config files: {}, {}\", codeResource, confResource);\n             StormTopology stormTopology;\n             try {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTAzMA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406455030", "body": "What does the comment mean? Or can it be removed?", "bodyText": "What does the comment mean? Or can it be removed?", "bodyHTML": "<p dir=\"auto\">What does the comment mean? Or can it be removed?</p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:21:46Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    public static ClassLoader getContextClassLoader() {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n+     * resource path.\n+     *\n+     * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n+     * @return An array of TopologyDetails representing resource files.\n+     * @throws Exception\n+     */\n+    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+        List<TopologyDetails> topoDetailsList = new ArrayList<>();\n+        List<String> errors = new ArrayList<>();\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Map<String, String> codeResourceMap = new TreeMap<>();\n+        Map<String, String> confResourceMap = new HashMap<>();\n+        for (int i = 0 ; i < resources.size() ; i++) {\n+            String resource = resources.get(i);\n+            int idxOfSlash = resource.lastIndexOf(\"/\");\n+            int idxOfDash = resource.lastIndexOf(\"-\");\n+            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n+            if (resource.endsWith(\"code.ser\")) {\n+                codeResourceMap.put(nm, resource);\n+            } else if (resource.endsWith(\"conf.ser\")) {\n+                confResourceMap.put(nm, resource);\n+            } else {\n+                LOG.info(\"Ignoring unsupported resource file \" + resource);\n+            }\n+        }\n+        String[] examinedConfParams = {\n+                Config.TOPOLOGY_NAME,\n+                Config.TOPOLOGY_SCHEDULER_STRATEGY,\n+                Config.TOPOLOGY_PRIORITY,\n+                Config.TOPOLOGY_WORKERS,\n+                Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB,\n+                Config.TOPOLOGY_SUBMITTER_USER,\n+                Config.TOPOLOGY_ACKER_CPU_PCORE_PERCENT,\n+                Config.TOPOLOGY_ACKER_RESOURCES_OFFHEAP_MEMORY_MB,\n+                Config.TOPOLOGY_ACKER_RESOURCES_ONHEAP_MEMORY_MB,\n+        };\n+\n+        for (String nm : codeResourceMap.keySet()) {\n+            String codeResource = codeResourceMap.get(nm);\n+            if (!confResourceMap.containsKey(nm)) {\n+                String err = String.format(\"Ignoring topology file %s because of missing config file for %s\", codeResource, nm);\n+                errors.add(err);\n+                LOG.error(err);\n+                continue;\n+            }\n+            String confResource = confResourceMap.get(nm);\n+            LOG.info(\"Found matching topology and config files: {}, {}\", codeResource, confResource);\n+            StormTopology stormTopology;\n+            try {\n+                stormTopology = Utils.deserialize(getResourceAsBytes(codeResource), StormTopology.class);\n+            } catch (Exception ex) {\n+                String err = String.format(\"Cannot read topology from resource %s\", codeResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+\n+            Map<String, Object> conf;\n+            try {\n+                conf = Utils.fromCompressedJsonConf(getResourceAsBytes(confResource));\n+            } catch (RuntimeException | IOException ex) {\n+                String err = String.format(\"Cannot read configuration from resource %s\", confResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+            // fix 0.10 conf class names\n+            String[] configParamsToFix = {Config.TOPOLOGY_SCHEDULER_STRATEGY, Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n+                    DaemonConfig.RESOURCE_AWARE_SCHEDULER_PRIORITY_STRATEGY };\n+            for (String configParam: configParamsToFix) {\n+                if (!conf.containsKey(configParam)) {\n+                    continue;\n+                }\n+                String className = (String) conf.get(configParam);\n+                if (className.startsWith(\"backtype\")) {\n+                    className = className.replace(\"backtype\", \"org.apache\");\n+                    conf.put(configParam, className);\n+                }\n+            }\n+            // fix conf params used by ConstraintSolverStrategy\n+            if (!conf.containsKey(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH)) {\n+                conf.put(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH, 10_000);\n+            }\n+            if (!conf.containsKey(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH)) {\n+                conf.put(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH, 10_000);\n+            }\n+\n+            String topoId = nm;\n+            String topoName = (String) conf.getOrDefault(Config.TOPOLOGY_NAME, nm);\n+\n+            // conf\n+            StringBuffer sb = new StringBuffer(\"Config for \" + nm + \": \");\n+            for (String param : examinedConfParams) {\n+                Object val = conf.getOrDefault(param, \"<null>\");\n+                sb.append(param).append(\"=\").append(val).append(\", \");\n+            }\n+            LOG.info(sb.toString());\n+\n+            // topo\n+            Map<ExecutorDetails, String> execToComp = TestUtilsForResourceAwareScheduler.genExecsAndComps(stormTopology);\n+            LOG.info(\"Topology \\\"{}\\\" spouts={}, bolts={}, execToComp size is {}\", topoName,\n+                    stormTopology.get_spouts_size(), stormTopology.get_bolts_size(), execToComp.size());\n+            int numWorkers = Integer.parseInt(\"\" + conf.getOrDefault(Config.TOPOLOGY_WORKERS, \"0\"));\n+            TopologyDetails topo = new TopologyDetails(topoId, conf, stormTopology,  numWorkers,\n+                    execToComp, Time.currentTimeSecs(), \"user\");\n+            topo.getComponents(); // sanity check - normally this should not fail\n+\n+            topoDetailsList.add(topo);\n+        }\n+        if (!errors.isEmpty() && failOnParseError) {\n+            throw new Exception(\"Unable to parse all serialized objects\\n\\t\" + String.join(\"\\n\\t\", errors));\n+        }\n+        return topoDetailsList.toArray(new TopologyDetails[0]);\n+    }\n+\n+    /**\n+     * Check if the files in the resource directory are matched, can be read properly, and code/config files occur\n+     * in matched pairs.\n+     *\n+     * @throws Exception showing bad and unmatched resource files.\n+     */\n+    @Test\n+    public void testReadSerializedTopologiesAndConfigs() throws Exception {\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Assert.assertTrue(\"No resource files found in \" + TEST_RESOURCE_PATH, !resources.isEmpty());\n+        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(true);\n+    }\n+\n+    /**\n+     * Create one supervisor and add to the supervisors list.\n+     *\n+     * @param rack rack-number\n+     * @param superInRack supervisor number in the rack\n+     * @param cpu percentage\n+     * @param mem in megabytes\n+     * @param numPorts number of ports on this supervisor\n+     * @param sups returned map os supervisors\n+     */\n+    private static void createAndAddOneSupervisor(\n+            int rack, int superInRack, double cpu, double mem, int numPorts,\n+            Map<String, SupervisorDetails> sups) {\n+\n+        List<Number> ports = new LinkedList<>();\n+        for (int p = 0; p < numPorts; p++) {\n+            ports.add(p);\n+        }\n+        String superId = String.format(\"r%03ds%03d\", rack, superInRack);\n+        String hostId  = String.format(\"host-%03d-rack-%03d\", superInRack, rack);\n+        Map<String, Double> resourceMap = new HashMap<>();\n+        resourceMap.put(Config.SUPERVISOR_CPU_CAPACITY, cpu);\n+        resourceMap.put(Config.SUPERVISOR_MEMORY_CAPACITY_MB, mem);\n+        resourceMap.put(\"network.resource.units\", 50.0);\n+        SupervisorDetails sup = new SupervisorDetails(superId,\n+                hostId, null, ports,\n+                NormalizedResources.RESOURCE_NAME_NORMALIZER.normalizedResourceMap(resourceMap));\n+        sups.put(sup.getId(), sup);\n+    }\n+\n+    /**\n+     * Create supervisors.\n+     *\n+     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n+     * @return supervisor details indexed by id\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n+        Map<String, SupervisorDetails> retVal;\n+        if (uniformSupervisors) {\n+            int numRacks = 16;\n+            int numSupersPerRack = 82;\n+            int numPorts = 50; // scheduling will fill up 2-6, leaving of 90% workerslots unused - does this cause slow scheduling?", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5MDIyMQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406490221", "bodyText": "I found that for topology components with large cpu/mem, most of the workeslots get left unused - but the looping logic in scheduling spends a lot of cycles in those. How workerslots are processed may need to be revisited for further speed gains. If it is not clear, it needs to be reworded.", "author": "bipinprasad", "createdAt": "2020-04-09T21:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDI3NQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406510275", "bodyText": "It would be better if it can be reworded. Your comment here is much clearer to me", "author": "Ethanlm", "createdAt": "2020-04-09T22:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTAzMA=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex ed7d84be0..cf18c6cb4 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -315,7 +320,7 @@ public class TestLargeCluster {\n         if (uniformSupervisors) {\n             int numRacks = 16;\n             int numSupersPerRack = 82;\n-            int numPorts = 50; // scheduling will fill up 2-6, leaving of 90% workerslots unused - does this cause slow scheduling?\n+            int numPorts = 50; // note: scheduling is slower when components with large cpu/mem leave large percent of workerslots unused\n             int rackStart = 0;\n             int superInRackStart = 1;\n             double cpu = 7200; // %percent\n", "next_change": {"commit": "1b870a829b84c31a1dba17139ff389762d523dbb", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex cf18c6cb4..f1553dcb6 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -310,57 +320,87 @@ public class TestLargeCluster {\n     }\n \n     /**\n-     * Create supervisors.\n+     * Create supervisors for a larger cluster configuration.\n      *\n-     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n-     * @return supervisor details indexed by id\n+     * @param reducedSupervisorsPerRack number of supervisors to reduce in rack.\n+     * @return created supervisors.\n      */\n-    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n-        Map<String, SupervisorDetails> retVal;\n-        if (uniformSupervisors) {\n-            int numRacks = 16;\n-            int numSupersPerRack = 82;\n-            int numPorts = 50; // note: scheduling is slower when components with large cpu/mem leave large percent of workerslots unused\n-            int rackStart = 0;\n-            int superInRackStart = 1;\n-            double cpu = 7200; // %percent\n-            double mem = 356_000; // MB\n-            Map<String, Double> miscResources = new HashMap<>();\n-            miscResources.put(\"network.resource.units\", 100.0);\n-\n-            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n-                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n-\n+    private static Map<String, SupervisorDetails> createSupervisors(int reducedSupervisorsPerRack) {\n+        if (TEST_CLUSTER_NAME.equals(TEST_CLUSTER_02)) {\n+            return createSupervisorsForCluster02(reducedSupervisorsPerRack);\n         } else {\n-            // this non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use\n-            int numSupersPerRack = 82;\n-            int numPorts = 50;\n-\n-            Map<String, SupervisorDetails> retList = new HashMap<>();\n+            return createSupervisorsForCluster01(reducedSupervisorsPerRack);\n+        }\n+    }\n \n-            for (int rack = 0 ; rack < 12 ; rack++) {\n-                double cpu = 3600; // %percent\n-                double mem = 178_000; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n+    /**\n+     * Create supervisors for a newer {@link #TEST_CLUSTER_02} cluster configuration to mimic a large cluster in use.\n+     *\n+     * @param reducedSupervisorsPerRack number of supervisors to reduce per rack.\n+     * @return created supervisors.\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisorsForCluster02(int reducedSupervisorsPerRack) {\n+        Collection<SupervisorDistribution> supervisorDistributions = SupervisorDistribution.getSupervisorDistribution02();\n+        Map<String, Collection<SupervisorDistribution>> byRackId = SupervisorDistribution.mapByRackId(supervisorDistributions);\n+        LOG.info(\"Cluster={}, Designed capacity: {}\", TEST_CLUSTER_NAME, SupervisorDistribution.clusterCapacity(supervisorDistributions));\n+\n+        Map<String, SupervisorDetails> retList = new HashMap<>();\n+        Map<String, AtomicInteger> seenRacks = new HashMap<>();\n+        byRackId.forEach((rackId, list) -> {\n+            int tmpRackSupervisorCnt = list.stream().mapToInt(x -> x.supervisorCnt).sum() - Math.abs(reducedSupervisorsPerRack);\n+            if (tmpRackSupervisorCnt > Math.abs(reducedSupervisorsPerRack)) {\n+                tmpRackSupervisorCnt -= Math.abs(reducedSupervisorsPerRack);\n             }\n-            for (int rack = 12 ; rack < 14 ; rack++) {\n-                double cpu = 2400; // %percent\n-                double mem = 118_100; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+            final int adjustedRackSupervisorCnt = tmpRackSupervisorCnt;\n+            list.forEach(x -> {\n+                int supervisorCnt = x.supervisorCnt;\n+                for (int i = 0; i < supervisorCnt ; i++) {\n+                    int superInRack = seenRacks.computeIfAbsent(rackId, z -> new AtomicInteger(-1)).incrementAndGet();\n+                    int rackNum = seenRacks.size() - 1;\n+                    if (superInRack >= adjustedRackSupervisorCnt) {\n+                        continue;\n+                    }\n+                    createAndAddOneSupervisor(rackNum, superInRack, x.cpuPercent, x.memoryMb, x.slotCnt, retList);\n                 }\n+            });\n+        });\n+        return retList;\n+    }\n+\n+    /**\n+     * Create supervisors for a non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use.\n+     *\n+     * @param reducedSupervisorsPerRack is the reduction in supervisors per rack to constrain capacity (15 is tight)\n+     * @return supervisor details indexed by id\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisorsForCluster01(int reducedSupervisorsPerRack) {\n+        int numSupersPerRack = 82 - Math.abs(reducedSupervisorsPerRack);\n+        int numPorts = 50;\n+\n+        Map<String, SupervisorDetails> retList = new HashMap<>();\n+\n+        for (int rack = 0 ; rack < 12 ; rack++) {\n+            double cpu = 3600; // %percent\n+            double mem = 178_000; // MB\n+            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n             }\n-            for (int rack = 14 ; rack < 16 ; rack++) {\n-                double cpu = 1200; // %percent\n-                double mem = 42_480; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n+        }\n+        for (int rack = 12 ; rack < 14 ; rack++) {\n+            double cpu = 2400; // %percent\n+            double mem = 118_100; // MB\n+            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n             }\n-            return retList;\n         }\n+        for (int rack = 14 ; rack < 16 ; rack++) {\n+            double cpu = 1200; // %percent\n+            double mem = 42_480; // MB\n+            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+            }\n+        }\n+        return retList;\n     }\n \n     /**\n", "next_change": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex f1553dcb6..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -367,98 +374,73 @@ public class TestLargeCluster {\n         return retList;\n     }\n \n-    /**\n-     * Create supervisors for a non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use.\n-     *\n-     * @param reducedSupervisorsPerRack is the reduction in supervisors per rack to constrain capacity (15 is tight)\n-     * @return supervisor details indexed by id\n-     */\n-    private static Map<String, SupervisorDetails> createSupervisorsForCluster01(int reducedSupervisorsPerRack) {\n-        int numSupersPerRack = 82 - Math.abs(reducedSupervisorsPerRack);\n-        int numPorts = 50;\n-\n-        Map<String, SupervisorDetails> retList = new HashMap<>();\n-\n-        for (int rack = 0 ; rack < 12 ; rack++) {\n-            double cpu = 3600; // %percent\n-            double mem = 178_000; // MB\n-            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-            }\n-        }\n-        for (int rack = 12 ; rack < 14 ; rack++) {\n-            double cpu = 2400; // %percent\n-            double mem = 118_100; // MB\n-            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-            }\n-        }\n-        for (int rack = 14 ; rack < 16 ; rack++) {\n-            double cpu = 1200; // %percent\n-            double mem = 42_480; // MB\n-            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-            }\n-        }\n-        return retList;\n-    }\n-\n     /**\n      * Create a large cluster, read topologies and configuration from resource directory and schedule.\n      *\n-     * @throws Exception\n+     * @throws Exception upon error.\n      */\n     @Test\n     public void testLargeCluster() throws Exception {\n-        Map<String, SupervisorDetails> supervisors = createSupervisors(0);\n+        for (TEST_CLUSTER_NAME testClusterName: TEST_CLUSTER_NAME.values()) {\n+            LOG.info(\"********************************************\");\n+            LOG.info(\"testLargeCluster: Start Processing cluster {}\", testClusterName.getClusterName());\n+\n+            String resourcePath = testClusterName.getResourcePath();\n+            Map<String, SupervisorDetails> supervisors = createSupervisors(testClusterName, 0);\n \n-        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(false);\n-        Assert.assertTrue(\"No topologies found\", topoDetailsArray.length > 0);\n-        Topologies topologies = new Topologies(topoDetailsArray);\n+            TopologyDetails[] topoDetailsArray = createTopoDetailsArray(resourcePath, false);\n+            Assert.assertTrue(\"No topologies found for cluster \" + testClusterName.getClusterName(), topoDetailsArray.length > 0);\n+            Topologies topologies = new Topologies(topoDetailsArray);\n \n-        Config confWithDefaultStrategy = new Config();\n-        confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n-        confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n-        confWithDefaultStrategy.put(\n+            Config confWithDefaultStrategy = new Config();\n+            confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n+            confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+            confWithDefaultStrategy.put(\n                 Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n                 TestUtilsForResourceAwareScheduler.GenSupervisorsDnsToSwitchMapping.class.getName());\n \n-        INimbus iNimbus = new INimbusTest();\n-        Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n+            INimbus iNimbus = new INimbusTest();\n+            Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n                 topologies, confWithDefaultStrategy);\n \n-        scheduler = new ResourceAwareScheduler();\n+            scheduler = new ResourceAwareScheduler();\n \n-        List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n+            List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n                 GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n                 Cluster.class\n-        );\n-        Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n-        long startTime = System.currentTimeMillis();\n-        scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-        scheduler.schedule(topologies, cluster);\n-        long endTime = System.currentTimeMillis();\n-        LOG.info(\"Scheduling Time: {} topologies in {} seconds\", topoDetailsArray.length, (endTime - startTime) / 1000.0);\n-\n-        for (TopologyDetails td : topoDetailsArray) {\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n-        }\n+            );\n+            Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n+            long startTime = System.currentTimeMillis();\n+            scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+            scheduler.schedule(topologies, cluster);\n+            long endTime = System.currentTimeMillis();\n+            LOG.info(\"Cluster={} Scheduling Time: {} topologies in {} seconds\",\n+                testClusterName.getClusterName(), topoDetailsArray.length, (endTime - startTime) / 1000.0);\n+\n+            for (TopologyDetails td : topoDetailsArray) {\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+            }\n+\n+            // Remove topology and reschedule it\n+            for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n+                startTime = System.currentTimeMillis();\n+                TopologyDetails topoDetails = topoDetailsArray[i];\n+                cluster.unassign(topoDetails.getId());\n+                LOG.info(\"Cluster={},  ({}) Removed topology {}\", testClusterName.getClusterName(), i, topoDetails.getName());\n+                IScheduler rescheduler = new ResourceAwareScheduler();\n+                rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+                rescheduler.schedule(topologies, cluster);\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n+                endTime = System.currentTimeMillis();\n+                LOG.info(\"Cluster={}, ({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\",\n+                    testClusterName.getClusterName(), i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+            }\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n \n-        // Remove topology and reschedule it\n-        for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n-            startTime = System.currentTimeMillis();\n-            TopologyDetails topoDetails = topoDetailsArray[i];\n-            cluster.unassign(topoDetails.getId());\n-            LOG.info(\"({}) Removed topology {}\", i, topoDetails.getName());\n-            IScheduler rescheduler = new ResourceAwareScheduler();\n-            rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-            rescheduler.schedule(topologies, cluster);\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n-            endTime = System.currentTimeMillis();\n-            LOG.info(\"({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\", i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+            LOG.info(\"testLargeCluster: End Processing cluster {}\", testClusterName.getClusterName());\n+            LOG.info(\"********************************************\");\n         }\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n     }\n \n     public static class SupervisorDistribution {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTQ5Ng==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406455496", "body": "`IridiumBlue` doesn't mean anything in the community code. Maybe reword it.\r\n\r\nTypo: `closelt`", "bodyText": "IridiumBlue doesn't mean anything in the community code. Maybe reword it.\nTypo: closelt", "bodyHTML": "<p dir=\"auto\"><code>IridiumBlue</code> doesn't mean anything in the community code. Maybe reword it.</p>\n<p dir=\"auto\">Typo: <code>closelt</code></p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:22:42Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    public static ClassLoader getContextClassLoader() {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n+     * resource path.\n+     *\n+     * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n+     * @return An array of TopologyDetails representing resource files.\n+     * @throws Exception\n+     */\n+    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+        List<TopologyDetails> topoDetailsList = new ArrayList<>();\n+        List<String> errors = new ArrayList<>();\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Map<String, String> codeResourceMap = new TreeMap<>();\n+        Map<String, String> confResourceMap = new HashMap<>();\n+        for (int i = 0 ; i < resources.size() ; i++) {\n+            String resource = resources.get(i);\n+            int idxOfSlash = resource.lastIndexOf(\"/\");\n+            int idxOfDash = resource.lastIndexOf(\"-\");\n+            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n+            if (resource.endsWith(\"code.ser\")) {\n+                codeResourceMap.put(nm, resource);\n+            } else if (resource.endsWith(\"conf.ser\")) {\n+                confResourceMap.put(nm, resource);\n+            } else {\n+                LOG.info(\"Ignoring unsupported resource file \" + resource);\n+            }\n+        }\n+        String[] examinedConfParams = {\n+                Config.TOPOLOGY_NAME,\n+                Config.TOPOLOGY_SCHEDULER_STRATEGY,\n+                Config.TOPOLOGY_PRIORITY,\n+                Config.TOPOLOGY_WORKERS,\n+                Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB,\n+                Config.TOPOLOGY_SUBMITTER_USER,\n+                Config.TOPOLOGY_ACKER_CPU_PCORE_PERCENT,\n+                Config.TOPOLOGY_ACKER_RESOURCES_OFFHEAP_MEMORY_MB,\n+                Config.TOPOLOGY_ACKER_RESOURCES_ONHEAP_MEMORY_MB,\n+        };\n+\n+        for (String nm : codeResourceMap.keySet()) {\n+            String codeResource = codeResourceMap.get(nm);\n+            if (!confResourceMap.containsKey(nm)) {\n+                String err = String.format(\"Ignoring topology file %s because of missing config file for %s\", codeResource, nm);\n+                errors.add(err);\n+                LOG.error(err);\n+                continue;\n+            }\n+            String confResource = confResourceMap.get(nm);\n+            LOG.info(\"Found matching topology and config files: {}, {}\", codeResource, confResource);\n+            StormTopology stormTopology;\n+            try {\n+                stormTopology = Utils.deserialize(getResourceAsBytes(codeResource), StormTopology.class);\n+            } catch (Exception ex) {\n+                String err = String.format(\"Cannot read topology from resource %s\", codeResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+\n+            Map<String, Object> conf;\n+            try {\n+                conf = Utils.fromCompressedJsonConf(getResourceAsBytes(confResource));\n+            } catch (RuntimeException | IOException ex) {\n+                String err = String.format(\"Cannot read configuration from resource %s\", confResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+            // fix 0.10 conf class names\n+            String[] configParamsToFix = {Config.TOPOLOGY_SCHEDULER_STRATEGY, Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n+                    DaemonConfig.RESOURCE_AWARE_SCHEDULER_PRIORITY_STRATEGY };\n+            for (String configParam: configParamsToFix) {\n+                if (!conf.containsKey(configParam)) {\n+                    continue;\n+                }\n+                String className = (String) conf.get(configParam);\n+                if (className.startsWith(\"backtype\")) {\n+                    className = className.replace(\"backtype\", \"org.apache\");\n+                    conf.put(configParam, className);\n+                }\n+            }\n+            // fix conf params used by ConstraintSolverStrategy\n+            if (!conf.containsKey(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH)) {\n+                conf.put(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH, 10_000);\n+            }\n+            if (!conf.containsKey(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH)) {\n+                conf.put(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH, 10_000);\n+            }\n+\n+            String topoId = nm;\n+            String topoName = (String) conf.getOrDefault(Config.TOPOLOGY_NAME, nm);\n+\n+            // conf\n+            StringBuffer sb = new StringBuffer(\"Config for \" + nm + \": \");\n+            for (String param : examinedConfParams) {\n+                Object val = conf.getOrDefault(param, \"<null>\");\n+                sb.append(param).append(\"=\").append(val).append(\", \");\n+            }\n+            LOG.info(sb.toString());\n+\n+            // topo\n+            Map<ExecutorDetails, String> execToComp = TestUtilsForResourceAwareScheduler.genExecsAndComps(stormTopology);\n+            LOG.info(\"Topology \\\"{}\\\" spouts={}, bolts={}, execToComp size is {}\", topoName,\n+                    stormTopology.get_spouts_size(), stormTopology.get_bolts_size(), execToComp.size());\n+            int numWorkers = Integer.parseInt(\"\" + conf.getOrDefault(Config.TOPOLOGY_WORKERS, \"0\"));\n+            TopologyDetails topo = new TopologyDetails(topoId, conf, stormTopology,  numWorkers,\n+                    execToComp, Time.currentTimeSecs(), \"user\");\n+            topo.getComponents(); // sanity check - normally this should not fail\n+\n+            topoDetailsList.add(topo);\n+        }\n+        if (!errors.isEmpty() && failOnParseError) {\n+            throw new Exception(\"Unable to parse all serialized objects\\n\\t\" + String.join(\"\\n\\t\", errors));\n+        }\n+        return topoDetailsList.toArray(new TopologyDetails[0]);\n+    }\n+\n+    /**\n+     * Check if the files in the resource directory are matched, can be read properly, and code/config files occur\n+     * in matched pairs.\n+     *\n+     * @throws Exception showing bad and unmatched resource files.\n+     */\n+    @Test\n+    public void testReadSerializedTopologiesAndConfigs() throws Exception {\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Assert.assertTrue(\"No resource files found in \" + TEST_RESOURCE_PATH, !resources.isEmpty());\n+        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(true);\n+    }\n+\n+    /**\n+     * Create one supervisor and add to the supervisors list.\n+     *\n+     * @param rack rack-number\n+     * @param superInRack supervisor number in the rack\n+     * @param cpu percentage\n+     * @param mem in megabytes\n+     * @param numPorts number of ports on this supervisor\n+     * @param sups returned map os supervisors\n+     */\n+    private static void createAndAddOneSupervisor(\n+            int rack, int superInRack, double cpu, double mem, int numPorts,\n+            Map<String, SupervisorDetails> sups) {\n+\n+        List<Number> ports = new LinkedList<>();\n+        for (int p = 0; p < numPorts; p++) {\n+            ports.add(p);\n+        }\n+        String superId = String.format(\"r%03ds%03d\", rack, superInRack);\n+        String hostId  = String.format(\"host-%03d-rack-%03d\", superInRack, rack);\n+        Map<String, Double> resourceMap = new HashMap<>();\n+        resourceMap.put(Config.SUPERVISOR_CPU_CAPACITY, cpu);\n+        resourceMap.put(Config.SUPERVISOR_MEMORY_CAPACITY_MB, mem);\n+        resourceMap.put(\"network.resource.units\", 50.0);\n+        SupervisorDetails sup = new SupervisorDetails(superId,\n+                hostId, null, ports,\n+                NormalizedResources.RESOURCE_NAME_NORMALIZER.normalizedResourceMap(resourceMap));\n+        sups.put(sup.getId(), sup);\n+    }\n+\n+    /**\n+     * Create supervisors.\n+     *\n+     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n+     * @return supervisor details indexed by id\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n+        Map<String, SupervisorDetails> retVal;\n+        if (uniformSupervisors) {\n+            int numRacks = 16;\n+            int numSupersPerRack = 82;\n+            int numPorts = 50; // scheduling will fill up 2-6, leaving of 90% workerslots unused - does this cause slow scheduling?\n+            int rackStart = 0;\n+            int superInRackStart = 1;\n+            double cpu = 7200; // %percent\n+            double mem = 356_000; // MB\n+            Map<String, Double> miscResources = new HashMap<>();\n+            miscResources.put(\"network.resource.units\", 100.0);\n+\n+            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n+                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n+\n+        } else {\n+            // this non-uniform supervisor distribution closelt (but not exactly) mimics IridiumBlue cluster", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5MTc2MQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406491761", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-04-09T21:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex ed7d84be0..cf18c6cb4 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -327,7 +332,7 @@ public class TestLargeCluster {\n                     numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n \n         } else {\n-            // this non-uniform supervisor distribution closelt (but not exactly) mimics IridiumBlue cluster\n+            // this non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use\n             int numSupersPerRack = 82;\n             int numPorts = 50;\n \n", "next_change": {"commit": "1b870a829b84c31a1dba17139ff389762d523dbb", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex cf18c6cb4..f1553dcb6 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -310,57 +320,87 @@ public class TestLargeCluster {\n     }\n \n     /**\n-     * Create supervisors.\n+     * Create supervisors for a larger cluster configuration.\n      *\n-     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n-     * @return supervisor details indexed by id\n+     * @param reducedSupervisorsPerRack number of supervisors to reduce in rack.\n+     * @return created supervisors.\n      */\n-    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n-        Map<String, SupervisorDetails> retVal;\n-        if (uniformSupervisors) {\n-            int numRacks = 16;\n-            int numSupersPerRack = 82;\n-            int numPorts = 50; // note: scheduling is slower when components with large cpu/mem leave large percent of workerslots unused\n-            int rackStart = 0;\n-            int superInRackStart = 1;\n-            double cpu = 7200; // %percent\n-            double mem = 356_000; // MB\n-            Map<String, Double> miscResources = new HashMap<>();\n-            miscResources.put(\"network.resource.units\", 100.0);\n-\n-            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n-                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n-\n+    private static Map<String, SupervisorDetails> createSupervisors(int reducedSupervisorsPerRack) {\n+        if (TEST_CLUSTER_NAME.equals(TEST_CLUSTER_02)) {\n+            return createSupervisorsForCluster02(reducedSupervisorsPerRack);\n         } else {\n-            // this non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use\n-            int numSupersPerRack = 82;\n-            int numPorts = 50;\n-\n-            Map<String, SupervisorDetails> retList = new HashMap<>();\n+            return createSupervisorsForCluster01(reducedSupervisorsPerRack);\n+        }\n+    }\n \n-            for (int rack = 0 ; rack < 12 ; rack++) {\n-                double cpu = 3600; // %percent\n-                double mem = 178_000; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n+    /**\n+     * Create supervisors for a newer {@link #TEST_CLUSTER_02} cluster configuration to mimic a large cluster in use.\n+     *\n+     * @param reducedSupervisorsPerRack number of supervisors to reduce per rack.\n+     * @return created supervisors.\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisorsForCluster02(int reducedSupervisorsPerRack) {\n+        Collection<SupervisorDistribution> supervisorDistributions = SupervisorDistribution.getSupervisorDistribution02();\n+        Map<String, Collection<SupervisorDistribution>> byRackId = SupervisorDistribution.mapByRackId(supervisorDistributions);\n+        LOG.info(\"Cluster={}, Designed capacity: {}\", TEST_CLUSTER_NAME, SupervisorDistribution.clusterCapacity(supervisorDistributions));\n+\n+        Map<String, SupervisorDetails> retList = new HashMap<>();\n+        Map<String, AtomicInteger> seenRacks = new HashMap<>();\n+        byRackId.forEach((rackId, list) -> {\n+            int tmpRackSupervisorCnt = list.stream().mapToInt(x -> x.supervisorCnt).sum() - Math.abs(reducedSupervisorsPerRack);\n+            if (tmpRackSupervisorCnt > Math.abs(reducedSupervisorsPerRack)) {\n+                tmpRackSupervisorCnt -= Math.abs(reducedSupervisorsPerRack);\n             }\n-            for (int rack = 12 ; rack < 14 ; rack++) {\n-                double cpu = 2400; // %percent\n-                double mem = 118_100; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+            final int adjustedRackSupervisorCnt = tmpRackSupervisorCnt;\n+            list.forEach(x -> {\n+                int supervisorCnt = x.supervisorCnt;\n+                for (int i = 0; i < supervisorCnt ; i++) {\n+                    int superInRack = seenRacks.computeIfAbsent(rackId, z -> new AtomicInteger(-1)).incrementAndGet();\n+                    int rackNum = seenRacks.size() - 1;\n+                    if (superInRack >= adjustedRackSupervisorCnt) {\n+                        continue;\n+                    }\n+                    createAndAddOneSupervisor(rackNum, superInRack, x.cpuPercent, x.memoryMb, x.slotCnt, retList);\n                 }\n+            });\n+        });\n+        return retList;\n+    }\n+\n+    /**\n+     * Create supervisors for a non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use.\n+     *\n+     * @param reducedSupervisorsPerRack is the reduction in supervisors per rack to constrain capacity (15 is tight)\n+     * @return supervisor details indexed by id\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisorsForCluster01(int reducedSupervisorsPerRack) {\n+        int numSupersPerRack = 82 - Math.abs(reducedSupervisorsPerRack);\n+        int numPorts = 50;\n+\n+        Map<String, SupervisorDetails> retList = new HashMap<>();\n+\n+        for (int rack = 0 ; rack < 12 ; rack++) {\n+            double cpu = 3600; // %percent\n+            double mem = 178_000; // MB\n+            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n             }\n-            for (int rack = 14 ; rack < 16 ; rack++) {\n-                double cpu = 1200; // %percent\n-                double mem = 42_480; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n+        }\n+        for (int rack = 12 ; rack < 14 ; rack++) {\n+            double cpu = 2400; // %percent\n+            double mem = 118_100; // MB\n+            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n             }\n-            return retList;\n         }\n+        for (int rack = 14 ; rack < 16 ; rack++) {\n+            double cpu = 1200; // %percent\n+            double mem = 42_480; // MB\n+            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+            }\n+        }\n+        return retList;\n     }\n \n     /**\n", "next_change": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex f1553dcb6..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -367,98 +374,73 @@ public class TestLargeCluster {\n         return retList;\n     }\n \n-    /**\n-     * Create supervisors for a non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use.\n-     *\n-     * @param reducedSupervisorsPerRack is the reduction in supervisors per rack to constrain capacity (15 is tight)\n-     * @return supervisor details indexed by id\n-     */\n-    private static Map<String, SupervisorDetails> createSupervisorsForCluster01(int reducedSupervisorsPerRack) {\n-        int numSupersPerRack = 82 - Math.abs(reducedSupervisorsPerRack);\n-        int numPorts = 50;\n-\n-        Map<String, SupervisorDetails> retList = new HashMap<>();\n-\n-        for (int rack = 0 ; rack < 12 ; rack++) {\n-            double cpu = 3600; // %percent\n-            double mem = 178_000; // MB\n-            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-            }\n-        }\n-        for (int rack = 12 ; rack < 14 ; rack++) {\n-            double cpu = 2400; // %percent\n-            double mem = 118_100; // MB\n-            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-            }\n-        }\n-        for (int rack = 14 ; rack < 16 ; rack++) {\n-            double cpu = 1200; // %percent\n-            double mem = 42_480; // MB\n-            for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-            }\n-        }\n-        return retList;\n-    }\n-\n     /**\n      * Create a large cluster, read topologies and configuration from resource directory and schedule.\n      *\n-     * @throws Exception\n+     * @throws Exception upon error.\n      */\n     @Test\n     public void testLargeCluster() throws Exception {\n-        Map<String, SupervisorDetails> supervisors = createSupervisors(0);\n+        for (TEST_CLUSTER_NAME testClusterName: TEST_CLUSTER_NAME.values()) {\n+            LOG.info(\"********************************************\");\n+            LOG.info(\"testLargeCluster: Start Processing cluster {}\", testClusterName.getClusterName());\n+\n+            String resourcePath = testClusterName.getResourcePath();\n+            Map<String, SupervisorDetails> supervisors = createSupervisors(testClusterName, 0);\n \n-        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(false);\n-        Assert.assertTrue(\"No topologies found\", topoDetailsArray.length > 0);\n-        Topologies topologies = new Topologies(topoDetailsArray);\n+            TopologyDetails[] topoDetailsArray = createTopoDetailsArray(resourcePath, false);\n+            Assert.assertTrue(\"No topologies found for cluster \" + testClusterName.getClusterName(), topoDetailsArray.length > 0);\n+            Topologies topologies = new Topologies(topoDetailsArray);\n \n-        Config confWithDefaultStrategy = new Config();\n-        confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n-        confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n-        confWithDefaultStrategy.put(\n+            Config confWithDefaultStrategy = new Config();\n+            confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n+            confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+            confWithDefaultStrategy.put(\n                 Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n                 TestUtilsForResourceAwareScheduler.GenSupervisorsDnsToSwitchMapping.class.getName());\n \n-        INimbus iNimbus = new INimbusTest();\n-        Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n+            INimbus iNimbus = new INimbusTest();\n+            Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n                 topologies, confWithDefaultStrategy);\n \n-        scheduler = new ResourceAwareScheduler();\n+            scheduler = new ResourceAwareScheduler();\n \n-        List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n+            List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n                 GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n                 Cluster.class\n-        );\n-        Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n-        long startTime = System.currentTimeMillis();\n-        scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-        scheduler.schedule(topologies, cluster);\n-        long endTime = System.currentTimeMillis();\n-        LOG.info(\"Scheduling Time: {} topologies in {} seconds\", topoDetailsArray.length, (endTime - startTime) / 1000.0);\n-\n-        for (TopologyDetails td : topoDetailsArray) {\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n-        }\n+            );\n+            Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n+            long startTime = System.currentTimeMillis();\n+            scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+            scheduler.schedule(topologies, cluster);\n+            long endTime = System.currentTimeMillis();\n+            LOG.info(\"Cluster={} Scheduling Time: {} topologies in {} seconds\",\n+                testClusterName.getClusterName(), topoDetailsArray.length, (endTime - startTime) / 1000.0);\n+\n+            for (TopologyDetails td : topoDetailsArray) {\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+            }\n+\n+            // Remove topology and reschedule it\n+            for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n+                startTime = System.currentTimeMillis();\n+                TopologyDetails topoDetails = topoDetailsArray[i];\n+                cluster.unassign(topoDetails.getId());\n+                LOG.info(\"Cluster={},  ({}) Removed topology {}\", testClusterName.getClusterName(), i, topoDetails.getName());\n+                IScheduler rescheduler = new ResourceAwareScheduler();\n+                rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+                rescheduler.schedule(topologies, cluster);\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n+                endTime = System.currentTimeMillis();\n+                LOG.info(\"Cluster={}, ({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\",\n+                    testClusterName.getClusterName(), i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+            }\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n \n-        // Remove topology and reschedule it\n-        for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n-            startTime = System.currentTimeMillis();\n-            TopologyDetails topoDetails = topoDetailsArray[i];\n-            cluster.unassign(topoDetails.getId());\n-            LOG.info(\"({}) Removed topology {}\", i, topoDetails.getName());\n-            IScheduler rescheduler = new ResourceAwareScheduler();\n-            rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-            rescheduler.schedule(topologies, cluster);\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n-            endTime = System.currentTimeMillis();\n-            LOG.info(\"({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\", i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+            LOG.info(\"testLargeCluster: End Processing cluster {}\", testClusterName.getClusterName());\n+            LOG.info(\"********************************************\");\n         }\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n     }\n \n     public static class SupervisorDistribution {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjU5OQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406456599", "body": "Which one we want to keep? ` iTopo = i` or `random.nextInt(topoDetailsArray.length);`", "bodyText": "Which one we want to keep?  iTopo = i or random.nextInt(topoDetailsArray.length);", "bodyHTML": "<p dir=\"auto\">Which one we want to keep? <code> iTopo = i</code> or <code>random.nextInt(topoDetailsArray.length);</code></p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:24:53Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    public static ClassLoader getContextClassLoader() {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n+     * resource path.\n+     *\n+     * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n+     * @return An array of TopologyDetails representing resource files.\n+     * @throws Exception\n+     */\n+    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+        List<TopologyDetails> topoDetailsList = new ArrayList<>();\n+        List<String> errors = new ArrayList<>();\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Map<String, String> codeResourceMap = new TreeMap<>();\n+        Map<String, String> confResourceMap = new HashMap<>();\n+        for (int i = 0 ; i < resources.size() ; i++) {\n+            String resource = resources.get(i);\n+            int idxOfSlash = resource.lastIndexOf(\"/\");\n+            int idxOfDash = resource.lastIndexOf(\"-\");\n+            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n+            if (resource.endsWith(\"code.ser\")) {\n+                codeResourceMap.put(nm, resource);\n+            } else if (resource.endsWith(\"conf.ser\")) {\n+                confResourceMap.put(nm, resource);\n+            } else {\n+                LOG.info(\"Ignoring unsupported resource file \" + resource);\n+            }\n+        }\n+        String[] examinedConfParams = {\n+                Config.TOPOLOGY_NAME,\n+                Config.TOPOLOGY_SCHEDULER_STRATEGY,\n+                Config.TOPOLOGY_PRIORITY,\n+                Config.TOPOLOGY_WORKERS,\n+                Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB,\n+                Config.TOPOLOGY_SUBMITTER_USER,\n+                Config.TOPOLOGY_ACKER_CPU_PCORE_PERCENT,\n+                Config.TOPOLOGY_ACKER_RESOURCES_OFFHEAP_MEMORY_MB,\n+                Config.TOPOLOGY_ACKER_RESOURCES_ONHEAP_MEMORY_MB,\n+        };\n+\n+        for (String nm : codeResourceMap.keySet()) {\n+            String codeResource = codeResourceMap.get(nm);\n+            if (!confResourceMap.containsKey(nm)) {\n+                String err = String.format(\"Ignoring topology file %s because of missing config file for %s\", codeResource, nm);\n+                errors.add(err);\n+                LOG.error(err);\n+                continue;\n+            }\n+            String confResource = confResourceMap.get(nm);\n+            LOG.info(\"Found matching topology and config files: {}, {}\", codeResource, confResource);\n+            StormTopology stormTopology;\n+            try {\n+                stormTopology = Utils.deserialize(getResourceAsBytes(codeResource), StormTopology.class);\n+            } catch (Exception ex) {\n+                String err = String.format(\"Cannot read topology from resource %s\", codeResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+\n+            Map<String, Object> conf;\n+            try {\n+                conf = Utils.fromCompressedJsonConf(getResourceAsBytes(confResource));\n+            } catch (RuntimeException | IOException ex) {\n+                String err = String.format(\"Cannot read configuration from resource %s\", confResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+            // fix 0.10 conf class names\n+            String[] configParamsToFix = {Config.TOPOLOGY_SCHEDULER_STRATEGY, Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n+                    DaemonConfig.RESOURCE_AWARE_SCHEDULER_PRIORITY_STRATEGY };\n+            for (String configParam: configParamsToFix) {\n+                if (!conf.containsKey(configParam)) {\n+                    continue;\n+                }\n+                String className = (String) conf.get(configParam);\n+                if (className.startsWith(\"backtype\")) {\n+                    className = className.replace(\"backtype\", \"org.apache\");\n+                    conf.put(configParam, className);\n+                }\n+            }\n+            // fix conf params used by ConstraintSolverStrategy\n+            if (!conf.containsKey(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH)) {\n+                conf.put(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH, 10_000);\n+            }\n+            if (!conf.containsKey(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH)) {\n+                conf.put(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH, 10_000);\n+            }\n+\n+            String topoId = nm;\n+            String topoName = (String) conf.getOrDefault(Config.TOPOLOGY_NAME, nm);\n+\n+            // conf\n+            StringBuffer sb = new StringBuffer(\"Config for \" + nm + \": \");\n+            for (String param : examinedConfParams) {\n+                Object val = conf.getOrDefault(param, \"<null>\");\n+                sb.append(param).append(\"=\").append(val).append(\", \");\n+            }\n+            LOG.info(sb.toString());\n+\n+            // topo\n+            Map<ExecutorDetails, String> execToComp = TestUtilsForResourceAwareScheduler.genExecsAndComps(stormTopology);\n+            LOG.info(\"Topology \\\"{}\\\" spouts={}, bolts={}, execToComp size is {}\", topoName,\n+                    stormTopology.get_spouts_size(), stormTopology.get_bolts_size(), execToComp.size());\n+            int numWorkers = Integer.parseInt(\"\" + conf.getOrDefault(Config.TOPOLOGY_WORKERS, \"0\"));\n+            TopologyDetails topo = new TopologyDetails(topoId, conf, stormTopology,  numWorkers,\n+                    execToComp, Time.currentTimeSecs(), \"user\");\n+            topo.getComponents(); // sanity check - normally this should not fail\n+\n+            topoDetailsList.add(topo);\n+        }\n+        if (!errors.isEmpty() && failOnParseError) {\n+            throw new Exception(\"Unable to parse all serialized objects\\n\\t\" + String.join(\"\\n\\t\", errors));\n+        }\n+        return topoDetailsList.toArray(new TopologyDetails[0]);\n+    }\n+\n+    /**\n+     * Check if the files in the resource directory are matched, can be read properly, and code/config files occur\n+     * in matched pairs.\n+     *\n+     * @throws Exception showing bad and unmatched resource files.\n+     */\n+    @Test\n+    public void testReadSerializedTopologiesAndConfigs() throws Exception {\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Assert.assertTrue(\"No resource files found in \" + TEST_RESOURCE_PATH, !resources.isEmpty());\n+        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(true);\n+    }\n+\n+    /**\n+     * Create one supervisor and add to the supervisors list.\n+     *\n+     * @param rack rack-number\n+     * @param superInRack supervisor number in the rack\n+     * @param cpu percentage\n+     * @param mem in megabytes\n+     * @param numPorts number of ports on this supervisor\n+     * @param sups returned map os supervisors\n+     */\n+    private static void createAndAddOneSupervisor(\n+            int rack, int superInRack, double cpu, double mem, int numPorts,\n+            Map<String, SupervisorDetails> sups) {\n+\n+        List<Number> ports = new LinkedList<>();\n+        for (int p = 0; p < numPorts; p++) {\n+            ports.add(p);\n+        }\n+        String superId = String.format(\"r%03ds%03d\", rack, superInRack);\n+        String hostId  = String.format(\"host-%03d-rack-%03d\", superInRack, rack);\n+        Map<String, Double> resourceMap = new HashMap<>();\n+        resourceMap.put(Config.SUPERVISOR_CPU_CAPACITY, cpu);\n+        resourceMap.put(Config.SUPERVISOR_MEMORY_CAPACITY_MB, mem);\n+        resourceMap.put(\"network.resource.units\", 50.0);\n+        SupervisorDetails sup = new SupervisorDetails(superId,\n+                hostId, null, ports,\n+                NormalizedResources.RESOURCE_NAME_NORMALIZER.normalizedResourceMap(resourceMap));\n+        sups.put(sup.getId(), sup);\n+    }\n+\n+    /**\n+     * Create supervisors.\n+     *\n+     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n+     * @return supervisor details indexed by id\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n+        Map<String, SupervisorDetails> retVal;\n+        if (uniformSupervisors) {\n+            int numRacks = 16;\n+            int numSupersPerRack = 82;\n+            int numPorts = 50; // scheduling will fill up 2-6, leaving of 90% workerslots unused - does this cause slow scheduling?\n+            int rackStart = 0;\n+            int superInRackStart = 1;\n+            double cpu = 7200; // %percent\n+            double mem = 356_000; // MB\n+            Map<String, Double> miscResources = new HashMap<>();\n+            miscResources.put(\"network.resource.units\", 100.0);\n+\n+            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n+                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n+\n+        } else {\n+            // this non-uniform supervisor distribution closelt (but not exactly) mimics IridiumBlue cluster\n+            int numSupersPerRack = 82;\n+            int numPorts = 50;\n+\n+            Map<String, SupervisorDetails> retList = new HashMap<>();\n+\n+            for (int rack = 0 ; rack < 12 ; rack++) {\n+                double cpu = 3600; // %percent\n+                double mem = 178_000; // MB\n+                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+                }\n+            }\n+            for (int rack = 12 ; rack < 14 ; rack++) {\n+                double cpu = 2400; // %percent\n+                double mem = 118_100; // MB\n+                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+                }\n+            }\n+            for (int rack = 14 ; rack < 16 ; rack++) {\n+                double cpu = 1200; // %percent\n+                double mem = 42_480; // MB\n+                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+                }\n+            }\n+            return retList;\n+        }\n+    }\n+\n+    /**\n+     * Create a large cluster, read topologies and configuration from resource directory and schedule.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testLargeCluster() throws Exception {\n+        boolean uniformSupervisors = false; // false means non-uniform supervisor distribution\n+\n+        Map<String, SupervisorDetails> supervisors = createSupervisors(uniformSupervisors);\n+\n+        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(false);\n+        Assert.assertTrue(\"No topologies found\", topoDetailsArray.length > 0);\n+        Topologies topologies = new Topologies(topoDetailsArray);\n+\n+        Config confWithDefaultStrategy = new Config();\n+        confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n+        confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+\n+        INimbus iNimbus = new INimbusTest();\n+        Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n+                topologies, confWithDefaultStrategy);\n+\n+        scheduler = new ResourceAwareScheduler();\n+\n+        List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n+                GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n+                Cluster.class // count calls to calculateSharedOffHeapNodeMemory()\n+        );\n+        Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n+        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n+        long startTime = System.currentTimeMillis();\n+        scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+        scheduler.schedule(topologies, cluster);\n+        long endTime = System.currentTimeMillis();\n+        LOG.info(\"Scheduling Time: {} topologies in {} seconds\", topoDetailsArray.length, (endTime - startTime) / 1000.0);\n+\n+        for (TopologyDetails td : topoDetailsArray) {\n+            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+        }\n+\n+        // Remove topology and reschedule it\n+        java.util.Random random = new java.util.Random();\n+        for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n+            startTime = System.currentTimeMillis();\n+            int iTopo = i; // random.nextInt(topoDetailsArray.length);", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5NTcyOA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406495728", "bodyText": "i for now.", "author": "bipinprasad", "createdAt": "2020-04-09T21:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDUxMQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406510511", "bodyText": "Maybe clean it up to avoid confusion. Pick one", "author": "Ethanlm", "createdAt": "2020-04-09T22:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMTQ1NA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406531454", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-04-09T23:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex ed7d84be0..cf18c6cb4 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -400,11 +405,9 @@ public class TestLargeCluster {\n         }\n \n         // Remove topology and reschedule it\n-        java.util.Random random = new java.util.Random();\n         for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n             startTime = System.currentTimeMillis();\n-            int iTopo = i; // random.nextInt(topoDetailsArray.length);\n-            TopologyDetails topoDetails = topoDetailsArray[iTopo];\n+            TopologyDetails topoDetails = topoDetailsArray[i];\n             cluster.unassign(topoDetails.getId());\n             LOG.info(\"({}) Removed topology {}\", i, topoDetails.getName());\n             IScheduler rescheduler = new ResourceAwareScheduler();\n", "next_change": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex cf18c6cb4..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -310,114 +336,234 @@ public class TestLargeCluster {\n     }\n \n     /**\n-     * Create supervisors.\n+     * Create supervisors based on a predefined supervisor distribution modeled after an existing\n+     * large cluster in use.\n      *\n-     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n-     * @return supervisor details indexed by id\n+     * @param testClusterName cluster for which the supervisors are created.\n+     * @param reducedSupervisorsPerRack number of supervisors to reduce per rack.\n+     * @return created supervisors.\n      */\n-    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n-        Map<String, SupervisorDetails> retVal;\n-        if (uniformSupervisors) {\n-            int numRacks = 16;\n-            int numSupersPerRack = 82;\n-            int numPorts = 50; // note: scheduling is slower when components with large cpu/mem leave large percent of workerslots unused\n-            int rackStart = 0;\n-            int superInRackStart = 1;\n-            double cpu = 7200; // %percent\n-            double mem = 356_000; // MB\n-            Map<String, Double> miscResources = new HashMap<>();\n-            miscResources.put(\"network.resource.units\", 100.0);\n-\n-            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n-                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n-\n-        } else {\n-            // this non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use\n-            int numSupersPerRack = 82;\n-            int numPorts = 50;\n-\n-            Map<String, SupervisorDetails> retList = new HashMap<>();\n-\n-            for (int rack = 0 ; rack < 12 ; rack++) {\n-                double cpu = 3600; // %percent\n-                double mem = 178_000; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n+    private static Map<String, SupervisorDetails> createSupervisors(\n+        TEST_CLUSTER_NAME testClusterName, int reducedSupervisorsPerRack) {\n+\n+        Collection<SupervisorDistribution> supervisorDistributions = SupervisorDistribution.getSupervisorDistribution(testClusterName);\n+        Map<String, Collection<SupervisorDistribution>> byRackId = SupervisorDistribution.mapByRackId(supervisorDistributions);\n+        LOG.info(\"Cluster={}, Designed capacity: {}\",\n+            testClusterName.getClusterName(), SupervisorDistribution.clusterCapacity(supervisorDistributions));\n+\n+        Map<String, SupervisorDetails> retList = new HashMap<>();\n+        Map<String, AtomicInteger> seenRacks = new HashMap<>();\n+        byRackId.forEach((rackId, list) -> {\n+            int tmpRackSupervisorCnt = list.stream().mapToInt(x -> x.supervisorCnt).sum() - Math.abs(reducedSupervisorsPerRack);\n+            if (tmpRackSupervisorCnt > Math.abs(reducedSupervisorsPerRack)) {\n+                tmpRackSupervisorCnt -= Math.abs(reducedSupervisorsPerRack);\n             }\n-            for (int rack = 12 ; rack < 14 ; rack++) {\n-                double cpu = 2400; // %percent\n-                double mem = 118_100; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+            final int adjustedRackSupervisorCnt = tmpRackSupervisorCnt;\n+            list.forEach(x -> {\n+                int supervisorCnt = x.supervisorCnt;\n+                for (int i = 0; i < supervisorCnt; i++) {\n+                    int superInRack = seenRacks.computeIfAbsent(rackId, z -> new AtomicInteger(-1)).incrementAndGet();\n+                    int rackNum = seenRacks.size() - 1;\n+                    if (superInRack >= adjustedRackSupervisorCnt) {\n+                        continue;\n+                    }\n+                    createAndAddOneSupervisor(rackNum, superInRack, x.cpuPercent, x.memoryMb, x.slotCnt, retList);\n                 }\n-            }\n-            for (int rack = 14 ; rack < 16 ; rack++) {\n-                double cpu = 1200; // %percent\n-                double mem = 42_480; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n-            }\n-            return retList;\n-        }\n+            });\n+        });\n+        return retList;\n     }\n \n     /**\n      * Create a large cluster, read topologies and configuration from resource directory and schedule.\n      *\n-     * @throws Exception\n+     * @throws Exception upon error.\n      */\n     @Test\n     public void testLargeCluster() throws Exception {\n-        boolean uniformSupervisors = false; // false means non-uniform supervisor distribution\n+        for (TEST_CLUSTER_NAME testClusterName: TEST_CLUSTER_NAME.values()) {\n+            LOG.info(\"********************************************\");\n+            LOG.info(\"testLargeCluster: Start Processing cluster {}\", testClusterName.getClusterName());\n+\n+            String resourcePath = testClusterName.getResourcePath();\n+            Map<String, SupervisorDetails> supervisors = createSupervisors(testClusterName, 0);\n+\n+            TopologyDetails[] topoDetailsArray = createTopoDetailsArray(resourcePath, false);\n+            Assert.assertTrue(\"No topologies found for cluster \" + testClusterName.getClusterName(), topoDetailsArray.length > 0);\n+            Topologies topologies = new Topologies(topoDetailsArray);\n+\n+            Config confWithDefaultStrategy = new Config();\n+            confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n+            confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+            confWithDefaultStrategy.put(\n+                Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n+                TestUtilsForResourceAwareScheduler.GenSupervisorsDnsToSwitchMapping.class.getName());\n+\n+            INimbus iNimbus = new INimbusTest();\n+            Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n+                topologies, confWithDefaultStrategy);\n+\n+            scheduler = new ResourceAwareScheduler();\n \n-        Map<String, SupervisorDetails> supervisors = createSupervisors(uniformSupervisors);\n+            List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n+                GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n+                Cluster.class\n+            );\n+            Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n+            long startTime = System.currentTimeMillis();\n+            scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+            scheduler.schedule(topologies, cluster);\n+            long endTime = System.currentTimeMillis();\n+            LOG.info(\"Cluster={} Scheduling Time: {} topologies in {} seconds\",\n+                testClusterName.getClusterName(), topoDetailsArray.length, (endTime - startTime) / 1000.0);\n+\n+            for (TopologyDetails td : topoDetailsArray) {\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+            }\n \n-        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(false);\n-        Assert.assertTrue(\"No topologies found\", topoDetailsArray.length > 0);\n-        Topologies topologies = new Topologies(topoDetailsArray);\n+            // Remove topology and reschedule it\n+            for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n+                startTime = System.currentTimeMillis();\n+                TopologyDetails topoDetails = topoDetailsArray[i];\n+                cluster.unassign(topoDetails.getId());\n+                LOG.info(\"Cluster={},  ({}) Removed topology {}\", testClusterName.getClusterName(), i, topoDetails.getName());\n+                IScheduler rescheduler = new ResourceAwareScheduler();\n+                rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+                rescheduler.schedule(topologies, cluster);\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n+                endTime = System.currentTimeMillis();\n+                LOG.info(\"Cluster={}, ({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\",\n+                    testClusterName.getClusterName(), i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+            }\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n \n-        Config confWithDefaultStrategy = new Config();\n-        confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n-        confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+            LOG.info(\"testLargeCluster: End Processing cluster {}\", testClusterName.getClusterName());\n+            LOG.info(\"********************************************\");\n+        }\n+    }\n \n-        INimbus iNimbus = new INimbusTest();\n-        Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n-                topologies, confWithDefaultStrategy);\n+    public static class SupervisorDistribution {\n+        final String rackId;\n+        final int supervisorCnt;\n+        final int slotCnt;\n+        final int memoryMb;\n+        final int cpuPercent;\n+\n+        public SupervisorDistribution(int supervisorCnt, String rackId, int slotCnt, int memoryMb, int cpuPercent) {\n+            this.rackId = rackId;\n+            this.supervisorCnt = supervisorCnt;\n+            this.slotCnt = slotCnt;\n+            this.memoryMb = memoryMb;\n+            this.cpuPercent = cpuPercent;\n+        }\n \n-        scheduler = new ResourceAwareScheduler();\n+        public static Map<String, Collection<SupervisorDistribution>> mapByRackId(Collection<SupervisorDistribution> supervisors) {\n+            Map<String, Collection<SupervisorDistribution>> retVal = new HashMap<>();\n+            supervisors.forEach(x -> retVal.computeIfAbsent(x.rackId, rackId -> new ArrayList<>()).add(x));\n+            return retVal;\n+        }\n \n-        List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n-                GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n-                Cluster.class\n-        );\n-        Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n-        long startTime = System.currentTimeMillis();\n-        scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-        scheduler.schedule(topologies, cluster);\n-        long endTime = System.currentTimeMillis();\n-        LOG.info(\"Scheduling Time: {} topologies in {} seconds\", topoDetailsArray.length, (endTime - startTime) / 1000.0);\n-\n-        for (TopologyDetails td : topoDetailsArray) {\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+        public static Collection<SupervisorDistribution> getSupervisorDistribution(TEST_CLUSTER_NAME testClusterName) {\n+            switch (testClusterName) {\n+                case TEST_CLUSTER_01:\n+                    return getSupervisorDistribution01();\n+                case TEST_CLUSTER_02:\n+                    return getSupervisorDistribution02();\n+                case TEST_CLUSTER_03:\n+                default:\n+                    return getSupervisorDistribution03();\n+            }\n         }\n \n-        // Remove topology and reschedule it\n-        for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n-            startTime = System.currentTimeMillis();\n-            TopologyDetails topoDetails = topoDetailsArray[i];\n-            cluster.unassign(topoDetails.getId());\n-            LOG.info(\"({}) Removed topology {}\", i, topoDetails.getName());\n-            IScheduler rescheduler = new ResourceAwareScheduler();\n-            rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-            rescheduler.schedule(topologies, cluster);\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n-            endTime = System.currentTimeMillis();\n-            LOG.info(\"({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\", i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+        private static Collection<SupervisorDistribution> getSupervisorDistribution01() {\n+            int numSupersPerRack = 82;\n+            int numPorts = 50;\n+            int numSupersPerRackEven = numSupersPerRack / 2;\n+            int numSupersPerRackOdd = numSupersPerRack - numSupersPerRackEven;\n+\n+            List<SupervisorDistribution> ret = new ArrayList<>();\n+\n+            for (int rack = 0; rack < 12; rack++) {\n+                String rackId = String.format(\"r%03d\", rack);\n+                int cpu = 3600; // %percent\n+                int mem = 178_000; // MB\n+                int adjustedCpu = cpu - 100;\n+                ret.add(new SupervisorDistribution(numSupersPerRackEven, rackId, numPorts, mem, cpu));\n+                ret.add(new SupervisorDistribution(numSupersPerRackOdd, rackId, numPorts, mem, adjustedCpu));\n+            }\n+            for (int rack = 12; rack < 14; rack++) {\n+                String rackId = String.format(\"r%03d\", rack);\n+                int cpu = 2400; // %percent\n+                int mem = 118_100; // MB\n+                int adjustedCpu = cpu - 100;\n+                ret.add(new SupervisorDistribution(numSupersPerRackEven, rackId, numPorts, mem, cpu));\n+                ret.add(new SupervisorDistribution(numSupersPerRackOdd, rackId, numPorts, mem, adjustedCpu));\n+            }\n+            for (int rack = 14; rack < 16; rack++) {\n+                String rackId = String.format(\"r%03d\", rack);\n+                int cpu = 1200; // %percent\n+                int mem = 42_480; // MB\n+                int adjustedCpu = cpu - 100;\n+                ret.add(new SupervisorDistribution(numSupersPerRackEven, rackId, numPorts, mem, cpu));\n+                ret.add(new SupervisorDistribution(numSupersPerRackOdd, rackId, numPorts, mem, adjustedCpu));\n+            }\n+            return ret;\n+        }\n+\n+        public static Collection<SupervisorDistribution> getSupervisorDistribution02() {\n+            return Arrays.asList(\n+                // Cnt, Rack,    Slot, Mem, CPU\n+                new SupervisorDistribution(78, \"r001\", 12, 42461, 1100),\n+                new SupervisorDistribution(146, \"r002\", 36, 181362, 3500),\n+                new SupervisorDistribution(18, \"r003\", 36, 181362, 3500),\n+                new SupervisorDistribution(120, \"r004\", 36, 181362, 3500),\n+                new SupervisorDistribution(24, \"r005\", 36, 181362, 3500),\n+                new SupervisorDistribution(16, \"r005\", 48, 177748, 4700),\n+                new SupervisorDistribution(12, \"r006\", 18, 88305, 1800),\n+                new SupervisorDistribution(368, \"r006\", 36, 181205, 3500),\n+                new SupervisorDistribution(62, \"r007\", 48, 177748, 4700),\n+                new SupervisorDistribution(50, \"r008\", 36, 181348, 3500),\n+                new SupervisorDistribution(64, \"r008\", 48, 177748, 4700),\n+                new SupervisorDistribution(74, \"r009\", 48, 177748, 4700),\n+                new SupervisorDistribution(74, \"r010\", 48, 177748, 4700),\n+                new SupervisorDistribution(10, \"r011\", 48, 177748, 4700),\n+                new SupervisorDistribution(78, \"r012\", 24, 120688, 2300),\n+                new SupervisorDistribution(150, \"r013\", 48, 177748, 4700),\n+                new SupervisorDistribution(76, \"r014\", 36, 181362, 3500),\n+                new SupervisorDistribution(38, \"r015\", 48, 174431, 4700),\n+                new SupervisorDistribution(78, \"r016\", 36, 181375, 3500),\n+                new SupervisorDistribution(72, \"r017\", 36, 181362, 3500),\n+                new SupervisorDistribution(80, \"r018\", 36, 181362, 3500),\n+                new SupervisorDistribution(76, \"r019\", 36, 181362, 3500),\n+                new SupervisorDistribution(78, \"r020\", 24, 120696, 2300),\n+                new SupervisorDistribution(80, \"r021\", 24, 120696, 2300)\n+            );\n+        }\n+\n+        public static Collection<SupervisorDistribution> getSupervisorDistribution03() {\n+            return Arrays.asList(\n+                // Cnt, Rack,    Slot, Mem, CPU\n+                new SupervisorDistribution(40, \"r001\", 12, 58829, 1100),\n+                new SupervisorDistribution(40, \"r002\", 12, 58829, 1100)\n+            );\n+        }\n+\n+        public static String clusterCapacity(Collection<SupervisorDistribution> supervisorDistributions) {\n+            long cpuPercent = 0;\n+            long memoryMb = 0;\n+            int supervisorCnt = 0;\n+            Set<String> racks = new HashSet<>();\n+\n+            for (SupervisorDistribution x: supervisorDistributions) {\n+                memoryMb += ((long) x.supervisorCnt * x.memoryMb);\n+                cpuPercent += ((long) x.supervisorCnt * x.cpuPercent);\n+                supervisorCnt += x.supervisorCnt;\n+                racks.add(x.rackId);\n+            }\n+            return String.format(\"Cluster summary: Racks=%d, Supervisors=%d, memoryMb=%d, cpuPercent=%d\",\n+                racks.size(), supervisorCnt, memoryMb, cpuPercent);\n         }\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n     }\n \n     public static class INimbusTest implements INimbus {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1Njk1Nw==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406456957", "body": "What does the comment mean here?", "bodyText": "What does the comment mean here?", "bodyHTML": "<p dir=\"auto\">What does the comment mean here?</p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:25:36Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    public static ClassLoader getContextClassLoader() {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n+     * resource path.\n+     *\n+     * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n+     * @return An array of TopologyDetails representing resource files.\n+     * @throws Exception\n+     */\n+    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+        List<TopologyDetails> topoDetailsList = new ArrayList<>();\n+        List<String> errors = new ArrayList<>();\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Map<String, String> codeResourceMap = new TreeMap<>();\n+        Map<String, String> confResourceMap = new HashMap<>();\n+        for (int i = 0 ; i < resources.size() ; i++) {\n+            String resource = resources.get(i);\n+            int idxOfSlash = resource.lastIndexOf(\"/\");\n+            int idxOfDash = resource.lastIndexOf(\"-\");\n+            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n+            if (resource.endsWith(\"code.ser\")) {\n+                codeResourceMap.put(nm, resource);\n+            } else if (resource.endsWith(\"conf.ser\")) {\n+                confResourceMap.put(nm, resource);\n+            } else {\n+                LOG.info(\"Ignoring unsupported resource file \" + resource);\n+            }\n+        }\n+        String[] examinedConfParams = {\n+                Config.TOPOLOGY_NAME,\n+                Config.TOPOLOGY_SCHEDULER_STRATEGY,\n+                Config.TOPOLOGY_PRIORITY,\n+                Config.TOPOLOGY_WORKERS,\n+                Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB,\n+                Config.TOPOLOGY_SUBMITTER_USER,\n+                Config.TOPOLOGY_ACKER_CPU_PCORE_PERCENT,\n+                Config.TOPOLOGY_ACKER_RESOURCES_OFFHEAP_MEMORY_MB,\n+                Config.TOPOLOGY_ACKER_RESOURCES_ONHEAP_MEMORY_MB,\n+        };\n+\n+        for (String nm : codeResourceMap.keySet()) {\n+            String codeResource = codeResourceMap.get(nm);\n+            if (!confResourceMap.containsKey(nm)) {\n+                String err = String.format(\"Ignoring topology file %s because of missing config file for %s\", codeResource, nm);\n+                errors.add(err);\n+                LOG.error(err);\n+                continue;\n+            }\n+            String confResource = confResourceMap.get(nm);\n+            LOG.info(\"Found matching topology and config files: {}, {}\", codeResource, confResource);\n+            StormTopology stormTopology;\n+            try {\n+                stormTopology = Utils.deserialize(getResourceAsBytes(codeResource), StormTopology.class);\n+            } catch (Exception ex) {\n+                String err = String.format(\"Cannot read topology from resource %s\", codeResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+\n+            Map<String, Object> conf;\n+            try {\n+                conf = Utils.fromCompressedJsonConf(getResourceAsBytes(confResource));\n+            } catch (RuntimeException | IOException ex) {\n+                String err = String.format(\"Cannot read configuration from resource %s\", confResource);\n+                errors.add(err);\n+                LOG.error(err, ex);\n+                continue;\n+            }\n+            // fix 0.10 conf class names\n+            String[] configParamsToFix = {Config.TOPOLOGY_SCHEDULER_STRATEGY, Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n+                    DaemonConfig.RESOURCE_AWARE_SCHEDULER_PRIORITY_STRATEGY };\n+            for (String configParam: configParamsToFix) {\n+                if (!conf.containsKey(configParam)) {\n+                    continue;\n+                }\n+                String className = (String) conf.get(configParam);\n+                if (className.startsWith(\"backtype\")) {\n+                    className = className.replace(\"backtype\", \"org.apache\");\n+                    conf.put(configParam, className);\n+                }\n+            }\n+            // fix conf params used by ConstraintSolverStrategy\n+            if (!conf.containsKey(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH)) {\n+                conf.put(DaemonConfig.RESOURCE_AWARE_SCHEDULER_MAX_STATE_SEARCH, 10_000);\n+            }\n+            if (!conf.containsKey(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH)) {\n+                conf.put(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH, 10_000);\n+            }\n+\n+            String topoId = nm;\n+            String topoName = (String) conf.getOrDefault(Config.TOPOLOGY_NAME, nm);\n+\n+            // conf\n+            StringBuffer sb = new StringBuffer(\"Config for \" + nm + \": \");\n+            for (String param : examinedConfParams) {\n+                Object val = conf.getOrDefault(param, \"<null>\");\n+                sb.append(param).append(\"=\").append(val).append(\", \");\n+            }\n+            LOG.info(sb.toString());\n+\n+            // topo\n+            Map<ExecutorDetails, String> execToComp = TestUtilsForResourceAwareScheduler.genExecsAndComps(stormTopology);\n+            LOG.info(\"Topology \\\"{}\\\" spouts={}, bolts={}, execToComp size is {}\", topoName,\n+                    stormTopology.get_spouts_size(), stormTopology.get_bolts_size(), execToComp.size());\n+            int numWorkers = Integer.parseInt(\"\" + conf.getOrDefault(Config.TOPOLOGY_WORKERS, \"0\"));\n+            TopologyDetails topo = new TopologyDetails(topoId, conf, stormTopology,  numWorkers,\n+                    execToComp, Time.currentTimeSecs(), \"user\");\n+            topo.getComponents(); // sanity check - normally this should not fail\n+\n+            topoDetailsList.add(topo);\n+        }\n+        if (!errors.isEmpty() && failOnParseError) {\n+            throw new Exception(\"Unable to parse all serialized objects\\n\\t\" + String.join(\"\\n\\t\", errors));\n+        }\n+        return topoDetailsList.toArray(new TopologyDetails[0]);\n+    }\n+\n+    /**\n+     * Check if the files in the resource directory are matched, can be read properly, and code/config files occur\n+     * in matched pairs.\n+     *\n+     * @throws Exception showing bad and unmatched resource files.\n+     */\n+    @Test\n+    public void testReadSerializedTopologiesAndConfigs() throws Exception {\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Assert.assertTrue(\"No resource files found in \" + TEST_RESOURCE_PATH, !resources.isEmpty());\n+        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(true);\n+    }\n+\n+    /**\n+     * Create one supervisor and add to the supervisors list.\n+     *\n+     * @param rack rack-number\n+     * @param superInRack supervisor number in the rack\n+     * @param cpu percentage\n+     * @param mem in megabytes\n+     * @param numPorts number of ports on this supervisor\n+     * @param sups returned map os supervisors\n+     */\n+    private static void createAndAddOneSupervisor(\n+            int rack, int superInRack, double cpu, double mem, int numPorts,\n+            Map<String, SupervisorDetails> sups) {\n+\n+        List<Number> ports = new LinkedList<>();\n+        for (int p = 0; p < numPorts; p++) {\n+            ports.add(p);\n+        }\n+        String superId = String.format(\"r%03ds%03d\", rack, superInRack);\n+        String hostId  = String.format(\"host-%03d-rack-%03d\", superInRack, rack);\n+        Map<String, Double> resourceMap = new HashMap<>();\n+        resourceMap.put(Config.SUPERVISOR_CPU_CAPACITY, cpu);\n+        resourceMap.put(Config.SUPERVISOR_MEMORY_CAPACITY_MB, mem);\n+        resourceMap.put(\"network.resource.units\", 50.0);\n+        SupervisorDetails sup = new SupervisorDetails(superId,\n+                hostId, null, ports,\n+                NormalizedResources.RESOURCE_NAME_NORMALIZER.normalizedResourceMap(resourceMap));\n+        sups.put(sup.getId(), sup);\n+    }\n+\n+    /**\n+     * Create supervisors.\n+     *\n+     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n+     * @return supervisor details indexed by id\n+     */\n+    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n+        Map<String, SupervisorDetails> retVal;\n+        if (uniformSupervisors) {\n+            int numRacks = 16;\n+            int numSupersPerRack = 82;\n+            int numPorts = 50; // scheduling will fill up 2-6, leaving of 90% workerslots unused - does this cause slow scheduling?\n+            int rackStart = 0;\n+            int superInRackStart = 1;\n+            double cpu = 7200; // %percent\n+            double mem = 356_000; // MB\n+            Map<String, Double> miscResources = new HashMap<>();\n+            miscResources.put(\"network.resource.units\", 100.0);\n+\n+            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n+                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n+\n+        } else {\n+            // this non-uniform supervisor distribution closelt (but not exactly) mimics IridiumBlue cluster\n+            int numSupersPerRack = 82;\n+            int numPorts = 50;\n+\n+            Map<String, SupervisorDetails> retList = new HashMap<>();\n+\n+            for (int rack = 0 ; rack < 12 ; rack++) {\n+                double cpu = 3600; // %percent\n+                double mem = 178_000; // MB\n+                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+                }\n+            }\n+            for (int rack = 12 ; rack < 14 ; rack++) {\n+                double cpu = 2400; // %percent\n+                double mem = 118_100; // MB\n+                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+                }\n+            }\n+            for (int rack = 14 ; rack < 16 ; rack++) {\n+                double cpu = 1200; // %percent\n+                double mem = 42_480; // MB\n+                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n+                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+                }\n+            }\n+            return retList;\n+        }\n+    }\n+\n+    /**\n+     * Create a large cluster, read topologies and configuration from resource directory and schedule.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testLargeCluster() throws Exception {\n+        boolean uniformSupervisors = false; // false means non-uniform supervisor distribution\n+\n+        Map<String, SupervisorDetails> supervisors = createSupervisors(uniformSupervisors);\n+\n+        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(false);\n+        Assert.assertTrue(\"No topologies found\", topoDetailsArray.length > 0);\n+        Topologies topologies = new Topologies(topoDetailsArray);\n+\n+        Config confWithDefaultStrategy = new Config();\n+        confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n+        confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+\n+        INimbus iNimbus = new INimbusTest();\n+        Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n+                topologies, confWithDefaultStrategy);\n+\n+        scheduler = new ResourceAwareScheduler();\n+\n+        List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n+                GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n+                Cluster.class // count calls to calculateSharedOffHeapNodeMemory()", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5MjM4Mw==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406492383", "bodyText": "I had debug statement earlier in Cluster.java - since removed. Comment is not relevant any more.\nRemoved.", "author": "bipinprasad", "createdAt": "2020-04-09T21:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1Njk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex ed7d84be0..cf18c6cb4 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -385,7 +390,7 @@ public class TestLargeCluster {\n \n         List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n                 GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n-                Cluster.class // count calls to calculateSharedOffHeapNodeMemory()\n+                Cluster.class\n         );\n         Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n         classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n", "next_change": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex cf18c6cb4..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -310,114 +336,234 @@ public class TestLargeCluster {\n     }\n \n     /**\n-     * Create supervisors.\n+     * Create supervisors based on a predefined supervisor distribution modeled after an existing\n+     * large cluster in use.\n      *\n-     * @param uniformSupervisors true if all supervisors are of the same size, false otherwise.\n-     * @return supervisor details indexed by id\n+     * @param testClusterName cluster for which the supervisors are created.\n+     * @param reducedSupervisorsPerRack number of supervisors to reduce per rack.\n+     * @return created supervisors.\n      */\n-    private static Map<String, SupervisorDetails> createSupervisors(boolean uniformSupervisors) {\n-        Map<String, SupervisorDetails> retVal;\n-        if (uniformSupervisors) {\n-            int numRacks = 16;\n-            int numSupersPerRack = 82;\n-            int numPorts = 50; // note: scheduling is slower when components with large cpu/mem leave large percent of workerslots unused\n-            int rackStart = 0;\n-            int superInRackStart = 1;\n-            double cpu = 7200; // %percent\n-            double mem = 356_000; // MB\n-            Map<String, Double> miscResources = new HashMap<>();\n-            miscResources.put(\"network.resource.units\", 100.0);\n-\n-            return TestUtilsForResourceAwareScheduler.genSupervisorsWithRacks(\n-                    numRacks, numSupersPerRack, numPorts, rackStart, superInRackStart, cpu, mem, miscResources);\n-\n-        } else {\n-            // this non-uniform supervisor distribution closely (but not exactly) mimics a large cluster in use\n-            int numSupersPerRack = 82;\n-            int numPorts = 50;\n-\n-            Map<String, SupervisorDetails> retList = new HashMap<>();\n-\n-            for (int rack = 0 ; rack < 12 ; rack++) {\n-                double cpu = 3600; // %percent\n-                double mem = 178_000; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n+    private static Map<String, SupervisorDetails> createSupervisors(\n+        TEST_CLUSTER_NAME testClusterName, int reducedSupervisorsPerRack) {\n+\n+        Collection<SupervisorDistribution> supervisorDistributions = SupervisorDistribution.getSupervisorDistribution(testClusterName);\n+        Map<String, Collection<SupervisorDistribution>> byRackId = SupervisorDistribution.mapByRackId(supervisorDistributions);\n+        LOG.info(\"Cluster={}, Designed capacity: {}\",\n+            testClusterName.getClusterName(), SupervisorDistribution.clusterCapacity(supervisorDistributions));\n+\n+        Map<String, SupervisorDetails> retList = new HashMap<>();\n+        Map<String, AtomicInteger> seenRacks = new HashMap<>();\n+        byRackId.forEach((rackId, list) -> {\n+            int tmpRackSupervisorCnt = list.stream().mapToInt(x -> x.supervisorCnt).sum() - Math.abs(reducedSupervisorsPerRack);\n+            if (tmpRackSupervisorCnt > Math.abs(reducedSupervisorsPerRack)) {\n+                tmpRackSupervisorCnt -= Math.abs(reducedSupervisorsPerRack);\n             }\n-            for (int rack = 12 ; rack < 14 ; rack++) {\n-                double cpu = 2400; // %percent\n-                double mem = 118_100; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n+            final int adjustedRackSupervisorCnt = tmpRackSupervisorCnt;\n+            list.forEach(x -> {\n+                int supervisorCnt = x.supervisorCnt;\n+                for (int i = 0; i < supervisorCnt; i++) {\n+                    int superInRack = seenRacks.computeIfAbsent(rackId, z -> new AtomicInteger(-1)).incrementAndGet();\n+                    int rackNum = seenRacks.size() - 1;\n+                    if (superInRack >= adjustedRackSupervisorCnt) {\n+                        continue;\n+                    }\n+                    createAndAddOneSupervisor(rackNum, superInRack, x.cpuPercent, x.memoryMb, x.slotCnt, retList);\n                 }\n-            }\n-            for (int rack = 14 ; rack < 16 ; rack++) {\n-                double cpu = 1200; // %percent\n-                double mem = 42_480; // MB\n-                for (int superInRack = 0; superInRack < numSupersPerRack ; superInRack++) {\n-                    createAndAddOneSupervisor(rack, superInRack, cpu - 100 * (superInRack % 2), mem, numPorts, retList);\n-                }\n-            }\n-            return retList;\n-        }\n+            });\n+        });\n+        return retList;\n     }\n \n     /**\n      * Create a large cluster, read topologies and configuration from resource directory and schedule.\n      *\n-     * @throws Exception\n+     * @throws Exception upon error.\n      */\n     @Test\n     public void testLargeCluster() throws Exception {\n-        boolean uniformSupervisors = false; // false means non-uniform supervisor distribution\n+        for (TEST_CLUSTER_NAME testClusterName: TEST_CLUSTER_NAME.values()) {\n+            LOG.info(\"********************************************\");\n+            LOG.info(\"testLargeCluster: Start Processing cluster {}\", testClusterName.getClusterName());\n+\n+            String resourcePath = testClusterName.getResourcePath();\n+            Map<String, SupervisorDetails> supervisors = createSupervisors(testClusterName, 0);\n+\n+            TopologyDetails[] topoDetailsArray = createTopoDetailsArray(resourcePath, false);\n+            Assert.assertTrue(\"No topologies found for cluster \" + testClusterName.getClusterName(), topoDetailsArray.length > 0);\n+            Topologies topologies = new Topologies(topoDetailsArray);\n+\n+            Config confWithDefaultStrategy = new Config();\n+            confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n+            confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+            confWithDefaultStrategy.put(\n+                Config.STORM_NETWORK_TOPOGRAPHY_PLUGIN,\n+                TestUtilsForResourceAwareScheduler.GenSupervisorsDnsToSwitchMapping.class.getName());\n+\n+            INimbus iNimbus = new INimbusTest();\n+            Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n+                topologies, confWithDefaultStrategy);\n+\n+            scheduler = new ResourceAwareScheduler();\n \n-        Map<String, SupervisorDetails> supervisors = createSupervisors(uniformSupervisors);\n+            List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n+                GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n+                Cluster.class\n+            );\n+            Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n+            long startTime = System.currentTimeMillis();\n+            scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+            scheduler.schedule(topologies, cluster);\n+            long endTime = System.currentTimeMillis();\n+            LOG.info(\"Cluster={} Scheduling Time: {} topologies in {} seconds\",\n+                testClusterName.getClusterName(), topoDetailsArray.length, (endTime - startTime) / 1000.0);\n+\n+            for (TopologyDetails td : topoDetailsArray) {\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+            }\n \n-        TopologyDetails[] topoDetailsArray = createTopoDetailsArray(false);\n-        Assert.assertTrue(\"No topologies found\", topoDetailsArray.length > 0);\n-        Topologies topologies = new Topologies(topoDetailsArray);\n+            // Remove topology and reschedule it\n+            for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n+                startTime = System.currentTimeMillis();\n+                TopologyDetails topoDetails = topoDetailsArray[i];\n+                cluster.unassign(topoDetails.getId());\n+                LOG.info(\"Cluster={},  ({}) Removed topology {}\", testClusterName.getClusterName(), i, topoDetails.getName());\n+                IScheduler rescheduler = new ResourceAwareScheduler();\n+                rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n+                rescheduler.schedule(topologies, cluster);\n+                TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n+                endTime = System.currentTimeMillis();\n+                LOG.info(\"Cluster={}, ({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\",\n+                    testClusterName.getClusterName(), i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+            }\n+            classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n \n-        Config confWithDefaultStrategy = new Config();\n-        confWithDefaultStrategy.putAll(topoDetailsArray[0].getConf());\n-        confWithDefaultStrategy.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, DefaultResourceAwareStrategy.class.getName());\n+            LOG.info(\"testLargeCluster: End Processing cluster {}\", testClusterName.getClusterName());\n+            LOG.info(\"********************************************\");\n+        }\n+    }\n \n-        INimbus iNimbus = new INimbusTest();\n-        Cluster cluster = new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supervisors, new HashMap<>(),\n-                topologies, confWithDefaultStrategy);\n+    public static class SupervisorDistribution {\n+        final String rackId;\n+        final int supervisorCnt;\n+        final int slotCnt;\n+        final int memoryMb;\n+        final int cpuPercent;\n+\n+        public SupervisorDistribution(int supervisorCnt, String rackId, int slotCnt, int memoryMb, int cpuPercent) {\n+            this.rackId = rackId;\n+            this.supervisorCnt = supervisorCnt;\n+            this.slotCnt = slotCnt;\n+            this.memoryMb = memoryMb;\n+            this.cpuPercent = cpuPercent;\n+        }\n \n-        scheduler = new ResourceAwareScheduler();\n+        public static Map<String, Collection<SupervisorDistribution>> mapByRackId(Collection<SupervisorDistribution> supervisors) {\n+            Map<String, Collection<SupervisorDistribution>> retVal = new HashMap<>();\n+            supervisors.forEach(x -> retVal.computeIfAbsent(x.rackId, rackId -> new ArrayList<>()).add(x));\n+            return retVal;\n+        }\n \n-        List<Class> classesToDebug = Arrays.asList(DefaultResourceAwareStrategy.class,\n-                GenericResourceAwareStrategy.class, ResourceAwareScheduler.class,\n-                Cluster.class\n-        );\n-        Level logLevel = Level.INFO ; // switch to Level.DEBUG for verbose otherwise Level.INFO\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), logLevel));\n-        long startTime = System.currentTimeMillis();\n-        scheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-        scheduler.schedule(topologies, cluster);\n-        long endTime = System.currentTimeMillis();\n-        LOG.info(\"Scheduling Time: {} topologies in {} seconds\", topoDetailsArray.length, (endTime - startTime) / 1000.0);\n-\n-        for (TopologyDetails td : topoDetailsArray) {\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, td.getName());\n+        public static Collection<SupervisorDistribution> getSupervisorDistribution(TEST_CLUSTER_NAME testClusterName) {\n+            switch (testClusterName) {\n+                case TEST_CLUSTER_01:\n+                    return getSupervisorDistribution01();\n+                case TEST_CLUSTER_02:\n+                    return getSupervisorDistribution02();\n+                case TEST_CLUSTER_03:\n+                default:\n+                    return getSupervisorDistribution03();\n+            }\n         }\n \n-        // Remove topology and reschedule it\n-        for (int i = 0 ; i < topoDetailsArray.length ; i++) {\n-            startTime = System.currentTimeMillis();\n-            TopologyDetails topoDetails = topoDetailsArray[i];\n-            cluster.unassign(topoDetails.getId());\n-            LOG.info(\"({}) Removed topology {}\", i, topoDetails.getName());\n-            IScheduler rescheduler = new ResourceAwareScheduler();\n-            rescheduler.prepare(confWithDefaultStrategy, new StormMetricsRegistry());\n-            rescheduler.schedule(topologies, cluster);\n-            TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled(cluster, topoDetails.getName());\n-            endTime = System.currentTimeMillis();\n-            LOG.info(\"({}) Scheduling Time: Removed topology {} and rescheduled in {} seconds\", i, topoDetails.getName(), (endTime - startTime) / 1000.0);\n+        private static Collection<SupervisorDistribution> getSupervisorDistribution01() {\n+            int numSupersPerRack = 82;\n+            int numPorts = 50;\n+            int numSupersPerRackEven = numSupersPerRack / 2;\n+            int numSupersPerRackOdd = numSupersPerRack - numSupersPerRackEven;\n+\n+            List<SupervisorDistribution> ret = new ArrayList<>();\n+\n+            for (int rack = 0; rack < 12; rack++) {\n+                String rackId = String.format(\"r%03d\", rack);\n+                int cpu = 3600; // %percent\n+                int mem = 178_000; // MB\n+                int adjustedCpu = cpu - 100;\n+                ret.add(new SupervisorDistribution(numSupersPerRackEven, rackId, numPorts, mem, cpu));\n+                ret.add(new SupervisorDistribution(numSupersPerRackOdd, rackId, numPorts, mem, adjustedCpu));\n+            }\n+            for (int rack = 12; rack < 14; rack++) {\n+                String rackId = String.format(\"r%03d\", rack);\n+                int cpu = 2400; // %percent\n+                int mem = 118_100; // MB\n+                int adjustedCpu = cpu - 100;\n+                ret.add(new SupervisorDistribution(numSupersPerRackEven, rackId, numPorts, mem, cpu));\n+                ret.add(new SupervisorDistribution(numSupersPerRackOdd, rackId, numPorts, mem, adjustedCpu));\n+            }\n+            for (int rack = 14; rack < 16; rack++) {\n+                String rackId = String.format(\"r%03d\", rack);\n+                int cpu = 1200; // %percent\n+                int mem = 42_480; // MB\n+                int adjustedCpu = cpu - 100;\n+                ret.add(new SupervisorDistribution(numSupersPerRackEven, rackId, numPorts, mem, cpu));\n+                ret.add(new SupervisorDistribution(numSupersPerRackOdd, rackId, numPorts, mem, adjustedCpu));\n+            }\n+            return ret;\n+        }\n+\n+        public static Collection<SupervisorDistribution> getSupervisorDistribution02() {\n+            return Arrays.asList(\n+                // Cnt, Rack,    Slot, Mem, CPU\n+                new SupervisorDistribution(78, \"r001\", 12, 42461, 1100),\n+                new SupervisorDistribution(146, \"r002\", 36, 181362, 3500),\n+                new SupervisorDistribution(18, \"r003\", 36, 181362, 3500),\n+                new SupervisorDistribution(120, \"r004\", 36, 181362, 3500),\n+                new SupervisorDistribution(24, \"r005\", 36, 181362, 3500),\n+                new SupervisorDistribution(16, \"r005\", 48, 177748, 4700),\n+                new SupervisorDistribution(12, \"r006\", 18, 88305, 1800),\n+                new SupervisorDistribution(368, \"r006\", 36, 181205, 3500),\n+                new SupervisorDistribution(62, \"r007\", 48, 177748, 4700),\n+                new SupervisorDistribution(50, \"r008\", 36, 181348, 3500),\n+                new SupervisorDistribution(64, \"r008\", 48, 177748, 4700),\n+                new SupervisorDistribution(74, \"r009\", 48, 177748, 4700),\n+                new SupervisorDistribution(74, \"r010\", 48, 177748, 4700),\n+                new SupervisorDistribution(10, \"r011\", 48, 177748, 4700),\n+                new SupervisorDistribution(78, \"r012\", 24, 120688, 2300),\n+                new SupervisorDistribution(150, \"r013\", 48, 177748, 4700),\n+                new SupervisorDistribution(76, \"r014\", 36, 181362, 3500),\n+                new SupervisorDistribution(38, \"r015\", 48, 174431, 4700),\n+                new SupervisorDistribution(78, \"r016\", 36, 181375, 3500),\n+                new SupervisorDistribution(72, \"r017\", 36, 181362, 3500),\n+                new SupervisorDistribution(80, \"r018\", 36, 181362, 3500),\n+                new SupervisorDistribution(76, \"r019\", 36, 181362, 3500),\n+                new SupervisorDistribution(78, \"r020\", 24, 120696, 2300),\n+                new SupervisorDistribution(80, \"r021\", 24, 120696, 2300)\n+            );\n+        }\n+\n+        public static Collection<SupervisorDistribution> getSupervisorDistribution03() {\n+            return Arrays.asList(\n+                // Cnt, Rack,    Slot, Mem, CPU\n+                new SupervisorDistribution(40, \"r001\", 12, 58829, 1100),\n+                new SupervisorDistribution(40, \"r002\", 12, 58829, 1100)\n+            );\n+        }\n+\n+        public static String clusterCapacity(Collection<SupervisorDistribution> supervisorDistributions) {\n+            long cpuPercent = 0;\n+            long memoryMb = 0;\n+            int supervisorCnt = 0;\n+            Set<String> racks = new HashSet<>();\n+\n+            for (SupervisorDistribution x: supervisorDistributions) {\n+                memoryMb += ((long) x.supervisorCnt * x.memoryMb);\n+                cpuPercent += ((long) x.supervisorCnt * x.cpuPercent);\n+                supervisorCnt += x.supervisorCnt;\n+                racks.add(x.rackId);\n+            }\n+            return String.format(\"Cluster summary: Racks=%d, Supervisors=%d, memoryMb=%d, cpuPercent=%d\",\n+                racks.size(), supervisorCnt, memoryMb, cpuPercent);\n         }\n-        classesToDebug.forEach(x -> Configurator.setLevel(x.getName(), Level.INFO));\n     }\n \n     public static class INimbusTest implements INimbus {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1Nzg3Nw==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406457877", "body": "Maybe clean up the comments if they are not needed", "bodyText": "Maybe clean up the comments if they are not needed", "bodyHTML": "<p dir=\"auto\">Maybe clean up the comments if they are not needed</p>", "author": "Ethanlm", "createdAt": "2020-04-09T20:27:23Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestTopologyAnonymizerUtils.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.Bolt;\n+import org.apache.storm.generated.GlobalStreamId;\n+import org.apache.storm.generated.SpoutSpec;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.serialization.GzipThriftSerializationDelegate;\n+import org.apache.storm.utils.Utils;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Anonymize Serialized Topologies and Configs with the goal of taking internally developed topologies and configuration\n+ * and make them publicly available for testing.\n+ *\n+ * Assume that topologies and configurations exist in the specified resource directory with names ending in stormcode.ser\n+ * and stormconf.ser respectively as they exist in blobstore. Also, stormconf.ser file shares the same name prefix with\n+ * the topology serialized file.\n+ *\n+ * <li> Rename topologies and its corresponding configuration (as identified by its resource name). Ensure that renamed\n+ * configuration file for a topology retains the proper linkage so that:\n+ *     <p>&lt;old-topo-name&gt;-stormcode.ser -&gt; &lt;new-topo-name&gt;-stormcode.ser</p> and its old conf\n+ *     <p>&lt;old-topo-name&gt;-stormconf.ser -&gt; &lt;new-topo-name&gt;-stormconf.ser</p>\n+ * </li>\n+ *\n+ * <li>Rename components in each of the topologies.</li>\n+ *\n+ * The new converted resource files can be copied to a resource directory under \"clusterconf\" and made available for use\n+ * in TestLargeCluster class.\n+ */\n+public class TestTopologyAnonymizerUtils {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestTopologyAnonymizerUtils.class);\n+\n+    private static final String DEFAULT_ORIGINAL_RESOURCES_PATH = \"clusterconf/iridiumblue\";\n+    private static final String DEFAULT_ANONYMIZED_RESOURCES_OUTDIR = \"src/test/resources/clusterconf/largeCluster01\";\n+\n+    private String originalResourcePath;\n+    private String outputDirPath;\n+\n+    public TestTopologyAnonymizerUtils() {\n+        this.originalResourcePath = DEFAULT_ORIGINAL_RESOURCES_PATH;\n+        this.outputDirPath = DEFAULT_ANONYMIZED_RESOURCES_OUTDIR;\n+    }\n+\n+    //public TestTopologyAnonymizerUtils(String originalResourcePath, String outputDirPath) {", "originalCommit": "4515a40cfeb391d62910f5f32951abe9f7b5277a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MzA5NA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r406483094", "bodyText": "removed", "author": "bipinprasad", "createdAt": "2020-04-09T21:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1Nzg3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestTopologyAnonymizerUtils.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestTopologyAnonymizerUtils.java\nindex 706d95b48..ee1b3378d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestTopologyAnonymizerUtils.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestTopologyAnonymizerUtils.java\n", "chunk": "@@ -76,11 +79,6 @@ public class TestTopologyAnonymizerUtils {\n         this.outputDirPath = DEFAULT_ANONYMIZED_RESOURCES_OUTDIR;\n     }\n \n-    //public TestTopologyAnonymizerUtils(String originalResourcePath, String outputDirPath) {\n-    //    this.originalResourcePath = originalResourcePath;\n-    //    this.outputDirPath = outputDirPath;\n-    //}\n-\n     /**\n      * Check if resource files are available in the resource path defined by originalResourcePath.\n      *\n", "next_change": null}]}}, {"oid": "772af366c158e84093552dec53399d70a9655c85", "url": "https://github.com/apache/storm/commit/772af366c158e84093552dec53399d70a9655c85", "message": "[STORM-3600] Use shared_memory instead of component_shared_memory.", "committedDate": "2020-04-10T00:54:23Z", "type": "commit"}, {"oid": "9b3eff3645b403df22fba92ecf0bb566d21824e7", "url": "https://github.com/apache/storm/commit/9b3eff3645b403df22fba92ecf0bb566d21824e7", "message": "[STORM-3600] Comment changes and cleanup.", "committedDate": "2020-04-10T00:56:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ4OQ==", "url": "https://github.com/apache/storm/pull/3244#discussion_r407731489", "body": "Nit: move these file extensions as constants to the head of the file", "bodyText": "Nit: move these file extensions as constants to the head of the file", "bodyHTML": "<p dir=\"auto\">Nit: move these file extensions as constants to the head of the file</p>", "author": "govind-menon", "createdAt": "2020-04-13T21:26:58Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {", "originalCommit": "9b3eff3645b403df22fba92ecf0bb566d21824e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1OTA3NA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r408559074", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-04-15T03:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex e381158e4..cf18c6cb4 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -100,7 +102,8 @@ public class TestLargeCluster {\n             String resource;\n \n             while ((resource = br.readLine()) != null) {\n-                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                if (resource.endsWith(COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING)\n+                        || resource.endsWith(COMPRESSED_SERIALIZED_CONFIG_FILENAME_ENDING)) {\n                     fileNames.add(path + \"/\" + resource);\n                 }\n             }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjUyNg==", "url": "https://github.com/apache/storm/pull/3244#discussion_r407732526", "body": "Nit: See above about extracting file extension as constants", "bodyText": "Nit: See above about extracting file extension as constants", "bodyHTML": "<p dir=\"auto\">Nit: See above about extracting file extension as constants</p>", "author": "govind-menon", "createdAt": "2020-04-13T21:29:09Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.scheduling;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.generated.StormTopology;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.ExecutorDetails;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.WorkerSlot;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResources;\n+import org.apache.storm.scheduler.resource.normalization.NormalizedResourcesExtension;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.utils.ObjectReader;\n+import org.apache.storm.utils.Time;\n+import org.apache.storm.utils.Utils;\n+import org.junit.Assert;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+@ExtendWith({NormalizedResourcesExtension.class})\n+public class TestLargeCluster {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n+\n+    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+\n+    private static IScheduler scheduler = null;\n+\n+    @AfterEach\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /**\n+     * Get the list of serialized topology (*code.ser) and configuration (*conf.ser)\n+     * resource files in the path. The resources are sorted so that paired topology and conf\n+     * files are sequential. Unpaired files may be ignored by the caller.\n+     *\n+     * @param path directory in which resources exist.\n+     * @return\n+     * @throws IOException\n+     */\n+    public static List<String> getResourceFiles(String path) throws IOException {\n+        List<String> fileNames = new ArrayList<>();\n+\n+        try (\n+                InputStream in = getResourceAsStream(path);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(in))\n+        ) {\n+            String resource;\n+\n+            while ((resource = br.readLine()) != null) {\n+                if (resource.endsWith(\"code.ser\") || resource.endsWith(\"conf.ser\")) {\n+                    fileNames.add(path + \"/\" + resource);\n+                }\n+            }\n+            Collections.sort(fileNames);\n+        }\n+        return fileNames;\n+    }\n+\n+    /**\n+     * InputStream to read the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     */\n+    public static InputStream getResourceAsStream(String resource) {\n+        final InputStream in = getContextClassLoader().getResourceAsStream(resource);\n+        return in == null ? ClassLoader.getSystemClassLoader().getResourceAsStream(resource) : in;\n+    }\n+\n+    /**\n+     * Read the contents of the fully qualified resource path.\n+     *\n+     * @param resource\n+     * @return\n+     * @throws Exception\n+     */\n+    public static byte[] getResourceAsBytes(String resource) throws Exception {\n+        InputStream in = getResourceAsStream(resource);\n+        if (in == null) {\n+            return null;\n+        }\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            while (in.available() > 0) {\n+                out.write(in.read());\n+            }\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    public static ClassLoader getContextClassLoader() {\n+        return Thread.currentThread().getContextClassLoader();\n+    }\n+\n+    /**\n+     * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n+     * resource path.\n+     *\n+     * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n+     * @return An array of TopologyDetails representing resource files.\n+     * @throws Exception\n+     */\n+    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+        List<TopologyDetails> topoDetailsList = new ArrayList<>();\n+        List<String> errors = new ArrayList<>();\n+        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        Map<String, String> codeResourceMap = new TreeMap<>();\n+        Map<String, String> confResourceMap = new HashMap<>();\n+        for (int i = 0 ; i < resources.size() ; i++) {\n+            String resource = resources.get(i);\n+            int idxOfSlash = resource.lastIndexOf(\"/\");\n+            int idxOfDash = resource.lastIndexOf(\"-\");\n+            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n+            if (resource.endsWith(\"code.ser\")) {", "originalCommit": "9b3eff3645b403df22fba92ecf0bb566d21824e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1ODk1Nw==", "url": "https://github.com/apache/storm/pull/3244#discussion_r408558957", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-04-15T03:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "7ffc44d083707bc60749fe6821f662fc730c6466", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex e381158e4..cf18c6cb4 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -162,10 +165,12 @@ public class TestLargeCluster {\n             String resource = resources.get(i);\n             int idxOfSlash = resource.lastIndexOf(\"/\");\n             int idxOfDash = resource.lastIndexOf(\"-\");\n-            String nm = idxOfDash > idxOfSlash ? resource.substring(idxOfSlash + 1, idxOfDash) : resource.substring(idxOfSlash + 1, resource.length() - 7);\n-            if (resource.endsWith(\"code.ser\")) {\n+            String nm = idxOfDash > idxOfSlash\n+                    ? resource.substring(idxOfSlash + 1, idxOfDash)\n+                    : resource.substring(idxOfSlash + 1, resource.length() - COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING.length());\n+            if (resource.endsWith(COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING)) {\n                 codeResourceMap.put(nm, resource);\n-            } else if (resource.endsWith(\"conf.ser\")) {\n+            } else if (resource.endsWith(COMPRESSED_SERIALIZED_CONFIG_FILENAME_ENDING)) {\n                 confResourceMap.put(nm, resource);\n             } else {\n                 LOG.info(\"Ignoring unsupported resource file \" + resource);\n", "next_change": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex cf18c6cb4..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -149,25 +167,24 @@ public class TestLargeCluster {\n \n     /**\n      * Create an array of TopologyDetails by reading serialized files for topology and configuration in the\n-     * resource path.\n+     * resource path. Skip topologies with no executors/components.\n      *\n      * @param failOnParseError throw exception if there are unmatched files, otherwise ignore unmatched and read errors.\n      * @return An array of TopologyDetails representing resource files.\n-     * @throws Exception\n+     * @throws Exception upon error in reading topology serialized files.\n      */\n-    public static TopologyDetails[] createTopoDetailsArray(boolean failOnParseError) throws Exception {\n+    public static TopologyDetails[] createTopoDetailsArray(String resourcePath, boolean failOnParseError) throws Exception {\n         List<TopologyDetails> topoDetailsList = new ArrayList<>();\n         List<String> errors = new ArrayList<>();\n-        List<String> resources = getResourceFiles(TEST_RESOURCE_PATH);\n+        List<String> resources = getResourceFiles(resourcePath);\n         Map<String, String> codeResourceMap = new TreeMap<>();\n         Map<String, String> confResourceMap = new HashMap<>();\n-        for (int i = 0 ; i < resources.size() ; i++) {\n-            String resource = resources.get(i);\n+        for (String resource : resources) {\n             int idxOfSlash = resource.lastIndexOf(\"/\");\n             int idxOfDash = resource.lastIndexOf(\"-\");\n             String nm = idxOfDash > idxOfSlash\n-                    ? resource.substring(idxOfSlash + 1, idxOfDash)\n-                    : resource.substring(idxOfSlash + 1, resource.length() - COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING.length());\n+                ? resource.substring(idxOfSlash + 1, idxOfDash)\n+                : resource.substring(idxOfSlash + 1, resource.length() - COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING.length());\n             if (resource.endsWith(COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING)) {\n                 codeResourceMap.put(nm, resource);\n             } else if (resource.endsWith(COMPRESSED_SERIALIZED_CONFIG_FILENAME_ENDING)) {\n", "next_change": null}]}}]}}, {"oid": "0c9d467efaf1c52647c24963571be594f6f4cebc", "url": "https://github.com/apache/storm/commit/0c9d467efaf1c52647c24963571be594f6f4cebc", "message": "[STORM-3600] Introduce constants for file name endings.", "committedDate": "2020-04-15T04:15:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4OTUwOA==", "url": "https://github.com/apache/storm/pull/3244#discussion_r408889508", "body": "There is a variable with the same name in TestTopologyAnonymizerUtils.java but with different meanings. What's the difference here?", "bodyText": "There is a variable with the same name in TestTopologyAnonymizerUtils.java but with different meanings. What's the difference here?", "bodyHTML": "<p dir=\"auto\">There is a variable with the same name in TestTopologyAnonymizerUtils.java but with different meanings. What's the difference here?</p>", "author": "Ethanlm", "createdAt": "2020-04-15T14:33:07Z", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java", "diffHunk": "@@ -70,6 +70,8 @@\n \n     public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n     public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n+    public static final String COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING = \"code.ser\";", "originalCommit": "0c9d467efaf1c52647c24963571be594f6f4cebc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkxMjk2Mw==", "url": "https://github.com/apache/storm/pull/3244#discussion_r408912963", "bodyText": "Anonymizer can be stricter with naming convention.  Files in the resources need just the bare minimum to be distinguished from each other. But more importantly, they are independent of each other.", "author": "bipinprasad", "createdAt": "2020-04-15T15:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4OTUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "1b870a829b84c31a1dba17139ff389762d523dbb", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex cf18c6cb4..f1553dcb6 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -63,12 +62,16 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n @ExtendWith({NormalizedResourcesExtension.class})\n public class TestLargeCluster {\n     private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n \n-    public static final String TEST_CLUSTER_NAME = \"largeCluster01\";\n+    public static final String TEST_CLUSTER_01 = \"largeCluster01\";\n+    public static final String TEST_CLUSTER_02 = \"largeCluster02\";\n+\n+    public static final String TEST_CLUSTER_NAME = TEST_CLUSTER_02;\n     public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n     public static final String COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING = \"code.ser\";\n     public static final String COMPRESSED_SERIALIZED_CONFIG_FILENAME_ENDING = \"conf.ser\";\n", "next_change": {"commit": "fa33d4b271df7cda61980361ec28093b4749768e", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex f1553dcb6..36251102b 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -70,6 +70,7 @@ public class TestLargeCluster {\n \n     public static final String TEST_CLUSTER_01 = \"largeCluster01\";\n     public static final String TEST_CLUSTER_02 = \"largeCluster02\";\n+    public static final String TEST_CLUSTER_03 = \"largeCluster03\";\n \n     public static final String TEST_CLUSTER_NAME = TEST_CLUSTER_02;\n     public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n", "next_change": {"commit": "fc20b4b528b9e5041c3bc189f2dc358215ba7993", "changed_code": [{"header": "diff --git a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\nindex 36251102b..b3d75841d 100644\n--- a/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n+++ b/storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestLargeCluster.java\n", "chunk": "@@ -68,12 +68,26 @@ import java.util.concurrent.atomic.AtomicInteger;\n public class TestLargeCluster {\n     private static final Logger LOG = LoggerFactory.getLogger(TestLargeCluster.class);\n \n-    public static final String TEST_CLUSTER_01 = \"largeCluster01\";\n-    public static final String TEST_CLUSTER_02 = \"largeCluster02\";\n-    public static final String TEST_CLUSTER_03 = \"largeCluster03\";\n+    public enum TEST_CLUSTER_NAME {\n+        TEST_CLUSTER_01(\"largeCluster01\"),\n+        TEST_CLUSTER_02(\"largeCluster02\"),\n+        TEST_CLUSTER_03(\"largeCluster03\");\n+\n+        private final String clusterName;\n+\n+        TEST_CLUSTER_NAME(String clusterName) {\n+            this.clusterName = clusterName;\n+        }\n+\n+        String getClusterName() {\n+            return clusterName;\n+        }\n+\n+        String getResourcePath() {\n+            return \"clusterconf/\" + clusterName;\n+        }\n+    }\n \n-    public static final String TEST_CLUSTER_NAME = TEST_CLUSTER_02;\n-    public static final String TEST_RESOURCE_PATH = \"clusterconf/\" + TEST_CLUSTER_NAME;\n     public static final String COMPRESSED_SERIALIZED_TOPOLOGY_FILENAME_ENDING = \"code.ser\";\n     public static final String COMPRESSED_SERIALIZED_CONFIG_FILENAME_ENDING = \"conf.ser\";\n \n", "next_change": null}]}}]}}]}}]}